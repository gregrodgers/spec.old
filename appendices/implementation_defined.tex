% This is implementation_defined.tex (Appendix C) of the OpenMP specification.
% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. There are environments that provide special formatting, e.g. language bars.
%       Please use them whereever appropriate.  Examples are:
%
%         \begin{fortranspecific}
%         This is text that appears enclosed in blue language bars for Fortran.
%         \end{fortranspecific}
%
%         \begin{note}
%         This is a note.  The "Note -- " header appears automatically.
%         \end{note}
%
%    6. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%

\chapter{OpenMP Implementation-Defined Behaviors}
\label{chap:OpenMP Implementation-Defined Behaviors}
\index{implementation}
This appendix summarizes the behaviors that are described as implementation defined in
this API. Each behavior is cross-referenced back to its description in the main
specification. An implementation is required to define and document its behavior in
these cases.

\begin{itemize}
\item \textbf{Processor}: a hardware unit that is implementation defined (see
\specref{subsec:Threading Concepts}).

\item \textbf{Device}: an implementation defined logical execution engine (see
\specref{subsec:Threading Concepts}).

\item \textbf{Device address}: an address in a \emph{device data environment} (see \specref{subsec:Data Terminology}).

\item \textbf{Memory model}: the minimum size at which a memory update may also read and
write back adjacent variables that are part of another variable (as array or structure
elements) is implementation defined but is no larger than required by the base
language (see \specref{subsec:Structure of the OpenMP Memory Model}).

\item \textbf{Memory model}: Implementations are allowed to relax the ordering imposed by
implicit flush operations when the result is only visible to programs using
non-sequentially consistent atomic directives (see \specref{subsec:OpenMP Memory Consistency}).

\index{internal control variables}
\item \textbf{Internal control variables}: the initial values of
\plc{dyn-var}, \plc{nest-var}, \plc{nthreads-var}, \plc{run-sched-var},
\plc{def-sched-var}, \plc{bind-var}, \plc{stacksize-var},
\plc{wait-policy-var}, \plc{thread-limit-var},
\plc{max-active-levels-var}, \plc{place-partition-var}, \plc{affinity-format-var},
\plc{default-device-var} and \plc{def-allocator-var} are implementation defined.  The method for
initializing a target device's internal control variable is
implementation defined (see \specref{subsec:ICV Initialization}).

\index{dynamic thread adjustment}
\item \textbf{Dynamic adjustment of threads}: providing the ability to dynamically adjust the
number of threads is implementation defined . Implementations are allowed to deliver
fewer threads (but at least one) than indicated in Algorithm 2-1 even if dynamic
adjustment is disabled (see \specref{subsec:Determining the Number of Threads for a parallel Region}).

\item \textbf{Thread affinity}: For the \code{close} thread affinity
  policy, if $T > P$ and $P$ does not divide $T$ evenly, the exact
  number of threads in a particular place is implementation defined.
  For the \code{spread} thread affinity, if $T > P$ and $P$ does not
  divide $T$ evenly, the exact number of threads in a particular
  subpartition is implementation defined.  The determination of
  whether the affinity request can be fulfilled is implementation
  defined.  If not, the number of threads in the team and their mapping
  to places become implementation defined (see
  \specref{subsec:Controlling OpenMP Thread Affinity}).

\item \code{declare variant} \textbf{directive}: whether, for some specific
  OpenMP context, the prototype of the variant should differ from that of
  the base function, and if so how it should differ, is implementation defined.

\item \textbf{Teams construct}: the assignment of initial threads to places and the values of the \plc{place-partition-var} and \plc{default-device-var} ICVs for each initial thread (see \specref{sec:teams Construct}) are implementation defined.

\item \textbf{Worksharing-Loop directive}: the integer type (or kind, for Fortran) used to compute the iteration
count of a collapsed loop is implementation defined. The effect of the
\code{schedule(runtime)} clause when the \plc{run-sched-var} ICV is set to \code{auto} is
implementation defined. The \plc{simd_width} used when a \code{simd}
schedule modifier is specified is implementation defined (see
    \specref{subsec:Worksharing-Loop Construct}).

\item \code{sections} \textbf{construct}: the method of scheduling the structured blocks among threads
in the team is implementation defined (see \specref{subsec:sections Construct}).

\item \code{single} \textbf{construct}: the method of choosing a thread to execute the structured block
is implementation defined (see \specref{subsec:single Construct})

\item \code{simd} \textbf{construct}: the integer type (or kind, for
  Fortran) used to compute the iteration count for the collapsed loop
  is implementation defined. The number of iterations that are
  executed concurrently at any given time is implementation
  defined. If the \plc{alignment} parameter is not specified in the
  \code{aligned} clause, the default alignments for the SIMD
  instructions are implementation defined (see \specref{subsubsec:simd Construct}).

\item \code{declare simd} \textbf{directive}: if the parameter of the
  \code{simdlen} clause is not a constant positive integer expression,
  the number of concurrent arguments for the function is
  implementation defined. If the \plc{alignment} parameter of the
  \code{aligned} clause is not specified, the default alignments for
  SIMD instructions are implementation defined (see
  \specref{subsubsec:declare simd Directive}).

\item \code{taskloop} \textbf{construct}: The number of loop
  iterations assigned to a task created from a \code{taskloop}
  construct is implementation defined, unless the \code{grainsize} or
  \code{num_tasks} clauses are specified. The integer type (or kind,
  for Fortran) used to compute the iteration count for the collapsed
  loop is implementation defined (see \specref{subsec:taskloop
    Construct}).

\item \code{is_device_ptr} \textbf{clause}:
  Support for pointers created outside of the OpenMP device data management
  routines is implementation defined (see \specref{subsec:target Construct}).

\item \code{target} \textbf{construct}: the effect of invoking a virtual member
function of an object on a device other than the device on which the object was
constructed is implementation defined (see \specref{subsec:target Construct}).

\item \code{teams} \textbf{construct}: the number of teams that are created is implementation defined but
less than or equal to the value of the \code{num_teams} clause if specified. The maximum
number of threads participating in the contention group that each team initiates is
implementation defined but less than or equal to the value of the \code{thread_limit}
clause if specified (see \specref{sec:teams Construct}).

\item \code{distribute} \textbf{construct}: the integer type (or kind, for
    Fortran) used to compute the iteration count for the collapsed loop is
    implementation defined (see \specref{subsec:distribute Construct}).

\item \code{distribute} \textbf{construct}: If no \code{dist_schedule} clause is specified then the schedule for the \code{distribute}
construct is implementation defined (see \specref{subsec:distribute Construct}).

\item \code{critical} \textbf{construct}: the effect of using a \code{hint}
clause is implementation defined (see \specref{subsec:critical Construct} and \specref{subsec:Synchronization Hints}).

\item \code{atomic} \textbf{construct}: a compliant implementation may enforce exclusive access
\index{atomic construct@{\code{atomic} construct}}
between \code{atomic} regions that update different storage locations. The circumstances
under which this occurs are implementation defined. If the storage location
designated by $x$ is not size-aligned (that is, if the byte alignment of $x$ is not a multiple
of the size of $x$), then the behavior of the atomic region is implementation defined
(see \specref{subsec:atomic Construct}).
The effect of using a \code{hint} clause is implementation defined (see \specref{subsec:atomic Construct} and \specref{subsec:Synchronization Hints}).

\begin{fortranspecific}

\item \textbf{Data-sharing attributes}: The data-sharing attributes of dummy arguments without the \code{VALUE} attribute are implementation-defined if the associated actual argument is shared, except for the conditions specified (see
\specref{subsubsec:Data-sharing Attribute Rules for Variables Referenced in a Region but not in a Construct}).

\item \code{threadprivate} \textbf{directive}: if the conditions for values of data in the threadprivate
objects of threads (other than an initial thread) to persist between two consecutive
active parallel regions do not all hold, the allocation status of an allocatable variable
in the second region is implementation defined (see \specref{subsec:threadprivate Directive}).

\item \textbf{Runtime library definitions}: it is implementation defined whether the include file
\code{omp_lib.h} or the module \code{omp_lib} (or both) is provided. It is implementation
defined whether any of the OpenMP runtime library routines that take an argument
are extended with a generic interface so arguments of different \code{KIND} type can be
accommodated (see \specref{sec:runtime library definitions}).

\end{fortranspecific}

\item \code{omp_set_num_threads} \textbf{routine}: if the argument is not a positive integer the
behavior is implementation defined (see \specref{subsec:omp_set_num_threads}).

\item \code{omp_set_schedule} \textbf{routine}: for implementation specific schedule types, the
values and associated meanings of the second argument are implementation defined.
(see \specref{subsec:omp_set_schedule}).

\item \code{omp_get_max_active_levels_supported}: the number of nesting levels
supported by the implementation is implementation defined (see
\specref{subsec:omp_get_max_active_levels_supported}).

\item \code{omp_set_max_active_levels} \textbf{routine}: when called from within any explicit
\code{parallel} region the binding thread set (and binding region, if required) for the
\code{omp_set_max_active_levels} region is implementation defined and the
behavior is implementation defined. If the argument is not a non-negative integer
then the behavior is implementation defined (see \specref{subsec:omp_set_max_active_levels}).

\item \code{omp_get_max_active_levels} \textbf{routine}: when called from within any explicit
\code{parallel} region the binding thread set (and binding region, if required) for the
\code{omp_get_max_active_levels} region is implementation defined (see
\specref{subsec:omp_get_max_active_levels}).

\item \code{omp_get_place_proc_ids} \textbf{routine}: the meaning of the
nonnegative numerical identifiers returned by the
\code{omp_get_place_proc_ids} routine is implementation defined (see
\specref{subsec:omp_get_place_proc_ids}).

\item \code{omp_set_affinity_format} \textbf{routine}: when called from within any explicit
\code{parallel} region the binding thread set (and binding region, if required) for the
\code{omp_set_affinity_format} region is implementation defined and the
behavior is implementation defined. If the argument does not
conform to the specified format then the result is implementation defined (see
\specref{subsec:omp_set_affinity_format}).

\item \code{omp_get_affinity_format} \textbf{routine}: when called from within any explicit
\code{parallel} region the binding thread set (and binding region, if required) for the
\code{omp_get_affinity_format} region is implementation defined (see
\specref{subsec:omp_get_affinity_format}).

\item \code{omp_display_affinity} \textbf{routine}:  if the argument does not
conform to the specified format then the result is implementation defined (see
\specref{subsec:omp_display_affinity}).

\item \code{omp_capture_affinity} \textbf{routine}:  if the \plc{format} argument does not
conform to the specified format then the result is implementation defined (see
\specref{subsec:omp_capture_affinity}).

\item \code{omp_get_initial_device} \textbf{routine}: the value of
  the device number is implementation defined (see \specref{subsec:omp_get_initial_device}).

\item \code{omp_init_lock_with_hint} and \code{omp_init_nest_lock_with_hint} \textbf{routines}:
if hints are stored with a lock variable, the effect of the hints on the locks are implementation defined
(see \specref{subsec:omp_init_lock_with_hint and omp_init_nest_lock_with_hint}).

\item \code{omp_target_memcpy_rect} \textbf{routine}:
  the maximum number of dimensions supported is implementation defined, but
  must be at least three (see \specref{subsec:omp_target_memcpy_rect}).

\item \code{OMP_SCHEDULE} \textbf{environment variable}: if the value does not
conform to the specified format then the result is implementation defined (see
\specref{sec:OMP_SCHEDULE}).

\item \code{OMP_NUM_THREADS} \textbf{environment variable}: if any value of the list specified in the
\code{OMP_NUM_THREADS} environment variable leads to a number of threads that is
greater than the implementation can support, or if any value is not a positive integer,
then the result is implementation defined (see \specref{sec:OMP_NUM_THREADS}).

\item \code{OMP_PROC_BIND} \textbf{environment variable}: if the value is not \code{true}, \code{false}, or a
comma separated list of \code{master}, \code{close}, or \code{spread}, the behavior is
implementation defined. The behavior is also implementation defined if an initial
thread cannot be bound to the first place in the OpenMP place list (see
\specref{sec:OMP_PROC_BIND}).

\item \code{OMP_DYNAMIC} \textbf{environment variable}: if the value is neither
\code{true} nor \code{false} the behavior is implementation defined (see
\specref{sec:OMP_DYNAMIC}).

\item \code{OMP_NESTED} \textbf{environment variable}: if the value is neither
\code{true} nor \code{false} the behavior is implementation defined (see
\specref{sec:OMP_NESTED}).

\item \code{OMP_STACKSIZE} \textbf{environment variable}: if the value does not conform to the
specified format or the implementation cannot provide a stack of the specified size
then the behavior is implementation defined (see \specref{sec:OMP_STACKSIZE}).

\item \code{OMP_WAIT_POLICY} \textbf{environment variable}: the details of the \code{ACTIVE} and
\code{PASSIVE} behaviors are implementation defined (see \specref{sec:OMP_WAIT_POLICY}).

\item \code{OMP_MAX_ACTIVE_LEVELS} \textbf{environment variable}: if the value is not a
non-negative integer or is greater than the number of parallel levels an implementation
can support then the behavior is implementation defined (see \specref{sec:OMP_MAX_ACTIVE_LEVELS}).

\item \code{OMP_THREAD_LIMIT} \textbf{environment variable}: if the requested value is greater than
the number of threads an implementation can support, or if the value is not a positive
integer, the behavior of the program is implementation defined (see \specref{sec:OMP_THREAD_LIMIT}).

\item \code{OMP_PLACES} \textbf{environment variable}: the meaning of the numbers specified in the
environment variable and how the numbering is done are implementation defined.
The precise definitions of the abstract names are implementation defined. An
implementation may add implementation-defined abstract names as appropriate for
the target platform. When creating a place list of n elements by appending the
number $n$ to an abstract name, the determination of which resources to include in the
place list is implementation defined. When requesting more resources than available,
the length of the place list is also implementation defined. The behavior of the
program is implementation defined when the execution environment cannot map a
numerical value (either explicitly defined or implicitly derived from an interval)
within the \code{OMP_PLACES} list to a processor on the target platform, or if it maps to an
unavailable processor. The behavior is also implementation defined when the
\code{OMP_PLACES} environment variable is defined using an abstract name (see \specref{sec:OMP_PLACES}).

\item \code{OMP_AFFINITY_FORMAT} \textbf{environment variable}: if the value does not
conform to the specified format then the result is implementation defined (see
\specref{sec:OMP_AFFINITY_FORMAT}).

\item \textbf{OMPT thread states}: The set of OMPT thread states supported is implementation defined (see \specref{sec:thread-states}).

\newcommand{\implcallback}[1]{
\item \code{#1} \textbf{tool callback}: if a tool attempts to register a callback with this string name using the runtime entry point \code{ompt_set_callback}, it is implementation defined whether the registered callback may never or sometimes invoke this callback for the associated events (see \tabref{table:valid_rc})}

\implcallback{ompt_callback_idle}
\implcallback{ompt_callback_sync_region_wait}
\implcallback{ompt_callback_mutex_released}
\implcallback{ompt_callback_task_dependences}
\implcallback{ompt_callback_task_dependence}
\implcallback{ompt_callback_work}
\implcallback{ompt_callback_master}
\implcallback{ompt_callback_target_map}
\implcallback{ompt_callback_sync_region}
\implcallback{ompt_callback_lock_init}
\implcallback{ompt_callback_lock_destroy}
\implcallback{ompt_callback_mutex_acquire}
\implcallback{ompt_callback_mutex_acquired}
\implcallback{ompt_callback_nest_lock}
\implcallback{ompt_callback_flush}
\implcallback{ompt_callback_cancel}
\implcallback{ompt_callback_dispatch}

\item \code{OMP_DEBUG} \textbf{environment variable}: if the value is neither
\code{disabled} nor \code{enabled} the behavior is implementation defined (see
\specref{sec:OMP_DEBUG}).

\item \textbf{Device tracing}: Whether a target device supports tracing or not is implementation defined;
if a target device does not support tracing, a \code{NULL} may be supplied for the \plc{lookup} function
to a tool's device initializer (see \specref{sec:tracing-device-activity}).

\newcommand{\ompttrace}[1]{
\item \code{#1} \textbf{runtime entry point}: it is implementation defined whether a device-specific tracing interface will define this
runtime entry point, indicating that it can collect traces in OMPT format (see \specref{sec:tracing-device-activity}).
}

\ompttrace{ompt_set_trace_ompt}
\ompttrace{ompt_buffer_get_record_ompt}

\item \textbf{Memory allocators}: The storage resource that will be used by each memory allocator defined in \tabref{tab:Predefined Allocators} is implementation defined.

\item \code{allocate} \textbf{directive}: The effect of not being able to fulfill an allocation request specified in \code{allocate} directive is implementation defined.

\item \code{allocate} \textbf{clause}: The effect of not being able to fulfill an allocation request specified in \code{allocate} clause is implementation defined.

\end{itemize}


% This is the end of appendix-D-ImplementationDefined.tex of the OpenMP specification.

