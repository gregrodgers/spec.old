% This is stubs_ccpp.tex (Appendix A) of the OpenMP specification.
% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. There are environments that provide special formatting, e.g. language bars.
%       Please use them whereever appropriate.  Examples are:
%
%         \begin{fortranspecific}
%         This is text that appears enclosed in blue language bars for Fortran.
%         \end{fortranspecific}
%
%         \begin{note}
%         This is a note.  The "Note -- " header appears automatically.
%         \end{note}
%
%    6. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of 
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%


\section{C/C++ Stub Routines}
\index{C/C++ stub routines}
\index{stub routines}
\label{sec:C/C++ Stub Routines}
{\small \begin{codepar}
\#include <stdio.h>
\#include <stdlib.h>
\#include "omp.h"

void omp\_set\_num\_threads(int num\_threads)
\{
\}

int omp\_get\_num\_threads(void)
\{
    return 1;
\}

int omp\_get\_max\_threads(void)
\{
    return 1;
\}

int omp\_get\_thread\_num(void)
\{
    return 0;
\}

int omp\_get\_num\_procs(void)
\{
    return 1;
\}

int omp\_in\_parallel(void)
\{
    return 0;
\}

void omp\_set\_dynamic(int dynamic\_threads)
\{
\}

int omp\_get\_dynamic(void)
\{
    return 0;
\}

int omp\_get\_cancellation(void)
\{
    return 0;
\}

void omp\_set\_nested(int nested)
\{
\}

int omp\_get\_nested(void)
\{
    return 0;
\}

void omp\_set\_schedule(omp\_sched\_t kind, int chunk\_size)
\{
\}

void omp\_get\_schedule(omp\_sched\_t *kind, int *chunk\_size)
\{
    *kind = omp\_sched\_static;
    *chunk\_size = 0;
\}

int omp\_get\_thread\_limit(void)
\{
    return 1;
\}

void omp\_set\_max\_active\_levels(int max\_active\_levels)
\{
\}

int omp\_get\_max\_active\_levels(void)
\{
    return 0;
\}

int omp\_get\_level(void)
\{
    return 0;
\}

int omp\_get\_ancestor\_thread\_num(int level)
\{
    if (level == 0)
    \{
        return 0;
    \}
    else
    \{
        return -1;
    \}
\}

int omp\_get\_team\_size(int level)
\{
    if (level == 0)
    \{
        return 1;
    \}
    else
    \{
        return -1;
    \}
\}

int omp\_get\_active\_level(void)
\{
    return 0;
\}

int omp\_in\_final(void)
\{
    return 1;
\}

omp\_proc\_bind\_t omp\_get\_proc\_bind(void) 
\{
    return omp\_proc\_bind\_false;
\}

int omp\_get\_num\_places(void)
\{
    return 0;
\}

int omp\_get\_place\_num\_procs(int place\_num)
\{
    return 0;
\}

void omp\_get\_place\_proc\_ids(int place\_num, int *ids)
\{
\}

int omp\_get\_place\_num(void)
\{
    return -1;
\}

int omp\_get\_partition\_num\_places(void)
\{
    return 0;
\}

void omp\_get\_partition\_place\_nums(int *place\_nums)
\{
\}

void omp\_set\_affinity\_format(char const *format)\{
\}

size_t omp\_get\_affinity\_format(char* buffer, size_t size)
\{
    return 0;
\}

void omp\_display\_affinity(char const *format)
\{
\}

size_t omp\_capture\_affinity(char *buffer, size_t size, char const *format)
\{
    return 0;
\}

void omp\_set\_default\_device(int device\_num)
\{
\}

int omp\_get\_default\_device(void)
\{
    return 0;
\}

int omp\_get\_num\_devices(void)
\{
    return 0;
\}

int omp\_get\_device\_num(void)
\{
    return -10;
\}

int omp\_get\_num\_teams(void)
\{
    return 1;
\}

int omp\_get\_team\_num(void)
\{
    return 0;
\}

int omp\_is\_initial\_device(void)
\{
    return 1;
\}

int omp\_get\_initial\_device(void)
\{
    return -10;
\}

int omp\_get\_max\_task\_priority(void)
\{
    return 0;
\}

struct \_\_omp\_lock
\{
    int lock;
\};

enum \{ UNLOCKED = -1, INIT, LOCKED \};

void omp\_init\_lock(omp\_lock\_t *arg)
\{
    struct \_\_omp\_lock *lock = (struct \_\_omp\_lock *)arg;
    lock->lock = UNLOCKED;
\}

void omp\_init\_lock\_with\_hint(omp\_lock\_t *arg, omp\_lock\_hint\_t hint)
\{
    omp\_init\_lock(arg);
\}

void omp\_destroy\_lock(omp\_lock\_t *arg)
\{
    struct \_\_omp\_lock *lock = (struct \_\_omp\_lock *)arg;
    lock->lock = INIT;
\}

void omp\_set\_lock(omp\_lock\_t *arg)
\{
    struct \_\_omp\_lock *lock = (struct \_\_omp\_lock *)arg;
    if (lock->lock == UNLOCKED)
    \{
        lock->lock = LOCKED;
    \}
    else if (lock->lock == LOCKED)
    \{
        fprintf(stderr, "error: deadlock in using lock variable{\textbackslash}n");
        exit(1);
    \}

    else
    \{
        fprintf(stderr, "error: lock not initialized{\textbackslash}n");
        exit(1);
    \}
\}

void omp\_unset\_lock(omp\_lock\_t *arg)
\{
    struct \_\_omp\_lock *lock = (struct \_\_omp\_lock *)arg;
    if (lock->lock == LOCKED)
    \{
        lock->lock = UNLOCKED;
    \}
    else if (lock->lock == UNLOCKED)
    \{
        fprintf(stderr, "error: lock not set{\textbackslash}n");
        exit(1);
    \}
    else
    \{
        fprintf(stderr, "error: lock not initialized{\textbackslash}n");
        exit(1);
    \}
\}

int omp\_test\_lock(omp\_lock\_t *arg)
\{
    struct \_\_omp\_lock *lock = (struct \_\_omp\_lock *)arg;
    if (lock->lock == UNLOCKED)
    \{
        lock->lock = LOCKED;
        return 1;
    \}
    else if (lock->lock == LOCKED)
    \{
        return 0;
    \}
    else
    \{
        fprintf(stderr, "error: lock not initialized{\textbackslash}n");
        exit(1);
    \}
\}

struct \_\_omp\_nest\_lock
\{
    short owner;
    short count;
\};

enum \{ NOOWNER = -1, MASTER = 0 \};

void omp\_init\_nest\_lock(omp\_nest\_lock\_t *arg)
\{
    struct \_\_omp\_nest\_lock *nlock=(struct \_\_omp\_nest\_lock *)arg;
    nlock->owner = NOOWNER;
    nlock->count = 0;
\}

void omp\_init\_nest\_lock\_with\_hint(omp\_nest\_lock\_t *arg, 
                                  omp\_lock\_hint\_t hint)
\{
    omp\_init\_nest\_lock(arg);
\}

void omp\_destroy\_nest\_lock(omp\_nest\_lock\_t *arg)
\{
    struct \_\_omp\_nest\_lock *nlock=(struct \_\_omp\_nest\_lock *)arg;
    nlock->owner = NOOWNER;
    nlock->count = UNLOCKED;
\}

void omp\_set\_nest\_lock(omp\_nest\_lock\_t *arg)
\{
    struct \_\_omp\_nest\_lock *nlock=(struct \_\_omp\_nest\_lock *)arg;
    if (nlock->owner == MASTER \&\& nlock->count >= 1)
    \{
        nlock->count++;
    \}
    else if (nlock->owner == NOOWNER \&\& nlock->count == 0)
    \{
        nlock->owner = MASTER;
        nlock->count = 1;
    \}
    else
    \{
        fprintf(stderr, "error: lock corrupted or not initialized{\textbackslash}n");
        exit(1);
    \}
\}

void omp\_unset\_nest\_lock(omp\_nest\_lock\_t *arg)
\{
    struct \_\_omp\_nest\_lock *nlock=(struct \_\_omp\_nest\_lock *)arg;
    if (nlock->owner == MASTER \&\& nlock->count >= 1)
    \{
        nlock->count--;
        if (nlock->count == 0)
        \{
            nlock->owner = NOOWNER;
        \}
    \}
    else if (nlock->owner == NOOWNER \&\& nlock->count == 0)
    \{
        fprintf(stderr, "error: lock not set{\textbackslash}n");
        exit(1);
    \}
    else
    \{
        fprintf(stderr, "error: lock corrupted or not initialized{\textbackslash}n");
        exit(1);
    \}
\}

int omp\_test\_nest\_lock(omp\_nest\_lock\_t *arg)
\{
    struct \_\_omp\_nest\_lock *nlock=(struct \_\_omp\_nest\_lock *)arg;
    omp\_set\_nest\_lock(arg);
    return nlock->count;
\}

double omp\_get\_wtime(void)
\{
/* This function does not provide a working
 * wallclock timer. Replace it with a version
 * customized for the target machine.
 */
    return 0.0;
\}

double omp\_get\_wtick(void)
\{
/* This function does not provide a working
 * clock tick function. Replace it with
 * a version customized for the target machine.
 */
    return 365. * 86400.;
\}

void * omp\_target\_alloc(size\_t size, int device\_num)
\{
    if (device\_num != -10)
      return NULL;
    return malloc(size)
\}

void omp\_target\_free(void *device\_ptr, int device\_num)
\{
    free(device\_ptr);
\}

int omp\_target\_is\_present(void *ptr, int device\_num)
\{
    return 1;
\}

int omp\_target\_memcpy(void *dst, void *src, size\_t length,
                      size\_t dst\_offset, size\_t src\_offset,
                      int dst\_device, int src\_device)
\{
    // only the default device is valid in a stub
    if (dst\_device != -10 || src\_device != -10
            || ! dst || ! src )
        return EINVAL;
    memcpy((char *)dst + dst\_offset,
           (char *)src + src\_offset,
           length);
    return 0;
\}

int omp\_target\_memcpy\_rect(
    void *dst, void *src,
    size\_t element\_size,
    int num\_dims,
    const size\_t *volume,
    const size\_t *dst\_offsets,
    const size\_t *src\_offsets,
    const size\_t *dst\_dimensions,
    const size\_t *src\_dimensions,
    int dst\_device\_num, int src\_device\_num)
\{
    int ret=0;
    // Both null, return number of dimensions supported,
    // this stub supports an arbitrary number
    if (dst == NULL && src == NULL) return INT\_MAX;

    if (!volume || !dst\_offsets || !src\_offsets
            || !dst\_dimensions || !src\_dimensions
            || num\_dims < 1 ) \{
        ret = EINVAL;
        goto done;
    \}
    if (num\_dims == 1) \{
        ret = omp\_target\_memcpy(dst, src,
                                element\_size * volume[0],
                                dst\_offsets[0] * element\_size,
                                src\_offsets[0] * element\_size,
                                dst\_device\_num, src\_device\_num);
        if(ret) goto done;
    \} else \{
        size\_t dst\_slice\_size = element\_size;
        size\_t src\_slice\_size = element\_size;
        for (int i=1; i < num\_dims; i++) \{
            dst\_slice\_size *= dst\_dimensions[i];
            src\_slice\_size *= src\_dimensions[i];
        \}
        size\_t dst\_off = dst\_offsets[0] * dst\_slice\_size;
        size\_t src\_off = src\_offsets[0] * src\_slice\_size;
        for (size\_t i=0; i < volume[0]; i++) \{
            ret = omp\_target\_memcpy\_rect(
                        (char *)dst + dst\_off + dst\_slice\_size*i,
                        (char *)src + src\_off + src\_slice\_size*i,
                        element\_size,
                        num\_dims - 1,
                        volume + 1,
                        dst\_offsets + 1,
                        src\_offsets + 1,
                        dst\_dimensions + 1,
                        src\_dimensions + 1,
                        dst\_device\_num,
                        src\_device\_num);
            if (ret) goto done;
        \}
    \}
done:
    return ret;
\}

int omp\_target\_associate\_ptr(void *host\_ptr, void *device\_ptr,
                             size\_t size, size\_t device\_offset,
                             int device\_num)
\{
    // No association is possible because all host pointers 
    // are considered present
    return EINVAL;
\}

int omp\_target\_disassociate\_ptr(void *ptr, int device\_num)
\{
    return EINVAL;
\}


int omp\_control\_tool(int command, int modifier, void *arg)
\{
    return omp_control_tool_notool;
\}

static omp\_allocator\_t * omp\_allocator = OMP\_NULL\_ALLOCATOR;

omp_allocator_t * omp_default_mem_alloc;
omp_allocator_t * omp_large_cap_mem_alloc;
omp_allocator_t * omp_const_mem_alloc;
omp_allocator_t * omp_high_bw_mem_alloc;
omp_allocator_t * omp_low_lat_mem_alloc;
omp_allocator_t * omp_cgroup_mem_alloc;
omp_allocator_t * omp_pteam_mem_alloc;
omp_allocator_t * omp_thread_mem_alloc;

void omp\_set\_default allocator(omp\_allocator\_t *allocator)
\{
     omp\_allocator = allocator;
\}

omp\_allocator\_t * omp\_get\_default\_allocator (void)
\{
    return omp\_allocator;
\}

\#ifdef _\_cplusplus
void * omp\_alloc (size\_t size, omp\_allocator\_t *allocator = OMP\_NULL\_ALLOCATOR)
\#else
void * omp\_alloc (size\_t size, omp\_allocator\_t *allocator)
\#endif
\{
    return malloc(size);
\}

\#ifdef _\_cplusplus
void omp\_free (void * ptr, omp\_allocator\_t *allocator = OMP\_NULL\_ALLOCATOR)
\#else
void omp\_free (void * ptr, omp\_allocator\_t *allocator)
\#endif
\{
    free(ptr);
\}

\end{codepar}} % end \small block

