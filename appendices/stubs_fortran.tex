% This is stubs_fortran.tex (Appendix A) of the OpenMP specification.
% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. There are environments that provide special formatting, e.g. language bars.
%       Please use them whereever appropriate.  Examples are:
%
%         \begin{fortranspecific}
%         This is text that appears enclosed in blue language bars for Fortran.
%         \end{fortranspecific}
%
%         \begin{note}
%         This is a note.  The "Note -- " header appears automatically.
%         \end{note}
%
%    6. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%


\section{Fortran Stub Routines}
\label{sec:Fortran Stub Routines}
{\small \begin{codepar}
subroutine omp\_set\_num\_threads(num\_threads)
  integer num\_threads
  return
end subroutine

integer function omp\_get\_num\_threads()
  omp\_get\_num\_threads = 1
  return
end function

integer function omp\_get\_max\_threads()
  omp\_get\_max\_threads = 1
  return
end function

integer function omp\_get\_thread\_num()
  omp\_get\_thread\_num = 0
  return
end function

integer function omp\_get\_num\_procs()
  omp\_get\_num\_procs = 1
  return
end function

logical function omp\_in\_parallel()
  omp\_in\_parallel = .false.
  return
end function

subroutine omp\_set\_dynamic(dynamic\_threads)
  logical dynamic\_threads
  return
end subroutine

logical function omp\_get\_dynamic()
  omp\_get\_dynamic = .false.
  return
end function

logical function omp\_get\_cancellation()
  omp\_get\_cancellation = .false.
  return
end function

subroutine omp\_set\_nested(nested)
  logical nested
  return
end subroutine

logical function omp\_get\_nested()
  omp\_get\_nested = .false.
  return
end function

subroutine omp\_set\_schedule(kind, chunk\_size)
  include 'omp\_lib\_kinds.h'
  integer (kind=omp\_sched\_kind) kind
  integer chunk\_size
  return
end subroutine

subroutine omp\_get\_schedule(kind, chunk\_size)
  include 'omp\_lib\_kinds.h'
  integer (kind=omp\_sched\_kind) kind
  integer chunk\_size
  kind = omp\_sched\_static
  chunk\_size = 0
  return
end subroutine

integer function omp\_get\_thread\_limit()
  omp\_get\_thread\_limit = 1
  return
end function

subroutine omp\_set\_max\_active\_levels(max\_level)
  integer max\_level
end subroutine

integer function omp\_get\_max\_active\_levels()
  omp\_get\_max\_active\_levels = 0
  return
end function

integer function omp\_get\_level()
  omp\_get\_level = 0
  return
end function

integer function omp\_get\_ancestor\_thread\_num(level)
  integer level
  if ( level .eq. 0 ) then
     omp\_get\_ancestor\_thread\_num = 0
  else
     omp\_get\_ancestor\_thread\_num = -1
  end if
  return
end function

integer function omp\_get\_team\_size(level)
  integer level
  if ( level .eq. 0 ) then
     omp\_get\_team\_size = 1
  else
     omp\_get\_team\_size = -1
  end if
  return
end function

integer function omp\_get\_active\_level()
  omp\_get\_active\_level = 0
  return
end function

logical function omp\_in\_final()
  omp\_in\_final = .true.
  return
end function

function omp\_get\_proc\_bind()
  include 'omp\_lib\_kinds.h'
  integer (kind=omp\_proc\_bind\_kind) omp\_get\_proc\_bind
  omp\_get\_proc\_bind = omp\_proc\_bind\_false
end function

integer function omp\_get\_num\_places()
  return 0
end function

integer function omp\_get\_place\_num\_procs(place\_num)
  integer place\_num
  return 0
end function

subroutine omp\_get\_place\_proc\_ids(place\_num, ids)
  integer place\_num
  integer ids(*)
  return
end subroutine

integer function omp\_get\_place\_num()
  return -1
end function

integer function omp\_get\_partition\_num\_places()
  return 0
end function

subroutine omp\_get\_partition\_place\_nums(place\_nums)
  integer place\_nums(*)
  return
end subroutine


subroutine omp\_set\_affinity\_format(\plc{format})
   character(len=*),intent(in)::format
   return
end subroutine

integer function omp\_get\_affinity\_format(buffer)
   character(len=*),intent(out)::buffer
   return 0
end function

subroutine omp\_display\_affinity(format)
   character(len=*),intent(in)::format
   return
end subroutine

integer function omp\_capture\_affinity(buffer,format)
   character(len=*),intent(out)::buffer
   character(len=*),intent(in)::format
   return 0
end function

subroutine omp\_set\_default\_device(device\_num)
  integer device\_num
  return
end subroutine

integer function omp\_get\_default\_device()
  omp\_get\_default\_device = 0
  return
end function

integer function omp\_get\_num\_devices()
  omp\_get\_num\_devices = 0
  return
end function

integer function omp\_get\_device\_num()
  omp\_get\_device\_num = -10
  return
end function

integer function omp\_get\_num\_teams()
  omp\_get\_num\_teams = 1
  return
end function

integer function omp\_get\_team\_num()
  omp\_get\_team\_num = 0
  return
end function

logical function omp\_is\_initial\_device()
  omp\_is\_initial\_device = .true.
  return
end function

integer function omp\_get\_initial\_device()
  omp\_get\_initial\_device = -10
  return
end function

integer function omp\_get\_max\_task\_priority()
  omp\_get\_max\_task\_priority = 0
  return
end function

subroutine omp\_init\_lock(lock)
  ! lock is 0 if the simple lock is not initialized
  !        -1 if the simple lock is initialized but not set
  !         1 if the simple lock is set
  include 'omp\_lib\_kinds.h'
  integer(kind=omp\_lock\_kind) lock

  lock = -1
  return
end subroutine

subroutine omp\_init\_lock\_with\_hint(lock, hint)
  include 'omp\_lib\_kinds.h'
  integer(kind=omp\_lock\_kind) lock
  integer(kind=omp\_lock\_hint\_kind) hint

  call omp\_init\_lock(lock)
  return
end subroutine

subroutine omp\_destroy\_lock(lock)
  include 'omp\_lib\_kinds.h'
  integer(kind=omp\_lock\_kind) lock

  lock = 0
  return
end subroutine

subroutine omp\_set\_lock(lock)
  include 'omp\_lib\_kinds.h'
  integer(kind=omp\_lock\_kind) lock

  if (lock .eq. -1) then
    lock = 1
  elseif (lock .eq. 1) then
    print *, 'error: deadlock in using lock variable'
    stop
  else
    print *, 'error: lock not initialized'
    stop
  endif
  return
end subroutine

subroutine omp\_unset\_lock(lock)
  include 'omp\_lib\_kinds.h'
  integer(kind=omp\_lock\_kind) lock

  if (lock .eq. 1) then
    lock = -1
  elseif (lock .eq. -1) then
    print *, 'error: lock not set'
    stop
  else
    print *, 'error: lock not initialized'
    stop
  endif
  return
end subroutine

logical function omp\_test\_lock(lock)
  include 'omp\_lib\_kinds.h'
  integer(kind=omp\_lock\_kind) lock

  if (lock .eq. -1) then
    lock = 1
    omp\_test\_lock = .true.
  elseif (lock .eq. 1) then
    omp\_test\_lock = .false.
  else
    print *, 'error: lock not initialized'
    stop
  endif

  return
end function

subroutine omp\_init\_nest\_lock(nlock)
  ! nlock is
  ! 0 if the nestable lock is not initialized
  ! -1 if the nestable lock is initialized but not set
  ! 1 if the nestable lock is set
  ! no use count is maintained
  include 'omp\_lib\_kinds.h'
  integer(kind=omp\_nest\_lock\_kind) nlock

  nlock = -1

  return
end subroutine

subroutine omp\_init\_nest\_lock\_with\_hint(nlock, hint)
  include 'omp\_lib\_kinds.h'
  integer(kind=omp\_nest\_lock\_kind) nlock
  integer(kind=omp\_lock\_hint\_kind) hint

  call omp\_init\_nest\_lock(nlock)
  return
end subroutine

subroutine omp\_destroy\_nest\_lock(nlock)
  include 'omp\_lib\_kinds.h'
  integer(kind=omp\_nest\_lock\_kind) nlock

  nlock = 0

  return
end subroutine

subroutine omp\_set\_nest\_lock(nlock)
  include 'omp\_lib\_kinds.h'
  integer(kind=omp\_nest\_lock\_kind) nlock

  if (nlock .eq. -1) then
    nlock = 1
  elseif (nlock .eq. 0) then
    print *, 'error: nested lock not initialized'
    stop
  else
    print *, 'error: deadlock using nested lock variable'
    stop
  endif

  return
end subroutine

subroutine omp\_unset\_nest\_lock(nlock)
  include 'omp\_lib\_kinds.h'
  integer(kind=omp\_nest\_lock\_kind) nlock

  if (nlock .eq. 1) then
    nlock = -1
  elseif (nlock .eq. 0) then
    print *, 'error: nested lock not initialized'
    stop
  else
    print *, 'error: nested lock not set'
    stop
  endif

  return
end subroutine

integer function omp\_test\_nest\_lock(nlock)
  include 'omp\_lib\_kinds.h'
  integer(kind=omp\_nest\_lock\_kind) nlock

  if (nlock .eq. -1) then
    nlock = 1
    omp\_test\_nest\_lock = 1
  elseif (nlock .eq. 1) then
    omp\_test\_nest\_lock = 0
  else
    print *, 'error: nested lock not initialized'
    stop
  endif

  return
end function

double precision function omp\_get\_wtime()
  ! this function does not provide a working
  ! wall clock timer. replace it with a version
  ! customized for the target machine.

  omp\_get\_wtime = 0.0d0

  return
end function

double precision function omp\_get\_wtick()
  ! this function does not provide a working
  ! clock tick function. replace it with
  ! a version customized for the target machine.
  double precision one\_year
  parameter (one\_year=365.d0*86400.d0)

  omp\_get\_wtick = one\_year

  return
end function

int function omp\_control\_tool(command, modifier)
  include 'omp\_lib\_kinds.h'
  integer (kind=omp\_control\_tool\_kind) command
  integer (kind=omp\_control\_tool\_kind) modifier

  return omp\_control\_tool\_notool
end function

subroutine omp\_set\_default\_allocator(allocator)
  include 'omp\_lib\_kinds.h'
  integer (kind=omp\_allocator\_kind) allocator
  return
end subroutine

function omp\_get\_default\_allocator
  include 'omp\_lib\_kinds.h'
  integer (kind=omp\_allocator\_kind) omp\_get\_default\_allocator
  omp\_get\_default\_allocator = omp\_null\_allocator
end function

\end{codepar}} % end \small block
