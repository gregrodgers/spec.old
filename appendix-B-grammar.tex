% This is appendix-B-grammar.tex of the OpenMP specification.
% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of 
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%


% Convenience macros for this file only:
\newcommand{\I}{\hspace{2em}}                  % indent the current line one level
\newcommand{\G}{\rmfamily\mdseries\slshape\small}    % select italic grammar font
\newcommand{\C}{\ttfamily\bfseries\upshape\small}    % select code (bold, monospace) font



\hyphenpenalty=10000
\chapter{OpenMP C and C++ Grammar}
\hyphenpenalty=1000
\label{chap:OpenMP C and C++ Grammar}
\section{Notation}
\index{grammar}
\label{sec:Notation}
The grammar rules consist of the name for a non-terminal, followed by a colon, 
followed by replacement alternatives on separate lines.

The syntactic expression \plc{term}$_{opt}$ indicates that the term is optional within the 
replacement.

The syntactic expression \plc{term}$_{optseq}$ is equivalent to \plc{term-seq}$_{opt}$ with the following 
additional rules:

{
\G term-seq :

\I term

\I term-seq term

\I term-seq , term
}




\pagebreak
\section{Rules}
\label{sec:Rules}
The notation is described in Section 6.1 of the C standard. This grammar appendix 
shows the extensions to the base language grammar for the OpenMP C and C++ 
directives.

{ % start of grammar block - encloses everything.
\I\G\cppspecificstart

\G statement-seq:

\I statement

\I openmp-directive

\I statement-seq statement

\I statement-seq openmp-directive

\G\cppspecificend

\cNinetyspecificstart

\G statement-list:

\I statement

\I openmp-directive

\I statement-list statement

\I statement-list openmp-directive

\G\cNinetyspecificend

\cNinetyNinespecificstart

\G block-item:

\I declaration

\I statement

\I openmp-directive

\G\cNinetyNinespecificend

\G statement:

\C\I {\rmfamily\bfseries\upshape\small /* standard statements */}

\G\I openmp-construct

\I declaration-definition:

\C\I\I {\rmfamily\bfseries\upshape\small /* Any C or C++ declaration or definition statement */}

\G\I function-statement:

\C\I\I {\rmfamily\bfseries\upshape\small /* C or C++ function definition or declaration */}

\G declaration-definition-seq:

\I declaration-definition

\I declaration-definition-seq declaration-definition

openmp-construct:

\I parallel-construct

\I for-construct

\I sections-construct

\I single-construct

\I simd-construct

\I for-simd-construct

\I parallel-for-simd-construct

\I target-data-construct

\I target-construct

\I target-update-construct

\I teams-construct

\I distribute-construct

\I distribute-simd-construct

\I distribute-parallel-for-construct

\I distribute-parallel-for-simd-construct

\I target-teams-construct

\I teams-distribute-construct

\I teams-distribute-simd-construct

\I target-teams-distribute-construct

\I target-teams-distribute-simd-construct

\I teams-distribute-parallel-for-construct

\I target-teams-distribute-parallel-for-construct

\I teams-distribute-parallel-for-simd-construct

\I target-teams-distribute-parallel-for-simd-construct

\I parallel-for-construct

\I parallel-sections-construct

\I task-construct

\I taskloop-construct

\I master-construct

\I critical-construct

\I taskgroup-construct

\I atomic-construct

\I ordered-construct

openmp-directive:

\I barrier-directive

\I taskwait-directive

\I taskyield-directive

\I flush-directive

structured-block:

\I statement

parallel-construct:

\I parallel-directive structured-block

parallel-directive:

\C\I \# pragma omp parallel \G parallel-clause$_{optseq}$ new-line

parallel-clause:

\I unique-parallel-clause

\I data-default-clause 

\I data-privatization-clause 

\I data-privatization-in-clause 

\I data-sharing-clause 

\I data-reduction-clause 

\I collapse-clause

unique-parallel-clause:

\I if-clause

\C\I num\_threads ( \G expression \C )

\C\I copyin ( \G variable-list \C )

\G for-construct:

\I for-directive iteration-statement

for-directive:

\C\I \# pragma omp for \G for-clause$_{optseq}$ new-line

for-clause:

\I unique-for-clause

\I data-privatization-clause 

\I data-privatization-in-clause 

\I data-privatization-out-clause 

\I data-reduction-clause 

\I collapse-clause

\C\I nowait

\G unique-for-clause:

\C\I ordered

\I schedule ( \G schedule-kind \C )

\I schedule ( \G schedule-kind \C, \G expression \C )

\I schedule ( \G schedule-modifier \C, \G schedule-kind \C )

\I schedule ( \G schedule-modifier \C, \G schedule-kind \C, \G expression \C )

\G collapse-clause:

\C\I collapse ( \G expression \C )

\G schedule-kind:

\C\I static

\I dynamic

\I guided

\I auto

\I runtime

\G schedule-modifier:

\C\I simd

\G sections-construct:

\I sections-directive section-scope

sections-directive:

\C\I \# pragma omp sections \G sections-clause$_{optseq}$ new-line

\G sections-clause:

\I data-privatization-clause 

\I data-privatization-in-clause 

\I data-privatization-out-clause 

\I data-reduction-clause 

\C\I nowait

\G section-scope:

\I \{ section-sequence \}

section-sequence:

\I section-directive$_{opt}$ structured-block

\I section-sequence section-directive structured-block

section-directive:

\C\I \# pragma omp section \G new-line

\G single-construct:

\I single-directive structured-block

single-directive:

\C\I \# pragma omp single \G single-clause$_{optseq}$ new-line

\G single-clause:

\I unique-single-clause

\I data-privatization-clause

\I data-privatization-in-clause

\C\I nowait

\G unique-single-clause:

\C\I copyprivate ( \G variable-list \C )

\G simd-construct:

\I simd-directive iteration-statement

simd-directive:

\C\I \# pragma omp simd \G simd-clause$_{optseq}$ new-line

simd-clause:

\I collapse-clause

\G\I aligned-clause

\I linear-clause

\I uniform-clause

\I data-reduction-clause

\I inbranch-clause

inbranch-clause:

\C\I inbranch

\I notinbranch

\G uniform-clause:

\C\I uniform ( \G variable-list \C )

\G linear-clause:

\C\I linear ( \G linear-list \C )

\C\I linear ( \G linear-list \C :\G expression \C )

\G linear-list:

\C\I\G variable-list

\C\I\G linear-modifier \C ( \G variable-list \C )

\G linear-modifier:

\C\I ref

\C\I val

\C\I uval

\G aligned-clause:

\C\I aligned ( \G variable-list \C )

\I aligned ( \G variable-list \C :\G expression \C )

\G declare-simd-construct:

\I declare-simd-directive-seq function-statement

declare-simd-directive-seq:

\I declare-simd-directive

\I declare-simd-directive-seq declare-simd-directive

declare-simd-directive:

\C\I \# pragma omp declare simd \G declare-simd-clause$_{optseq}$ new-line

\G declare-simd-clause:

\C\I simdlen ( \G expression \C )

\G\I aligned-clause

\I linear-clause

\I uniform-clause

\I data-reduction-clause

\I inbranch-clause

for-simd-construct:

\I for-simd-directive iteration-statement

for-simd-directive:

\C\I \# pragma omp for simd \G for-simd-clause$_{optseq}$ new-line

for-simd-clause:

\I for-clause

\I simd-clause

parallel-for-simd-construct:

\I parallel-for-simd-directive iteration-statement

parallel-for-simd-directive:

\C\I \# pragma omp parallel for simd \G parallel-for-simd-clause$_{optseq}$ new-line

parallel-for-simd-clause:

\I parallel-for-clause

\I simd-clause

target-data-construct:

\I target-data-directive structured-block

target-data-directive:

\C\I \# pragma omp target data \G target-data-clause$_{optseq}$ new-line

target-data-clause:

\I device-clause

\I map-clause

\I if-clause

device-clause:

\C\I device ( \G expression \C )

\G map-clause:

\C\I map ( \G map-type$_{opt}$ variable-array-section-list \C )

\G map-type:

\C\I alloc:

\I to:

\I from:

\I tofrom:

\G target-construct:

\I target-directive structured-block

target-directive:

\C\I \# pragma omp target \G target-clause$_{optseq}$ new-line

target-clause:

\I device-clause

\I map-clause

\I if-clause

target-update-construct:

\I target-update-directive structured-block

target-update-directive:

\C\I \# pragma omp target update \G target-update-clause$_{optseq}$ new-line

target-update-clause:

\I motion-clause

\I device-clause

\I if-clause

motion-clause:

\C\I to ( \G variable-array-section-list \C )

\C\I from ( \G variable-array-section-list \C )

\G declare-target-construct:

\I declare-target-directive declaration-definition-seq end-declare-target-directive

declare-target-directive:

\C\I \# pragma omp declare target \G new-line

end-declare-target-directive:

\C\I \# pragma omp end declare target \G new-line

teams-construct:

\I teams-directive structured-block

teams-directive:

\C\I \# pragma omp teams \G teams-clause$_{optseq}$ new-line

teams-clause:

\C\I num\_teams ( \G expression \C )

\C\I thread\_limit ( \G expression \C )

\G\I data-default-clause

\I data-privatization-clause

\I data-privatization-in-clause

\I data-sharing-clause

\I data-reduction-clause

distribute-construct:

\I distribute-directive iteration-statement

distribute-directive:

\C\I \# pragma omp distribute \G distribute-clause$_{optseq}$ new-line

distribute-clause:

\I data-privatization-clause

\I data-privatization-in-clause

\I collapse-clause

\I dist\_schedule ( static )

\I dist\_schedule ( static , \G expression \C )

\G distribute-simd-construct:

\I distribute-simd-directive iteration-statement

distribute-simd-directive:

\C\I \#pragma omp distribute simd \G distribute-simd-clause$_{optseq}$ new-line

distribute-simd-clause:

\I distribute-clause

\I simd-clause

distribute-parallel-for-construct:

\I distribute-parallel-for-directive iteration-statement

distribute-parallel-for-directive:

\C\I \#pragma omp distribute parallel for \G distribute-parallel-for-clause$_{optseq}$ new-line

\I distribute-parallel-for-clause:

\I\I distribute-clause

\I\I parallel-for-clause

\I distribute-parallel-for-simd-construct:

\I\I distribute-parallel-for-simd-directive iteration-statement

\I distribute-parallel-for-simd-directive:

\C\I\I \#pragma omp distribute parallel for \G distribute-parallel-for-simd-clause$_{optseq}$ new-line

\I distribute-parallel-for-simd-clause:

\I\I distribute-clause

\I\I parallel-for-simd-clause

\I target-teams-construct:

\I\I target-teams-directive iteration-statement

\I target-teams-directive:

\C\I\I \#pragma omp target teams \G target-teams-clause$_{optseq}$ new-line

\I target-teams-clause:

\I\I target-clause

\I\I teams-clause

\I teams-distribute-construct:

\I\I teams-distribute-directive iteration-statement

\I teams-distribute-directive:

\C\I\I \#pragma omp teams distribute \G teams-distribute-clause$_{optseq}$ new-line

\I teams-distribute-clause:

\I\I teams-clause

\I\I distribute-clause

\I teams-distribute-simd-construct:

\I\I teams-distribute-simd-directive iteration-statement

\I teams-distribute-simd-directive:

\C\I \#pragma omp teams distribute simd \G teams-distribute-simd-clause$_{optseq}$ new-line

\I teams-distribute-simd-clause:

\I\I teams-clause

\I\I distribute-simd-clause

\I target-teams-distribute-construct:

\I\I target-teams-distribute-directive iteration-statement

\I target-teams-distribute-directive:

\C\I\I \#pragma omp target teams distribute \G target-teams-distribute-clause$_{optseq}$ new-line

\I target-teams-distribute-clause:

\I\I target-clause

\I\I teams-distribute-clause

\I target-teams-distribute-simd-construct:

\I\I target-teams-distribute-simd-directive iteration-statement

\I target-teams-distribute-simd-directive:

\C \I\I \#pragma omp target teams distribute simd \G target-teams-distribute-simd-clause$_{optseq}$ new-line

\I target-teams-distribute-simd-clause:

\I\I target-clause

\I\I teams-distribute-simd-clause

\I teams-distribute-parallel-for-construct:

\I\I teams-distribute-parallel-for-directive iteration-statement

\I teams-distribute-parallel-for-directive:

\C\I\I \#pragma omp teams distribute parallel for \G teams-distribute-parallel-for-clause$_{optseq}$ new-line

\I teams-distribute-parallel-for-clause:

\I\I teams-clause

\I\I distribute-parallel-for-clause

\I target-teams-distribute-parallel-for-construct:

\I\I target-teams-distribute-parallel-for-directive iteration-statement

\I target-teams-distribute-parallel-for-directive:

\C\I\I \#pragma omp teams distribute parallel for \G target-teams-distribute-parallel-for-clause$_{optseq}$ new-line

\I target-teams-distribute-parallel-for-clause:

\I\I target-clause

\I\I teams-distribute-parallel-for-clause

\I teams-distribute-parallel-for-simd-construct:

\I\I teams-distribute-parallel-for-simd-directive iteration-statement

\I teams-distribute-parallel-for-simd-directive:

\C\I \#pragma omp teams distribute parallel for simd \G teams-distribute-parallel-for-simd-clause$_{optseq}$ new-line

\I teams-distribute-parallel-for-simd-clause:

\I\I teams-clause

\I\I distribute-parallel-for-simd-clause

\I target-teams-distribute-parallel-for-simd-construct:

\I\I target-teams-distribute-parallel-for-simd-directive iteration-statement

\I target-teams-distribute-parallel-for-simd-directive:

\C\I\I \#pragma omp target teams distribute parallel for simd \G target-teams-distribute-parallel-for-simd-clause$_{optseq}$ new-line

\I target-teams-distribute-parallel-for-simd-clause:

\I\I target-clause

\I\I teams-distribute-parallel-for-simd-clause

\I task-construct:

\I\I task-directive structured-block

\I task-directive:

\C\I\I \# pragma omp task \G task-clause$_{optseq}$ new-line

task-clause:

\I unique-task-clause

\I data-default-clause

\I data-privatization-clause

\I data-privatization-in-clause

\I data-sharing-clause

unique-task-clause:

\I if-clause

\I final-clause

\I untied-clause

\I mergeable-clause 

\I priority-clause

\C\I depend ( \G dependence-type \C :\G variable-array-section-list \C )

\G final-clause:

\C\I final ( \G scalar-expression \C )

\G untied-clause:

\C\I untied

\G mergeable-clause:

\C\I mergeable

\G dependence-type:

\C\I in

\I out

\I inout

\G priority-clause:

\C\I priority ( \G scalar-expression \C )

\G taskloop-construct:

\I taskloop-directive iteration-statement

taskloop-directive:

\C\I \#pragma omp taskloop \G taskloop-clause$_{optseq}$ new-line

taskloop-clause:

\I unique-taskloop-clause 

\I data-sharing-clause

\I data-privatization-clause

\I data-privatization-in-clause

\I data-privatization-out-clause

\I data-default-clause

unique-taskloop-clause:

\C\I grainsize ( \G expression \C )

\I num\_tasks ( \G expression \C )

\G\I collapse-clause

\I if-clause

\I final-clause

\I untied-clause

\I mergeable-clause

\C\I nogroup

\G taskloop-simd-construct:

\I taskloop-simd-directive iteration-statement

\G taskloop-simd-directive:

\C\I \#pragma omp taskloop simd \G taskloop-simd-clause$_{optseq}$ new-line

taskloop-simd-clause:

\I taskloop-clause

\I simd-clause

\G parallel-for-construct:

\I parallel-for-directive iteration-statement

parallel-for-directive:

\C\I \# pragma omp parallel for \G parallel-for-clause$_{optseq}$ new-line

parallel-for-clause:

\I unique-parallel-clause

\I unique-for-clause

\I data-default-clause 

\I data-privatization-clause 

\I data-privatization-in-clause

\I data-privatization-out-clause 

\I data-sharing-clause 

\I data-reduction-clause 

parallel-sections-construct:

\I parallel-sections-directive section-scope

 parallel-sections-directive:

\C\I \# pragma omp parallel sections \G parallel-sections-clause$_{optseq}$ new-line

parallel-sections-clause:

\I unique-parallel-clause

\I data-default-clause 

\I data-privatization-clause 

\I data-privatization-in-clause

\I data-privatization-out-clause 

\I data-sharing-clause 

\I data-reduction-clause 

master-construct:

\I master-directive structured-block

master-directive:

\C\I \# pragma omp master \G new-line

critical-construct:

\I critical-directive structured-block

critical-directive:

\C\I \# pragma omp critical \G region-phrase$_{opt}$ hint-clause$_{opt}$ new-line

region-phrase:

\C\I ( \G identifier \C )

hint-clause: 

\C\I hint ( \G expression \C )

barrier-directive:

\C\I \# pragma omp barrier \G new-line

taskwait-directive:

\C\I \# pragma omp taskwait \G new-line

taskgroup-construct:

\I taskgroup-directive structured-block

taskgroup-directive:

\C\I \# pragma omp taskgroup \G new-line

taskyield-directive:

\C\I \# pragma omp taskyield \G new-line

atomic-construct:

\I atomic-directive expression-statement

\I atomic-directive structured block

atomic-directive:

\C\I \# pragma omp atomic \G atomic-construct-clause-seq$_{opt}$ new-line

atomic-construct-clause-seq:

\I atomic-clause

\I seq-cst-clause

\I seq-cst-clause atomic-clause

\I seq-cst-clause, atomic-clause

\I atomic-clause seq-cst-clause 

\I atomic-clause, seq-cst-clause 

atomic-clause:

\C\I read

\I write

\I update

\I capture

\G seq-cst-clause:

\C\I seq\_cst

\G flush-directive:

\C\I \# pragma omp flush \G flush-vars$_{opt}$ new-line

flush-vars:

\I ( variable-list )

ordered-construct:

\I ordered-directive structured-block

ordered-directive:

\C\I \# pragma omp ordered \G new-line

cancel-directive:

\C\I \# pragma omp cancel \G construct-type-clause if-clause$_{opt}$ new-line

construct-type-clause:

\C\I parallel

\I sections

\I for

\I taskgroup

\G cancellation-point-directive:

\C\I \# pragma omp cancellation point \G construct-type-clause new-line

declaration:

\G\I {\rmfamily\bfseries\upshape\small /* standard declarations */}

\G\I threadprivate-directive

\I declare-simd-directive

\I declare-target-construct

\I declare-reduction-directive

threadprivate-directive:

\C\I \# pragma omp threadprivate ( \G variable-list \C ) \G new-line

declare-reduction-directive:

\C\I \# pragma omp declare reduction ( \G reduction-identifier \C : \G reduction-type-list \C : \G expression \C ) \G initializer-clause$_{opt}$ new-line

reduction-identifier: 

\G\cspecificstart

\I identifier 

\G\cspecificend

\cppspecificstart

\I id-expression 

\G\cppspecificend

\ccppspecificstart

\I one of: \C + * - \& \^ { } \C | \&\& || min max 

\G\ccppspecificend

\G reduction-type-list: 

\I type-id 

\I reduction-type-list, type-id 

\begin{samepage}
initializer-clause: 

\G\cspecificstart

\C\I initializer ( \G identifier \C = \G initializer \C )

\C\I initializer ( \G identifier \C ( \G argument-expression-list \C ) ) 

\G\cspecificend
\end{samepage}

\G\cppspecificstart

\C\I initializer \C ( \G identifier initializer \C )

\I initializer \C ( \G id-expression \C ( \G expression-list \C ) ) 

\G\cppspecificend

\G data-default-clause:

\C\I default ( shared )

\I default ( none )

\G data-privatization-clause:

\C\I private ( \G variable-list \C )

\G data-privatization-in-clause:

\C\I firstprivate ( \G variable-list \C )

\G data-privatization-out-clause:

\C\I lastprivate ( \G variable-list \C )

\G data-sharing-clause:

\C\I shared ( \G variable-list \C )

\G data-reduction-clause:

\C\I reduction ( \G reduction-identifier \C : \G variable-list \C )

\G if-clause:

\C\I if ( \G scalar-expression \C )

\G\cspecificstart

\G array-section:

\I identifier array-section-subscript

variable-list:

\I identifier

\I variable-list \C, \G identifier

variable-array-section-list:

\I identifier

\I array-section

\I variable-array-section-list \C ,\G identifier

\I variable-array-section-list \C ,\G array-section

\G\cspecificend

\cppspecificstart

\I array-section:

\I id-expression array-section-subscript

variable-list:

\I id-expression

\I variable-list \C ,\G id-expression

variable-array-section-list:

\I id-expression

\I array-section

\I variable-array-section-list \C ,\G id-expression

\I variable-array-section-list \C ,\G array-section

\G\cppspecificend

\G array-section-subscript:

\I array-section-subscript [ expression$_{opt}$ \C :\G expression$_{opt}$ ]

\I array-section-subscript [ expression ]

\I [ expression$_{opt}$ \C :\G expression$_{opt}$ ]

\I [ expression ]

} % end of grammar block

% This is the end of appendix-B-grammar.tex

