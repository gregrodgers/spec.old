% This is ch4-toolsSupport.tex of the OpenMP specification.
% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%


\chapter{Tool Interface}
\index{Tools Support}
\label{chap:ToolsSupport}

This chapter describes the OMPT interface provided by the OpenMP API
to support third-party monitoring and performance analysis tools.
The chapter first explains if and how an implementation of
the OpenMP API will attempt to register a tool prior to initializing the 
OpenMP implementation and
how a registered tool will use the OMPT interface to initialize tool state maintained by
an implementation of the OpenMP API.
It concludes with a description of data types
used to identify entities managed by an OpenMP runtime and to interpret the
call stack of an OpenMP thread.

\section{Activating a Tool}
Activating a tool requires three steps: registering the tool with an OpenMP
implementation by supplying the implementation with a
callback to a tool initializer, executing the tool
initializer callback, binding pointers to OMPT interface functions 
in the tool, and registering tool callbacks for OpenMP events. 
Finally, to understand what information dynamic measurements might yield
about thread states and implementations of mutual exclusion, a tool can
enumerate the thread states and implementations of mutual exclusion 
that a particular OpenMP implementation implementation employs.
The following subsections explain each of these steps in turn.

\subsection{Registering a Tool}
\index{tool registration}
\label{sec:ToolsSupport_Registration}

If the value of the \plc{tool-var} ICV is \code{enabled}
when an OpenMP implementation begins to initialize itself, 
the OpenMP implementation will attempt to register a tool by first 
determining if
an implementation of the function \code{ompt\_tool} exists in a program's address space and, if so, calling it.
If the value of \plc{tool-var} is \code{disabled}, an OpenMP 
implementation will neither check for the existence of an implementation of
\code{ompt\_tool} in the address space nor try to call any that might exist.

To register itself with an OpenMP implementation, a tool provides
an implementation of \code{ompt\_tool} that returns
a non-\code{NULL} pointer to a function with type
signature \code{ompt\_initialize\_fn\_t}, which is in
Section~\ref{sec:ompt_initialize_fn_t}.
A tool-provided implementation of \code{ompt\_tool} may decline to 
to register itself with an OpenMP implementation by returning
\code{NULL}.

Since only one tool-provided definition of \code{ompt\_tool} will be seen by an OpenMP implementation, only one tool may register itself.
If a tool-supplied implementation of \code{ompt\_tool} returns a non-\code{NULL} initializer,
an implementation of the OpenMP API will maintain state information for each OpenMP thread and will perform
any OMPT event callbacks successfully registered during tool initialization.

After a process fork, if OpenMP is re-initialized in the child process,
an implementation of the OpenMP API in the child process will call \code{ompt\_tool}
under the same conditions as it would for any process.

\subsection{Initializing a Tool}
\label{sec:tool-initialize}

When an OpenMP implementation receives a non-\code{NULL} pointer to a tool initializer function with signature \code{ompt\_initialize\_fn\_t} as the return value from a call to a tool-provided implementation of \code{ompt\_tool}, the runtime will call the tool initializer immediately after the runtime fully initializes itself.
The initializer must be called before beginning execution of any OpenMP construct or completing any execution environment routine invocation.

The two principal duties of a tool initializer are binding pointers to all OMPT interface functions that the tool uses and registering tool callbacks. These
two operations are described in the next two sections.

\subsection{Binding OMPT Interface Functions}
\label{sec:ToolsSupport_bind}

The first duty of a tool initializer is binding pointers to the 
an OpenMP implementation's OMPT interface functions.
Table~\ref{table:host-ompt-interface-functions} 
indicates functions in the host implementation of the 
OMPT interface of an OpenMP runtime and their
type signatures.

\begin{table}
\begin{tabular}{ll}\hline
Entry Point String Name & Type signature\\\hline\hline
\code{``ompt\_enumerate\_states''}  & \code{ompt\_enumerate\_states\_t}\\
\code{``ompt\_enumerate\_mutex\_kinds''} & \code{ompt\_enumerate\_mutex\_kinds\_t}\\
\code{``ompt\_set\_callback''} & \code{ompt\_set\_callback\_t}\\
\code{``ompt\_get\_callback''} & \code{ompt\_get\_callback\_t}\\
\code{``ompt\_get\_thread\_data''} & \code{ompt\_get\_thread\_data\_t}\\
\code{``ompt\_get\_state''} & \code{ompt\_get\_state\_t}\\
\code{``ompt\_get\_parallel\_info''} & \code{ompt\_get\_parallel\_info\_t}\\
\code{``ompt\_get\_task\_info''} & \code{ompt\_get\_task\_info\_t}\\
\code{``ompt\_get\_num\_devices''} & \code{ompt\_get\_num\_devices\_t}\\
\code{``ompt\_get\_device\_info''} & \code{ompt\_get\_device\_info\_t}\\
\code{``ompt\_get\_device\_id''} & \code{ompt\_get\_device\_id\_t}\\\hline
\end{tabular}
\vskip 1ex
\caption{OMPT callback interface entry point names and their type signatures.}
\label{table:host-ompt-interface-functions} 
\end{table}

The following example shows how to use the \plc{lookup} callback 
passed to a tool's initializer to obtain a pointer to the 
OMPT interface function \code{ompt\_get\_thread\_id}:




\vbox{
\ccppspecificstart
\begin{boxedcode}
ompt\_interface\_fn\_t \plc{ompt\_get\_thread\_id\_fn} =
                        \plc{lookup}("ompt\_get\_thread\_id");
\end{boxedcode}
\ccppspecificend
}

Other routines in the OMPT interface may be looked up analogously.
If a particular OMPT interface function is not supported by 
an OpenMP implementation, \plc{lookup} will return \code{NULL} when 
invoked with the function's name as an argument. 

\subsection{Registering Tool Callbacks}
\index{event callback registration}
\label{sec:ToolsSupport_callback_registration}

Tools register callbacks to receive notification of events that occur as
an OpenMP program executes by invoking the runtime callback known by the name
\code{ompt\_set\_callback}.
The \code{ompt\_set\_callback} routine may only be called within
the implementation of a tool's initializer.  The possible return
codes for \code{ompt\_set\_callback} and their meaning is shown in
Table~\ref{table:ToolsSupport_set_rc}.  Registration of supported
callbacks may fail, returning 0, if this routine is called outside
a tool's initializer.  

The \code{ompt\_callback\_t} type for a callback to be registered 
does not reflect the actual signature of the callback; 
OMPT uses this generic type
to avoid the need to declare a separate registration function for each actual callback type.
The valid return codes for each event are listed in Table~\ref{table:valid_rc}.
Some events always need to invoke the registered callback.
For other events, its implementation defined whether they invoke the registered
callback never, sometimes, or always.
The return code makes this implementation defined behaviour machine readable to
the connected tool.

\begin{table}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{lp{3em}p{3em}p{3em}p{3em}}
                                & \rot{event may occur; no callback is possible}
                                & \rot{event will never occur in runtime}
                                & \rot{event may occur; callback invoked when convenient}
                                & \rot{event may occur; callback always invoked when event occurs}\\
                                \midrule
ompt\_event\_thread\_begin          &   &   &   & * \\
ompt\_event\_thread\_end            &   &   &   & * \\
ompt\_event\_parallel\_begin        &   &   &   & * \\
ompt\_event\_parallel\_end          &   &   &   & * \\
ompt\_event\_task\_create           &   &   &   & * \\
ompt\_event\_task\_schedule         &   &   &   & * \\
ompt\_event\_implicit\_task         &   &   &   & * \\
ompt\_event\_target                 &   &   &   & * \\
ompt\_event\_target\_data           &   &   &   & * \\
ompt\_event\_target\_submit         &   &   &   & * \\
ompt\_event\_tcontrol               &   &   &   & * \\
ompt\_event\_runtime\_shutdown      &   &   &   & * \\
ompt\_event\_idle                   & * & * & * & * \\
ompt\_event\_sync\_region\_wait     & * & * & * & * \\
ompt\_event\_mutex\_release         & * & * & * & * \\
ompt\_event\_task\_dependences      & * & * & * & * \\
ompt\_event\_task\_dependence\_pair & * & * & * & * \\
ompt\_event\_worksharing            & * & * & * & * \\
ompt\_event\_master                 & * & * & * & * \\
ompt\_event\_target\_data\_map      & * & * & * & * \\
ompt\_event\_sync\_region           & * & * & * & * \\
ompt\_event\_init\_lock             & * & * & * & * \\
ompt\_event\_destroy\_lock          & * & * & * & * \\
ompt\_event\_mutex\_acquire         & * & * & * & * \\
ompt\_event\_mutex\_acquired        & * & * & * & * \\
ompt\_event\_nested\_lock           & * & * & * & * \\
ompt\_event\_flush                  & * & * & * & * \\
\bottomrule
\end{tabular}
\caption{Valid return codes of \code{ompt\_set\_callback} for each input event argument.}
\label{table:valid_rc}
\end{table}

\crossreferences
\begin{itemize}
\item \code{ompt\_event\_t} enumeration type, see
\specref{sec:ompt_event_t}.
\end{itemize}

\clearpage

\subsection{Enumerating States and Implementations}
Using the OMPT interface, a tool may interrogate an OpenMP implementation to 
determine what thread states it supports and what mechanisms it employs to 
implement mutual exclusion for various purposes.

\section{Tracing Device Activity}
\label{sec:tracing-device-activity}

Target devices typically operate asynchronously with respect to a
host. It may not be practical or possible to make event callbacks
on a target device. These characteristics motivate the design of a
performance monitoring interface for target devices where:

\begin{itemize}
\item the target device records events that occur during its execution in a trace buffer,
\item when a trace buffer fills on a device (or it is otherwise useful to flush the buffer),  the device provides it to a tool on the host, by invoking a tool-supplied callback function to process and empty the buffer,
\item when the target device needs a new trace buffer, it invokes a tool-supplied callback function to request a new buffer,
\end{itemize}


Section~\ref{sec:ompt_set_trace_ompt_t}  describes how to enable or disable
tracing on a target device for specific OMPT events.
Section~\ref{sec:ompt_set_trace_native_t}  describes how to enable or
disable tracing on a target device for specific native events.
The Sections~\ref{sec:ompt_start_trace_t}, \ref{sec:ompt_pause_trace_t} 
and \ref{sec:ompt_stop_trace_t}  describe how to start, pause and
stop event tracing on a device.

Some functions in the target device tracing control API described
in this section are marked with \code{OMPT\_TARG\_API}. These represent
function pointers that should be obtained from a target device by
invoking the \code{lookup} function (provided by the target  as a
return value to function \code{ompt\_get\_device\_info}) and
passing it the name of the function of interest.


\section{Data Types}
\label{sec:data}

\subsection{Thread States}
\label{sec:thread-states}

To enable a tool to understand the behavior of an executing program, 
an OpenMP implementation maintains a state for each thread. 
The state maintained for a thread is an
approximation of the thread's instantaneous state. 

\vbox{
\ccppspecificstart
A thread's state will be one of the values of the  
enumeration type \code{omp\_state\_t} or
an implementation-defined state value of 512 or higher. 
Thread states in the enumeration fall into several classes: 
work, barrier wait, task wait, mutex wait, target wait, 
and miscellaneous. 

\begin{boxedcode}
typedef enum omp_state_t \{
  omp_state_work_serial            = 0x000,
  omp_state_work_parallel          = 0x001,
  omp_state_work_reduction         = 0x002,

  omp_state_wait_barrier           = 0x010,
  omp_state_wait_barrier_implicit  = 0x011,
  omp_state_wait_barrier_explicit  = 0x012,

  omp_state_wait_taskwait          = 0x020,
  omp_state_wait_taskgroup         = 0x021,

  omp_state_wait_mutex             = 0x040,
  omp_state_wait_lock              = 0x041,
  omp_state_wait_critical          = 0x042,
  omp_state_wait_atomic            = 0x043,
  omp_state_wait_ordered           = 0x044,

  omp_state_wait_target            = 0x080,
  omp_state_wait_target_data       = 0x081,
  omp_state_wait_target_update     = 0x082,

  omp_state_idle                   = 0x100, 
  omp_state_overhead               = 0x101, 
  omp_state_undefined              = 0x102
\} omp_state_t;
\end{boxedcode}
\ccppspecificend
}


A tool can query the OpenMP state of a thread at any time. 
If a tool queries the state of a thread that is not associated 
with OpenMP, the implementation reports the state as \code{omp\_state\_undefined}.

\begin{comment}
For each OpenMP thread the runtime maintains not only a state but also an \code{ompt\_wait\_id\_t}
identifier.  When a thread is waiting for a lock, critical region,
ordered, or atomic, and the thread is in a wait
state, then 
the thread's \code{wait\_id} field identifies the lock, critical construct, ordered construct, atomic construct, or internal variable
upon which the
thread is waiting. The semantics of the values used for a \code{wait\_id} are implementation defined.
A thread's \code{wait\_id} is undefined if the thread
is not in a wait state.
\end{comment}

Some values of the enumeration type \code{omp\_state\_t} are used by all 
OpenMP implementations, 
e.g., \code{omp\_state\_work\_serial}, 
which indicates that a thread is executing in a serial region, and  
\code{omp\_state\_work\_parallel}, 
which indicates that a thread is executing in a parallel region.
Other values of the enumeration type describe a thread's state at 
different levels of specificity. 
For instance, an OpenMP implementation may use 
the state \code{omp\_state\_wait\_barrier}  to represent all 
waiting at barriers; or it may differentiate between waiting at 
implicit and explicit barriers by using the pair of states
\code{omp\_state\_wait\_barrier\_implicit} and 
\code{omp\_state\_wait\_barrier\_explicit}. 

For states that represent waiting, an OpenMP implementation has the 
choice of transitioning a thread to such states early or late.
For instance, when an OpenMP thread is trying to acquire a lock,
there are several points at which an OpenMP implementation
transition the thread to the \code{omp\_state\_wait\_lock} state.
One implementation may transition the thread to the state 
early before the thread attempts to acquire a
lock. Another implementation may transition the thread to the state 
late, only if the thread begins to spin or
block to wait for an unavailable lock. A third implementation
may transition the thread to the state even later, e.g., only
after the thread waits for a significant amount of time. 

The following describes the classes and the states in each class.
\subsubsection{Work States}
An OpenMP implementation reports a thread in a work state 
when the thread is performing serial work, parallel work, or a reduction.

\begin{description}

\item \code{omp\_state\_work\_serial} 

  The thread is executing code outside all parallel regions. 

\item \code{omp\_state\_work\_parallel} 

  The thread is executing code within the scope of a parallel region construct.

\sloppy
\item \code{omp\_state\_work\_reduction} 
 
  The thread is combining partial reduction results from threads in its team. 
  An OpenMP implementation  
  might never report a thread in this state; a thread
  combining partial reduction results may have its state reported as
  \code{omp\_state\_work\_parallel} or \code{omp\_state\_overhead}.

\end{description}


\subsubsection{Barrier Wait States}

An OpenMP implementation reports that a thread is in a barrier wait state 
when the thread is is awaiting completion of a barrier.


\begin{description}

  \item \code{omp\_state\_wait\_barrier} 
  
  \sloppy
  The thread is waiting at either an implicit or explicit barrier.
  A thread may enter this state
  early, when the thread encounters a barrier, or late, when the
  thread begins to wait at the barrier. An implementation may never report a thread in this state; instead, a thread may have its state reported
  as \code{omp\_state\_wait\_barrier\_implicit}  or \code{omp\_state\_wait\_barrier\_explicit}, as appropriate.
  
  \item \code{omp\_state\_wait\_barrier\_implicit} 
  
  \sloppy
  The thread is waiting at an implicit barrier in a parallel region. 
  A  thread may enter this state
  early, when the thread encounters a barrier, or late, when the
  thread begins to wait at the barrier.
  An OpenMP implementation may report \code{omp\_state\_wait\_barrier} 
  for implicit barriers.
  
  \item \code{omp\_state\_wait\_barrier\_explicit} 

  The thread is waiting at an explicit barrier  in a parallel region. 
  A thread may enter this state
  early, when the thread encounters a barrier, or late, when the
  thread begins to wait at the barrier.
  An implementation may report \code{omp\_state\_wait\_barrier} 
  for explicit barriers.
  
\end{description}
  
\subsubsection{Task Wait States}

\begin{description}

\item \code{omp\_state\_wait\_taskwait} 

  The thread is waiting at a taskwait construct. A 
  thread may enter this state early, when the
  thread encounters a taskwait construct, or late, when the thread
  begins to wait for an uncompleted task.

\item \code{omp\_state\_wait\_taskgroup} 

  The thread is waiting at the end of a taskgroup construct. A 
  thread may enter this state early, when the
  thread encounters the end of a taskgroup construct, or late, when the thread
  begins to wait for an uncompleted task.

\end{description}


\subsubsection{Mutex Wait States}

OpenMP provides several mechanisms that enforce mutual exclusion:
locks as well as critical, atomic, and ordered sections.  This
grouping contains all states used to indicate that a thread is is
awaiting exclusive access to a lock, critical section, variable,
or ordered section.

An OpenMP implementation may report a thread waiting for any type
of mutual exclusion using either a state that precisely identifies
the type of mutual exclusion, or  a more generic state such as
\code{omp\_state\_wait\_mutex} or \code{omp\_state\_wait\_lock}.  This
flexibility may significantly simplify the maintenance of states
associated with mutual exclusion in the runtime when various
mechanisms for mutual exclusion rely on a common implementation,
e.g., locks.

% Section~\ref{sec:wait-identifier} describes how each thread maintains a wait identifier to identify what a thread is awaiting. Before a thread enters any state indicating that it is awaiting mutual exclusion, the OpenMP runtime will update the thread's wait identifier to indicate what the thread is awaiting. 

\begin{description}

\item \code{omp\_state\_wait\_mutex}

  The thread is waiting for a mutex of an unspecified type. A 
  thread may enter this state early, when a thread encounters a lock acquisition or a region that requires mutual exclusion, or late, when the thread begins to wait.

\item \code{omp\_state\_wait\_lock}

  The thread is waiting for a  lock  or nest lock. A 
  thread may enter this state early, when a thread
  encounters a lock \code{set} routine, or late, when the thread
  begins to wait for a lock.

\item \code{omp\_state\_wait\_critical} 

  The thread is waiting to enter a critical region. A 
  thread may enter this state early, when the
  thread encounters a critical construct, or late, when the thread
  begins to wait to enter the critical region. 


\item \code{omp\_state\_wait\_atomic} 

  The thread is waiting to enter an atomic region. A 
  thread may enter this state early, when the thread
  encounters an atomic construct, or late, when the thread begins
  to wait to enter the atomic region. 
  An implementation may opt not to report
  this state when using atomic hardware instructions that support non-blocking atomic implementations.
  

\item \code{omp\_state\_wait\_ordered} 

  The thread is waiting to enter an ordered region. A 
  thread may enter this state early, when the thread encounters
  an ordered construct, or late, when the thread begins
  to wait to enter the ordered region. 
  
\end{description}
  
\subsubsection{Target Wait States}

\begin{description}

\item \code{omp\_state\_wait\_target} 

  The thread is waiting for a target region to complete.
  
\item \code{omp\_state\_wait\_target\_data} 

  The thread is waiting for a target data mapping operation to complete. 
  An implementation may report \code{omp\_state\_wait\_target} 
  for target data constructs.

\item \code{omp\_state\_wait\_target\_update} 

  The thread is waiting for a target  update operation to complete. 
  An implementation may report \code{omp\_state\_wait\_target} 
  for target update constructs.

\end{description}


\subsubsection{Miscellaneous States}

\begin{description}
\item \code{omp\_state\_idle} 

  The thread is idle, waiting for work.

\item \code{omp\_state\_overhead} 

  A thread may be reported as being in the overhead state at any point while 
  executing within an OpenMP runtime, except while waiting indefinitely
  at a synchronization point.
%  e.g., while preparing to execute a parallel, task, or worksharing construct. 
  An OpenMP implementation report a thread's state as a work state for
  some or all of the time the thread spends in executing in the OpenMP runtime.

\item \code{omp\_state\_undefined} 

  This state is reserved for threads that are not user threads,
  initial threads, threads currently in an OpenMP team, or threads
  waiting to become part of an OpenMP team.

\end{description}

\subsection{Tool Callback Events}
\label{sec:ompt_event_t}

The following enumeration type indicates the integer code used to identify 
events when registering or querying callbacks associated with them.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_event_t \{
  ompt_event_thread_begin             = 1,
  ompt_event_thread_end               = 2,
  ompt_event_parallel_begin           = 3,
  ompt_event_parallel_end             = 4,
  ompt_event_task_create              = 5,
  ompt_event_task_schedule            = 6,
  ompt_event_implicit_task            = 7,
  ompt_event_target                   = 8,
  ompt_event_target_data              = 9,
  ompt_event_target_submit            = 10,
  ompt_event_tcontrol                 = 11,
  ompt_event_runtime_shutdown         = 12,
  ompt_event_idle                     = 13,
  ompt_event_sync_region_wait         = 14,
  ompt_event_mutex_release            = 15,
  ompt_event_task_dependences         = 16,
  ompt_event_task_dependence_pair     = 17,
  ompt_event_worksharing              = 18,
  ompt_event_master                   = 19,
  ompt_event_target_data_map          = 20,
  ompt_event_sync_region              = 21,
  ompt_event_init_lock                = 22,
  ompt_event_destroy_lock             = 23,
  ompt_event_mutex_acquire            = 24,
  ompt_event_mutex_acquired           = 25,
  ompt_event_nested_lock              = 26,
  ompt_event_flush                    = 27,
  ompt_event_device_initialize        = 28
\} ompt_event_t;
\end{boxedcode}
\ccppspecificend
}

\subsection{Identifiers for Tracing}
\label{sec:identifiers}

Since a tool receives trace records for devices asynchronously, a
tool cannot store data in an \code{ompt\_data\_t} field when device
events happen.  For that reason, trace records for OpenMP threads,
parallel regions, task regions use an identifier of type \code{ompt\_id\_t}
rather than providing a tool access to a data field in their runtime
representation.  A thread or region's identifier is assigned when
the thread or region is created.  On each device, such identifiers
are unique from the time an OpenMP runtime is initialized until it
is shut down.  Tools should not assume that \code{ompt\_id\_t} values
are small or densely allocated. The value \code{ompt\_id\_none} is
reserved to indicate an invalid id.


\littleheader{Thread Identifier}
\index{Thread Identifier}

Each OpenMP thread  has an associated identifier of type \code{ompt\_thread\_id\_t}.
\begin{comment}
\begin{boxedcode}
typedef unsigned long long int ompt\_thread\_id\_t;
\end{boxedcode}
\end{comment}
  A thread's identifier is assigned when the thread is created.
  Identifiers assigned to threads on each device are unique from the time an OpenMP implementation is initialized until it is shut down.
  A thread identifier can be retrieved
  on demand by invoking the  \code{ompt\_get\_thread\_id}
  function (described in Section~\ref{sec:thread-inquiry}).
  Tools should not assume that \code{ompt\_thread\_id\_t} values are small or densely allocated.
  The value \code{ompt\_thread\_id\_none} is reserved to indicate an invalid thread id.

\littleheader{Parallel Region Identifiers}
\index{Parallel Region Identifiers}
Each OpenMP parallel region has an associated identifier of type
\code{ompt\_parallel\_id\_t}.
\begin{comment}
\begin{boxedcode}
typedef unsigned long long int ompt\_parallel\_id\_t;
\end{boxedcode}
\end{comment}
  A parallel region's identifier is assigned
  when the region is created.  Identifiers assigned to parallel regions on each device are unique from the time an
  OpenMP implementation is initialized until it is shut down.
  A parallel region identifer can be retrieved for an enclosing parallel region
  on demand using the function \code{ompt\_get\_parallel\_info}  (described in Section~\ref{sec:ompt_get_parallel_info}).
  Tools should not assume that \code{ompt\_parallel\_id\_t} values are small or densely allocated.
  The value \code{ompt\_parallel\_id\_none} is reserved to indicate an invalid parallel id.


\littleheader{Task Region Identifiers}
\index{Task Region Identifiers}
Each OpenMP task has an associated identifier of type
\code{ompt\_task\_id\_t}. Task identifiers are assigned to
initial, implicit, explicit, and target tasks.
\begin{comment}
\begin{boxedcode}
typedef unsigned long long int ompt\_task\_id\_t;
\end{boxedcode}
\end{comment}
  A task's identifier is assigned
  when the task is created.
  Identifiers assigned to tasks on each device are unique from the time an
  OpenMP implementation is initialized until it is shut down.
  A task's identifier can be retrieved
  on demand by invoking the \code{ompt\_get\_task\_info}  function (described in Section~\ref{sec:ompt_get_task_info}).
  Tools should not assume that \code{ompt\_task\_id\_t} values are small or densely allocated.
  The value \code{ompt\_task\_id\_none} is reserved to indicate an invalid task identifier.

\littleheader{Target Region and Operation Identifiers}
\index{Target Region and Operation Identifiers}
Each OpenMP target region and target operation has an associated identifier of type \code{ompt\_target\_id\_t}.
A unique target identifier is assigned on the host each time an instance of a target construct is encountered.
Each operation within a target region, e.g., transferring data to/from a device or launching a kernel launch
on a device, is also assigned a unique target identifier.
Identifiers assigned to target regions or operations
are unique from the time an OpenMP implementation is initialized until it is shut down.
The current target region and operation identifiers can be retrieved by invoking the \code{ompt\_get\_target\_info} function (described in Section~\ref{sec:ompt_get_target_info}).
Tools should not assume that \code{ompt\_target\_id\_t} values are small or densely allocated.
The value \code{ompt\_target\_id\_none} is reserved to indicate an invalid target identifier.
The value \code{ompt\_target\_id\_none} will be returned for (a) the target region identifier if \code{ompt\_get\_target\_info} is invoked outside a target region and (b) the target operation identifier if \code{ompt\_get\_target\_info} is invoked while no target operation is in progress.

\littleheader{Wait Identifiers}
\index{Wait Identifiers}

Each thread instance maintains a {\em wait identifier} of type \code{ompt\_wait\_id\_t}.
When a task executing on a thread is waiting for something, the thread's wait identifer indicates what the thread is awaiting.
A wait identifier may represent a critical section {\em name}, a lock,  a program variable accessed in an atomic region, or a synchronization object internal to an OpenMP implementation.
\begin{comment}
\begin{boxedcode}
typedef unsigned long long int ompt\_wait\_id\_t;
\end{boxedcode}
\end{comment}
A thread's wait identifier can be retrieved on demand by invoking the \code{ompt\_get\_state} function (described in Section~\ref{sec:ompt_get_state}).
Tools should not assume that \code{ompt\_wait\_id\_t} values are small or densely allocated.
When a thread is not in a wait state, a thread's wait identifier has an undefined value.
%%? Does that mean that the value is undefined and cannot sensibley be read, or that it has a specific value which we have
%%? defined somewhere, whose name is (something like) ompt_wait_id_undefined  ?
%%johnmc says: a wait_id typically is set to the address of a lock on which you are spinning. If you aren't spinning on a lock, this value is undefined.
%%             we could zero it out, but that would cost more.

\subsection{Frames}
\index{Frames}

When executing an OpenMP program, at times procedure frames from
the OpenMP runtime appear on the call stack between procedure frames
for user code.  To enable a tool to determine whether each procedure
frame on the call stack represents user code or an OpenMP runtime
routine, an implementation of the OpenMP API must maintains an
instance of an \code{ompt\_frame\_t} for each (possibly
degenerate\footnote{ A task is considered degenerate if a call to
the OpenMP runtime to create a parallel region or task does not
create a new task.  A degenerate task may arise when a parallel
construct is encountered in a parallel region and nested parallelism
is not enabled or when an orphaned directive that would create a
task is encountered outside a parallel region.  A degenerate task
region may add runtime frames to the call stack before invoking an
outlined function for the degenerate task and thus require an
\code{ompt\_frame\_t} data structure.}) task that is active on a
thread's stack.  To simplify discussion that follows, we omit the
qualifier ``possibly degenerate'' each time we use the term {\em
task}.

Each initial, implicit, explicit, or target task maintains an
\code{ompt\_frame\_t} data structure that contains a pair of pointers.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_frame_s \{\\
  void * \plc{exit_frame};
  void * \plc{enter_frame};
\} ompt_frame_t;
\end{boxedcode}
\ccppspecificend
}

An \code{ompt\_frame\_t}'s  lifetime begins when a task  is created
and ends when the task is destroyed.  Tools should not assume that
a frame structure remains at a constant location in memory throughout
a task's lifetime.  A frame object is passed to some callbacks; it
can also be retrieved asynchronously by invoking the
\code{ompt\_get\_task\_info}  function (described in
Section~\ref{sec:ompt_get_task_info}) in a signal handler.  A task's frame
object contains two fields: \code{exit\_frame} and \code{enter\_frame}.

The \code{exit\_frame} field of a task's frame object is set just
before the task starts executing the structred block of the task
region.  The field contains the canonical frame address of the
procedure that invoked the outlined function.  In cases where the
an outlined procedure is invoked directly from a user code frame,
\code{exit\_frame} will contain the canonical frame address of a
procedure containing  user code that belongs to the enclosing task.
The value of \code{exit\_frame} is \code{NULL} in a task's frame
object until just before the task calls an outlined function to
begin execution. The value of \code{exit\_frame} is set to \code{NULL}
when the task returns to the runtime, whether finished or deferred.

The \code{enter\_frame} field of a task's frame object is set each time the task re-enters the
runtime to create a new implicit, explicit, or target task. When a task invokes an entry point in the
OpenMP runtime to create a task,
the \code{enter\_frame} field of the task's frame object will be set to
the canonical frame address of the user function that invoked the runtime.
The value of \code{enter\_frame} is set when a task enters the OpenMP runtime
and cleared before the OpenMP runtime returns control to the task.

\begin{table}
\begin{center}
\begin{tabular}{p{1in}p{2in}p{2in}}
\hline
\code{exit\_frame} / \code{enter\_frame} 	& \code{enter\_frame} is \code{NULL}										& \code{enter\_frame} is defined \\
\hline
\code{exit\_frame} is \code{NULL} & case 1)  initial task in user code\newline case 2) task that is created but not yet scheduled or already finished & initial task entered the runtime to schedule an implicit, explicit, or target task \\\hline
\code{exit\_frame} is defined 	& non-initial task in (or soon to be in) user code							& non-initial task entered the runtime and scheduled an implicit, explicit, or target task\\
\hline
\end{tabular}
\vspace{1ex}
\end{center}
\caption{Meaning of various values for \code{exit\_frame} and \code{enter\_frame}.}
\label{tab:frame}
\end{table}

Table~\ref{tab:frame} describes the meaning of this structure with
various values.  In the presence of nested parallelism, a tool may
observe a sequence of \code{ompt\_frame\_t} records for a thread.
Appendix~\ref{app:frame} discusses  an example that illustrates the
use of \code{ompt\_frame\_t} records with nested parallelism.

\littleheader{Advice to tool implementers:} 
A monitoring tool using asynchronous sampling can observe values
of \code{exit\_frame} and \code{enter\_frame} at inconvenient times.
Tools must be prepared to observe and handle frame exit and reenter
values that have not yet been set or reset as the program enters
or leaves the runtime.

\subsection{Miscellaneous Type Definitions}
\label{sec:ompt-types:misc}
This section describes miscellaneous defines, types and enumerations used by tool callbacks.

% OMPT_API

\subsubsection{\code{OMPT\_API}}
\label{OMPT_API} 
\code{OMPT\_API} is used to mark OMPT functions obtained from lookup function
passed to \code{ompt\_initialize\_fn\_t}.
                                             
% OMPT_TARG_API

\subsubsection{\code{OMPT\_TARG\_API}}
\label{OMPT_TARG_API} 
\code{OMPT\_TARG\_API} is used to mark OMPT functions obtained from lookup
function passed to \code{ompt\_get\_device\_info}.

% ompt_hwid_none

\subsubsection{\code{ompt\_hwid\_none}}
\label{sec:ompt_hwid_none} 
\code{ompt\_hwid\_none} refers to an uknown or unspecified hardware id.
If there is no \code{hwid} associated with a
\code{ompt\_record\_native\_abstract\_t}, the value of \code{hwid} shall be
\code{ompt\_hwid\_none}.

\vbox{
\ccppspecificstart
\begin{boxedcode}
#define ompt\_hwid\_none (-1)
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_record\_native\_abstract\_t} enumeration type, see
\specref{sec:ompt_buffer_get_record_native_abstract_t}.
\end{itemize}
\end{comment}

% ompt_dev_task_none

\begin{comment}
KAH: What does this do?  Is it supposed to be ompt_dep_task_none? i.e. no task dependency?
JP:  I think, there was a device task in some previous version of the tr.

\subsubsection{\code{ompt\_dev\_task\_none}}
\label{sec:ompt_dev_task_none} 
\code{ompt\_dev\_task\_none} is ...?
\vbox{
\ccppspecificstart
\begin{boxedcode}
#define ompt\_dev\_task\_none (~0ULL)
\end{boxedcode}
\ccppspecificend
}
\end{comment}

% ompt_time_none 

\subsubsection{\code{ompt\_time\_none}}
\label{sec:ompt_time_none} 
\code{ompt\_time\_none} refers to an uknown or unspecified time.
If there is no \code{start\_time} and/or \code{end\_time} associated with a
\code{ompt\_record\_native\_abstract\_t}, 
the value of an unavailable field will be the value
\code{ompt\_time\_none}.

\vbox{
\ccppspecificstart
\begin{boxedcode}
#define ompt\_time\_none (~0ULL)
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_record\_native\_abstract\_t} enumeration type, see
\specref{sec:ompt_buffer_get_record_native_abstract_t}.
\end{itemize}
\end{comment}

% ompt_id_none

\subsubsection{\code{ompt\_id\_none}}
\label{sec:ompt_id_none} 
The value \code{ompt\_id\_none} is reserved to indicate an invalid id for any parameter of type \code{ompt\_id\_t}.

\vbox{
\ccppspecificstart
\begin{boxedcode}
#define ompt\_id\_none 0
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_id\_t} type, see \specref{sec:ompt_id_t}.
\end{itemize}
\end{comment}

% ompt_data_none

\subsubsection{\code{ompt\_data\_none}}
\label{sec:ompt_data_none} 
The initial value of an \code{ompt\_data\_t} identifier is
\code{ompt\_data\_none}. This allows tools to detect if the identifier has
already been initialzed.

\vbox{
\ccppspecificstart
\begin{boxedcode}
/* initial value of ompt_data_t instances *
 * provided by the runtime                */
ompt_data_t ompt_data_none = \{.id=0\};         
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see \specref{sec:ompt_data_t}.
\end{itemize}
\end{comment}

% ompt_mutex_kind_none

\subsubsection{\code{ompt\_mutex\_kind\_none}}
\label{sec:ompt_mutex_kind_none} 
The value \code{ompt\_mutex\_kind\_none} is reserved to indicate an invalid
kind for any parameter of type \code{ompt\_mutex\_kind\_t}.

\vbox{
\ccppspecificstart
\begin{boxedcode}
#define ompt\_mutex\_kind\_unknown 0
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_mutex\_kind\_t} type, see \specref{sec:ompt_mutex_kind_t}.
\end{itemize}
\end{comment}

% ompt_id_t

\subsubsection{\code{ompt\_id\_t}}
\label{sec:ompt_id_t} 
Each OpenMP target region and target operation has an associated identifier of
type \code{ompt\_id\_t}.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef unsigned long long int ompt_id_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_scoped\_target\_callback\_t} callback type, see \specref{sec:ompt_scoped_target_callback_t}.
\item \code{ompt\_target\_data\_callback\_t} callback type, see \specref{sec:ompt_target_data_callback_t}.
\item \code{ompt\_target\_data\_map\_callback\_t} callback type, see \specref{sec:ompt_target_data_map_callback_t}.
\item \code{ompt\_target\_submit\_callback\_t} callback type, see \specref{sec:ompt_target_submit_callback_t}.
\item \code{ompt\_get\_target\_info\_inquiry\_t} callback type, see \specref{sec:ompt_get_target_info_inquiry_t}.
\item \code{ompt\_get\_target\_info} function, see \specref{sec:ompt_get_target_info}.
\item \code{ompt\_buffer\_get\_record\_native} inquiry function, see \specref{sec:ompt_buffer_get_record_native}.
\item \code{ompt\_record\_parallel\_begin\_t} data type, see \specref{sec:ompt_record_parallel_begin_t}.
\item \code{ompt\_record\_parallel\_end\_t} data type, see \specref{sec:ompt_record_parallel_end_t}.
\item \code{ompt\_record\_task\_create\_t} data type, see \specref{sec:ompt_record_task_create_t}.
\item \code{ompt\_record\_task\_dependence\_t} data type, see \specref{sec:ompt_record_task_dependence_t}.
\item \code{ompt\_record\_task\_schedule\_t} data type, see \specref{sec:ompt_record_task_schedule_t}.
\item \code{ompt\_record\_scoped\_implicit\_t} data type, see \specref{sec:ompt_record_scoped_implicit_t}.
\item \code{ompt\_record\_scoped\_sync\_region\_t} data type, see \specref{sec:ompt_record_scoped_sync_region_t}.
\item \code{ompt\_record\_target\_data\_t} data type, see \specref{sec:ompt_record_target_data_t}.
\item \code{ompt\_record\_target\_kernel\_t} data type, see \specref{sec:ompt_record_target_kernel_t}.
\item \code{ompt\_record\_scoped\_master\_t} data type, see \specref{sec:ompt_record_scoped_master_t}.
\item \code{ompt\_record\_scoped\_worksharing\_t} data type, see \specref{sec:ompt_record_scoped_worksharing_t}.
\item \code{ompt\_record\_ompt\_t} data type, see \specref{sec:ompt_record_ompt_t}.
\end{itemize}
\end{comment}

% ompt_data_t

\subsubsection{\code{ompt\_data\_t}}
\label{sec:ompt_data_t} 
Threads, parallel regions, task regions, target regions, and target operations
are represented by unique identifiers of type \code{ompt\_data\_t}.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef union ompt_data_u \{\\
  ompt_id_t id; /* integer ID under tool control */
  void *ptr;    /* pointer under tool control    */
\} ompt_data_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_get\_parallel\_info} inquiry function, see \specref{sec:ompt_get_parallel_info}.
\item \code{ompt\_get\_task\_info} inquiry function, see \specref{sec:ompt_get_task_info}.
\item \code{ompt\_get\_thread\_data} inquiry function, see \specref{sec:ompt_get_thread_data}.
\item \code{ompt\_thread\_begin\_callback\_t} callback type, see \specref{sec:ompt_thread_begin_callback_t}.
\item \code{ompt\_thread\_begin\_callback\_t} callback type, see \specref{sec:ompt_thread_begin_callback_t}.
\item \code{ompt\_parallel\_end\_callback\_t} callback type, see \specref{sec:ompt_parallel_end_callback_t}.
\item \code{ompt\_parallel\_end\_callback\_t} callback type, see \specref{sec:ompt_parallel_end_callback_t}.
\item \code{ompt\_task\_create\_callback\_t} callback type, see \specref{sec:ompt_task_create_callback_t}.
\item \code{ompt\_task\_dependencies\_callback\_t} callback type, see \specref{sec:ompt_task_dependencies_callback_t}.
\item \code{ompt\_task\_dependence\_callback\_t} callback type, see \specref{sec:ompt_task_dependence_callback_t}.
\item \code{ompt\_task\_schedule\_callback\_t} callback type, see \specref{sec:ompt_task_schedule_callback_t}.
\item \code{ompt\_task\_scoped\_implicit\_callback\_t} callback type, see \specref{sec:ompt_task_scoped_implicit_callback_t}.
\item \code{ompt\_task\_scoped\_sync\_region\_callback\_t} callback type, see \specref{sec:ompt_task_scoped_sync_region_callback_t}.
\item \code{ompt\_task\_scoped\_master\_callback\_t} callback type, see \specref{sec:ompt_task_scoped_master_callback_t}.
\item \code{ompt\_task\_scoped\_worksharing\_callback\_t} callback type, see \specref{sec:ompt_task_scoped_worksharing_callback_t}.
\item \code{ompt\_task\_scoped\_target\_callback\_t} callback type, see \specref{sec:ompt_task_scoped_target_callback_t}.
\item \code{ompt\_flush\_callback\_t} callback type, see \specref{sec:ompt_flush_callback_t}.
\end{itemize}
\end{comment}

% ompt_wait_id_t

\subsubsection{\code{ompt\_wait\_id\_t}}
\label{sec:ompt_wait_id_t} 
\code{ompt\_wait\_id\_t} indicates what a thread is waiting on. 
When a thread is waiting for a lock, critical region, ordered, or atomic, and
the thread is in a wait state, then the thread's \code{ompt\_wait\_id} field
identifies the lock, critical construct, ordered construct, atomic construct,
or internal variable upon which the thread is waiting.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef unsigned long long int ompt_wait_id_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_get\_state} inquiry function, see \specref{sec:ompt_get_state}.
\item \code{ompt\_lock\_init\_callback\_t} callback type, see \specref{sec:ompt_lock_init_callback_t}.
\item \code{ompt\_lock\_destroy\_callback\_t} callback type, see \specref{sec:ompt_lock_destroy_callback_t}.
\item \code{ompt\_mutex\_acquire\_callback\_t} callback type, see \specref{sec:ompt_mutex_acquire_callback_t}.
\item \code{ompt\_mutex\_callback\_t} callback type, see \specref{sec:ompt_mutex_callback_t}.
\item \code{ompt\_scoped\_nested\_lock\_callback\_t} callback type, see \specref{sec:ompt_scoped_nested_lock_callback_t}.
\item \code{ompt\_record\_lock\_init\_t} data type, see \specref{sec:ompt_record_lock_init_t}.
\item \code{ompt\_record\_lock\_destroy\_t} data type, see \specref{sec:ompt_record_lock_destroy_t}.
\item \code{ompt\_record\_mutex\_acquire\_t} data type, see \specref{sec:ompt_record_mutex_acquire_t}.
\item \code{ompt\_record\_mutex\_t} data type, see \specref{sec:ompt_record_mutex_t}.
\item \code{ompt\_record\_scoped\_nested\_lock\_t} data type, see \specref{sec:ompt_record_scoped_nested_lock_t}.
\end{itemize}
\end{comment}

% ompt_device_t

\subsubsection{\code{ompt\_device\_t}}
\label{sec:ompt_device_t} 
\code{ompt\_device\_t} is an opaque object representing a device.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void ompt_device_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_get\_time} inquiry function, see \specref{sec:ompt_get_time}.
\item \code{ompt\_translate\_time} inquiry function, see \specref{sec:ompt_translate_time}.
\item \code{ompt\_set\_trace\_ompt} tool function, see \specref{sec:ompt_set_trace_ompt}.
\item \code{ompt\_set\_trace\_native} tool function, see \specref{sec:ompt_set_trace_native}.
\item \code{ompt\_start\_trace} tool function, see \specref{sec:ompt_start_trace}.
\item \code{ompt\_pause\_trace} tool function, see \specref{sec:ompt_pause_trace}.
\item \code{ompt\_stop\_trace} tool function, see \specref{sec:ompt_stop_trace}.
\end{itemize}
\end{comment}

% ompt_device_time_t

\subsubsection{\code{ompt\_device\_time\_t}}
\label{sec:ompt_device_time_t} 
\code{ompt\_device\_time\_t} is an opaque object representing a raw time value from a device.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef unsigned long long int ompt_device_time_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_get\_device\_time} inquiry function, see \specref{sec:ompt_get_device_time}.
\item \code{ompt\_translate\_time} inquiry function, see \specref{sec:ompt_translate_time}.
\item \code{ompt\_record\_native\_abstract\_t} data type, see \specref{sec:ompt_record_native_abstract_t}.
\item \code{ompt\_record\_target\_data\_t} data type, see \specref{sec:ompt_record_target_data_t}.
\item \code{ompt\_record\_target\_kernel\_t} data type, see \specref{sec:ompt_record_target_kernel_t}.
\item \code{ompt\_record\_ompt\_t} data type, see \specref{sec:ompt_record_ompt_t}.
\end{itemize}
\end{comment}

% ompt_buffer_t

\subsubsection{\code{ompt\_buffer\_t}}
\label{sec:ompt_buffer_t} 
\code{ompt\_buffer\_t} is an opaque object handle for a target buffer.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void ompt_buffer_t; 
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_buffer\_request\_callback\_t} callback type, see \specref{sec:ompt_buffer_request_callback_t}.
\item \code{ompt\_buffer\_complete\_callback\_t} callback type, see \specref{sec:ompt_buffer_complete_callback_t}.
\item \code{ompt\_advance\_buffer\_cursor} tool function, see \specref{sec:ompt_advance_buffer_cursor}.
\item \code{ompt\_buffer\_get\_record\_type} tool function, see \specref{sec:ompt_buffer_get_record_type}.
\item \code{ompt\_buffer\_get\_record\_ompt} tool function, see \specref{sec:ompt_buffer_get_record_ompt}.
\item \code{ompt\_buffer\_get\_record\_correlation} tool function, see \specref{sec:ompt_buffer_get_record_correlation}.
\item \code{ompt\_buffer\_get\_record\_native} tool function, see \specref{sec:ompt_buffer_get_record_native}.
\end{itemize}
\end{comment}

% ompt_buffer_cursor_t

\subsubsection{\code{ompt\_buffer\_cursor\_t}}
\label{sec:ompt_buffer_cursor_t} 
\code{ompt\_buffer\_cursor\_t} is an opaque handle for a position in a target buffer.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef unsigned long long int ompt_buffer_cursor_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_buffer\_complete\_callback\_t} callback type, see \specref{sec:ompt_buffer_complete_callback_t}.
\item \code{ompt\_advance\_buffer\_cursor} tool function, see \specref{sec:ompt_advance_buffer_cursor}.
\item \code{ompt\_buffer\_get\_record\_type} tool function, see \specref{sec:ompt_buffer_get_record_type}.
\item \code{ompt\_buffer\_get\_record\_ompt} tool function, see \specref{sec:ompt_buffer_get_record_ompt}.
\item \code{ompt\_buffer\_get\_record\_correlation} tool function, see \specref{sec:ompt_buffer_get_record_correlation}.
\item \code{ompt\_buffer\_get\_record\_native} tool function, see \specref{sec:ompt_buffer_get_record_native}.
\end{itemize}
\end{comment}

% ompt_task_dependence_t

\subsubsection{\code{ompt\_task\_dependence\_t}}
\label{sec:ompt_task_dependence_t} 
\code{ompt\_task\_dependence\_t} is a task dependence.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_task_dependence_s \{\\
  void *variable_addr;
  unsigned int  dependence_flags;
\} ompt_task_dependence_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_task\_dependences\_callback\_t} callback type, see \specref{sec:ompt_task_dependences_callback_t}.
\item \code{ompt\_task\_dependence\_flag\_t} enumeration type, see \specref{sec:ompt_task_dependence_flag_t}.
\end{itemize}
\end{comment}

% ompt_frame_t

\subsubsection{\code{ompt\_frame\_t}}
\label{sec:ompt_frame_t} 
\code{ompt\_frame\_t} is a structure to maintain the runtime frame that reenters
user code, and the user fram ethat enters the runtime.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_frame_s \{\\
  void *exit_frame;  /* runtime frame that reenters user code */
  void *enter_frame; /* user frame that enters the runtime    */
\} ompt_frame_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_get\_task\_info} inquiry function, see \specref{sec:ompt_get_task_info}.
\item \code{ompt\_parallel\_begin\_callback\_t} callback type, see \specref{sec:ompt_parallel_begin_callback_t}.
\item \code{ompt\_create\_callback\_t} callback type, see \specref{sec:ompt_create_callback_t}.
\item \code{ompt\_record\_parallel\_begin\_t} data type, see \specref{sec:ompt_record_parallel_begin_t}.
\item \code{ompt\_record\_task\_create\_t} data type, see \specref{sec:ompt_record_task_create_t}.
\end{itemize}
\end{comment}

% ompt_thread_type_t

\subsubsection{\code{ompt\_thread\_type\_t}}
\label{sec:ompt_thread_type_t} 
\code{ompt\_thread\_type\_t} is an enumeration that defines the valid thread type values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_thread_type_e \{\\
  ompt_thread_initial                 = 1,
  ompt_thread_worker                  = 2,
  ompt_thread_other                   = 3,
  ompt_thread_unknown                 = 4
\} ompt_thread_type_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_thread\_begin\_callback\_t} callback type, see \specref{sec:ompt_thread_begin_callback_t}.
\item \code{ompt\_record\_thread\_begin\_t} data type, see \specref{sec:ompt_record_thread_begin_t}.
\end{itemize}
\end{comment}

% ompt_scope_endpoint_t

\subsubsection{\code{ompt\_scope\_endpoint\_t}}
\label{sec:ompt_scope_endpoint_t} 
\code{ompt\_scope\_endpoint\_t} is an enumeration that defines valid scope endpoint values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_scope_endpoint_e \{\\
  ompt_scope_begin                    = 1,
  ompt_scope_end                      = 2
\} ompt_scope_endpoint_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_idle\_callback\_t} callback type, see \specref{sec:ompt_idle_callback_t}.
\item \code{ompt\_scoped\_implicit\_callback\_t} callback type, see \specref{sec:ompt_scoped_implicit_callback_t}.
\item \code{ompt\_scoped\_sync\_region\_callback\_t} callback type, see \specref{sec:ompt_scoped_sync_region_callback_t}.
\item \code{ompt\_scoped\_nested\_lock\_callback\_t} callback type, see \specref{sec:ompt_scoped_nested_lock_callback_t}.
\item \code{ompt\_scoped\_master\_callback\_t} callback type, see \specref{sec:ompt_scoped_master_callback_t}.
\item \code{ompt\_scoped\_worksharing\_callback\_t} callback type, see \specref{sec:ompt_scoped_worksharing_callback_t}.
\item \code{ompt\_scoped\_target\_callback\_t} callback type, see \specref{sec:ompt_scoped_target_callback_t}.
\item \code{ompt\_record\_idle\_t} data type, see \specref{sec:ompt_record_idle_t}.
\item \code{ompt\_record\_scoped\_implicit\_t} data type, see \specref{sec:ompt_record_scoped_implicit_t}.
\item \code{ompt\_scoped\_sync\_region\_t} data type, see \specref{sec:ompt_scoped_sync_region_t}.
\item \code{ompt\_scoped\_nested\_lock\_t} data type, see \specref{sec:ompt_scoped_nested_lock_t}.
\item \code{ompt\_scoped\_master\_t} data type, see \specref{sec:ompt_scoped_master_t}.
\item \code{ompt\_scoped\_worksharing\_t} data type, see \specref{sec:ompt_scoped_worksharing_t}.
\end{itemize}
\end{comment}

% ompt_sync_region_kind_t

\subsubsection{\code{ompt\_sync\_region\_kind\_t}}
\label{sec:ompt_sync_region_kind_t} 
\code{ompt\_sync\_region\_kind\_t} is an enumeration that defines the valid sync region kind values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_sync_region_kind_e \{\\
  ompt_sync_region_barrier            = 1, 
  ompt_sync_region_taskwait           = 2,
  ompt_sync_region_taskgroup          = 3
\} ompt_sync_region_kind_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_scoped\_sync\_region\_callback\_t} callback type, see \specref{sec:ompt_scoped_sync_region_callback_t}.
\item \code{ompt\_record\_scoped\_sync\_region\_t} data type, see \specref{sec:ompt_record_scoped_sync_region_t}.
\end{itemize}
\end{comment}

% ompt_target_data_op_t

\subsubsection{\code{ompt\_target\_data\_op\_t}}
\label{sec:ompt_target_data_op_t} 
\code{ompt\_target\_data\_op\_t} is an enumeration that defines the valid target data operation values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_target_data_op_e \{\\
  ompt_target_data_alloc              = 1,
  ompt_target_data_transfer_to_dev    = 2,
  ompt_target_data_transfer_from_dev  = 3,
  ompt_target_data_delete             = 4
\} ompt_target_data_op_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_target\_data\_callback\_t} callback type, see \specref{sec:ompt_target_data_callback_t}.
\item \code{ompt\_record\_target\_data\_t} data type, see \specref{sec:ompt_record_target_data_t}.
\end{itemize}
\end{comment}

% ompt_worksharing_type_t

\subsubsection{\code{ompt\_worksharing\_type\_t}}
\label{sec:ompt_worksharing_type_t} 
\code{ompt\_worksharing\_type\_t} is an enumeration that defines the valid worksharing type values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_worksharing_type_e \{\\
  ompt_worksharing_loop               = 1, 
  ompt_worksharing_sections           = 2,
  ompt_worksharing_single_executor    = 3,
  ompt_worksharing_single_other       = 4,
  ompt_worksharing_workshare          = 5,
  ompt_worksharing_distribute         = 6
\} ompt_worksharing_type_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_scoped\_worksharing\_callback\_t} callback type, see \specref{sec:ompt_scoped_worksharing_callback_t}.
\item \code{ompt\_record\_scoped\_worksharing\_t} data type, see \specref{sec:ompt_record_scoped_worksharing_t}.
\end{itemize}
\end{comment}

% ompt_mutex_kind_t

\subsubsection{\code{ompt\_mutex\_kind\_t}}
\label{sec:ompt_mutex_kind_t} 
\code{ompt\_mutex\_kind\_t} is an enumeration that defines the valid mutex kind values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_mutex_kind_e \{\\
  ompt_mutex                          = 0x10,
  ompt_mutex_lock                     = 0x11,
  ompt_mutex_nest_lock                = 0x12,
  ompt_mutex_critical                 = 0x13,
  ompt_mutex_atomic                   = 0x14,
  ompt_mutex_ordered                  = 0x20
\} ompt_mutex_kind_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_mutex\_acquire\_callback\_t} callback type, see \specref{sec:ompt_mutex_acquire_callback_t}.
\item \code{ompt\_mutex\_callback\_t} callback type, see \specref{sec:ompt_mutex_callback_t}.
\item \code{ompt\_record\_mutex\_acquire\_t} data type, see \specref{sec:ompt_record_mutex_acquire_t}.
\item \code{ompt\_record\_mutex\_t} data type, see \specref{sec:ompt_record_mutex_t}.
\end{itemize}
\end{comment}

% ompt_native_mon_flags_t

\subsubsection{\code{ompt\_native\_mon\_flags\_t}}
\label{sec:ompt_native_mon_flags_t}
\code{ompt\_native\_mon\_flags\_t} is an enumeration that defines the valid native monitoring flag values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_native_mon_flags_e \{\\
  ompt_native_data_motion_explicit    = 1,
  ompt_native_data_motion_implicit    = 2,
  ompt_native_kernel_invocation       = 4,
  ompt_native_kernel_execution        = 8,
  ompt_native_driver                  = 16,
  ompt_native_runtime                 = 32,
  ompt_native_overhead                = 64,
  ompt_native_idleness                = 128
\} ompt_native_mon_flags_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_set\_trace\_native} tool function, see \specref{sec:ompt_set_trace_native}.
\end{itemize}
\end{comment}

% ompt_task_type_t

\subsubsection{\code{ompt\_task\_type\_t}}
\label{sec:ompt_task_type_t}
\code{ompt\_task\_type\_t} is an enumeration that defines the valid task type values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum  ompt_task_type_e \{\\
  ompt_task_initial                   = 1,
  ompt_task_implicit                  = 2,
  ompt_task_explicit                  = 3,
  ompt_task_target                    = 4,
  ompt_task_degenerate                = 5
\} ompt_task_type_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_task\_create\_callback\_t} callback type, see \specref{sec:ompt_task_create_callback_t}.
\item \code{ompt\_get\_task\_info} inquiry function, see \specref{sec:ompt_get_task_info}.
\item \code{ompt\_record\_task\_create\_t} data type, see \specref{sec:ompt_record_task_create_t}.
\end{itemize}
\end{comment}

% ompt_target_type_t

\subsubsection{\code{ompt\_target\_type\_t}}
\label{sec:ompt_target_type_t}
\code{ompt\_target\_type\_t} is an enumeration that defines the valid target type values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_target_type_e \{\\
  ompt_target                         = 1,
  ompt_target_enter_data              = 2,
  ompt_target_exit_data               = 3,
  ompt_target_update                  = 4
\} ompt_target_type_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_scoped\_target\_callback\_t} callback type, see \specref{sec:ompt_scoped_target_callback_t}.
\end{itemize}
\end{comment}

% ompt_invoker_t

\subsubsection{\code{ompt\_invoker\_t}}
\label{sec:ompt_invoker_t}
\code{ompt\_invoker\_t} is an enumeration that defines the valid invoker values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_invoker_e \{\\
  ompt_invoker_program = 1, /* program invokes master task */
  ompt_invoker_runtime = 2  /* runtime invokes master task */
\} ompt_invoker_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_parallel\_begin\_callback\_t} callback type, see \specref{sec:ompt_parallel_begin_callback_t}.
\item \code{ompt\_parallel\_end\_callback\_t} callback type, see \specref{sec:ompt_parallel_end_callback_t}.
\item \code{ompt\_record\_parallel\_begin\_t} data type, see \specref{sec:ompt_record_parallel_begin_t}.
\item \code{ompt\_record\_parallel\_end\_t} data type, see \specref{sec:ompt_record_parallel_end_t}.
\end{itemize}
\end{comment}

% ompt_target_map_flag_t

\subsubsection{\code{ompt\_target\_map\_flag\_t}}
\label{sec:ompt_target_map_flag_t}
\code{ompt\_target\_map\_flag\_t} is an enumeration that defines the valid target map flag values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_target_map_flag_e \{\\
  ompt_target_map_flag_to             = 1,
  ompt_target_map_flag_from           = 2,
  ompt_target_map_flag_alloc          = 4,
  ompt_target_map_flag_release        = 8, 
  ompt_target_map_flag_delete         = 16
\} ompt_target_map_flag_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_target\_data\_map\_callback\_t} callback type, see \specref{sec:ompt_target_data_map_callback_t}.
\end{itemize}
\end{comment}

% ompt_task_dependence_flag_t

\subsubsection{\code{ompt\_task\_dependence\_flag\_t}}
\label{sec:ompt_task_dependence_flag_t}
\code{ompt\_task\_dependence\_flag\_t} is an enumeration that defines the valid task dependence flag values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_task_dependence_flag_e \{\\
  // a two bit field for the dependence type
  ompt_task_dependence_type_out       = 1,
  ompt_task_dependence_type_in        = 2,
  ompt_task_dependence_type_inout     = 3
\} ompt_task_dependence_flag_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_task\_dependence\_t} data type, see \specref{sec:ompt_task_dependence_t}.
\end{itemize}
\end{comment}

% end miscelaneous types

\section{Events without Directives}
\subsection{\code{ompt\_event\_thread\_begin}}
\label{sec:ompt_event_thread_begin}
An OpenMP implementation invokes this callback in the context of an initial thread just after it initializes the runtime, or in the context of a new thread created by the runtime just after the thread initializes itself. In either case, this callback must be the first callback for a thread
and must occur before the thread executes any OpenMP tasks. This callback has type signature \code{ompt\_thread\_begin\_callback\_t}.
The callback argument \code{thread\_type} indicates the type of the thread: initial, worker, or other.

\subsection{\code{ompt\_event\_thread\_end}}
\label{sec:ompt_event_thread_end}
An OpenMP implementation invokes this callback
after an OpenMP thread completes all of
its tasks but before the thread is destroyed. The callback
executes in the context of the OpenMP thread. This callback must be the last callback event for any worker thread; it is optional for other types of threads.
This callback has type signature \code{ompt\_thread\_end\_callback\_t}.

\subsection{\code{ompt\_event\_target\_submit}}
\label{sec:ompt_event_target_submit}
An OpenMP implementation invokes this callback prior to submitting a kernel for execution on a target device.
This callback has type signature \code{ompt\_target\_submit\_callback\_t}.
The callback argument \code{target\_id} indicates the instance of the target construct associated with this operation.
The callback argument \code{host\_op\_id} provides a unique host-side identifier that represents the activity on the device.
The callback arguments \code{requested\_num\_teams}  \code{granted\_num\_teams} indicate, respectively, the number of teams requested by the user and granted by the runtime.

\subsection{\code{ompt\_event\_tcontrol}}
\label{sec:ompt_event_tcontrol}
If the user program calls \code{omp\_tcontrol}, an
OpenMP implementation invokes this callback.
The callback executes in the context that the call occurs in the user program.
This callback has type signature \code{ompt\_tcontrol\_callback\_t}.
Arguments passed to the callback are those passed by the user to \code{omp\_tcontrol}.

\subsection{\code{ompt\_event\_runtime\_shutdown}}
\label{sec:ompt_event_runtime_shutdown}
An OpenMP implementation invokes this callback before it shuts down the
 runtime system.  This callback enables a tool to clean up its
 state and record or report information gathered. A runtime may later restart and reinitialize the tool by
calling the tool initializer
function (described in Section~\ref{sec:tool-initialize}) again.
 This callback has type signature \code{ompt\_callback\_t}.

\subsection{\code{ompt\_event\_idle}}
\label{sec:ompt_event_idle}
An OpenMP implementation invokes this callback with \code{endpoint=}\code{ompt\_scope\_begin} when a thread waits for work outside a parallel region.
  The OpenMP runtime invokes this callback with \code{endpoint=}\code{ompt\_scope\_end} before the thread  begins to execute an implicit task for
   a parallel region or terminates. The callback executes in the environment of the waiting thread.
  This callback has type signature \code{ompt\_idle\_callback\_t}.

\subsection{\code{ompt\_event\_sync\_region\_wait}}
\label{sec:ompt_event_sync_region_wait}

If the \code{ompt\_event\_sync\_region\_wait} callback is registered,
an OpenMP implementation will invoke this callback when a task starts
and stops waiting in a barrier region, taskwait region, or taskgroup
region. 
This callback has
type signature \code{ompt\_sync\_region\_callback\_t}.  
One region may
generate multiple pairs of start/stop callbacks if another task is
scheduled on the thread while the task awaiting completion of the
region is stalled. 
This callback executes in the context of the task
that encountered the barrier, taskwait, or taskgroup construct.

\subsection{\code{ompt\_event\_device\_initialize}}
\label{sec:ompt_event_device_initialize}

If the \code{ompt\_event\_device\_initialize} callback is registered,
an OpenMP implementation will invoke the this callback for a device
after OpenMP is initialized for the device but before beginning
execution of any OpenMP construct on the device.
This callback has
type signature \code{ompt\_device\_initialize\_callback\_t}.  

\section{Tool Interface Routine}

\subsubsection{\code{ompt\_tool}}
\label{sec:ompt_tool}

\summary
If a tool wants to use an OpenMP implementation's OMPT interface,
the tool must implement \code{ompt\_tool} to announce its interest.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
extern "C" \{
  ompt_initialize_fn_t ompt_tool(void);
\};
\end{boxedcode}
\ccppspecificend
}

\descr
For a tool to use an OpenMP implementation's OMPT interface,
the tool must define a globally-visible implementation of the
function \code{ompt\_tool}.

A tool may indicate its intent to use the OMPT interface provided
by an OpenMP implementation by having
\code{ompt\_tool} return a non-\code{NULL} pointer to a tool
initializer routine with type signature \code{ompt\_initialize\_fn\_t}.

\begin{comment}
If a tool so indicates its interest in OMPT, the OpenMP implementation
will maintain state information for each OpenMP thread and will
perform any OMPT event callbacks registered by the tool.
\end{comment}

If a tool implements \code{ompt\_tool} but has no interest in using
an OpenMP implementation's OMPT interface in a particular execution,
\code{ompt\_tool} should return \code{NULL}. 

\effect
If a tool returns a non-\code{NULL} pointer to a tool
initializer routine, an OpenMP implementation will 
call the tool initializer
after fully initializing itself but before
beginning execution of any OpenMP construct
or completing execution of any environment routine invocation. 

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_initialize\_fn\_t} type signature, see \specref{sec:ompt_initialize_fn_t}
\end{itemize}
\end{comment}

\section{Tool Callback Signatures}
\subsection{Initializer Callback Signature}

\subsubsection{\code{ompt\_initialize\_fn\_t}}
\label{sec:ompt_initialize_fn_t}

\summary
A tool implements an initializer with the type signature
\code{ompt\_initialize\_fn\_t} to initialize the tool's use of
an OpenMP implementation's OMPT interface.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*\plc{ompt\_initialize\_fn\_t}) (
  ompt\_function\_lookup\_t \plc{lookup},
  const char *\plc{runtime\_version},
  unsigned int \plc{ompt\_version}
);
\end{boxedcode}
\ccppspecificend
}

\descr
For a tool to initialize an OpenMP implementation's OMPT interface,
the tool's implementation of \code{ompt\_tool} must return a 
pointer to a tool initializer with type signature \code{ompt\_initialize\_fn\_t}.
An OpenMP implementation will call the tool initializer returned by
\code{ompt\_tool} after fully initializing itself but before 
beginning execution of any OpenMP construct
or completing execution of any environment routine invocation.  

\argdesc
The first argument passed to a tool initializer 
is \plc{lookup}---a callback 
to an OpenMP runtime routine that a tool must use to 
obtain a pointer to each function in the runtime's OMPT interface.

\begin{comment}
All functions in the OMPT interface are marked with \code{OMPT\_API}, which
indicates that the only way a tool can obtain bindings for them
is using the \plc{lookup} callback.

% The language committee prefers to avoid rationale
The \code{lookup} callback is necessary in the case when an OpenMP runtime 
is dynamically loaded by a shared library. In this case, 
OMPT interface functions provided by the library may 
not be visible to a preloaded tool.
% Within a tool, one uses \code{lookup} to obtain function pointers to each function in the OMPT interface.
\end{comment}

The second argument passed to a tool initializer 
is a version string that unambiguously identifies the OpenMP implementation.

\begin{comment}
% The language committee prefers to avoid rationale
This argument is useful to tool developers trying to debug a statically-linked executable that contains both a tool implementation and an OpenMP implementation.
Knowing exactly what version of an OpenMP implementation is present 
may be helpful when diagnosing a problem, e.g., identifying an old runtime system that may be incompatible with a newer tool.
\end{comment}

The third argument an OpenMP implementation passed to a tool initializer 
is a version number that unambiguously identifies the version of the 
OMPT interface supported by the OpenMP implementation.  
The version of OMPT described by this document is 2.

\effect
A tool's initializer has several duties.  First, it should use
\plc{ompt\_version} to determine whether it is compatibile
with the version of the OMPT interface that the OpenMP implementation
supports.  Second, it should use \plc{lookup} 
to look up pointers to OMPT interface callbacks provided by the
OpenMP runtime on the host. 
Third, it should use the OMPT interface 
callback known as \code{ompt\_set\_callback} 
to register tool callbacks for OpenMP events.  Fourth, the tool
should use the OMPT interface callback known as \code{ompt\_get\_num\_devices} 
to identify whether any target devices are present
and then use the OMPT interface callback known as 
\code{ompt\_get\_device\_info} to interrogate each device.
Using information returned by the \code{ompt\_get\_device\_info} callback,
a tool initializer can then set up tracing for a device, 
as described in \specref{sec:tracing-device-activity}. 
Finally, a tool initializer can use OMPT interface callbacks known as 
\code{ompt\_enumerate\_states} and \code{ompt\_enumerate\_mutex\_kinds} to
enumerate the thread states and implementations of mutual exclusion
that a particular OpenMP implementation employs.

\crossreferences
\begin{itemize}
\item The actions of a tool initializer are described in 
\specref{sec:tool-initialize}.
\item \code{ompt\_tool}, see \specref{sec:ompt_tool}
\item \code{ompt\_function\_lookup\_t} type signature, see \specref{sec:ompt_function_lookup_t}
\item \code{ompt\_set\_callback\_t} type signature, see \specref{sec:ompt_set_callback_t}
\item \code{ompt\_get\_num\_devices\_t} type signature, see \specref{sec:ompt_get_num_devices_t}
\end{itemize}


\subsection{Event Callback Signatures}
\index{event callback signatures}
\label{sec:ToolsSupport_callback_signatures}

This section describes the signatures of tool callback functions that an OMPT
tool might register and that are called during runtime of an OpenMP program.

\subsubsection{\code{ompt\_thread\_begin\_callback\_t}}
\index{ompt\_thread\_begin\_callback\_t@{\code{ompt\_thread\_begin\_callback\_t}}}
\label{sec:ompt_thread_begin_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt\_thread\_begin\_callback\_t) (
  ompt\_thread\_type\_t \plc{thread\_type},
  ompt\_data\_t *\plc{thread\_data}
);
\end{boxedcode}
\ccppspecificend
}
\descr
The callback with type signature \code{ompt\_thread\_begin\_callback\_t},
includes a parameter \plc{thread\_type}
that indicates the type of the new thread: initial, worker, or other.
The binding of \plc{thread\_data} is the new thread.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_thread\_type\_t} type, see
\specref{sec:ompt_thread_type_t}.
\end{itemize}



\subsubsection{\code{ompt\_thread\_end\_callback\_t}}
\index{ompt\_thread\_end\_callback\_t@{\code{ompt\_thread\_end\_callback\_t}}}
\label{sec:ompt_thread_end_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt\_thread\_end\_callback\_t) (
  ompt\_data\_t *\plc{thread\_data}
);
\end{boxedcode}
\ccppspecificend
}
\descr
The binding of \plc{thread\_data} is the finished thread.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\end{itemize}



\subsubsection{\code{ompt\_idle\_callback\_t}}
\index{ompt\_idle\_callback\_t@{\code{ompt\_idle\_callback\_t}}}
\label{sec:ompt_idle_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt\_idle\_callback\_t) (
  ompt\_scope\_endpoint\_t \plc{endpoint}
);
\end{boxedcode}
\ccppspecificend
}
\descr
The callback with type signature \code{ompt\_idle\_callback\_t},
includes a parameter \plc{endpoint}
that indicates whether the callback signals the begin or end of the scope.

\crossreferences
\begin{itemize}
\item \code{ompt\_scope\_endpoint\_t} type, see
\specref{sec:ompt_scope_endpoint_t}.
\end{itemize}



\subsubsection{\code{ompt\_parallel\_begin\_callback\_t}}
\index{ompt\_parallel\_begin\_callback\_t@{\code{ompt\_parallel\_begin\_callback\_t}}}
\label{sec:ompt_parallel_begin_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt\_parallel\_begin\_callback\_t) (
               ompt\_data\_t * \plc{parent\_task\_data},
               const ompt\_frame\_t * \plc{parent\_frame},
               ompt\_data\_t * \plc{parallel\_data},
               unsigned int \plc{requested\_team\_size},
               unsigned int \plc{actual\_team\_size},
               ompt\_invoker\_t \plc{invoker},
               const void * \plc{codeptr\_ra}
);
\end{boxedcode}
\ccppspecificend
}

\descr
The callbacks with type signature \code{ompt\_parallel\_begin\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.
The binding of \plc{parent\_task\_data} is the enclosing task, the binding of
\plc{parallel\_data} is the new team.


\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_frame\_t} type, see
\specref{sec:ompt_frame_t}.
\item \code{ompt\_invoker\_t} type, see
\specref{sec:ompt_invoker_t}.
\end{itemize}



\subsubsection{\code{ompt\_parallel\_end\_callback\_t}}
\index{ompt\_parallel\_end\_callback\_t@{\code{ompt\_parallel\_end\_callback\_t}}}
\label{sec:ompt_parallel_end_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt\_parallel\_end\_callback\_t) (
               ompt\_data\_t * \plc{parallel\_data},
               ompt\_data\_t * \plc{task\_data},
               ompt\_invoker\_t \plc{invoker},
               const void * \plc{codeptr\_ra}
);
\end{boxedcode}
\ccppspecificend
}

\descr
The callbacks with type signature \code{ompt\_parallel\_begin\_callback\_t}
include a parameter \plc{invoker} which explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.
The binding of \plc{parallel\_data} is the finishing team.

%\effect
% ompt events have no effect

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type signature, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_invoker\_t} type signature, see
\specref{sec:ompt_invoker_t}.
\end{itemize}

\subsubsection{\code{ompt\_scoped\_master\_callback\_t}}
\index{ompt\_scoped\_master\_callback\_t@{\code{ompt\_scoped\_master\_callback\_t}}}
\label{sec:ompt_scoped_master_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*\plc{ompt\_scoped\_master\_callback\_t}) (
               ompt\_scope\_endpoint\_t \plc{endpoint},
               ompt\_data\_t *\plc{parallel\_data},
               ompt\_data\_t *\plc{task\_data},
               const void *\plc{codeptr\_ra}
);
\end{boxedcode}
\ccppspecificend
}

\descr
The callbacks with type signature \code{ompt\_scoped\_master\_callback\_t}
include a parameter \plc{codeptr\_ra} which contains the return address of the
call to the OpenMP runtime routine and a parameter \plc{endpoint}
that indicates whether the callback signals the begin or end of the scope.
The binding of \plc{task\_data} is the innermost enclosing implicit task,
the binding of \plc{parallel\_data} is the innermost enclosing parallel region.

%\effect
% ompt events have no effect

\crossreferences
\begin{itemize}
\item \code{ompt\_scope\_endpoint\_t} type, see
\specref{sec:ompt_scope_endpoint_t}.
\item \code{ompt\_data\_t} type signature, see
\specref{sec:ompt_data_t}.
\end{itemize}





\subsubsection{\code{ompt\_task\_create\_callback\_t}}
\index{ompt\_task\_create\_callback\_t@{\code{ompt\_task\_create\_callback\_t}}}
\label{sec:ompt_task_create_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt\_task\_create\_callback\_t) (
  ompt\_data\_t *\plc{parent\_task\_data},
  const ompt\_frame\_t *\plc{parent\_frame},
  ompt\_data\_t *\plc{new\_task\_data},
  ompt\_task\_type\_t \plc{type},
  \_Bool \plc{has\_dependences},
  const void *\plc{codeptr\_ra}
);
\end{boxedcode}
\ccppspecificend
}
\descr
The callbacks with type signature \code{ompt\_task\_create\_callback\_t},
include a parameter \plc{parent\_frame}
that indicates the frame information of the encountering task, and a parameter
\plc{type} that indicates the kind of the task: initial, explicit or target.
The binding of \plc{parent\_task\_data} is the encountering task,
the binding of \plc{new\_task\_data} is the created task.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_frame\_t} type, see
\specref{sec:ompt_frame_t}.
\item \code{ompt\_task\_type\_t} type, see
\specref{sec:ompt_task_type_t}.
\end{itemize}



\subsubsection{\code{ompt\_task\_dependences\_callback\_t}}
\index{ompt\_task\_dependences\_callback\_t@{\code{ompt\_task\_dependences\_callback\_t}}}
\label{sec:ompt_task_dependences_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt\_task\_dependences\_callback\_t) (
  ompt\_data\_t *\plc{task\_data},
  const ompt\_task\_dependence\_t *\plc{deps},
  int \plc{ndeps}
);
\end{boxedcode}
\ccppspecificend
}
\descr
The callback with type signature \code{ompt\_task\_dependences\_callback\_t},
includes a parameter \plc{deps} that lists all dependences of a new task and
a parameter \plc{ndeps} that specifies the length of the list.
The memory ownage of \plc{deps} remains at the caller, the tool cannot rely on
the data after the callback returns.
The binding of \plc{task\_data} is the created task.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_task\_dependence\_t} type, see
\specref{sec:ompt_task_dependence_t}.
\end{itemize}



\subsubsection{\code{ompt\_task\_dependence\_callback\_t}}
\index{ompt\_task\_dependence\_callback\_t@{\code{ompt\_task\_dependence\_callback\_t}}}
\label{sec:ompt_task_dependence_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt\_task\_dependence\_callback\_t) (
  ompt\_data\_t *\plc{src\_task\_data},
  ompt\_data\_t *\plc{sink\_task\_data}
);
\end{boxedcode}
\ccppspecificend
}
\descr
The binding of \plc{src\_task\_data} is a running task with an out dependency.
The binding of \plc{sink\_task\_data} is a task with a non-satisfied in dependency.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type signature, see
\specref{sec:ompt_data_t}.
\end{itemize}



\subsubsection{\code{ompt\_task\_schedule\_callback\_t}}
\index{ompt\_task\_schedule\_callback\_t@{\code{ompt\_task\_schedule\_callback\_t}}}
\label{sec:ompt_task_schedule_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt\_task\_schedule\_callback\_t) (
  ompt\_data\_t *\plc{prior\_task\_data},
  \_Bool \plc{prior\_completed},
  ompt\_data\_t *\plc{next\_task\_data}
);
\end{boxedcode}
\ccppspecificend
}
\descr
The callback with type signature \code{ompt\_task\_schedule\_callback\_t},
include a parameter \plc{prior\_completed}
that indicates whether the task that reached the task scheduling point finished
execution its task region.
The binding of \plc{prior\_task\_data} is the task that reached the task scheduling point.
The binding of \plc{next\_task\_data} is the task to be scheduled.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\end{itemize}



\subsubsection{\code{ompt\_scoped\_implicit\_callback\_t}}
\index{ompt\_scoped\_implicit\_callback\_t@{\code{ompt\_scoped\_implicit\_callback\_t}}}
\label{sec:ompt_scoped_implicit_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt\_scoped\_implicit\_callback\_t) (
  ompt\_scope\_endpoint\_t \plc{endpoint},
  ompt\_data\_t *\plc{parallel\_data},
  ompt\_data\_t *\plc{task\_data},
  unsigned int \plc{thread\_num}
);
\end{boxedcode}
\ccppspecificend
}
\descr
The callback with type signature \code{ompt\_scoped\_implicit\_callback\_t},
includes a parameter \plc{endpoint} that indicates whether the callback signals
the begin or end of the scope and a parameter \plc{thread\_num} that indicates
the thread number of the calling thread, within the team executing the parallel
region to which the implicit region binds.
The binding of \plc{parallel\_data} is the innermost enclosing parallel region.
The binding of \plc{task\_data} is the implicit task executing the parallel
region's structured block.


\crossreferences
\begin{itemize}
\item \code{ompt\_scope\_endpoint\_t} enumeration type, see
\specref{sec:ompt_scope_endpoint_t}.
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\end{itemize}



\subsubsection{\code{ompt\_scoped\_sync\_region\_callback\_t}}
\index{ompt\_scoped\_sync\_region\_callback\_t@{\code{ompt\_scoped\_sync\_region\_callback\_t}}}
\label{sec:ompt_scoped_sync_region_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt\_scoped\_sync\_region\_callback\_t) (
  ompt\_sync\_region\_kind\_t \plc{kind},
  ompt\_scope\_endpoint\_t \plc{endpoint},
  ompt\_data\_t *\plc{parallel\_data},
  ompt\_data\_t *\plc{task\_data},
  const void *\plc{codeptr\_ra}
);
\end{boxedcode}
\ccppspecificend
}
\descr 

A tool executes a callback with type signature
\code{ompt\_sync\_region\_callback\_t} to receive notification of
event \code{ompt\_sync\_region\_callback\_t} when an OpenMP
implementation starts and stops waiting in a barrier region, taskwait
region, or taskgroup region.

\constraints
The first argument indicates the kind of region causing the wait.  
The second argument indicates whether the callback indicates whether the
task is about to start waiting with value \code{ompt\_scope\_begin}, or about
to stop waiting, with value \code{ompt\_scope\_end}. 
The third argument is a pointer to the tool's data area for the
current parallel region.
The fourth argument is a pointer to the tool's data area for the
current task region.
The last argument, \code{codeptr\_ra}, is the return address following the
task's call to a routine to implement the waiting or invoke this
callback; \code{codeptr\_ra} may be NULL.  

\crossreferences
\begin{itemize}
\item \code{ompt\_sync\_region\_kind\_t} type, see
\specref{sec:ompt_sync_region_kind_t}.
\item \code{ompt\_scope\_endpoint\_t} type, see
\specref{sec:ompt_scope_endpoint_t}.
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\end{itemize}



\subsubsection{\code{ompt\_lock\_init\_callback\_t}}
\index{ompt\_lock\_init\_callback\_t@{\code{ompt\_lock\_init\_callback\_t}}}
\label{sec:ompt_lock_init_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt\_lock\_init\_callback\_t) (
  \_Bool \plc{is\_nest\_lock},
  ompt\_wait\_id\_t \plc{wait\_id},
  unsigned int \plc{hint},
  unsigned int \plc{kind},
  const void *\plc{codeptr\_ra}
);
\end{boxedcode}
\ccppspecificend
}
\descr ToDo
The callbacks with type signature \code{ompt\_lock\_init\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_wait\_id\_t} type, see
\specref{sec:ompt_wait_id_t}.
\end{itemize}



\subsubsection{\code{ompt\_lock\_destroy\_callback\_t}}
\index{ompt\_lock\_destroy\_callback\_t@{\code{ompt\_lock\_destroy\_callback\_t}}}
\label{sec:ompt_lock_destroy_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt\_lock\_destroy\_callback\_t) (
  \_Bool \plc{is\_nest\_lock},
  ompt\_wait\_id\_t \plc{wait\_id},
  const void *\plc{codeptr\_ra}
);
\end{boxedcode}
\ccppspecificend
}
\descr ToDo
The callbacks with type signature \code{ompt\_lock\_destroy\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_wait\_id\_t} type, see
\specref{sec:ompt_wait_id_t}.
\end{itemize}



\subsubsection{\code{ompt\_mutex\_acquire\_callback\_t}}
\index{ompt\_mutex\_acquire\_callback\_t@{\code{ompt\_mutex\_acquire\_callback\_t}}}
\label{sec:ompt_mutex_acquire_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt\_mutex\_acquire\_callback\_t) (
  ompt\_mutex\_kind\_t \plc{kind},
  unsigned int \plc{hint},
  unsigned int \plc{impl},
  ompt\_wait\_id\_t \plc{wait\_id},
  const void *\plc{codeptr\_ra}
);
\end{boxedcode}
\ccppspecificend
}
\descr ToDo
The callbacks with type signature \code{ompt\_mutex\_acquire\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_mutex\_kind\_t} type, see
\specref{sec:ompt_mutex_kind_t}.
\item \code{ompt\_wait\_id\_t} type, see
\specref{sec:ompt_wait_id_t}.
\end{itemize}



\subsubsection{\code{ompt\_mutex\_callback\_t}}
\index{ompt\_mutex\_callback\_t@{\code{ompt\_mutex\_callback\_t}}}
\label{sec:ompt_mutex_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt\_mutex\_callback\_t) (
  ompt\_mutex\_kind\_t \plc{kind},
  ompt\_wait\_id\_t \plc{wait\_id},
  const void *\plc{codeptr\_ra}
);
\end{boxedcode}
\ccppspecificend
}
\descr ToDo
The callbacks with type signature \code{ompt\_mutex\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_mutex\_kind\_t} type signature, see
\specref{sec:ompt_mutex_kind_t}.
\item \code{ompt\_wait\_id\_t} type signature, see
\specref{sec:ompt_wait_id_t}.
\end{itemize}



\subsubsection{\code{ompt\_scoped\_nested\_lock\_callback\_t}}
\index{ompt\_scoped\_nested\_lock\_callback\_t@{\code{ompt\_scoped\_nested\_lock\_callback\_t}}}
\label{sec:ompt_scoped_nested_lock_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt\_scoped\_nested\_lock\_callback\_t) (
  ompt\_scope\_endpoint\_t \plc{endpoint},
  ompt\_wait\_id\_t \plc{wait\_id},
  const void *\plc{codeptr\_ra}
);
\end{boxedcode}
\ccppspecificend
}
\descr ToDo
The callbacks with type signature \code{ompt\_scoped\_nested\_lock\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

include a parameter \plc{codeptr\_ra} which contains the return address of the
call to the OpenMP runtime routine and a parameter \plc{endpoint}
that indicates whether the callback signals the begin or end of the scope.

\crossreferences
\begin{itemize}
\item \code{ompt\_scope\_endpoint\_t} type signature, see
\specref{sec:ompt_scope_endpoint_t}.
\item \code{ompt\_wait\_id\_t} type signature, see
\specref{sec:ompt_wait_id_t}.
\end{itemize}



\subsubsection{\code{ompt\_scoped\_worksharing\_callback\_t}}
\index{ompt\_scoped\_worksharing\_callback\_t@{\code{ompt\_scoped\_worksharing\_callback\_t}}}
\label{sec:ompt_scoped_worksharing_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt\_scoped\_worksharing\_callback\_t) (
  ompt\_worksharing\_type\_t \plc{wstype},
  ompt\_scope\_endpoint\_t \plc{endpoint},
  ompt\_data\_t *\plc{parallel\_data},
  ompt\_data\_t *\plc{task\_data},
  const void *\plc{codeptr\_ra}
);
\end{boxedcode}
\ccppspecificend
}
\descr ToDo
The callbacks with type signature \code{ompt\_scoped\_worksharing\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

include a parameter \plc{codeptr\_ra} which contains the return address of the
call to the OpenMP runtime routine and a parameter \plc{endpoint}
that indicates whether the callback signals the begin or end of the scope.

\crossreferences
\begin{itemize}
\item \code{ompt\_worksharing\_type\_t} type signature, see
\specref{sec:ompt_worksharing_type_t}.
\item \code{ompt\_scope\_endpoint\_t} type signature, see
\specref{sec:ompt_scope_endpoint_t}.
\item \code{ompt\_data\_t} type signature, see
\specref{sec:ompt_data_t}.
\end{itemize}



\subsubsection{\code{ompt\_flush\_callback\_t}}
\index{ompt\_flush\_callback\_t@{\code{ompt\_flush\_callback\_t}}}
\label{sec:ompt_flush_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt\_flush\_callback\_t) (
  ompt\_data\_t *\plc{thread\_data},
  const void *\plc{codeptr\_ra}
);
\end{boxedcode}
\ccppspecificend
}
\descr ToDo
The callbacks with type signature \code{ompt\_flush\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type signature, see
\specref{sec:ompt_data_t}.
\end{itemize}



\subsubsection{\code{ompt\_scoped\_target\_callback\_t}}
\index{ompt\_scoped\_target\_callback\_t@{\code{ompt\_scoped\_target\_callback\_t}}}
\label{sec:ompt_scoped_target_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt\_scoped\_target\_callback\_t) (
  int32\_t \plc{device\_id},
  ompt\_target\_type\_t \plc{kind},
  ompt\_data\_t *\plc{task\_data},
  ompt\_scope\_endpoint\_t \plc{endpoint},
  ompt\_id\_t \plc{target\_id},
  const void *\plc{codeptr\_ra}
);
\end{boxedcode}
\ccppspecificend
}
\descr ToDo
The callbacks with type signature \code{ompt\_scoped\_target\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

include a parameter \plc{codeptr\_ra} which contains the return address of the
call to the OpenMP runtime routine and a parameter \plc{endpoint}
that indicates whether the callback signals the begin or end of the scope.

\crossreferences
\begin{itemize}
\item \code{ompt\_target\_type\_t} type signature, see
\specref{sec:ompt_target_type_t}.
\item \code{ompt\_data\_t} type signature, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_scope\_endpoint\_t} type signature, see
\specref{sec:ompt_scope_endpoint_t}.
\item \code{ompt\_id\_t} type, see
\specref{sec:ompt_id_t}.
\end{itemize}



\subsubsection{\code{ompt\_target\_data\_callback\_t}}
\index{ompt\_target\_data\_callback\_t@{\code{ompt\_target\_data\_callback\_t}}}
\label{sec:ompt_target_data_callback_t}
\format

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt\_target\_data\_callback\_t) (
  ompt\_id\_t \plc{target\_id},
  ompt\_id\_t \plc{host\_op\_id},
  ompt\_target\_data\_op\_t \plc{optype},
  void *\plc{host\_addr},
  void *\plc{device\_addr},
  size\_t \plc{bytes}
);
\end{boxedcode}
\ccppspecificend
}

\descr ToDo
The callbacks with type signature \code{ompt\_target\_data\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_id\_t} type, see
\specref{sec:ompt_id_t}.
\item \code{ompt\_target\_data\_op\_t} type signature, see
\specref{sec:ompt_target_data_op_t}.
\end{itemize}



\subsubsection{\code{ompt\_target\_data\_map\_callback\_t}}
\index{ompt\_target\_data\_map\_callback\_t@{\code{ompt\_target\_data\_map\_callback\_t}}}
\label{sec:ompt_target_data_map_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt\_target\_data\_map\_callback\_t) (
  ompt\_id\_t \plc{target\_id},
  unsigned int \plc{nitems},
  void **\plc{host\_addr},
  void **\plc{device\_addr},
  size\_t *\plc{bytes},
  unsigned int *\plc{mapping\_flags}
);
\end{boxedcode}
\ccppspecificend
}
\descr ToDo
The callbacks with type signature \code{ompt\_target\_data\_map\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_id\_t} type, see
\specref{sec:ompt_id_t}.
\end{itemize}



\subsubsection{\code{ompt\_target\_submit\_callback\_t}}
\index{ompt\_target\_submit\_callback\_t@{\code{ompt\_target\_submit\_callback\_t}}}
\label{sec:ompt_target_submit_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt\_target\_submit\_callback\_t) (
  ompt\_id\_t \plc{target\_id},
  ompt\_id\_t \plc{host\_op\_id},
  unsigned int \plc{requested\_num\_teams},
  unsigned int \plc{granted\_num\_teams}
);
\end{boxedcode}
\ccppspecificend
}
\descr ToDo
The callbacks with type signature \code{ompt\_target\_submit\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_id\_t} type, see
\specref{sec:ompt_id_t}.
\end{itemize}


\subsubsection{\code{ompt\_buffer\_request\_callback\_t}}
\index{ompt\_buffer\_request\_callback\_t@{\code{ompt\_buffer\_request\_callback\_t}}}
\label{sec:ompt_buffer_request_callback_t}

\summary
The OpenMP runtime will invoke a callback with type signature  
\code{ompt\_buffer\_request\_callback\_t} to request a
buffer to store event records for a device.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt\_buffer\_request\_callback\_t) (
  int32\_t \plc{device\_id},
  ompt\_buffer\_t** \plc{buffer},
  size\_t *\plc{bytes}
);
\end{boxedcode}
\ccppspecificend
}

\constraints 
The callback requests a buffer to store trace records for device \plc{device\_id}.  
A tool should set \plc{*buffer} to point to a buffer where device events
may be recorded and \plc{*bytes} to the length of that buffer.  A
buffer request callback  may set \plc{*bytes} to 0 if it does not
want to provide a buffer for any reason. If a callback sets
\plc{*bytes} to 0, further recording of events for the device will
be disabled until the next invocation of \code{ompt\_start\_trace}.
This will cause the device to drop future trace records until
recording is restarted.

Note: {\em buffer request and completion callbacks are not 
required to be async-signal safe.}

To start recording, a tool needs to register a \emph{buffer request}
callback that will supply a device with a buffer to deposit events
and a \emph{buffer complete} callback that will be invoked by the
OpenMP runtime to empty a buffer containing event records. A device's
offloading runtime library is responsible for invoking these callbacks
on a thread that is not an OpenMP master or worker. 

\crossreferences
\begin{itemize}
\item \code{ompt\_buffer\_t} type, see
\specref{sec:ompt_buffer_t}.
\end{itemize}

\subsubsection{\code{ompt\_buffer\_complete\_callback\_t}}
\index{ompt\_buffer\_complete\_callback\_t@{\code{ompt\_buffer\_complete\_callback\_t}}}
\label{sec:ompt_buffer_complete_callback_t}
\summary
A device triggers a call to \code{ompt\_buffer\_complete\_callback\_t} when no further records will be recorded in an event buffer and all records written to the buffer are valid. 

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt\_buffer\_complete\_callback\_t) (
  int32\_t \plc{device\_id},
  const ompt\_buffer\_t *\plc{buf},
  size\_t \plc{bytes},
  ompt\_buffer\_cursor\_t \plc{begin},
  \_Bool \plc{buffer\_owned}
);
\end{boxedcode}
\ccppspecificend
}
\descr ToDo
The callbacks with type signature \code{ompt\_buffer\_complete\_callback\_t},

\constraints

The argument \plc{device\_id} indicates the device whose events the
buffer contains. The argument \plc{buffer} is the address of a
buffer previously allocated by a \emph{buffer request} callback.
The argument \plc{bytes} indicates the full size of the buffer.
The argument \plc{begin} is an opaque cursor that indicates the
position at the beginning of the first record in the buffer. The
argument \plc{buffer\_owned} indicates whether or not the data
pointed to by buffer was allocated by a call to the buffer request
callback for that device. If multiple devices accumulate trace
events into a single buffer (as is the case for NVIDIA's CUPTI API),
this callback might be invoked with a pointer to one or more trace
records in a shared buffer with \plc{buffer\_owned} = \code{false}. In this
case, the callback may not delete the buffer.

Under normal operating conditions, every event buffer provided to
a device by a \emph{buffer request} callback will receive a
\emph{buffer complete} callback before the OpenMP runtime shuts
down. If an exceptional condition terminates  execution of an OpenMP
program, the OpenMP runtime may choose not to provide a \emph{buffer
complete} callback for buffers provided to any device.


\crossreferences
\begin{itemize}
\item \code{ompt\_buffer\_t} type, see
\specref{sec:ompt_buffer_t}.
\item \code{ompt\_buffer\_cursor\_t} type, see
\specref{sec:ompt_buffer_cursor_t}.
\end{itemize}

\subsubsection{\code{ompt\_tcontrol\_callback\_t}}
\index{ompt\_tcontrol\_callback\_t@{\code{ompt\_tcontrol\_callback\_t}}}
\label{sec:ompt_tcontrol_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt\_tcontrol\_callback\_t) (
  long long int \plc{command},
  long long int \plc{modifier}
);
\end{boxedcode}
\ccppspecificend
}
\descr 
The callback with type signature \code{ompt\_tcontrol\_callback\_t},
includes parameters \plc{command} and \plc{modifier}. Standard values for
\plc{command} are defined by \code{omp\_tcontrol\_t}. 
defined in \specref{sec:tool_tcontrol}.
The callback also allows tool-specific values for \plc{command} and \plc{modifier}.
Tool-specific values for \plc{command} must be $\geq$ 64.
Tools must ignore \plc{command} values that they are not 
explicitly designed to handle.

\crossreferences
\begin{itemize}
\item \code{omp\_tcontrol\_t} enumeration type, see \specref{sec:tool_tcontrol}.
\end{itemize}


\subsubsection{\code{ompt\_device\_initialize\_callback\_t}}
\index{ompt\_flush\_callback\_t@{\code{ompt\_device\_initialize\_callback\_t}}}
\label{sec:ompt_device_initialize_callback_t}

\summary The tool callback with type signature
\code{ompt\_device\_initialize\_callback\_t} initializes a
tool's tracing interface for a device.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_device_initialize_callback_t) (
  int device_id,
  const char *type,
  ompt_device_t *device,
  ompt_function_lookup_t *lookup,
  const char *documentation
);
\end{boxedcode}
\ccppspecificend
}

\descr 

A tool that wants to asynchronously collect a trace of
activities on a device should register a callback with type signature
\code{ompt\_device\_initialize\_callback\_t} for the
\code{ompt\_event\_device\_initialize} OpenMP event. An OpenMP
implementation will invoke this callback for a device after OpenMP is
initialized for the device but before beginning execution of any
OpenMP construct on the device.

\argdesc

The first argument identifies the logical device being initialized.

The second argument is a character string indicating the type of the
device. A device type string is a semicolon separated character string
that includes at a minimum the vendor and model name of the
device. This may be followed by a semicolon-separated sequence of
properties that describe a device's hardware or software.  An example
type string in this format is the following: ``NVIDIA; Tesla M2050;
compute capability 2.0; CUDA 8.0''.

The third argument is a pointer to an opaque object that represents
the target device instance. The pointer to the device instance object
is used by functions in the device tracing interface to identify the
device being addressed.

The fourth argument is \plc{lookup}---a pointer to a runtime callback
that a tool must use to obtain pointers to entry points in the
device's OMPT tracing interface.

The last argument is a string that describes names and type signatures
of any additional device-specific entry points that can be obtained
using \plc{lookup}. Ideally, the documentation string should include
not only the type signature but also descriptive text for how to use
the device-specific API or pointers to external documentation about
it.

\effect

A tool's device initializer has several duties.  First, it should use
\plc{type} to determine whether the tool has any special knowledge
about a device's hardware and/or software.  Second, it should use
\plc{lookup} to look up pointers to entry points in the OMPT tracing
interface for the device.  Finally, using these entry points, it can
then set up tracing for a device.

\crossreferences
\begin{itemize}
\item device tracing, see
\specref{sec:tracing-device-activity}. 
\item \code{ompt\_function\_lookup\_t} type signature, see \specref{sec:ompt_function_lookup_t}
\end{itemize}

\section{Runtime Entry Points for Tools}

\subsection{Miscellaneous Entry Point Signatures}


\subsubsection{\code{ompt\_function\_lookup\_t}}
\label{sec:ompt_function_lookup_t}
\label{sec:ompt_function_lookup}

\summary
A tool uses a lookup routine with type signature 
\code{ompt\_function\_lookup\_t}
to obtain pointers to runtime entry points that are
part of an OpenMP implementation's OMPT interface.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef ompt\_interface\_fn\_t (*\plc{ompt\_function\_lookup\_t}) (
  const char *\plc{interface\_function\_name}
);
\end{boxedcode}
\ccppspecificend
}

\descr

An OpenMP implementation provides a pointer to a lookup routine 
as an argument to tool and device initializers. A lookup routine
enables a tool to obtain pointers to OMPT runtime tool entry points 
for an OpenMP implementation's callback or tracing tool interfaces.

\constraints
A lookup routine with type
signature \code{ompt\_function\_lookup\_t} takes a C string
representing a routine in the OMPT interface of that device and
returns a pointer to the corresponding function for that device.

\crossreferences
\begin{itemize}
\item Table~\ref{table:host-ompt-interface-functions} 
lists names and type signatures of
host OMPT interface functions. 
\item Table~\ref{table:device-ompt-interface-functions} lists 
names and type signatures of device OMPT interface functions.
\item Tool initializer, see \specref{sec:ompt_initialize_fn_t}.
\end{itemize}

\begin{table}
{\small
\begin{tabular}{ll}\hline
Function name & Type signature\\\hline\hline
\code{ompt\_get\_device\_time} & \code{ompt\_get\_device\_time\_t}\\
\code{ompt\_translate\_time} & \code{ompt\_translate\_time\_t}\\
\code{ompt\_set\_trace\_ompt} & \code{ompt\_set\_trace\_ompt\_t}\\
\code{ompt\_set\_trace\_native} & \code{ompt\_set\_trace\_native\_t}\\
\code{ompt\_start\_trace} & \code{ompt\_start\_trace\_t}\\
\code{ompt\_pause\_trace} & \code{ompt\_pause\_trace\_t}\\
\code{ompt\_stop\_trace} & \code{ompt\_stop\_trace\_t}\\
\code{ompt\_advance\_buffer\_cursor} & \code{ompt\_advance\_buffer\_cursor\_t}\\
\code{ompt\_buffer\_get\_record\_type} & \code{ompt\_buffer\_get\_record\_type\_t}\\
\code{ompt\_buffer\_get\_record\_ompt} & \code{ompt\_buffer\_get\_record\_ompt\_t}\\
\code{ompt\_buffer\_get\_record\_native} & \code{ompt\_buffer\_get\_record\_native\_t}\\
\code{ompt\_buffer\_get\_record\_native\_abstract} & \code{ompt\_buffer\_get\_record\_native\_abstract\_t}\\\hline
\end{tabular}
}
\vskip 1ex
\caption{Device OMPT interface function names and their type signatures.}
\label{table:device-ompt-interface-functions} 
\end{table}

\subsection{Entry Points in the OMPT Callback Interface}

Inquiry functions enable a tool to retrieve data from the 
current device's execution environment.
These functions should not be global symbols in
an OpenMP implementation so that tool developers cannot call
them directly.  Section~\ref{sec:ToolsSupport_bind} describes how
a tool should obtain pointers to these inquiry functions.

{\em All inquiry functions must be async signal safe} since they 
are expected to be called from signal handlers. 

\begin{comment}
OpenMP Runtime Library Routines are not guaranteed to be async
signal safe. That means that they might acquire and release 
a lock as part of their normal operation. For that reason,
is unsafe to call OpenMP Runtime Library Routines 
within an OMPT callback because doing
so may cause deadlock.
\end{comment}


\subsubsection{\code{ompt\_enumerate\_states\_t}}
\label{sec:ompt_enumerate_states_t}
\label{sec:ompt_enumerate_states}

\summary
An OpenMP implementation's 
tool entry point known as \code{ompt\_enumerate\_states} 
with type signature \code{ompt\_enumerate\_states\_t} 
enumerates the thread states supported by an OpenMP 
implementation.

\format

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_enumerate_states_t)(
  int \plc{current_state}, 
  int *\plc{next_state}, 
  const char **\plc{next_state_name}
);
\end{boxedcode}
\ccppspecificend
}

\descr
An OpenMP implementation may support only a subset of the states defined by 
the \code{omp\_states\_t} enumeration type. In addition, an
OpenMP implementation may support implementation-specific states.
The \code{ompt\_enumerate\_states} entry point enables a tool to 
enumerate the thread states supported by an OpenMP implementation.
 
When a thread state supported by an OpenMP implementation is passed
as the first argument to the entry point,
the entry point will assign the next thread state in the enumeration to
the pointer passed as the entry point's second argument.

The third argument passed to the entry point
is the address of a character pointer that will be assigned a pointer
to the name associated with the state value assigned to the pointer
passed as the second argument.
 
Whenever one or more states are left in the enumeration, 
the enumerate states entry point will return $1$.
When the last state in the enumeration is passed 
as the first argument, the entry point will return $0$ 
indicating that the enumeration is complete.

\begin{comment}
For instance, a particular OpenMP implementation may want to 
provide more detail about the nature of runtime overhead, 
e.g., to differentiate between overhead associated with setting up 
parallel regions
and overhead associated with setting up tasks. 
% A tool need not report all states defined herein, e.g., if state tracking for a particular state would be too expensive.
To enable a tool to identify all states that an OpenMP implementation
supports, the following interface for enumerating all states that may be reported by the runtime that is being used.
\end{comment}

\constraints

The first argument passed to the enumerate states entry point must be
the value for a valid thread state supported by the OpenMP implementation.  
To begin enumerating the states that an OpenMP implementation supports,
a tool should pass the value \code{omp\_state\_undefined} as the
first argument to the enumerate states entry point.
Subsequent invocations of the entry point by the tool
should pass the value 
assigned to the pointer passed as the second argument of the previous call.

The second and third arguments to the entry point must be non-\code{NULL} 
pointers of the specified types.

\vspace{2ex}

\needspace{6\baselineskip}\notestart
\noteheader -- The following example illustrates how a tool can 
enumerate all states supported by an OpenMP implementation.
The example assumes that a pointer to an OpenMP implementation's enumerate
states entry point has previously been assigned to a function pointer
\code{ompt\_enumerate\_states}.

\vbox{
\ccppspecificstart
\begin{boxedcode}
int state = omp_state_undefined;
const char *state_name;
while (ompt_enumerate_states(state, &state, &state_name)) \{
  // note that the runtime supports a state value "state" 
  // associated with the name "state_name" 
\}
\end{boxedcode}
\ccppspecificend
\noteend
}

\crossreferences
\begin{itemize}
\item \code{omp\_state\_t}, see \specref{sec:thread-states}.
\end{itemize}

\subsubsection{\code{ompt\_enumerate\_mutex\_kinds\_t}}
\label{sec:ompt_enumerate_mutex_kinds_t}
\label{sec:ompt_enumerate_mutex_kinds}
 
\summary

An OpenMP implementation's tool entry point known as \code{ompt\_enumerate\_mutex\_kinds} 
with type signature \code{ompt\_enumerate\_mutex\_kinds\_t} 
enumerates the kinds of mutual exclusion implementations that
an OpenMP implementation employs.


\format

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_enumerate_mutex_kinds_t)(
  int current_kind, 
  int *next_kind, 
  const char **next_kind_name
);
\end{boxedcode}
\ccppspecificend
}

\descr
An OpenMP implementation may implement mutual exclusion for locks,
nest locks, critical sections, and atomic regions in several different
ways.  The \code{ompt\_enumerate\_mutex\_kinds} entry point
enables a tool to enumerate the 
kinds of mutual exclusion implementations that an OpenMP implementation
employs.

\begin{comment}
For that reason, a user program can provide hints
to help the runtime system to select appropriate implementations.
When a lock or nest lock is initialized, the \code{ompt\_event\_init\_lock}
callback receives the argument \code{kind}---a small integer that
indicates the lock implementation chosen by the OpenMP runtime.
Similarly, the \code{ompt\_event\_mutex\_acquire} callback receives
the argument \code{kind} to indicate the implementation of a lock,
critical section, atomic region, or ordered section. 
\end{comment}
 
When a mutex kind supported by an OpenMP implementation is passed
as the first argument to the entry point, the entry point 
will assign the next mutex kind in the enumeration to
the pointer passed as the second argument.

The third argument passed to the entry point 
is the address of a character pointer that will be assigned a pointer
to the name associated with the mutex kind value assigned to the pointer
passed as the second argument.

Whenever one or more states are left in the enumeration, 
the enumerate mutex kinds entry point will return $1$.
When the last state in the enumeration is passed 
as the first argument, the entry point will return $0$ 
indicating that the enumeration is complete.

\constraints
The first argument passed to the enumerate mutex kinds entry point must be
the value for a valid mutex implementation kind supported
by an OpenMP implementation.  To begin enumerating the mutex
implementation kinds that an OpenMP implementation supports, a tool
should pass the value \code{ompt\_mutex\_kind\_unknown} as the first
argument of the enumerate mutex kinds entry point.  Subsequent invocations
of the entry point by the tool should pass the
value assigned to the pointer passed as the second argument of the
previous call.

The second and third arguments to the entry point must be non-\code{NULL} 
pointers of the specified types.

\needspace{6\baselineskip}\notestart
\noteheader -- The following example illustrates how a tool can 
enumerate all types of mutex implementations supported by an OpenMP runtime.
The example assumes that a pointer to an OpenMP implementation's enumerate
mutex kinds callback has previously been assigned to a function pointer
\code{ompt\_enumerate\_mutex\_kinds}.

\vspace{2ex}

\vbox{
\ccppspecificstart
\begin{boxedcode}
int kind = ompt_mutex_kind_unknown;
const char *kind_name;
while (ompt_enumerate_mutex_kinds(kind, &kind, &kind_name)) \{
  // note that the runtime supports a mutex value "kind" 
  // associated with the name "kind_name" 
\}
\end{boxedcode}
\ccppspecificend
\noteend
}


\subsubsection{\code{ompt\_set\_callback\_t}}
\label{sec:ompt_set_callback_t}
\label{sec:ompt_set_callback}

\summary

An OpenMP implementation's tool entry point known as \code{ompt\_set\_callback} 
with type signature \code{ompt\_set\_callback\_t} registers a
pointer to a tool callback that an OpenMP implementation will invoke when a host
OpenMP event occurs.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt\_set\_callback_t)(
  ompt\_event\_t \plc{event},
  ompt\_callback\_t \plc{callback}
);
\end{boxedcode}
\ccppspecificend
}

\descr

To set tool callbacks for OpenMP events, a tool uses 
an OpenMP implementation's tool entry point known as
\code{ompt\_set\_callback}. 

The set callback entry point with type signature 
\code{ompt\_set\_callback\_t} is
used on the current device by a tool to install a 
pointer to a tool callback that 
an OpenMP implementation will invoke when an OpenMP event occurs on
that device.

\constraints
When a tool registers a callback for an event code \plc{event}, the type
signature for the callback must match the type signature appropriate for the
event. 
For an event with enumeration value name {\ttfamily\bfseries ompt\_event\_{\em xxx}}, 
the type signature for the event is {\ttfamily\bfseries ompt\_{\em xxx}\_callback\_t}. 
 
\begin{table}
\centering
\begin{tabular}{ll}
\hline
return code & meaning \\
\hline
0 & callback registration error\\
1 & event may occur; no callback is possible\\
2 & event will never occur in runtime\\
3 & event may occur; callback invoked when convenient\\
4 & event may occur; callback always invoked when event occurs\\
\hline
\end{tabular}
\caption{Meaning of return codes for \code{ompt\_set\_callback}.}
\label{table:ToolsSupport_set_rc}
\end{table}

\crossreferences
\begin{itemize}
\item \code{ompt\_event\_t} enumeration type, see \specref{sec:ompt_event_t}.
\item \code{ompt\_callback\_t} type, see \specref{sec:ompt_callback_t}.
\item \code{ompt\_get\_callback\_t} host callback ftype signature,
see \specref{sec:ompt_get_callback_t}.
\end{itemize}

\subsubsection{\code{ompt\_get\_callback\_t}}
\label{sec:ompt_get_callback_t}
\label{sec:ompt_get_callback}

\summary

An OpenMP implementation's tool entry point known as \code{ompt\_get\_callback} 
with type signature \code{ompt\_get\_callback\_t} retrieves a pointer
to a tool callback routine (if any) 
that an OpenMP implementation will invoke when an OpenMP event occurs.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_get_callback_t)(
  ompt_event_t \plc{event},
  ompt_callback_t *\plc{callback}
);
\end{boxedcode}
\ccppspecificend
}

\descr
A tool uses an OpenMP implementation's tool entry point known 
as \code{ompt\_get\_callback} 
with type signature \code{ompt\_get\_callback\_t} is
to obtain a pointer to the tool callback routine that 
an OpenMP implementation will invoke when a host OpenMP event occurs. 
If no tool callback is registered for the specified event, 
\plc{*callback} will be set to \code{NULL}.

\constraints
The first argument to the get callback entry point is an enumeration
type that specifies an OpenMP execution event.

\crossreferences
\begin{itemize}
\item \code{ompt\_event\_t} enumeration type, see \specref{sec:ompt_event_t}.
\item \code{ompt\_callback\_t} type, see \specref{sec:ompt_callback_t}.
\item \code{ompt\_set\_callback\_t} type signature, 
see \specref{sec:ompt_set_callback_t}. 
\end{itemize}

\subsubsection{\code{ompt\_get\_thread\_data\_t}}
\label{sec:thread-inquiry}
\label{sec:ompt_get_thread_data_t}
\label{sec:ompt_get_thread_data}

\summary
An OpenMP implementation's tool entry point known as \code{ompt\_get\_thread\_data}
with type signature \code{ompt\_get\_thread\_data\_t} 
returns the address of the thread identifier for the current thread.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef ompt_data_t *(*ompt_get_thread_data_t)(void);
\end{boxedcode}
\ccppspecificend}

\descr
If the current thread is unknown to the OpenMP runtime, the function
returns NULL.  A tool can check if the thread identifier is in its
initial state by comparing against \code{ompt\_data\_none}.  A tool
may modify the identifier.  

{\em This callback is async signal safe.}

\subsubsection{\code{ompt\_get\_state\_t}}
\label{sec:ompt_get_state_t}
\label{sec:ompt_get_state}

\summary
An OpenMP implementation's tool entry point known as \code{ompt\_get\_state}
with type signature \code{ompt\_get\_state\_t} 
returns the state and the wait identifier of the 
current thread. 

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef omp_state_t (*ompt_get_state_t)(
  ompt_wait_id_t *wait_id       
);
\end{boxedcode}
\ccppspecificend}

\descr
If the returned state indicates that the thread is waiting for a
lock, nest lock, critical section, atomic region, or ordered region,
it will fill in \code{*wait\_id} with the wait identifier associated
with the state.  

{\em This callback is async signal safe.}

\subsubsection{\code{ompt\_get\_parallel\_info\_t}} 
\label{sec:ompt_get_parallel_info_t}
\label{sec:ompt_get_parallel_info}

\summary
An OpenMP implementation's tool entry point known as \code{ompt\_get\_parallel\_info} 
with type signature \code{ompt\_get\_parallel\_info\_t} 
returns information about
the parallel region, if any, at the specified ancestor level in the
current execution context.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_get_parallel_info_t)(
  int ancestor_level,
  ompt_data_t **parallel_data,
  int *team_size
);
\end{boxedcode}
\ccppspecificend}

\descr
Ancestor level 0 refers to the current parallel region; information
about enclosing parallel regions may be obtained using higher
ancestor levels.  Function \code{ompt\_get\_parallel\_info} returns a
Boolean, which indicates whether there is a parallel region at the
specified ancestor level.  The function results \code{**parallel\_data}
and \code{*team\_size} indicate properties of the parallel region
at the specified ancestor level.  If there is no enclosing parallel
region at the specified ancestry level, the address of the provided
parallel region identifier \code{*parallel\_data} equals NULL and
the value of \code{*team\_size} is undefined.  A tool can check if
the parallel region identifier is in its initial state by comparing
against \code{ompt\_data\_none}.  A tool may modify the identifier.

{\em This callback is async signal safe.}

\subsubsection{\code{ompt\_get\_task\_info\_t}}
\label{sec:ompt_get_task_info_t}
\label{sec:ompt_get_task_info}

\summary
An OpenMP implementation's tool entry point known as \code{ompt\_get\_task\_info} 
with type signature \code{ompt\_get\_task\_info\_t} provides information about the
task, if any, at the specified ancestor level in the current execution
context.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_get_task_info_t)(
  int ancestor_level,
  ompt_task_type_t *type,
  ompt_data_t **task_data,
  ompt_frame_t **task_frame,
  ompt_data_t **parallel_data,
  int *thread_num
);
\end{boxedcode}
\ccppspecificend}

\descr
Ancestor level 0 refers to the current task; information about
ancestor tasks in the current execution context may be queried at
higher ancestor levels.  Function \code{ompt\_get\_task\_info\_t} returns
a Boolean, which indicates whether there is a task at the specified
ancestor level.  

{\em This callback is async signal safe.}

A task may be of type initial, implicit, explicit,  target, or
degenerate.  If the task at the specified level is degenerate, the
address returned in \code{*task\_data} will be NULL.  A degenerate
task will be associated with the enclosing parallel region.  If the
thread invoking this function is outside any parallel region, the
address returned in \code{*parallel\_data} will be NULL.  A tool can
check if the task region or parallel region identifier are in their
initial states by comparing against \code{ompt\_data\_none}.  A tool
may modify the identifiers.  The value returned in \code{thread\_num}
indicates the number of the OpenMP thread executing the task in the
parallel region to which the task belongs.

Using values inside  \code{ompt\_frame\_t} objects returned by calls
to  \code{ompt\_get\_task\_info}, a tool can analyze  frames in the
call stack and identify ones that exist on behalf of the runtime
system.\footnote{A frame on the call stack is said to exist on
behalf of an OpenMP runtime if it is a frame for a runtime system
routine, or if it belongs to a library function called by a runtime
system routine, directly or indirectly.} This capability enables a
tool to map from an implementation-level view of the call stack
back to a source-level view that is easier for application developers
to understand.  Appendix~\ref{app:frame} discusses  an example that
illustrates the use of \code{ompt\_frame\_t} objects with multiple
threads and nested parallelism.

\subsubsection{\code{ompt\_get\_target\_info\_t}}
\label{sec:ompt_get_target_info_t}
\label{sec:ompt_get_target_info}

\summary
An OpenMP implementation's tool entry point known as \code{ompt\_get\_target\_info} 
with type signature \code{ompt\_get\_target\_info\_t} returns identifiers that specify a
thread's current target region and target operation id, if any.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_get_target_info_t)(
  ompt_id_t *target_id,
  ompt_id_t *host_op_id
);
\end{boxedcode}
\ccppspecificend}

\descr
This function returns \code{false} if the thread invoking it is
outside a target region. In that case, the values of both of its
returned parameters are undefined. If \code{ompt\_get\_target\_info}
returns \code{true}, the value for \code{*host\_op\_id} will be
\code{ompt\_id\_none} if the thread invoking it is not in the process
of initiating an operation on a target (e.g., copying data to or
from an accelerator or launching a kernel).  

{\em This callback is async signal safe.}

\crossreferences
\begin{itemize}
\item \code{ompt\_id\_t} type, see \specref{sec:ompt_id_t}.
\end{itemize}

\subsubsection{\code{ompt\_get\_num\_devices\_t}}
\label{sec:ompt_get_num_devices_t}
\label{sec:ompt_get_num_devices}

\summary
An OpenMP implementation's tool entry point known as \code{ompt\_get\_num\_devices} 
with type signature \code{ompt\_get\_num\_devices\_t} 
returns the number of available devices.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_get_num_devices_t)(void);
\end{boxedcode}
\ccppspecificend}

\descr
This inquiry function is only supported on the host. If the inquiry
function is invoked by a thread not executing in the scope of a
\code{target}, \code{target data}, or \code{target update} construct,
the return value is undefined. 

{\em This callback is async signal safe.}


\begin{comment}
\subsubsection{\code{ompt\_get\_device\_info\_t}}
\label{sec:ompt_get_device_info_t}
\label{sec:ompt_get_device_info}

\summary
An OpenMP implementation's tool entry point known as \code{ompt\_get\_device\_info} 
with type signature \code{ompt\_get\_device\_info\_t} r
returns information about a specified device.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_get_device_info_t)(
  int32_t device_id, 
  const char **type, 
  ompt_device_t **device,
  ompt_function_lookup_t *lookup,
  const char **documentation
);
\end{boxedcode}
\ccppspecificend}

\descr
If \code{device\_id} refers to a valid device, the function will
return \code{true} indicating success; otherwise, it will return
\code{false} and the values of its return parameters are undefined.
The runtime will set \code{*type} to point to a character string
that identifies at a minimum the  type of the device. It might also
indicate the software stack it is running and perhaps even the
version number of one or more components in that stack. An example
string could be ``NVIDIA Tesla M2050, compute capability 2.0, CUDA
5.5.'' A tool can use such a type string to determine if it has any
special knowledge about hardware and software of the specific device.
The OpenMP runtime will set \code{*device} to point to an opaque
object that represents the target device instance. The device pointer
returned will need to be supplied as an argument to calls to
device-specific functions in the target interface to identify the
device being addressed.

The OpenMP runtime will set the value of \code{*lookup} to point
to a function that can be used to look up device-specific API
functions.  The \code{lookup} function for a device will enable a
tool to look up all functions marked \code{OMPT\_TARG\_API}.  If a
named function is not available in an OpenMP runtime's implementation
of OMPT, lookup will return NULL. Documentation for the names and
type signatures of any additional device-specific API functions
available through \code{lookup} should be provided in the form of
a single character string \code{*documentation}. Ideally, the
documentation string should include not only the type signature but
also necessary descriptive text for how to use the device-specific
API or pointers to external documentation.
\end{comment}

\subsubsection{\code{ompt\_get\_device\_id\_t}}
\label{sec:ompt_get_device_id_t}
\label{sec:ompt_get_device_id}

\summary
An OpenMP implementation's tool entry point known as \code{ompt\_get\_device\_id} 
with type signature \code{ompt\_get\_device\_id} returns the device
identifier for the active target device.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_get_device_id_t)(void);
\end{boxedcode}
\ccppspecificend}

\descr
This inquiry function is only supported on the host. If the inquiry
function is invoked by a thread not executing in the scope of a
{\ttfamily target}, {\ttfamily target data}, or {\ttfamily target update} construct,
then it will return a value of -1. 

{\em This callback is async signal safe.}

\subsection{Tracing Entry Points}
\subsection{Tracing Callback Signatures}
\subsubsection{\code{ompt\_get\_device\_time\_t}}
\label{sec:ompt_get_device_time_t}

\summary
An OpenMP implementation's tool entry point known as \code{ompt\_get\_device\_time} 
with type signature \code{ompt\_get\_device\_time\_t} 
returns the current time on a specified device.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef ompt_device_time_t (*ompt_get_device_time_t)(
  ompt_device_t *device
);
\end{boxedcode}
\ccppspecificend}

\descr
Host and target devices are typically distinct and run independently.
If host and target devices are different hardware components, they
may use different clock generators. For this reason,  there may be
no common time base for ordering host-side and device-side events.

This inquiry function can be used to acquire information that can
be used to align time stamps from the target device with time stamps
from the host or other devices.

\subsubsection{\code{ompt\_translate\_time\_t}}

\summary
An OpenMP implementation's tool entry point known as \code{ompt\_translate\_time} 
with type signature \code{ompt\_translate\_time\_t} translates
a time value obtained from a target device to a corresponding time
value on the host device. 

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef double (*ompt_translate_time_t)(
  ompt_device_t *device,
  ompt_device_time_t time
);
\end{boxedcode}
\ccppspecificend}

\descr
The {\ttfamily double} result for the host time has
the same meaning as the {\ttfamily double} returned from \code{omp\_get\_wtime}.

\littleheader{Advice to tool implementers:} 
The accuracy of time translations may degrade if they are not
performed promptly after a device time value is received if either
the host or device vary their clock speeds. Prompt translation of
device times to host times is recommended.

\subsubsection{\code{ompt\_set\_trace\_ompt\_t}}
\label{sec:ompt_set_trace_ompt_t}

\summary
An OpenMP implementation's tool entry point known as \code{ompt\_set\_trace\_ompt} 
with type signature \code{ompt\_set\_trace\_ompt\_t} 
enables or disables the recording of trace records for one or more
types of OMPT events.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_set_trace_ompt_t)(
  ompt_device_t *device,
  _Bool enable,
  ompt_event_t etype
);
\end{boxedcode}
\ccppspecificend}

\constraints
The argument \code{device} is a handle to identify the target device
whose performance monitoring may be altered by invoking this function.
The boolean \code{enable} indicates whether recording of events of
type \code{rtype} should be enabled or disabled by this invocation.
Actual record types are specified using positive numbers; an
\code{rtype} of 0 indicates that all record types will be enabled
or disabled.  Table~\ref{table:record_set} shows the possible return
codes for \code{ompt\_set\_trace\_ompt}.  If a single invocation
of \code{ompt\_set\_trace\_ompt} is used to enable or disable
more than one event (i.e., \code{rtype}=0), the return code will
be 3 if tracing is possible for one or more events but not for
others.

\begin{table}
\centering
\begin{tabular}{|l|l|}
\hline
return code & meaning \\\hline
0 & error\\\hline
1 & event may occur but no tracing is possible\\\hline
2 & event will never occur in runtime\\\hline
3 & event may occur and will be traced  when convenient\\\hline
4 & event may occur and will always be traced if event occurs\\\hline
\end{tabular}
\caption{Meaning of return codes for {\ttfamily ompt\_trace\_set\_ompt} and {\ttfamily ompt\_set\_trace\_native}.}
\label{table:record_set}
\end{table}

\subsubsection{\code{ompt\_set\_trace\_native\_t}}
\label{sec:ompt_set_trace_native_t}

\summary
An OpenMP implementation's tool entry point known as \code{ompt\_set\_trace\_native} 
with type signature \code{ompt\_set\_trace\_native\_t} 
enables or disables the recording of native trace records for a device.


\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_set_trace_native_t)(
  ompt_device_t *device,
  int enable,
  int  flags
);
\end{boxedcode}
\ccppspecificend}

\descr
This interface is designed for use by a tool with no knowledge about
an attached device. If a tool knows how to program a particular
attached device, it may opt to invoke native control functions
directly using pointers obtained through the \code{lookup} function
associated with the device and described in the \code{documentation}
string that is returned by \code{ompt\_get\_device\_info}.

\constraints
The argument \code{device} is a handle to identify the target device
whose performance monitoring may be altered by invoking this function.
The boolean \code{enable} indicates whether recording of events
should be enabled or disabled by this invocation.  The kinds of
native device monitoring to enable or disable are specified by
\code{flags}. Each kind of monitoring is specified by a flag bit.
Flags can be composed by using logical {\ttfamily or}  to combine enumeration
values from type \code{ompt\_native\_mon\_flags\_t}.
Table~\ref{table:record_set} shows the possible return codes for
\code{ompt\_set\_trace\_native}.  If a single invocation of
\code{ompt\_set\_trace\_ompt} is used to enable/disable more
than one kind of monitoring, the return code will be 3 if tracing
is possible for one or more kinds of monitoring but not for others.


To start, pause, or stop tracing for a specific target device associated with the handle \code{device}, 
a tool calls the functions \code{ompt\_start\_trace}, \code{ompt\_pause\_trace}, or \code{ompt\_stop\_trace}.

\subsubsection{\code{ompt\_start\_trace\_t}}
\label{sec:ompt_start_trace_t}

\summary
An OpenMP implementation's tool entry point known as \code{ompt\_start\_trace} 
with type signature \code{ompt\_start\_trace\_t} 
starts tracing of activity on a specific device.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_start_trace_t)(
  ompt_device_t *device,
  ompt_buffer_request_callback_t request,
  ompt_buffer_complete_callback_t complete,
  ompt_get_target_info_callback_t get_info
);
\end{boxedcode}
\ccppspecificend}


\subsubsection{\code{ompt\_pause\_trace\_t}}
\label{sec:ompt_pause_trace_t}

\summary
An OpenMP implementation's tool entry point known as \code{ompt\_pause\_trace} 
with type signature \code{ompt\_pause\_trace\_t} 
pauses or restarts activity tracing on a specific device.

\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_pause_trace_t)(
  ompt_device_t *device,
  int begin_pause
);
\end{boxedcode}
\ccppspecificend}


\subsubsection{\code{ompt\_stop\_trace\_t}}
\label{sec:ompt_stop_trace_t}

\summary
An OpenMP implementation's tool entry point known as \code{ompt\_stop\_trace} 
with type signature \code{ompt\_stop\_trace\_t} 
stops tracing for a device.

\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_stop_trace_t)(
  ompt_device_t *device
);
\end{boxedcode}
\ccppspecificend}

\descr
Each invocation returns 1 if the command succeeded and 0 otherwise.
A call to \code{ompt\_stop\_trace} also implicitly requests that the device flush any buffers that it owns.

%%? johnmc says: we should export one more function from a target device: ompt_target_scope(begin/end, host_id)
%% this function will be used by the OpenMP runtime when a target device is being monitored to signal the target device when 
%% (1) entering and leaving a target region
%% (2) before and after launching a kernel
%% (3) before and after performing a data operation: copy, allocation, release, ...
%% this function will enable the target device to associate device_activity_ids with some host_id that either represents a 
%% target region, target data operation, or target kernel submission

\subsubsection{\code{ompt\_advance\_buffer\_cursor\_t}}
\label{sec:ompt_advance_buffer_cursor_t}

%There are several routines that need to be used together to process %target event records deposited in a buffer by a device. 

\summary
An OpenMP implementation's tool entry point known as \code{ompt\_advance\_buffer\_cursor} 
with type signature \code{ompt\_advance\_buffer\_cursor\_t}
advances a trace buffer cursor to the next record.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_advance_buffer_cursor_t)(
  ompt_buffer_t *buffer,
  size_t size, 
  ompt_buffer_cursor_t current, 
  ompt_buffer_cursor_t *next
); 
\end{boxedcode}
\ccppspecificend}

\descr
It returns \code{true} if the advance is successful and the returned value \code{*next} is valid.

\subsubsection{\code{ompt\_buffer\_get\_record\_type\_t}}
\label{sec:ompt_buffer_get_record_type_t}

\summary
An OpenMP implementation's tool entry point known as
\code{ompt\_buffer\_get\_record\_type} with type signature
\code{ompt\_buffer\_get\_record\_type\_t} inspects the type
of a trace record.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef ompt_record_type_t (*ompt_buffer_get_record_type_t)(
  ompt_buffer_t *buffer, 
  ompt_buffer_cursor_t current
);
\end{boxedcode}
\ccppspecificend}

\descr

\code{ompt\_buffer\_get\_record\_type} returns either \code{ompt\_record\_ompt} if the record represents a OMPT event,  
%\code{ompt\_record\_correlation} if the purpose of the record is to associate the identifier for a device activity with a host target task id, 
\code{ompt\_record\_native} if the record represents a device native record type that does not represent an OMPT event record, or \code{ompt\_record\_invalid} if the cursor is out of bounds. 

\crossreferences
Appendix~\ref{appendix:ompt-records} defines the corresponding enumeration type for \code{ompt\_record\_type\_t}. 
Section~\ref{sec:native-record-data} describes the interface to use for accessing native record types.

\subsubsection{\code{ompt\_buffer\_get\_record\_ompt\_t}}
\label{sec:ompt_buffer_get_record_ompt_t}
 
\summary
An OpenMP implementation's tool entry point known as \code{ompt\_buffer\_get\_record\_ompt} 
with type signature \code{ompt\_buffer\_get\_record\_ompt\_t} 
obtains a pointer to an OMPT trace record from a trace buffer associated with a device.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef ompt_record_ompt_t *(*ompt_buffer_get_record_ompt_t)(
  ompt_buffer_t *buffer, 
  ompt_buffer_cursor_t current
);
\end{boxedcode}
\ccppspecificend}

\descr

This function returns a pointer that may point into the record
buffer, or it may point into thread local storage where the information
extracted from a record was assembled. The information available
for an event depends upon its type. 

\crossreferences
Appendix~\ref{appendix:ompt-records} defines a union type that will
be used to return information for different OMPT event record types.
A subsequent call to \code{ompt\_record\_get} may overwrite the
contents of the fields in a record returned by a prior invocation.

\subsubsection{\code{ompt\_buffer\_get\_record\_native\_t}}
\label{sec:ompt_buffer_get_record_native_t}

\summary

An OpenMP implementation's tool entry point known as
\code{ompt\_buffer\_get\_record\_native} with type signature
\code{ompt\_buffer\_get\_record\_native\_t} 
obtains a pointer to a native trace record from a trace buffer associated with a device.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef void *(ompt_buffer_get_record_native_t)(
  ompt_buffer_t *buffer, 
  ompt_buffer_cursor_t current,
  ompt_id_t *host_op_id
);
\end{boxedcode}
\ccppspecificend}

\descr

The pointer returned  may point into the trace buffer, or into
thread local storage where the information extracted from a trace
record was assembled. The information available for a native event
depends upon its type. If the function returns a non-NULL result,
it will also set \code{*host\_op\_id} to identify host-side identifier
for the operation associated with the record.  A subsequent call
to \code{ompt\_buffer\_get\_record\_native} may overwrite the
contents of the fields in a record returned by a prior invocation.

\subsubsection{\code{ompt\_buffer\_get\_record\_native\_abstract\_t}}
\label{sec:ompt_buffer_get_record_native_abstract_t}

\summary
An OpenMP implementation's tool entry point known as
\code{ompt\_buffer\_get\_record\_native\_abstract} 
with type signature
\code{ompt\_buffer\_get\_record\_native\_abstract\_t} 
summarizes the context of a native trace record.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef ompt_record_native_abstract_t *
(*ompt_buffer_get_record_native_abstract_t)(
  void *native_record 
);
\end{boxedcode}
\ccppspecificend}

\descr

A \code{ompt\_record\_native\_abstract\_t} record contains several
pieces of information that a tool can use to process a native record
that it may not fully understand. The record \code{rclass} field
indicates whether the record is informational
(\code{ompt\_record\_native\_class\_info}) or represents an event
(\code{ompt\_record\_native\_class\_event}). Knowing whether a record
is informational or represents an event can help a tool determine
how to present the record. The record  \code{type} field points to
a statically-allocated, immutable character string that provides
a meaningful name  a tool might want to use to describe the event
to a user. The \code{start\_time} and \code{end\_time} fields are
used to place an event in time. The times are relative to the device
clock. If an event has no associated \code{start\_time} and/or
\code{end\_time}, the value of an unavailable field will be the
distinguished value \code{ompt\_time\_none}. The hardware id field,
\code{hwid},  is used to indicate the location on the device where
the event occurred. A \code{hwid} may represent a hardware abstraction
such as a core or a hardware thread id. The meaning of a \code{hwid}
value for a device is defined by the implementer of the software
stack for the device. If there is no \code{hwid} associated with a
record, the value of \code{hwid} shall be \code{ompt\_hwid\_none}.

% This is the end of ch4-toolsSupport.tex
