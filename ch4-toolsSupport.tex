% This is ch4-toolsSupport.tex of the OpenMP specification.
% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%

\newcommand\longlongint{uint64\_t}
\newcommand\ulonglongint{uint64\_t}
\newcommand\callbackarg{argument}

\newcommand{\devicedesc}{
The \callbackarg{} \plc{device} is a pointer to an opaque object that
represents the target device instance. The pointer to the device
instance object is used by functions in the device tracing interface
to identify the device being addressed.
}

\newcommand{\epdesc}{
The \callbackarg{} \plc{endpoint} indicates whether the callback is
signalling the beginning or the end of a scope.
}

\newcommand\codeptrdesc{
The \callbackarg{} \plc{codeptr\_ra} is used to relate the implementation
of an OpenMP region back to its source code.  In cases where a runtime
routine implements the region associated with this callback,
\plc{codeptr\_ra} is expected to contain the return address of the
call to the runtime routine.  In cases where the implementation of
this feature is inlined, \plc{codeptr\_ra} is expected to contain the
return address of the invocation of this callback.  In cases where
attribution to source code is impossible or inappropriate,
\plc{codeptr\_ra} may be \code{NULL}.
}


\newcommand{\ompttype}[1]{\subsubsection{#1}}  % section 4.5.7
\newcommand{\ompttoolsignature}[1]{\subsection{#1}}  % section 4.8.2
\newcommand{\omptcallbacksignature}[1]{\subsubsection{#1}}  % section 4.8.2
\newcommand{\omptruntimeentrypoint}[1]{\subsubsection{#1}}  % sections 4.9.*
\newcommand{\ompteventswithoutdirectives}[1]{\littleheader{#1}}

\chapter{Tool Support}
\index{tool support}
\label{chap:ToolsSupport}

%To enable development of high-quality, portable, \emph{first-party} tools
%that support monitoring and performance analysis of OpenMP programs
%developed using any implementation of the OpenMP API, the OpenMP API
%includes a tool interface known as OMPT. 

This chapter describes OMPT---a tool interface for the OpenMP API.
The chapter begins with an overview of the OMPT interface in
Section~\ref{sec:ompt-overview}. Next,
it describes how to initialize (Section~\ref{sec:ompt-initialization}) and 
and finalize (Sections~\ref{sec:ompt-finalization}) a tool.
Subsequent sections describe details of the interface, including
data types shared between an OpenMP implementation and a tool
(Section~\ref{sec:ompt-data-types}), 
an interface that enables an OpenMP implementation to determine that a
tool is available (Section~\ref{sec:tool-interface}),
type signatures for tool callbacks 
that an OpenMP implementation may dispatch for OpenMP events
(Section~\ref{sec:ompt-tool-callbacks}), and 
\emph{runtime entry points}---function interfaces
provided by an OpenMP implementation for use by a tool
(Section~\ref{sec:entry-points}). 

\section{Overview}
\label{sec:ompt-overview}

The OMPT interface defines mechanisms for initializing a tool,
exploring the details of an OpenMP implementation, examining OpenMP state
associated with an OpenMP thread, interpreting an OpenMP thread's call stack,
receiving notification about OpenMP \emph{events}, tracing activity on 
OpenMP target devices, and controlling a tool from an OpenMP application.

\section{Activating a Tool}
\label{sec:ompt-initialization}

There are three steps to activating a tool. First, an OpenMP
implementation determines whether a tool should be initialized.  If
so, the OpenMP implementation invokes the tool's initializer, enabling
the tool to prepare to monitor the execution on the host. Finally, a
tool may arrange to monitor computation that execute 
on target devices. This section explains how the tool and an 
OpenMP implementation interact to accomplish these tasks.

\subsection{Determining Whether a Tool Should be Initialized}
\label{sec:ompt-check-tool}

A tool indicates its interest in using the OMPT interface 
by providing a non-\code{NULL} pointer to an \code{ompt\_fns\_t}
structure to an OpenMP implementation as a return value from 
\code{ompt\_start\_tool}. There are three ways
that a tool can provide a definition of \code{ompt\_start\_tool} to an
OpenMP implementation:

\begin{itemize}
\item statically-linking the tool's definition of \code{ompt\_start\_tool}
  into an OpenMP application, 
\item introducing a dynamically-linked library that includes the tool's definition
  of \code{ompt\_start\_tool} into the application's address space, or 
\item providing the name of a dynamically-linked library appropriate
  for the architecture and operating system used by the application
  in the \plc{tool-libraries-var} ICV.
\end{itemize}

Immediately before an OpenMP implementation initializes itself, it
determines whether it should check for the presence of a tool
interested in using the OMPT interface by examining the \plc{tool-var}
ICV.  If value of \plc{tool-var} is \plc{disabled}, the OpenMP
implementation will initialize itself without even checking whether a
tool is present and the functionality of the OMPT interface will be
unavailable as the program executes.
 
If the value of \plc{tool-var} is \plc{enabled}, the OpenMP
implementation will check to see if a tool has provided an
implmentation of \code{ompt\_start\_tool}.  The OpenMP implementation first
checks if a tool-provided implementation of \code{ompt\_start\_tool} is
available in the address space, either statically-linked into the
application or in a dynamically-linked library loaded in the address
space. If multiple implementations of \code{ompt\_start\_tool} are available,
the OpenMP implementation will use the first tool-provided
implementation of \code{ompt\_start\_tool} found.

If no tool-provided implementation of \code{ompt\_start\_tool} is found in
the address space, the OpenMP implementation will consult the
\plc{tool-libraries-var} ICV, which contains a (possibly empty) list
of dynamically-linked libraries.  As described in detail in
Section~\ref{sec:OMP_TOOL_LIBRARIES}, the libraries in
\plc{tool-libraries-var}, will be searched for the first usable
implementation of \code{ompt\_start\_tool} provided by one of the libraries
in the list.

If a tool-provided definition of \code{ompt\_start\_tool} is found using
either method, the OpenMP implementation will invoke it; if it returns
a non-\code{NULL} pointer to an \code{ompt\_fns\_t} structure, 
the OpenMP implementation will know
that a tool is present that wants to use the OMPT interface.

Next, the OpenMP implementation will initialize itself. If a tool
provided a non-\code{NULL} pointer to an \code{ompt\_fns\_t} structure,
the OpenMP runtime will prepare itself for use of the OMPT interface by a tool. 

\crossreferences
\begin{itemize}
\item \plc{tool-var} ICV, see \specref{sec:Internal Control Variables}.
\item \plc{tool-libraries-var} ICV, see \specref{sec:Internal Control Variables}.
\item \code{ompt\_fns\_t}, see \specref{sec:ompt_fns_t}.
\item \code{ompt\_start\_tool}, see \specref{sec:ompt_start_tool}.
\end{itemize}

\subsection{Tool Initialization}
\index{tool initialization}
\label{sec:tool-initialize}

If a tool-provided implementation of \code{ompt\_start\_tool} returns a
non-\code{NULL} pointer to an \code{ompt\_fns\_t} structure,
the OpenMP implementation will invoke the tool initializer specified
in this structure prior to the occurrence of any OpenMP \emph{event}. 

A tool's initializer, described in \specref{sec:ompt_initialize_t}
uses its \callbackarg{} \plc{lookup} to look up pointers
to OMPT interface runtime entry points provided by the OpenMP
implementation; this process is described in \specref{sec:ompt-bind}.
After obtaining a pointer to the OpenMP runtime entry point known as
known as \code{ompt\_callback\_set} with type signature
\code{ompt\_callback\_set\_t}, the tool initializer should use it to
register tool callbacks for OpenMP events, as described in
\specref{sec:ompt-register-callbacks}.

A tool initializer may use the OMPT interface runtime
entry points known as \code{ompt\_enumerate\_states} and
\code{ompt\_enumerate\_mutex\_impls}, which have type signatures
\code{ompt\_enumerate\_states\_t} and
\code{ompt\_enumerate\_mutex\_impls\_t}, to determine what thread
states and implementations of mutual exclusion a particular OpenMP
implementation employs. The descriptions of the enumeration runtime entry point
type signatures show how to use them to determine what
thread states and mutual exclusion mechanisms an OpenMP implementation supports.

If a tool initializer returns a non-zero value, the tool will be
\emph{activated} for the execution; otherwise, the tool will be
inactive.

If a tool has been activated, an OpenMP implementation dispatches
a registered \code{ompt\_callback\_thread\_begin} in the initial
thread. The callback occurs in the context of the thread.  The
callback has type signature \code{ompt\_callback\_thread\_begin\_t}.

\crossreferences
\begin{itemize}
\item \code{ompt\_initialize\_t}, see \specref{sec:ompt_initialize_t}.
\item \code{ompt\_callback\_thread\_begin\_t}, see \specref{sec:ompt_callback_thread_begin_t}.
\item \code{ompt\_enumerate\_states\_t}, see \specref{sec:ompt_enumerate_states_t}.
\item \code{ompt\_enumerate\_mutex\_impls\_t}, see   \specref{sec:ompt_enumerate_mutex_impls_t}.
\item \code{ompt\_callback\_set\_t}, see \specref{sec:ompt_callback_set_t}.
\item \code{ompt\_function\_lookup\_t}, see \specref{sec:ompt_function_lookup_t}.
\end{itemize}


\subsubsection{Binding Entry Points in the OMPT Callback Interface}
\label{sec:ompt-bind}

Functions that an OpenMP implementation provides to support the OMPT interface
are not defined as global function symbols. Instead, they are defined as runtime entry points 
that a tool can only identify using the \plc{lookup} function provided as an
argument to the tool's initializer. This design avoids tool
implementations that
will fail in certain circumstances when functions defined as part of
the OpenMP runtime are not visible to a tool, even though the tool and
the OpenMP runtime are both present in the same address space.
It also prevents inadvertant use of a tool support routine by
applications.
 
A tool's initializer receives a function pointer to a \plc{lookup}
runtime entry point with type signature
\code{ompt\_function\_lookup\_t} as its first argument. Using this
function, a tool initializer may obtain a pointer to each of the
runtime entry points that an OpenMP implementation provides to support
the OMPT interface. Once a tool has obtained a 
\plc{lookup} function, it may employ it at any point in the future.

For each runtime entry point in the OMPT interface for the host device, 
Table~\ref{table:ompt-callback-interface-functions} provides the string
name by which it is known and its associated type signature. Implementations
can provide additional, implementation specific names and corresponding
entry points as long as they don't use names that start with the prefix
``\code{ompt\_}''. These are reserved for future extensions in the 
OpenMP specification.

During initialization, a tool should look up each runtime entry point in the
OMPT interface by name and bind a pointer maintained by the tool
that it can use later to invoke the entry point as needed. The entry points
described in Table~\ref{table:ompt-callback-interface-functions}
enable a tool to assess 
what thread states and mutual exclusion implementations that an OpenMP runtime supports,
register tool callbacks, inspect callbacks registered,
introspect OpenMP state associated with threads, and use tracing to monitor
computations that execute on target devices.

Detailed information about each runtime entry point listed in 
Table~\ref{table:ompt-callback-interface-functions} is included as
part of the description of its type signature.

\begin{table}
\begin{tabular}{ll}\hline
Entry Point String Name & Type signature\\\hline\hline
``\code{ompt\_enumerate\_states}'' & \code{ompt\_enumerate\_states\_t}\\
``\code{ompt\_enumerate\_mutex\_impls}'' & \code{ompt\_enumerate\_mutex\_impls\_t}\\
``\code{ompt\_callback\_set}'' & \code{ompt\_callback\_set\_t}\\
``\code{ompt\_callback\_get}'' & \code{ompt\_callback\_get\_t}\\
``\code{ompt\_get\_thread\_data}'' & \code{ompt\_get\_thread\_data\_t}\\
``\code{ompt\_get\_num\_places}'' & \code{ompt\_get\_num\_places\_t}\\
``\code{ompt\_get\_place\_proc\_ids}'' & \code{ompt\_get\_place\_proc\_ids\_t}\\
``\code{ompt\_get\_place\_num}'' & \code{ompt\_get\_place\_num\_t}\\
``\code{ompt\_get\_partition\_place\_nums}'' & \code{ompt\_get\_partition\_place\_nums\_t}\\
``\code{ompt\_get\_proc\_id}'' & \code{ompt\_get\_proc\_id\_t}\\
``\code{ompt\_get\_state}'' & \code{ompt\_get\_state\_t}\\
``\code{ompt\_get\_parallel\_info}'' & \code{ompt\_get\_parallel\_info\_t}\\
``\code{ompt\_get\_task\_info}'' & \code{ompt\_get\_task\_info\_t}\\
``\code{ompt\_get\_num\_devices}'' & \code{ompt\_get\_num\_devices\_t}\\
``\code{ompt\_get\_target\_info}'' & \code{ompt\_get\_target\_info\_t}\\\hline
% ``\code{ompt\_callback\_device\_initialize}'' & \code{ompt\_callback\_device\_initialize\_t}\\\hline
\end{tabular}
\vskip 1ex
\caption{OMPT callback interface runtime entry point names and their type signatures.}
\label{table:ompt-callback-interface-functions} 
\end{table}

\crossreferences
\begin{itemize}
\item \code{ompt\_enumerate\_states\_t}, see \specref{sec:ompt_enumerate_states_t}.
\item \code{ompt\_enumerate\_mutex\_impls\_t}, see  \specref{sec:ompt_enumerate_mutex_impls_t}.
\item \code{ompt\_callback\_set\_t}, see \specref{sec:ompt_callback_set_t}.
\item \code{ompt\_callback\_get\_t}, see \specref{sec:ompt_callback_get_t}.
\item \code{ompt\_get\_thread\_data\_t}, see \specref{sec:ompt_get_thread_data_t}.
\item \code{ompt\_get\_num\_places\_t}, see \specref{sec:ompt_get_num_places_t}.
\item \code{ompt\_get\_place\_proc\_ids\_t}, see \specref{sec:ompt_get_place_proc_ids_t}.
\item \code{ompt\_get\_place\_num\_t}, see \specref{sec:ompt_get_place_num_t}.
\item \code{ompt\_get\_partition\_place\_nums\_t}, see \specref{sec:ompt_get_partition_place_nums_t}.
\item \code{ompt\_get\_procid\_t}, see \specref{sec:ompt_get_proc_id_t}.
\item \code{ompt\_get\_state\_t}, see \specref{sec:ompt_get_state_t}.
\item \code{ompt\_get\_parallel\_info\_t}, see \specref{sec:ompt_get_parallel_info_t}.
\item \code{ompt\_get\_task\_info\_t}, see \specref{sec:ompt_get_task_info_t}.
\item \code{ompt\_get\_target\_info\_t}, see \specref{sec:ompt_get_target_info_t}.
\item \code{ompt\_get\_num\_devices\_t}, see \specref{sec:ompt_get_num_devices_t}.
\item \code{ompt\_function\_lookup\_t}, see \specref{sec:ompt_function_lookup_t}.
\end{itemize}

\subsection{Monitoring Activity on the Host}
\index{event callback registration}
\label{sec:ompt-register-callbacks}

To monitor execution of an OpenMP program on the host device, a tool's
initializer must register to receive notification
of events that occur as an OpenMP program executes.  
A tool can register callbacks for OpenMP events using
the runtime entry point known as 
\code{ompt\_callback\_set}.  The possible return codes for
\code{ompt\_callback\_set} and their meanings are shown in
Table~\ref{table:ToolsSupport_set_rc}.  
If the \code{ompt\_callback\_set} runtime entry point is
called outside a tool's initializer, registration of supported
callbacks may fail with a return code of \code{ompt\_set\_error}. 

All callbacks registered with \code{ompt\_callback\_set} or returned
by \code{ompt\_callback\_get} use the dummy type signature
\code{ompt\_callback\_t}.  While this is a compromise, it is better
than providing unique runtime entry points with a precise type signatures to
set and get the callback for each unique runtime entry point type signature.

Table~\ref{table:valid_rc} indicates the return codes permissible
when trying to register various callbacks. For callbacks where the only registration return code
allowed is \code{ompt\_set\_always}, an
OpenMP implementation must guarantee that the callback will be
invoked every time a runtime event associated with it occurs. Support
for such callbacks is required in a minimal implementation of the
OMPT interface. For other callbacks where registration is allowed to return values
other than \code{ompt\_set\_always}, its implementation-defined
whether an OpenMP implementation invokes a registered callback
never, sometimes, or always. If registration for a callback allows 
a return code of \code{omp\_set\_never}, support for invoking such 
a callback need not be present in a minimal implementation of the 
OMPT interface.  The return code when a callback is
registered enables a tool to know what to expect when the level
of support for the callback can be implementation defined.

\begin{comment}
Some callback registrations are associated with a singleton event; 
others are associated with event pairs. 
Callbacks for event pairs have an \plc{endpoint}
parameter that can accept values \code{ompt\_scope\_begin} or
\code{ompt\_scope\_end}. 
If an OpenMP implementation returns \code{ompt\_set\_sometimes} when registering a callback for an event pair,
the OpenMP implementation guarantees that the callback will be invoked for neither or both endpoints
of each matching event pair. 
\end{comment}

\begin{table}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{lp{3em}p{3em}p{3em}p{3em}}
                                & \rot{\code{ompt\_set\_never}}
                                & \rot{\vbox{\code{ompt\_set\_sometimes}
                                             \code{ompt\_set\_sometimes\_paired}}}
                                & \rot{\code{ompt\_set\_always}}\\
                                \midrule
\code{ompt\_callback\_thread\_begin}          &   &   & * \\
\code{ompt\_callback\_thread\_end}            &   &   & * \\
\code{ompt\_callback\_parallel\_begin}        &   &   & * \\
\code{ompt\_callback\_parallel\_end}          &   &   & * \\
\code{ompt\_callback\_task\_create}           &   &   & * \\
\code{ompt\_callback\_task\_schedule}         &   &   & * \\
\code{ompt\_callback\_implicit\_task}         &   &   & * \\
\code{ompt\_callback\_target}                 &   &   & * \\
\code{ompt\_callback\_target\_data\_op}       &   &   & * \\
\code{ompt\_callback\_target\_submit}         &   &   & * \\
\code{ompt\_callback\_device\_initialize}     &   &   & * \\
\code{ompt\_callback\_control\_tool}          &   &   & * \\
\code{ompt\_callback\_idle}                   & * & * & * \\
\code{ompt\_callback\_sync\_region\_wait}     & * & * & * \\
\code{ompt\_callback\_mutex\_release}         & * & * & * \\
\code{ompt\_callback\_task\_dependences}      & * & * & * \\
\code{ompt\_callback\_task\_dependence}       & * & * & * \\
\code{ompt\_callback\_work}                   & * & * & * \\
\code{ompt\_callback\_master}                 & * & * & * \\
\code{ompt\_callback\_target\_map}            & * & * & * \\
\code{ompt\_callback\_sync\_region}           & * & * & * \\
\code{ompt\_callback\_lock\_init}             & * & * & * \\
\code{ompt\_callback\_lock\_destroy}          & * & * & * \\
\code{ompt\_callback\_mutex\_acquire}         & * & * & * \\
\code{ompt\_callback\_mutex\_acquired}        & * & * & * \\
\code{ompt\_callback\_nest\_lock}             & * & * & * \\
\code{ompt\_callback\_flush}                  & * & * & * \\
\code{ompt\_callback\_cancel}                 & * & * & * \\
\bottomrule
\end{tabular}
\vskip 1ex
\caption{Valid return codes of \code{ompt\_callback\_set} for each callback.}
\label{table:valid_rc}
\end{table}

To avoid a tool interface specification that enables a tool to
register unique callbacks for an overwhelming number of events,
the interface was collapsed in several ways.
First, in cases where events are naturally paired, e.g., the beginning and
end of a region, and the arguments needed by the callback at each
endpoint were identical, the pair of events was collapsed so that a
a tool registers a single callback that will be invoked at both endpoints
with \code{ompt\_scope\_begin} or \code{ompt\_scope\_end} provided
as an argument to identify which endpoint the callback invocation reflects.
Second, when a whole class of events is amenable to uniform treatment, only a
single callback is provided for a family of events, e.g.,  a
\code{ompt\_callback\_sync\_region\_wait} callback is used for multiple
kinds of synchronization regions, i.e., barrier, taskwait, and taskgroup
regions. Some events involve both kinds of collapsing: the aforementioned
\code{ompt\_callback\_sync\_region\_wait} represents
a callback that will be invoked at each endpoint for different kinds
of synchronization regions.


\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_set\_t}, see \specref{sec:ompt_callback_set_t}.
\item \code{ompt\_callback\_get\_t}, see \specref{sec:ompt_callback_get_t}.
\end{itemize}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_callbacks\_t} enumeration type, see
\specref{sec:ompt_callbacks_t}.
\item \code{ompt\_callback\_set\_t} type signature, see \specref{sec:ompt_callback_set_t}
\item \code{ompt\_callback\_t} type signature, see \specref{sec:ompt_callback_t}.

\item \code{ompt\_callback\_thread\_begin\_t}, see \specref{sec:ompt_callback_thread_begin}. 
\item \code{ompt\_callback\_thread\_end}, see \specref{sec:ompt_callback_thread_end}. 
\item \code{ompt\_callback\_parallel\_begin}, see \specref
\item \code{ompt\_callback\_parallel\_end}, see \specrefdependences
\item \code{ompt\_callback\_task\_create}, see \specref
\item \code{ompt\_callback\_task\_schedule}, see \specref
\item \code{ompt\_callback\_implicit\_task}, see \specref
\item \code{ompt\_callback\_target}, see \specref
\item \code{ompt\_callback\_target\_data}, see \specref
\item \code{ompt\_callback\_target\_submit}, see \specref
\item \code{ompt\_callback\_device\_initialize}, see \specref{sec:Device Constructs}.
\item \code{ompt\_callback\_control\_tool}, see \specref
\item \code{ompt\_callback\_idle}, see \specref{sec:ompt_callback_idle}. 
\item \code{ompt\_callback\_sync\_region\_wait}, see \specref
\item \code{ompt\_callback\_mutex\_release}, see \specref
\item \code{ompt\_callback\_task\_dependences}, see \specref
\item \code{ompt\_callback\_task\_dependence}, see \specref
\item \code{ompt\_callback\_worksharing}, see \specref
\item \code{ompt\_callback\_master}, see \specref
\item \code{ompt\_callback\_target\_data\_map}, see \specref
\item \code{ompt\_callback\_sync\_region}, see \specref
\item \code{ompt\_callback\_init\_lock}, see \specref
\item \code{ompt\_callback\_destroy\_lock}, see \specref
\item \code{ompt\_callback\_mutex\_acquire}, see \specref
\item \code{ompt\_callback\_mutex\_acquired}, see \specref
\item \code{ompt\_callback\_nest\_lock}, see ...
\item \code{ompt\_callback\_flush}, see \specref{subsec:flush Construct}.
\item \code{ompt\_callback\_cancel}, see \specref{sec:Cancellation Constructs}.
\end{itemize}
\end{comment}


\subsection{Tracing Activity on Target Devices}
\index{tracing device activity}
\label{sec:tracing-device-activity}

A target device may or may not initialize a full OpenMP runtime system.
Unless it does, it may not be possible to monitor activity 
on a device using a tool interface based on callbacks.
To accommodate such cases, the OMPT interface defines 
a performance monitoring interface for tracing activity on target
devices. Tracing activity on a target device involves the following
steps:

\begin{itemize}
\item To prepare to trace activity on a target device, when a tool
  initializer executes, it must register a tool 
  \code{ompt\_callback\_device\_initialize} callback.
\item When an OpenMP implementation initializes a target device, the
  OpenMP implementation will dispatch the tool's device initialization
  callback on the host device. If the OpenMP implementation or target device does not support tracing, 
  the OpenMP implementation will pass a \code{NULL} to the tool's device initializer for its
  \plc{lookup} argument; otherwise, the OpenMP implementation will pass 
  a pointer to a device-specific runtime entry point with type 
  signature \code{ompt\_function\_lookup\_t} to the tool's device initializer. 
\item If the device initializer for the tool receives a
  non-\code{NULL} \plc{lookup} pointer, the tool may use it to query
  which runtime entry points in the tracing interface are available for a target device
  and bind the function pointers returned to tool variables.
  Table~\ref{table:ompt-tracing-interface-functions} indicates the
  names of the runtime entry points that a target device may provide for use
  by a tool.  
  Implementations
can provide additional, implementation specific names and corresponding
entry points as long as they don't use names that start with the prefix
``\code{ompt\_}''. Theses are reserved for future extensions in the 
OpenMP specification.

  If \plc{lookup} is non-\code{NULL}, the driver for a device will
  provide runtime entry points that enable a tool to control the device's
  interface for collecting traces in its \emph{native} trace format,
  which may be device specific.  
  The kinds of trace records available for a device will typically be
  implementation-defined.
  Some devices may also allow a tool to
  collect traces of records in a standard format known as OMPT format,
  described in this document. If so, the \plc{lookup} function will
  return values for the runtime entry points 
  \code{ompt\_set\_trace\_ompt} and \code{ompt\_buffer\_get\_record\_ompt}, which support
  collecting and decoding OMPT traces. 
  These runtime entry points are not required for all devices and will only be available for target devices that support 
  collection of standard traces in OMPT format.
  For some devices, their native
  tracing format may be OMPT format. In that case, tracing can be
  controlled using either the runtime entry points for native or OMPT
  tracing.

\begin{table}
{\small
\begin{tabular}{ll}\hline
Entry Point String Name & Type Signature\\\hline\hline
``\code{ompt\_get\_device\_time}'' & \code{ompt\_get\_device\_time\_t}\\
``\code{ompt\_translate\_time}'' & \code{ompt\_translate\_time\_t}\\
``\code{ompt\_set\_trace\_ompt}'' & \code{ompt\_set\_trace\_ompt\_t}\\
``\code{ompt\_set\_trace\_native}'' & \code{ompt\_set\_trace\_native\_t}\\
``\code{ompt\_start\_trace}'' & \code{ompt\_start\_trace\_t}\\
``\code{ompt\_pause\_trace}'' & \code{ompt\_pause\_trace\_t}\\
``\code{ompt\_stop\_trace}'' & \code{ompt\_stop\_trace\_t}\\
``\code{ompt\_advance\_buffer\_cursor}'' & \code{ompt\_advance\_buffer\_cursor\_t}\\
``\code{ompt\_buffer\_get\_record\_type}'' & \code{ompt\_buffer\_get\_record\_type\_t}\\
``\code{ompt\_buffer\_get\_record\_ompt}'' & \code{ompt\_buffer\_get\_record\_ompt\_t}\\
``\code{ompt\_buffer\_get\_record\_native}'' & \code{ompt\_buffer\_get\_record\_native\_t}\\
``\code{ompt\_buffer\_get\_record\_native\_abstract}'' & \code{ompt\_buffer\_get\_record\_native\_abstract\_t}\\\hline
\end{tabular}
}
\vskip 1ex
\caption{OMPT tracing interface runtime entry point names and their type signatures.}
\label{table:ompt-tracing-interface-functions} 
\end{table}


\item The tool will use the \code{ompt\_set\_trace\_native}
  and/or the \code{ompt\_set\_trace\_ompt} runtime entry point to specify what
  types of events or activities to monitor on the target device.
\item The tool will initiate tracing on the target device by 
  invoking \code{ompt\_start\_trace}. Arguments to \code{ompt\_start\_trace}
  include two tool callbacks for use by the OpenMP implementation to manage
  traces associated with the target device: one to allocate
  a buffer where the target device can deposit trace events and a
  second to process a buffer of trace events from the target device. 
\item When the target device needs a trace buffer, the OpenMP implementation 
  will invoke the tool-supplied callback function on the host device to request a new buffer.
\item The OpenMP implementation will monitor execution of OpenMP constructs on the target device as
  directed and record a trace of events or activities into a trace
  buffer. If the device is capable, device trace records will be
  marked with a \plc{host\_op\_id}---an identifier used to associate
  device activities with the target operation initiated on the host
  that caused these activities.  To correlate activities on the host
  with activities on a device, a tool can register a
  \code{ompt\_callback\_target\_submit} callback. 
  Before the host initiates each distinct activity associated with a structured block for a \code{target} construct
  on a target device, the OpenMP implementation will dispatch the \code{ompt\_callback\_target\_submit} callback
  on the host in the thread executing the task that encounters the \code{target} construct. 
  Examples of activities that could cause an \code{ompt\_callback\_target\_submit} callback to be dispatched
  include an explicit data copy between a host and target device or execution of a computation.
  The callback provides the tool with a pair of identifiers: one that identifies the target region and a second
  that uniquely identifies an activity associated with that region.  
  These identifiers help the tool correlate activities on the target device with their target region.
\item When appropriate, e.g., when a trace buffer fills or needs to be
  flushed, the OpenMP implementation will invoke the tool-supplied buffer
  completion callback to process a non-empty sequence of
  records in a trace buffer associated with the target device.

\item The tool-supplied buffer completion callback may return
  immediately, ignoring records in the trace buffer, or it may iterate
  through them using the \code{ompt\_advance\_buffer\_cursor} entry
  point
  and inspect each one. A tool may inspect the type of the record at
  the current cursor position using the \code{ompt\_get\_record\_type}
  runtime entry point.  A tool may choose to inspect the contents of some or
  all records in a trace buffer using the \code{ompt\_get\_record\_ompt},
  \code{ompt\_get\_record\_native}, or
  \code{ompt\_get\_record\_native\_abstract} runtime entry point.  Presumably, a tool that
  chooses to use the \code{ompt\_get\_record\_native} runtime entry point to
  inspect records will have some knowledge about a device's native
  trace format.  A tool may always use the
  \code{ompt\_get\_record\_native\_abstract} runtime entry point to inspect a trace
  record; this runtime entry point will decode the contents of a native trace
  and summarize them in a standard format, namely, a
  \code{ompt\_record\_native\_abstract\_t} record.
  Only a record in OMPT format can be retrieved using the
  \code{ompt\_get\_record\_ompt} runtime entry point.
\item Once tracing has been started on a device, a tool may pause or resume
  tracing on the device at any time by invoking
  \code{ompt\_pause\_trace} with an appropriate flag value as an
  argument.  
\item A tool may start or stop tracing on a device at any time using the 
  \code{ompt\_start\_trace} or \code{ompt\_stop\_trace} runtime entry points,
  respectively. When tracing is stopped on a device, the OpenMP implementatin will eventually 
  gather all trace records already collected on the device and present to the tool using
  the buffer completion callback provided by the tool.
\item It is legal to shut down the OpenMP implementation while device tracing 
is in progress.  
\item When the OpenMP implementation is shut down, any device tracing in progress will be
  stopped and all trace records collected on each device will be flushed.
  For each target device, the OpenMP implementation will present the tool 
  with the trace records for the device using the buffer completion callback 
  associated with that device.
\end{itemize}


\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_device\_initialize\_t}, see \specref{sec:ompt_callback_device_initialize_t}.
\item \code{ompt\_get\_device\_time}, see \specref{sec:ompt_get_device_time_t}.
\item \code{ompt\_translate\_time}, see \specref{sec:ompt_translate_time_t}.
\item\code{ompt\_set\_trace\_ompt}, see \specref{sec:ompt_set_trace_ompt_t}.
\item \code{ompt\_set\_trace\_native}, see \specref{sec:ompt_set_trace_native_t}.
\item \code{ompt\_start\_trace}, see \specref{sec:ompt_start_trace_t}.
\item \code{ompt\_pause\_trace}, see \specref{sec:ompt_pause_trace_t}.
\item \code{ompt\_stop\_trace}, see \specref{sec:ompt_stop_trace_t}.
\item \code{ompt\_advance\_buffer\_cursor}, see \specref{sec:ompt_advance_buffer_cursor_t}.
\item \code{ompt\_buffer\_get\_record\_type}, see \specref{sec:ompt_buffer_get_record_type_t}.
\item \code{ompt\_buffer\_get\_record\_ompt}, see \specref{sec:ompt_buffer_get_record_ompt_t}.
\item \code{ompt\_buffer\_get\_record\_native}, see \specref{sec:ompt_buffer_get_record_native_t}.
\item \code{ompt\_buffer\_get\_record\_native\_abstract}, see \specref{sec:ompt_buffer_get_record_native_abstract_t}.
\end{itemize}


\section{Finalizing a Tool}
\label{sec:ompt-finalization}

If \code{ompt\_start\_tool} returned a non-\code{NULL} pointer when an OpenMP
implementation was initialized, the tool finalizer, of type signature 
\code{ompt\_finalize\_t}, specified by the
\plc{finalize} field in this structure will be called as the OpenMP
implementation shuts down.

\crossreferences
\begin{itemize}
\item \code{ompt\_finalize\_t}, \specref{sec:ompt_finalize_t}
\end{itemize}

\section{Data Types}
\label{sec:ompt-data-types}

\subsection{Tool Initialization and Finalization}
\label{sec:ompt_fns_t}

\summary
A tool's implementation of \code{ompt\_start\_tool} returns a pointer to an
\code{ompt\_fns\_t} structure that contains pointers to the tool's 
initializer and finalizer functions.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_fns_t \{
  ompt_initialize_t \plc{initialize};
  ompt_finalize_t \plc{finalize};
\} ompt_fns_t;
\end{boxedcode}
\ccppspecificend
}

\restrictions

Both the \plc{initialize} and \plc{finalize} function pointers in an
\code{ompt\_fns\_t} structure returned by \code{ompt\_start\_tool} must be
non-\code{NULL}.

\crossreferences
\begin{itemize}
\item \code{ompt\_start\_tool}, see \specref{sec:ompt_start_tool}.
\end{itemize}


\subsection{Thread States}
\label{sec:thread-states}

To enable a tool to understand the behavior of an executing program, 
an OpenMP implementation maintains a state for each thread. 
The state maintained for a thread is an
approximation of the thread's instantaneous state. 

\vbox{
\ccppspecificstart
A thread's state will be one of the values of the  
enumeration type \code{omp\_state\_t} or
an implementation-defined state value of 512 or higher. 
Thread states in the enumeration fall into several classes: 
work, barrier wait, task wait, mutex wait, target wait, 
and miscellaneous. 

\begin{boxedcode}
typedef enum omp_state_e \{
  omp_state_work_serial                      = 0x000,
  omp_state_work_parallel                    = 0x001,
  omp_state_work_reduction                   = 0x002,

  omp_state_wait_barrier                     = 0x010,
  omp_state_wait_barrier_implicit_parallel   = 0x011,
  omp_state_wait_barrier_implicit_workshare  = 0x012,
  omp_state_wait_barrier_implicit            = 0x013,
  omp_state_wait_barrier_explicit            = 0x014,

  omp_state_wait_taskwait                    = 0x020,
  omp_state_wait_taskgroup                   = 0x021,

  omp_state_wait_mutex                       = 0x040,
  omp_state_wait_lock                        = 0x041,
  omp_state_wait_critical                    = 0x042,
  omp_state_wait_atomic                      = 0x043,
  omp_state_wait_ordered                     = 0x044,

  omp_state_wait_target                      = 0x080,
  omp_state_wait_target_map                  = 0x081,
  omp_state_wait_target_update               = 0x082,

  omp_state_idle                             = 0x100, 
  omp_state_overhead                         = 0x101, 
  omp_state_undefined                        = 0x102
\} omp_state_t;
\end{boxedcode}
\ccppspecificend
}


A tool can query the OpenMP state of a thread at any time. 
If a tool queries the state of a thread that is not associated 
with OpenMP, the implementation reports the state as \code{omp\_state\_undefined}.

\begin{comment}
For each OpenMP thread the runtime maintains not only a state but also an \code{ompt\_wait\_id\_t}
identifier.  When a thread is waiting for a lock, critical region,
ordered, or atomic, and the thread is in a wait
state, then 
the thread's \code{wait\_id} field identifies the lock, critical construct, ordered construct, atomic construct, or internal variable
upon which the
thread is waiting. The semantics of the values used for a \code{wait\_id} are implementation defined.
A thread's \code{wait\_id} is undefined if the thread
is not in a wait state.
\end{comment}

Some values of the enumeration type \code{omp\_state\_t} are used by all 
OpenMP implementations, 
e.g., \code{omp\_state\_work\_serial}, 
which indicates that a thread is executing in a serial region, and  
\code{omp\_state\_work\_parallel}, 
which indicates that a thread is executing in a parallel region.
Other values of the enumeration type describe a thread's state at 
different levels of specificity. 
For instance, an OpenMP implementation may use 
the state \code{omp\_state\_wait\_barrier}  to represent all 
waiting at barriers. It may differentiate between waiting at implicit or explicit barriers using
\code{omp\_state\_wait\_barrier\_implicit} and \code{omp\_state\_wait\_barrier\_explicit}. 
To provide full detail about the type of an implicit barrier, a runtime may report either
\code{omp\_state\_wait\_barrier\_implicit\_parallel} or 
\code{omp\_state\_wait\_barrier\_implicit\_workshare}.
As explained in \specref{sec:ompt_callback_sync_region_t},
reporting the state \code{omp\_state\_wait\_barrier\_implicit\_parallel} 
permits a weaker contract between a runtime and a tool that 
enables a simpler and faster implementation of parallel regions.

For states that represent waiting, an OpenMP implementation has the 
choice of transitioning a thread to such states early or late.
For instance, when an OpenMP thread is trying to acquire a lock,
there are several points at which an OpenMP implementation
transition the thread to the \code{omp\_state\_wait\_lock} state.
One implementation may transition the thread to the state 
early before the thread attempts to acquire a
lock. Another implementation may transition the thread to the state 
late, only if the thread begins to spin or
block to wait for an unavailable lock. A third implementation
may transition the thread to the state even later, e.g., only
after the thread waits for a significant amount of time. 

The following sections describe the classes of states and the states in each class.
\subsubsection{Work States}
An OpenMP implementation reports a thread in a work state 
when the thread is performing serial work, parallel work, or a reduction.

\begin{description}

\item \code{omp\_state\_work\_serial} 

  The thread is executing code outside all parallel regions. 

\item \code{omp\_state\_work\_parallel} 

  The thread is executing code within the scope of a parallel region construct.

\sloppy
\item \code{omp\_state\_work\_reduction} 
 
  The thread is combining partial reduction results from threads in its team. 
  An OpenMP implementation  
  might never report a thread in this state; a thread
  combining partial reduction results may have its state reported as
  \code{omp\_state\_work\_parallel} or \code{omp\_state\_overhead}.

\end{description}


\subsubsection{Barrier Wait States}

An OpenMP implementation reports that a thread is in a barrier wait state 
when the thread is is awaiting completion of a barrier.


\begin{description}

  \item \code{omp\_state\_wait\_barrier} 
  
  \sloppy
  The thread is waiting at either an implicit or explicit barrier.
  A thread may enter this state
  early, when the thread encounters a barrier, or late, when the
  thread begins to wait at the barrier. An implementation may never report a thread in this state; instead, a thread may have its state reported
  as \code{omp\_state\_wait\_barrier\_implicit}  or \code{omp\_state\_wait\_barrier\_explicit}, as appropriate.
  
  \item \code{omp\_state\_wait\_barrier\_implicit} 
  
  \sloppy
  The thread is waiting at an implicit barrier in a parallel region. 
  A  thread may enter this state
  early, when the thread encounters a barrier, or late, when the
  thread begins to wait at the barrier.
  An OpenMP implementation may report \code{omp\_state\_wait\_barrier} 
  for implicit barriers.
  
  \item \code{omp\_state\_wait\_barrier\_explicit} 

  The thread is waiting at an explicit barrier  in a parallel region. 
  A thread may enter this state
  early, when the thread encounters a barrier, or late, when the
  thread begins to wait at the barrier.
  An implementation may report \code{omp\_state\_wait\_barrier} 
  for explicit barriers.
  
\end{description}
  
\subsubsection{Task Wait States}

\begin{description}

\item \code{omp\_state\_wait\_taskwait} 

  The thread is waiting at a taskwait construct. A 
  thread may enter this state early, when the
  thread encounters a taskwait construct, or late, when the thread
  begins to wait for an uncompleted task.

\item \code{omp\_state\_wait\_taskgroup} 

  The thread is waiting at the end of a taskgroup construct. A 
  thread may enter this state early, when the
  thread encounters the end of a taskgroup construct, or late, when the thread
  begins to wait for an uncompleted task.

\end{description}


\subsubsection{Mutex Wait States}

OpenMP provides several mechanisms that enforce mutual exclusion:
locks as well as critical, atomic, and ordered sections.  This
grouping contains all states used to indicate that a thread is is
awaiting exclusive access to a lock, critical section, variable,
or ordered section.

An OpenMP implementation may report a thread waiting for any type
of mutual exclusion using either a state that precisely identifies
the type of mutual exclusion, or  a more generic state such as
\code{omp\_state\_wait\_mutex} or \code{omp\_state\_wait\_lock}.  This
flexibility may significantly simplify the maintenance of states
associated with mutual exclusion in the runtime when various
mechanisms for mutual exclusion rely on a common implementation,
e.g., locks.

% Section~\ref{sec:wait-identifier} describes how each thread maintains a wait identifier to identify what a thread is awaiting. Before a thread enters any state indicating that it is awaiting mutual exclusion, the OpenMP runtime will update the thread's wait identifier to indicate what the thread is awaiting. 

\begin{description}

\item \code{omp\_state\_wait\_mutex}

  The thread is waiting for a mutex of an unspecified type. A 
  thread may enter this state early, when a thread encounters a lock acquisition or a region that requires mutual exclusion, or late, when the thread begins to wait.

\item \code{omp\_state\_wait\_lock}

  The thread is waiting for a  lock  or nest lock. A 
  thread may enter this state early, when a thread
  encounters a lock \code{set} routine, or late, when the thread
  begins to wait for a lock.

\item \code{omp\_state\_wait\_critical} 

  The thread is waiting to enter a critical region. A 
  thread may enter this state early, when the
  thread encounters a critical construct, or late, when the thread
  begins to wait to enter the critical region. 


\item \code{omp\_state\_wait\_atomic} 

  The thread is waiting to enter an atomic region. A 
  thread may enter this state early, when the thread
  encounters an atomic construct, or late, when the thread begins
  to wait to enter the atomic region. 
  An implementation may opt not to report
  this state when using atomic hardware instructions that support non-blocking atomic implementations.
  

\item \code{omp\_state\_wait\_ordered} 

  The thread is waiting to enter an ordered region. A 
  thread may enter this state early, when the thread encounters
  an ordered construct, or late, when the thread begins
  to wait to enter the ordered region. 
  
\end{description}
  
\subsubsection{Target Wait States}

\begin{description}

\item \code{omp\_state\_wait\_target} 

  The thread is waiting for a target region to complete.
  
\item \code{omp\_state\_wait\_target\_map} 

  The thread is waiting for a target data mapping operation to complete. 
  An implementation may report \code{omp\_state\_wait\_target} 
  for target data constructs.

\item \code{omp\_state\_wait\_target\_update} 

  The thread is waiting for a target  update operation to complete. 
  An implementation may report \code{omp\_state\_wait\_target} 
  for target update constructs.

\end{description}


\subsubsection{Miscellaneous States}

\begin{description}
\item \code{omp\_state\_idle} 

  The thread is idle, waiting for work.

\item \code{omp\_state\_overhead} 

  A thread may be reported as being in the overhead state at any point while 
  executing within an OpenMP runtime, except while waiting indefinitely
  at a synchronization point.
%  e.g., while preparing to execute a parallel, task, or worksharing construct. 
  An OpenMP implementation report a thread's state as a work state for
  some or all of the time the thread spends in executing in the OpenMP runtime.

\item \code{omp\_state\_undefined} 

  This state is reserved for threads that are not user threads,
  initial threads, threads currently in an OpenMP team, or threads
  waiting to become part of an OpenMP team.

\end{description}

\subsection{Events}
\label{sec:ompt_callbacks_t}

The following enumeration type indicates the integer codes used to identify 
OpenMP events when registering or querying callbacks associated with them.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_callbacks_e \{
  ompt_callback_thread_begin             = 1,
  ompt_callback_thread_end               = 2,
  ompt_callback_parallel_begin           = 3,
  ompt_callback_parallel_end             = 4,
  ompt_callback_task_create              = 5,
  ompt_callback_task_schedule            = 6,
  ompt_callback_implicit_task            = 7,
  ompt_callback_target                   = 8,
  ompt_callback_target_data_op           = 9,
  ompt_callback_target_submit            = 10,
  ompt_callback_control_tool             = 11,
  ompt_callback_idle                     = 12,
  ompt_callback_sync_region_wait         = 13,
  ompt_callback_mutex_release            = 14,
  ompt_callback_task_dependences         = 15,
  ompt_callback_task_dependence          = 16,
  ompt_callback_work                     = 17,
  ompt_callback_master                   = 18,
  ompt_callback_target_map               = 19,
  ompt_callback_sync_region              = 20,
  ompt_callback_lock_init                = 21,
  ompt_callback_lock_destroy             = 22,
  ompt_callback_mutex_acquire            = 23,
  ompt_callback_mutex_acquired           = 24,
  ompt_callback_nest_lock                = 25,
  ompt_callback_flush                    = 26,
  ompt_callback_device_initialize        = 27,
  ompt_callback_cancel                   = 28
\} ompt_callbacks_t;
\end{boxedcode}
\ccppspecificend
}


%\subsubsection{Triggers for Miscellaneous Events}
%Most events trigger during the execution of OpenMP directives. Other
%events trigger when an application calls certain runtime library
%routines, e.g., those for setting and unsetting locks.
%This section describes events triggered during initialization and
%finialization of an OpenMP implementation. 
%
%\ompteventswithoutdirectives{\code{ompt\_callback\_thread\_begin}}
%\label{sec:ompt_callback_thread_begin}
%
%An OpenMP implementation invokes this callback in the context of an
%initial thread just after it initializes the runtime, or in the
%context of a new thread created by the runtime just after the thread
%initializes itself. In either case, this callback must be the first
%callback for a thread and must occur before the thread executes any
%OpenMP tasks. This callback has type signature
%\code{ompt\_callback\_thread\_begin\_t}.  The callback argument
%\code{thread\_type} indicates the type of the thread: initial, worker,
%or other.
%
%\ompteventswithoutdirectives{\code{ompt\_callback\_thread\_end}}
%\label{sec:ompt_callback_thread_end}
%
%An OpenMP implementation invokes this callback after an OpenMP thread
%completes all of its tasks but before the thread is destroyed. The
%callback executes in the context of the OpenMP thread. This callback
%must be the last callback event for any worker thread; it is optional
%for other types of threads.  This callback has type signature
%\code{ompt\_callback\_thread\_end\_t}.
%
%\ompteventswithoutdirectives{\code{ompt\_callback\_idle}}
%\label{sec:ompt_callback_idle}
%
%An OpenMP implementation invokes this callback with
%\code{endpoint=}\code{ompt\_scope\_begin} when a thread waits for work
%outside a parallel region.  The OpenMP runtime invokes this callback
%with \code{endpoint=}\code{ompt\_scope\_end} before the thread begins
%to execute an implicit task for a parallel region or terminates. The
%callback executes in the environment of the waiting thread.  This
%callback has type signature \code{ompt\_callback\_idle\_t}.
%
%\ompteventswithoutdirectives{\code{ompt\_callback\_sync\_region\_wait}}
%\label{sec:ompt_callback_sync_region_wait}
%
%If the \code{ompt\_callback\_sync\_region\_wait} callback is registered,
%an OpenMP implementation will invoke this callback when a task starts
%and stops waiting in a barrier region, taskwait region, or taskgroup
%region.  This callback has type signature
%\code{ompt\_callback\_sync\_region\_t}.  One region may generate
%multiple pairs of start/stop callbacks if another task is scheduled on
%the thread while the task awaiting completion of the region is
%stalled.  This callback executes in the context of the task that
%encountered the barrier, taskwait, or taskgroup construct.
%
%\ompteventswithoutdirectives{\code{ompt\_callback\_runtime\_shutdown}}
%\label{sec:ompt_callback_runtime_shutdown}
%
%An OpenMP implementation invokes this callback before it shuts down
%the runtime system.  This callback enables a tool to clean up its
%state and record or report information gathered. A runtime may later
%restart and reinitialize the tool by calling the tool initializer
%function (described in Section~\ref{sec:tool-initialize}) again.  This
%callback has type signature \code{ompt\_callback\_t}.


\subsection{Frames}
\index{frames}
\label{sec:ompt_frame_t}

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_frame_s \{\\
  void *\plc{exit_frame};
  void *\plc{enter_frame};
\} ompt_frame_t;
\end{boxedcode}
\ccppspecificend
}

\descr

When executing an OpenMP program, at times, one or more procedure frames associated with
the OpenMP runtime may appear on a thread's stack between frames
associated with tasks. To help a tool determine whether a procedure
frame on the call stack belongs to a task or not,
for each task whose frames appear on the stack, the runtime
maintains an \code{ompt\_frame\_t} object 
that indicates a contiguous sequence of 
procedure frames associated with the task.
Each \code{ompt\_frame\_t} object is associated with the task to which the procedure frames belong.
Each non-merged initial, implicit, explicit, or target task with one or more frames on a thread's stack
will have an associated \code{ompt\_frame\_t} object.

\begin{comment}
The OpenMP API will maintain an
instance of an \code{ompt\_frame\_t} for each 
degenerate task as well. 
To simplify the following discussion, we omit the
qualifier ``possibly degenerate'' each time we use the term {\em
task}.
\end{comment}

An \code{ompt\_frame\_t} object associated with a task contains a pair
of pointers: \plc{exit\_frame} and \plc{enter\_frame}. The field names were
chosen, respectively, to reflect that they typically contain a pointer to a procedure frame on the stack when 
\emph{exiting} the OpenMP runtime into code for a task or \emph{entering} the OpenMP runtime from a task.

The \plc{exit\_frame} field of a task's \code{ompt\_frame\_t} object 
contains the canonical frame address for the procedure frame that
transfers control to the structured block for the task. 
The value of \plc{exit\_frame} is \code{NULL} until just prior to
beginning execution of the structured block for the task.
A task's \plc{exit\_frame} may point to a procedure frame that belongs
to the OpenMP runtime or one that belongs to another task.
The \plc{exit\_frame} for the \code{ompt\_frame\_t} object associated 
with an \emph{initial task} is \code{NULL}.

The \plc{enter\_frame} field of a task's \code{ompt\_frame\_t} object 
contains the canonical frame address of a task procedure frame that invoked the
OpenMP runtime causing the current task to suspend and another task to
execute.
If a task with frames on the stack has not suspended, the value of
\plc{enter\_frame} for the \code{ompt\_frame\_t} object 
associated with the task may contain \code{NULL}. 
The value of \plc{enter\_frame} in a task's \code{ompt\_frame\_t} is
reset to \code{NULL} just before a suspended task resumes execution.

An \code{ompt\_frame\_t}'s lifetime begins when a task is created
and ends when the task is destroyed. Tools should not assume that
a frame structure remains at a constant location in memory throughout
a task's lifetime. A pointer to a task's \code{ompt\_frame\_t} object is passed to
some callbacks; a pointer to a task's \code{ompt\_frame\_t} object 
can also be retrieved by a tool at any time, including in a signal
handler, by invoking the
\code{ompt\_get\_task\_info} runtime entry point (described in
Section~\ref{sec:ompt_get_task_info}).

\begin{comment}
The value of \plc{exit\_frame} is \code{NULL} in a task's frame
object until just before a procedure associated with the task is invoked.
When a procedure associated with a task is invoked,
\plc{exit\_frame} is set to the canonical frame
address of the procedure frame that
executes immediately before the structured block of the task.
\end{comment}

\begin{comment}
The \plc{enter\_frame} field of a task's frame object is set each time the task re-enters the
runtime to create a new implicit, explicit, or target 
task. When a task invokes the OpenMP runtime 
to create a task,
\plc{enter\_frame} of the task's frame object will be set to
the canonical frame address of the user function that invoked the runtime.
The value of \plc{enter\_frame} is set to \code{NULL} when a task
resumes execution.
\end{comment}

\begin{table}
\begin{center}
\begin{tabular}{|p{1in}||p{2in}|p{2in}|}
\hline
\plc{exit\_frame} / \plc{enter\_frame} 	state & \plc{enter\_frame} is
\code{NULL}
& \plc{enter\_frame} is non-\code{NULL} \\
\hline
\hline
\plc{exit\_frame} is \code{NULL} & 
case 1)  initial task during execution\newline 
case 2) task that is created but not yet scheduled or already finished & 
initial task suspended while another task executes
\\\hline
\plc{exit\_frame} is non-\code{NULL} 	& non-initial task that has
been scheduled &
non-initial task 
suspended while another task executes
\\\hline
\end{tabular}
\vspace{1ex}
\end{center}
\caption{Meaning of various states of an \code{ompt\_frame\_t}
  object.}
\label{tab:frame}
\end{table}

Table~\ref{tab:frame} describes various states in which 
an \code{ompt\_frame\_t} object may be observed and their meaning.
In the presence of nested parallelism, a tool may
observe a sequence of \code{ompt\_frame\_t} objects for a thread.
Appendix~\ref{chap:frames} illustrates 
use of \code{ompt\_frame\_t} objects with nested parallelism.

\needspace{6\baselineskip}\notestart
\noteheader -- A monitoring tool using asynchronous sampling can observe values
of \plc{exit\_frame} and \plc{enter\_frame} at inconvenient times.
Tools must be prepared to observe and handle \code{ompt\_frame\_t}
objects observed just prior to when their field values should be set or reset.
\noteend

\subsection{Tracing Support}
\label{sec:ompt-records}

\subsubsection{Record Kind}
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_record_kind_e \{
  ompt_record_ompt               = 1,
  ompt_record_native             = 2,
  ompt_record_invalid            = 3
\} ompt_record_kind_t; 
\end{boxedcode}
\ccppspecificend
}

\subsubsection{Native Record Kind}
\label{sec:ompt_record_native_kind_t}

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_record_native_kind_e \{
  ompt_record_native_info  = 1,
  ompt_record_native_event = 2
\} ompt_record_native_kind_t;
\end{boxedcode}
\ccppspecificend
}

\subsubsection{Native Record Abstract Type}
\label{sec:ompt_record_native_abstract_t}

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_native_abstract_s \{
  ompt_record_native_class_t \plc{rclass};
  const char *\plc{type};
  ompt_device_time_t \plc{start\_time};
  ompt_device_time_t \plc{end\_time};
  ompt_hwid_t \plc{hwid};
\} ompt_record_native_abstract_t;
\end{boxedcode}
\ccppspecificend
}

\descr

A \code{ompt\_record\_native\_abstract\_t} record contains several
pieces of information that a tool can use to process a native record
that it may not fully understand. The \plc{rclass} field
indicates whether the record is informational
or represents an event; knowing this can help a tool determine
how to present the record. The record \plc{type} field points to
a statically-allocated, immutable character string that provides
a meaningful name that a tool might want to use to describe the event
to a user. The \plc{start\_time} and \plc{end\_time} fields are
used to place an event in time. The times are relative to the device
clock. If an event has no associated \plc{start\_time} and/or
\plc{end\_time}, its value will be 
\code{ompt\_time\_none}. The hardware id field,
\plc{hwid},  is used to indicate the location on the device where
the event occurred. A \plc{hwid} may represent a hardware abstraction
such as a core or a hardware thread id. The meaning of a \plc{hwid}
value for a device is defined by the implementer of the software
stack for the device. If there is no hardware abstraction associated 
with the record, the value of \plc{hwid} 
will be \code{ompt\_hwid\_none}.

\subsubsection{Record Type}
\label{sec:ompt_record_ompt_t}
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_ompt_s \{
  ompt_callbacks_t \plc{type};
  ompt_target_time\_t \plc{time};
  ompt_id_t \plc{thread_id};
  ompt_id_t \plc{target_id};
  union \{
    ompt_record_thread_begin_t \plc{thread_begin};
    ompt_record_idle_t \plc{idle};
    ompt_record_parallel_begin_t \plc{parallel_begin};
    ompt_record_parallel_end_t \plc{parallel_end};
    ompt_record_task_create_t \plc{task_create};
    ompt_record_task_dependence_t \plc{task_dep};
    ompt_record_task_schedule_t \plc{task_sched};
    ompt_record_implicit_t \plc{implicit};
    ompt_record_sync_region_t \plc{sync_region};
    ompt_record_target_t \plc{target_record};
    ompt_record_target_data_op_t \plc{target_data_op};
    ompt_record_target_map_t \plc{target_map};
    ompt_record_target_kernel_t \plc{kernel};
    ompt_record_lock_init_t \plc{lock_init};
    ompt_record_lock_destroy_t \plc{lock_destroy};
    ompt_record_mutex_acquire_t \plc{mutex_acquire};
    ompt_record_mutex_t \plc{mutex};
    ompt_record_nest_lock_t \plc{nest_lock};
    ompt_record_master_t \plc{master};
    ompt_record_work_t \plc{work};
    ompt_record_flush_t \plc{flush};
  \} \plc{record};
\} ompt_record_ompt_t;
\end{boxedcode}
\ccppspecificend
}

\subsection{Miscellaneous Type Definitions}
\label{sec:ompt-types:misc}
This section describes miscellaneous types and enumerations used by the tool interface.

\ompttype{\code{ompt\_callback\_t}}
\label{sec:ompt_callback_t}

Pointers to tool callback functions with many different type
signatures are passed to the \code{ompt\_callback\_set} runtime entry point and 
returned by the \code{ompt\_callback\_get} runtime entry point. For convenience,
these runtime entry points expect all type signatures to be cast to   
a dummy type \code{ompt\_callback\_t}.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_t)(void);
\end{boxedcode}
\ccppspecificend
}

% ompt_id_t

\ompttype{\code{ompt\_id\_t}}
\label{sec:ompt_id_t} 
When tracing asynchronous activity on OpenMP devices, tools need identifiers to correlate target regions and operations initiated by the host with 
associated activities on a target device. In addition, tools need identifiers to refer to parallel regions and tasks that execute on a device.
OpenMP implementations use identifiers of type \code{ompt\_id\_t} type for each of these purposes. 
The value \code{ompt\_id\_none} is
reserved to indicate an invalid id.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef \ulonglongint{} ompt_id_t;
#define ompt_id_none 0
\end{boxedcode}
\ccppspecificend
}

Identifiers created on each device must be unique from the time an OpenMP implementation is initialized until it is shut down.  
Specifically, this means that (1) identifiers for each target region and target operation instance initiated by the host device must be unique over time on the host,
and (2) identifiers for parallel and task region instances that execute on a device must be unique over time within that device.

Tools should not assume that \code{ompt\_id\_t} values are small or densely allocated. 

% ompt_data_t

\ompttype{\code{ompt\_data\_t}}
\label{sec:ompt_data_t} 
Threads, parallel regions, and task regions 
each have an associated data object of type \code{ompt\_data\_t} reserved for use by a tool.
When an OpenMP implementation creates a thread or an instance of a parallel or task region, 
it will initialize its associated \code{ompt\_data\_t} object with the value \code{ompt\_data\_none}. 

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef union ompt_data_u \{\\
  \ulonglongint{} \plc{value}; 
  void *\plc{ptr};                     
\} ompt_data_t;

const ompt_data_t ompt_data_none = \{.value=0\};         
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_get\_parallel\_info}, see \specref{sec:ompt_get_parallel_info}.
\item \code{ompt\_get\_task\_info}, see \specref{sec:ompt_get_task_info}.
\item \code{ompt\_get\_thread\_data}, see \specref{sec:ompt_get_thread_data}.
\item \code{ompt\_callback\_thread\_begin\_t}, see \specref{sec:ompt_callback_thread_begin_t}.
\item \code{ompt\_callback\_thread\_begin\_t}, see \specref{sec:ompt_callback_thread_begin_t}.
\item \code{ompt\_callback\_parallel\_end\_t}, see
  \specref{sec:ompt_callback_parallel_end_t}.
\item \code{ompt\_callback\_parallel\_end\_t}, see \specref{sec:ompt_callback_parallel_end_t}.
\item \code{ompt\_callback\_task\_create\_t}, see \specref{sec:ompt_callback_task_create_t}.
\item \code{ompt\_callback\_task\_dependences\_t}, see \specref{sec:ompt_callback_task_dependences_t}.
\item \code{ompt\_callback\_task\_dependence\_t}, see \specref{sec:ompt_callback_task_dependence_t}.
\item \code{ompt\_callback\_task\_schedule\_t}, see
  \specref{sec:ompt_callback_task_schedule_t}.
\item \code{ompt\_callback\_implicit\_task\_t}, see
  \specref{sec:ompt_callback_task_implicit_task_t}.
\item \code{ompt\_callback\_task\_sync\_region}, see
  \specref{sec:ompt_callback_task_sync_region_t}.
\item \code{ompt\_callback\_task\_master\_t},
  see \specref{sec:ompt_callback_task_master_d}.
\item \code{ompt\_callback\_task\_work\_t}, see \specref{sec:ompt_callback_task_work_t}.
\item \code{ompt\_callback\_task\_target\_t}, see \specref{sec:ompt_callback_task_target_t}.
\item \code{ompt\_callback\_flush\_t}, see \specref{sec:ompt_callback_flush_t}.
\end{itemize}
\end{comment}

% ompt_wait_id_t

\ompttype{\code{ompt\_wait\_id\_t}}
\label{sec:ompt_wait_id_t} 
\index{wait identifier}

Each thread instance maintains a \emph{wait identifier} of type \code{ompt\_wait\_id\_t}.
When a task executing on a thread is waiting for mutual exclusion, the thread's wait identifer indicates what the thread is awaiting.
A wait identifier may represent a critical section {\em name}, a lock, a program variable accessed in an atomic region, or a synchronization object internal to an OpenMP implementation.
% A thread's wait identifier can be retrieved on demand by invoking the \code{ompt\_get\_state} function (described in Section~\ref{sec:ompt_get_state}).

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef \ulonglongint{} ompt_wait_id_t;
\end{boxedcode}
\ccppspecificend
}

When a thread is not in a wait state, the value of the thread's wait identifier is undefined.

% Tools should not assume that \code{ompt\_wait\_id\_t} values are small or densely allocated.

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_get\_state}, see \specref{sec:ompt_get_state}.
\item \code{ompt\_callback\_lock\_init\_t} callback type, see \specref{sec:ompt_callback_lock_init_t}.
\item \code{ompt\_callback\_lock\_destroy\_t} callback type, see \specref{sec:ompt_callback_lock_destroy_t}.
\item \code{ompt\_callback\_mutex\_acquire\_t} callback type, see \specref{sec:ompt_callback_mutex_acquire_t}.
\item \code{ompt\_callback\_mutex\_t} callback type, see \specref{sec:ompt_callback_mutex_t}.
\item \code{ompt\_callback\_nest\_lock\_t} callback type, see \specref{sec:ompt_callback_nest_lock_t}.
\item \code{ompt\_record\_lock\_init\_t} data type, see \specref{sec:ompt_record_lock_init_t}.
\item \code{ompt\_record\_lock\_destroy\_t} data type, see \specref{sec:ompt_record_lock_destroy_t}.
\item \code{ompt\_record\_mutex\_acquire\_t} data type, see \specref{sec:ompt_record_mutex_acquire_t}.
\item \code{ompt\_record\_mutex\_t} data type, see \specref{sec:ompt_record_mutex_t}.
\item \code{ompt\_record\_nest\_lock\_t} data type, see \specref{sec:ompt_record_nest_lock_t}.
\end{itemize}
\end{comment}

% ompt_device_t

\ompttype{\code{ompt\_device\_t}}
\label{sec:ompt_device_t} 
\code{ompt\_device\_t} is an opaque object representing a device.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void ompt_device_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_get\_time}, see \specref{sec:ompt_get_time}.
\item \code{ompt\_translate\_time}, see \specref{sec:ompt_translate_time}.
\item \code{ompt\_set\_trace\_ompt} tool function, see \specref{sec:ompt_set_trace_ompt}.
\item \code{ompt\_set\_trace\_native} tool function, see \specref{sec:ompt_set_trace_native}.
\item \code{ompt\_start\_trace} tool function, see \specref{sec:ompt_start_trace}.
\item \code{ompt\_pause\_trace} tool function, see \specref{sec:ompt_pause_trace}.
\item \code{ompt\_stop\_trace} tool function, see \specref{sec:ompt_stop_trace}.
\end{itemize}
\end{comment}

% ompt_device_time_t

\ompttype{\code{ompt\_device\_time\_t}}
\label{sec:ompt_device_time_t} 
\code{ompt\_device\_time\_t} is an opaque object representing a raw time value from a device.
\label{sec:ompt_time_none} 
\code{ompt\_time\_none} refers to an uknown or unspecified time.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef \ulonglongint{} ompt_device_time_t;
#define ompt_time_none 0
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_get\_device\_time}, see \specref{sec:ompt_get_device_time}.
\item \code{ompt\_translate\_time}, see \specref{sec:ompt_translate_time}.
\item \code{ompt\_record\_native\_abstract\_t} data type, see \specref{sec:ompt_record_native_abstract_t}.
\item \code{ompt\_record\_target\_data\_op\_t} data type, see \specref{sec:ompt_record_target_data_op_t}.
\item \code{ompt\_record\_target\_kernel\_t} data type, see \specref{sec:ompt_record_target_kernel_t}.
\item \code{ompt\_record\_ompt\_t} data type, see \specref{sec:ompt_record_ompt_t}.
\end{itemize}
\end{comment}

% ompt_buffer_t

\ompttype{\code{ompt\_buffer\_t}}
\label{sec:ompt_buffer_t} 
\code{ompt\_buffer\_t} is an opaque object handle for a target buffer.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void ompt_buffer_t; 
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_buffer\_request\_t} callback type, see \specref{sec:ompt_callback_buffer_request_t}.
\item \code{ompt\_callback\_buffer\_complete\_t} callback type, see \specref{sec:ompt_callback_buffer_complete_t}.
\item \code{ompt\_advance\_buffer\_cursor} tool function, see \specref{sec:ompt_advance_buffer_cursor}.
\item \code{ompt\_buffer\_get\_record\_type} tool function, see \specref{sec:ompt_buffer_get_record_type}.
\item \code{ompt\_buffer\_get\_record\_ompt} tool function, see \specref{sec:ompt_buffer_get_record_ompt}.
\item \code{ompt\_buffer\_get\_record\_correlation} tool function, see \specref{sec:ompt_buffer_get_record_correlation}.
\item \code{ompt\_buffer\_get\_record\_native} tool function, see \specref{sec:ompt_buffer_get_record_native}.
\end{itemize}
\end{comment}

% ompt_buffer_cursor_t

\ompttype{\code{ompt\_buffer\_cursor\_t}}
\label{sec:ompt_buffer_cursor_t} 
\code{ompt\_buffer\_cursor\_t} is an opaque handle for a position in a target buffer.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef \ulonglongint{} ompt_buffer_cursor_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_buffer\_complete\_t} callback type, see \specref{sec:ompt_callback_buffer_complete_t}.
\item \code{ompt\_advance\_buffer\_cursor} tool function, see \specref{sec:ompt_advance_buffer_cursor}.
\item \code{ompt\_buffer\_get\_record\_type} tool function, see \specref{sec:ompt_buffer_get_record_type}.
\item \code{ompt\_buffer\_get\_record\_ompt} tool function, see \specref{sec:ompt_buffer_get_record_ompt}.
\item \code{ompt\_buffer\_get\_record\_correlation} tool function, see \specref{sec:ompt_buffer_get_record_correlation}.
\item \code{ompt\_buffer\_get\_record\_native} tool function, see \specref{sec:ompt_buffer_get_record_native}.
\end{itemize}
\end{comment}

% ompt_task_dependence_t

\ompttype{\code{ompt\_task\_dependence\_t}}
\label{sec:ompt_task_dependence_t} 
\code{ompt\_task\_dependence\_t} is a task dependence.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_task_dependence_s \{\\
  void *\plc{variable_addr};
  unsigned int \plc{dependence_flags};
\} ompt_task_dependence_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_task\_dependences\_t} callback type, see \specref{sec:ompt_callback_task_dependences_t}.
\item \code{ompt\_task\_dependence\_flag\_t} enumeration type, see \specref{sec:ompt_task_dependence_flag_t}.
\end{itemize}
\end{comment}

\begin{comment}
% ompt_frame_t
\ompttype{\code{ompt\_frame\_t}}
\label{sec:ompt_frame_t} 
\code{ompt\_frame\_t} is a structure to maintain the runtime frame that reenters
user code, and the user fram ethat enters the runtime.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_frame_s \{\\
  void *\plc{exit_frame};  /* runtime frame that reenters user code */
  void *\plc{enter_frame}; /* user frame that enters the runtime    */
\} ompt_frame_t;
\end{boxedcode}
\ccppspecificend
}
\end{comment}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_get\_task\_info}, see \specref{sec:ompt_get_task_info}.
\item \code{ompt\_callback\_parallel\_begin\_t} callback type, see
  \specref{sec:ompt_callback_parallel_begin_t}.
\item \code{ompt\_callback\_create\_t} callback type, see \specref{sec:ompt_callback_create_t}.
\item \code{ompt\_record\_parallel\_begin\_t} data type, see \specref{sec:ompt_record_parallel_begin_t}.
\item \code{ompt\_record\_task\_create\_t} data type, see \specref{sec:ompt_record_task_create_t}.
\end{itemize}
\end{comment}

% ompt_thread_type_t

\ompttype{\code{ompt\_thread\_type\_t}}
\label{sec:ompt_thread_type_t} 
\code{ompt\_thread\_type\_t} is an enumeration that defines the valid thread type values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_thread_type_e \{
  ompt_thread_initial                 = 1,
  ompt_thread_worker                  = 2,
  ompt_thread_other                   = 3,
  ompt_thread_unknown                 = 4
\} ompt_thread_type_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_thread\_begin\_t} callback type, see \specref{sec:ompt_callback_thread_begin_t}.
\item \code{ompt\_record\_thread\_begin\_t} data type, see \specref{sec:ompt_record_thread_begin_t}.
\end{itemize}
\end{comment}

% ompt_scope_endpoint_t

\ompttype{\code{ompt\_scope\_endpoint\_t}}
\label{sec:ompt_scope_endpoint_t} 
\code{ompt\_scope\_endpoint\_t} is an enumeration that defines valid scope endpoint values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_scope_endpoint_e \{
  ompt_scope_begin                    = 1,
  ompt_scope_end                      = 2
\} ompt_scope_endpoint_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_idle\_t} callback type, see \specref{sec:ompt_callback_idle_t}.
\item \code{ompt\_callback\_implicit\_task\_t} callback type, see
  \specref{sec:ompt_callback_implicit_task_t}.
\item \code{ompt\_callback\_sync\_region\_t} callback type, see \specref{sec:ompt_callback_sync_region_t}.
\item \code{ompt\_callback\_nest\_lock\_t} callback type, see \specref{sec:ompt_callback_nest_lock_t}.
\item \code{ompt\_callback\_master\_t} callback type, see \specref{sec:ompt_callback_master_t}.
\item \code{ompt\_callback\_work\_t} callback type, see \specref{sec:ompt_callback_work_t}.
\item \code{ompt\_callback\_target\_t} callback type, see \specref{sec:ompt_callback_target_t}.
\item \code{ompt\_record\_idle\_t} data type, see \specref{sec:ompt_record_idle_t}.
\item \code{ompt\_record\_implicit\_t} data type, see \specref{sec:ompt_record_implicit_t}.
\item \code{ompt\_sync\_region\_t} data type, see \specref{sec:ompt_sync_region_t}.
\item \code{ompt\_nest\_lock\_t} data type, see \specref{sec:ompt_nest_lock_t}.
\item \code{ompt\_master\_t} data type, see \specref{sec:ompt_master_t}.
\item \code{ompt\_work\_t} data type, see \specref{sec:ompt_work_t}.
\end{itemize}
\end{comment}

% ompt_sync_region_kind_t

\ompttype{\code{ompt\_sync\_region\_kind\_t}}
\label{sec:ompt_sync_region_kind_t} 
\code{ompt\_sync\_region\_kind\_t} is an enumeration that defines the valid sync region kind values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_sync_region_kind_e \{
  ompt_sync_region_barrier            = 1, 
  ompt_sync_region_taskwait           = 2,
  ompt_sync_region_taskgroup          = 3
\} ompt_sync_region_kind_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_sync\_region\_t} callback type, see \specref{sec:ompt_callback_sync_region_t}.
\item \code{ompt\_record\_sync\_region\_t} data type, see \specref{sec:ompt_record_sync_region_t}.
\end{itemize}
\end{comment}

% ompt_target_data_op_t

\ompttype{\code{ompt\_target\_data\_op\_t}}
\label{sec:ompt_target_data_op_t} 
\code{ompt\_target\_data\_op\_t} is an enumeration that defines the valid target data operation values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_target_data_op_e \{
  ompt_target_data_alloc              = 1,
  ompt_target_data_transfer_to_dev    = 2,
  ompt_target_data_transfer_from_dev  = 3,
  ompt_target_data_delete             = 4
\} ompt_target_data_op_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_target\_data\_t} callback type, see \specref{sec:ompt_callback_target_data_op_t}.
\item \code{ompt\_record\_target\_data\_t} data type, see \specref{sec:ompt_record_target_data_t}.
\end{itemize}
\end{comment}

% ompt_work_type_t

\ompttype{\code{ompt\_work\_type\_t}}
\label{sec:ompt_work_type_t} 
\code{ompt\_work\_type\_t} is an enumeration that defines the valid work type values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_work_type_e \{
  ompt_work_loop               = 1, 
  ompt_work_sections           = 2,
  ompt_work_single_executor    = 3,
  ompt_work_single_other       = 4,
  ompt_work_workshare          = 5,
  ompt_work_distribute         = 6,
  ompt_work_taskloop           = 7
\} ompt_work_type_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_work\_t} callback type, see \specref{sec:ompt_callback_work_t}.
\item \code{ompt\_record\_work\_t} data type, see \specref{sec:ompt_record_work_t}.
\end{itemize}
\end{comment}

% ompt_mutex_kind_t

\ompttype{\code{ompt\_mutex\_kind\_t}}
\label{sec:ompt_mutex_kind_t} 
\code{ompt\_mutex\_kind\_t} is an enumeration that defines the valid mutex kind values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_mutex_kind_e \{
  ompt_mutex                          = 0x10,
  ompt_mutex_lock                     = 0x11,
  ompt_mutex_nest_lock                = 0x12,
  ompt_mutex_critical                 = 0x13,
  ompt_mutex_atomic                   = 0x14,
  ompt_mutex_ordered                  = 0x20
\} ompt_mutex_kind_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_mutex\_acquire\_t} callback type, see \specref{sec:ompt_callback_mutex_acquire_t}.
\item \code{ompt\_callback\_mutex\_t} callback type, see \specref{sec:ompt_callback_mutex_t}.
\item \code{ompt\_record\_mutex\_acquire\_t} data type, see \specref{sec:ompt_record_mutex_acquire_t}.
\item \code{ompt\_record\_mutex\_t} data type, see \specref{sec:ompt_record_mutex_t}.
\end{itemize}
\end{comment}

% ompt_native_mon_flags_t

\ompttype{\code{ompt\_native\_mon\_flags\_t}}
\label{sec:ompt_native_mon_flags_t}
\code{ompt\_native\_mon\_flags\_t} is an enumeration that defines the valid native monitoring flag values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_native_mon_flags_e \{
  ompt_native_data_motion_explicit    = 1,
  ompt_native_data_motion_implicit    = 2,
  ompt_native_kernel_invocation       = 4,
  ompt_native_kernel_execution        = 8,
  ompt_native_driver                  = 16,
  ompt_native_runtime                 = 32,
  ompt_native_overhead                = 64,
  ompt_native_idleness                = 128
\} ompt_native_mon_flags_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_set\_trace\_native} tool function, see \specref{sec:ompt_set_trace_native}.
\end{itemize}
\end{comment}

% ompt_task_type_t

\ompttype{\code{ompt\_task\_type\_t}}
\label{sec:ompt_task_type_t}
\code{ompt\_task\_type\_t} is an enumeration that defines the valid task type values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_task_type_e \{
  ompt_task_initial                   = 1,
  ompt_task_implicit                  = 2,
  ompt_task_explicit                  = 3,
  ompt_task_target                    = 4
\} ompt_task_type_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_task\_create\_t} callback type, see \specref{sec:ompt_callback_task_create_t}.
\item \code{ompt\_get\_task\_info}, see \specref{sec:ompt_get_task_info}.
\item \code{ompt\_record\_task\_create\_t} data type, see \specref{sec:ompt_record_task_create_t}.
\end{itemize}
\end{comment}

%xxx
% ompt_task_status

\ompttype{\code{ompt\_task\_status\_t}}
\label{sec:ompt_task_status_t}
\code{ompt\_task\_status\_t} is an enumeration that explains the
reasons for switching a task that reached  a task scheduling point. 

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_task_status_e \{
  ompt_task_complete  = 1,
  ompt_task_yield     = 2,
  ompt_task_cancel    = 3,
  ompt_task_others    = 4
\} ompt_task_status_t;
\end{boxedcode}
\ccppspecificend
}

The \code{ompt\_task\_complete} indicates the completion of task that
encountered the task scheduling point. The \code{ompt\_task\_yield} indicates
that the task encountered a \code{taskyield} construct. The \code{ompt\_task\_cancel} indicates
that the taks is canceled due to the encountering of an active cancellation point resulting in the
cancelation of that task.
The \code{ompt\_task\_others} is used in the remaining cases.

% ompt_target_type_t

\ompttype{\code{ompt\_target\_type\_t}}
\label{sec:ompt_target_type_t}
\code{ompt\_target\_type\_t} is an enumeration that defines the valid target type values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_target_type_e \{
  ompt_target                         = 1,
  ompt_target_enter_data              = 2,
  ompt_target_exit_data               = 3,
  ompt_target_update                  = 4
\} ompt_target_type_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_target\_t} callback type, see \specref{sec:ompt_callback_target_t}.
\end{itemize}
\end{comment}

% ompt_invoker_t

\ompttype{\code{ompt\_invoker\_t}}
\label{sec:ompt_invoker_t}
\code{ompt\_invoker\_t} is an enumeration that defines the valid invoker values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_invoker_e \{
  ompt_invoker_program = 1, /* program invokes master task */
  ompt_invoker_runtime = 2  /* runtime invokes master task */
\} ompt_invoker_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_callback_parallel\_begin\_t}, see \specref{sec:ompt_callback_parallel_begin__t}.
\item \code{ompt\_record\_parallel\_begin\_t}, see \specref{sec:ompt_record_parallel_begin_t}.
\item \code{ompt\_callback\_parallel\_end\_t}, see \specref{sec:ompt_callback_parallel_end_t}.
\item \code{ompt\_record\_parallel\_end\_t}, see \specref{sec:ompt_record_parallel_end_t}.
\end{itemize}
\end{comment}

% ompt_target_map_flag_t

\ompttype{\code{ompt\_target\_map\_flag\_t}}
\label{sec:ompt_target_map_flag_t}
\code{ompt\_target\_map\_flag\_t} is an enumeration that defines the valid target map flag values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_target_map_flag_e \{
  ompt_target_map_flag_to             = 1,
  ompt_target_map_flag_from           = 2,
  ompt_target_map_flag_alloc          = 4,
  ompt_target_map_flag_release        = 8, 
  ompt_target_map_flag_delete         = 16
\} ompt_target_map_flag_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_target\_data\_map\_t} callback type, see \specref{sec:ompt_callback_target_data_map_t}.
\end{itemize}
\end{comment}

% ompt_task_dependence_flag_t

\ompttype{\code{ompt\_task\_dependence\_flag\_t}}
\label{sec:ompt_task_dependence_flag_t}
\code{ompt\_task\_dependence\_flag\_t} is an enumeration that defines the valid task dependence flag values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_task_dependence_flag_e \{
  ompt_task_dependence_type_out       = 1,
  ompt_task_dependence_type_in        = 2,
  ompt_task_dependence_type_inout     = 3
\} ompt_task_dependence_flag_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_task\_dependence\_t} data type, see \specref{sec:ompt_task_dependence_t}.
\end{itemize}
\end{comment}


% ompt_cancel_flag_t

\ompttype{\code{ompt\_cancel\_flag\_t}}
\label{sec:ompt_cancel_flag_t}
\code{ompt\_cancel\_flag\_t} is an enumeration that defines the valid cancel flag values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_cancel_flag_e \{
  ompt_cancel_parallel     = 0x1,
  ompt_cancel_sections     = 0x2,
  ompt_cancel_do           = 0x4,
  ompt_cancel_taskgroup    = 0x8,
  ompt_cancel_activated    = 0x10,
  ompt_cancel_detected     = 0x20
\} ompt_cancel_flag_t;
\end{boxedcode}
\ccppspecificend
}

\crossreferences
\begin{itemize}
\item \code{ompt\_cancel\_t} data type, see \specref{sec:ompt_callback_cancel_t}.
\end{itemize}

% ompt_hwid_t

\ompttype{\code{ompt\_hwid\_t}}
\label{sec:ompt_hwid_t}
\code{ompt\_hwid\_t} is an opaque object representing a hardware identifier for a target device.
\label{sec:ompt_hwid_none} 
\code{ompt\_hwid\_none} refers to an uknown or unspecified hardware id.
If there is no \code{hwid} associated with a
\code{ompt\_record\_native\_abstract\_t}, the value of \code{hwid} shall be
\code{ompt\_hwid\_none}.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef \ulonglongint{} ompt_hwid_t;
#define ompt_hwid_none 0
\end{boxedcode}
\ccppspecificend
}



% end miscellaneous types

\begin{comment}
% These "none" objects have been integrated into the relevant sections,
% rather than have a seperate section.
\subsection{Miscellaneous Constants}
This section describes miscellaneous constants used by the tool interface.
% ompt_hwid_none
% ompt_dev_task_none
% ompt_time_none 
% ompt_id_none
% ompt_data_none
% ompt_mutex_kind_none
% end miscellaneous constants
\end{comment}
\section{Tool Interface Routine}
\label{sec:tool-interface}

\ompttoolsignature{\code{ompt\_start\_tool}}
\label{sec:ompt_start_tool}

\summary
If a tool wants to use the OMPT interface provided by an OpenMP implementation,
the tool must implement \code{ompt\_start\_tool} to announce its interest.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
ompt_fns_t *ompt_start_tool(
  unsigned int \plc{omp_version},
  const char *\plc{runtime_version}
);
\end{boxedcode}
\ccppspecificend
}

\descr
For a tool to use the OMPT interface provided by an OpenMP implementation,
the tool must define a globally-visible implementation of the
function \code{ompt\_start\_tool}.

A tool may indicate its intent to use the OMPT interface provided
by an OpenMP implementation by having
\code{ompt\_start\_tool} return a non-\code{NULL} pointer to an
\code{ompt\_fns\_t} structure, which contains pointers to
a tool's initializer and finalizer functions.

A tool may use its \callbackarg{} \plc{omp\_version} to determine
whether it is compatible with the OMPT interface provided by an OpenMP
implementation.

If a tool implements \code{ompt\_start\_tool} but has no interest in using
the OMPT interface in a particular execution,
\code{ompt\_start\_tool} should return \code{NULL}. 

\argdesc

The \callbackarg{} \plc{omp\_version} 
is the value of the \code{\_OPENMP} version macro 
associated with the OpenMP API implementation. This value 
identifies the OpenMP API version supported by an OpenMP implementation,
which specifies the version of the OMPT interface that it supports.

The \callbackarg{} \plc{runtime\_version}
is a version string that unambiguously identifies the OpenMP implementation.

\constraints

The \callbackarg{} \plc{runtime\_version} must be
an immutable string that is defined for the lifetime of a program
execution.

\effect
If a tool returns a non-\code{NULL} pointer,
an OpenMP implementation will call the tool initializer specified by the
\plc{finalize} field in this structure but before
beginning execution of any OpenMP construct
or completing execution of any environment routine invocation; the
OpenMP implementation will call the tool finializer when the OpenMP
implementation shuts down.

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_initialize\_t} type signature, see \specref{sec:ompt_initialize_t}
\end{itemize}
\end{comment}

\crossreferences
\begin{itemize}
\item \code{ompt\_fns\_t}, see \specref{sec:ompt_fns_t}.
\end{itemize}

\section{Tool Callback Signatures and Trace Records}
\label{sec:ompt-tool-callbacks}

\restrictions
Tool callbacks may not use OpenMP directives or call any runtime library routines
described in Section~\ref{chap:Runtime Library Routines}.

\subsection{Initialization and Finalization Callback Signature}

\omptcallbacksignature{\code{ompt\_initialize\_t}}
\label{sec:ompt_initialize_t}

\summary
A tool implements an initializer with the type signature
\code{ompt\_initialize\_t} to initialize the tool's use of
the OMPT interace.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_initialize_t) (
  ompt_function_lookup_t \plc{lookup},
  struct ompt_fns_t *\plc{fns}
);
\end{boxedcode}
\ccppspecificend
}

\descr
For a tool to initialize the OMPT interface of an OpenMP implementation,
the tool's implementation of \code{ompt\_start\_tool} must return a 
pointer to a tool initializer with type signature \code{ompt\_initialize\_t}.
An OpenMP implementation will call the tool initializer returned by
\code{ompt\_start\_tool} after fully initializing itself but before 
beginning execution of any OpenMP construct
or completing execution of any environment routine invocation.  

The initializer returns a non-zero value if it succeeds.

\argdesc
The \callbackarg{} \plc{lookup} is a callback 
to an OpenMP runtime routine that a tool must use to 
obtain a pointer to each runtime entry point in the OMPT interface.
The \callbackarg{} \plc{fns} is the value returned by \code{ompt\_start\_tool}.
The actions of a tool initializer are described in \specref{sec:tool-initialize}.

\crossreferences
\begin{itemize}
\item \code{ompt\_function\_lookup\_t}, see
  \specref{sec:ompt_function_lookup_t}.
\end{itemize}


\omptcallbacksignature{\code{ompt\_finalize\_t}}
\label{sec:ompt_finalize_t}

\summary
A tool implements an finalizer with the type signature
\code{ompt\_finalize\_t} to finalize the tool's use of
the OMPT interface.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_finalize_t) (
  struct ompt_fns_t *\plc{fns}
);
\end{boxedcode}
\ccppspecificend
}

\descr
The finalizer for an OpenMP implementation is invoked by an OpenMP
implementation as it shuts down.

\argdesc
The \callbackarg{} \plc{fns} is the value returned by \code{ompt\_start\_tool}.

\crossreferences
\begin{itemize}
\item \code{ompt\_fns\_t}, see
  \specref{sec:ompt_fns_t}.
\end{itemize}


\subsection{Event Callback Signatures and Trace Records}
\index{event callback signatures}
\label{sec:ToolsSupport_callback_signatures}

This section describes the signatures of tool callback functions that an OMPT
tool might register and that are called during runtime of an OpenMP program.

\omptcallbacksignature{\code{ompt\_callback\_thread\_begin\_t}}
\index{ompt\_callback\_thread\_begin\_t@{\code{ompt\_callback\_thread\_begin\_t}}}
\label{sec:ompt_callback_thread_begin_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_thread_begin_t) (
  ompt_thread_type_t \plc{thread_type},
  ompt_data_t *\plc{thread_data}
);
\end{boxedcode}
\ccppspecificend
}

\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_thread_begin_s \{
  ompt_thread_type_t \plc{thread_type};
\} ompt_record_thread_begin_t;
\end{boxedcode}
\ccppspecificend
}

\argdesc

The \callbackarg{} \plc{thread\_type}
indicates the type of the new thread: initial, worker, or other.

The binding of \callbackarg{} \plc{thread\_data} is the new thread.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_thread\_type\_t} type, see
\specref{sec:ompt_thread_type_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_thread\_end\_t}}
\index{ompt\_callback\_thread\_end\_t@{\code{ompt\_callback\_thread\_end\_t}}}
\label{sec:ompt_callback_thread_end_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_thread_end_s) (
  ompt_data_t *\plc{thread_data}
);
\end{boxedcode}
\ccppspecificend
}

\argdesc

The binding of \callbackarg{} \plc{thread\_data} is the thread that is
terminating.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\end{itemize}


\omptcallbacksignature{\code{ompt\_callback\_idle\_t}}
\index{ompt\_callback\_idle\_t@{\code{ompt\_callback\_idle\_t}}}
\label{sec:ompt_callback_idle_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback\_idle_t) (
  ompt_scope_endpoint_t \plc{endpoint}
);
\end{boxedcode}
\ccppspecificend
}

\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_idle_s \{
  ompt_scope_endpoint_t \plc{endpoint};
\} ompt_record_idle_t;
\end{boxedcode}
\ccppspecificend
}

\argdesc

The \callbackarg{} \plc{endpoint} indicates whether the callback is
signalling the beginning or end of an idle interval.

\crossreferences
\begin{itemize}
\item \code{ompt\_scope\_endpoint\_t} type, see
\specref{sec:ompt_scope_endpoint_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_parallel\_begin\_t}}
\index{ompt\_callback\_parallel\_begin\_t@{\code{ompt\_callback\_parallel\_begin\_t}}}
\label{sec:ompt_callback_parallel_begin_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_parallel_begin_t) (
  ompt_data_t *\plc{parent_task_data},
  const ompt_frame_t *\plc{parent_frame},
  ompt_data_t *\plc{parallel_data},
  unsigned int \plc{requested_team_size},
  unsigned int \plc{actual_team_size},
  ompt_invoker_t \plc{invoker},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_parallel_begin_s \{
  ompt_id_t \plc{parent_task_id};
  const ompt_frame_t *\plc{parent_frame};
  ompt_id_t \plc{parallel_id};
  unsigned int \plc{requested_team_size};
  ompt_invoker_t \plc{invoker};
  const void *\plc{codeptr_ra};
\} ompt_record_parallel_begin_t;
\end{boxedcode}
\ccppspecificend
}

\argdesc

The binding of \callbackarg{} \plc{parent\_task\_data} is the
encountering task.

The \callbackarg{} \plc{parent\_frame} points to the frame object
associated with the encountering task.

The binding of \callbackarg{} \plc{parallel\_data} is the parallel
region that is beginning.

The \callbackarg{} \plc{requested\_team\_size}
indicates the number of threads requested by the user. 

The \callbackarg{} \plc{actual\_team\_size} indicates the number of
threads in the team.

The \callbackarg{} \plc{invoker} indicates whether the code for the
parallel region is inlined into the application or invoked by the
runtime.

\codeptrdesc

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see \specref{sec:ompt_data_t}.
\item \code{ompt\_frame\_t} type, see \specref{sec:ompt_frame_t}.
\item \code{ompt\_invoker\_t} type, see \specref{sec:ompt_invoker_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_parallel\_end\_t}}
\index{ompt\_callback\_parallel\_end\_t@{\code{ompt\_callback\_parallel\_end\_t}}}
\label{sec:ompt_callback_parallel_end_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_parallel_end_t) (
  ompt_data_t *\plc{parallel_data},
  ompt_data_t *\plc{task_data},
  ompt_invoker_t \plc{invoker},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_parallel_end_s \{
  ompt_id_t \plc{parallel_id}; 
  ompt_id_t \plc{task_id};
  ompt_invoker_t \plc{invoker};
  const void *\plc{codeptr_ra};
\} ompt_record_parallel_end_t;
\end{boxedcode}
\ccppspecificend
}

\argdesc

The binding of \callbackarg{} \plc{parallel\_data} is the parallel
region that is ending.

The binding of \callbackarg{} \plc{task\_data} is the encountering
task.

The \callbackarg{} \plc{invoker} explains whether the execution of the
parallel region code is inlined into the application code or started
by the runtime.

\codeptrdesc

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type signature, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_invoker\_t} type signature, see
\specref{sec:ompt_invoker_t}.
\end{itemize}

\omptcallbacksignature{\code{ompt\_callback\_master\_t}}
\index{ompt\_callback\_master\_t@{\code{ompt\_callback\_master\_t}}}
\label{sec:ompt_callback_master_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_master_t) (
  ompt_scope_endpoint_t \plc{endpoint},
  ompt_data_t *\plc{parallel_data},
  ompt_data_t *\plc{task_data},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_master_s \{
  ompt_scope_endpoint_t \plc{endpoint};
  ompt_id_t \plc{parallel_id};
  ompt_id_t \plc{task_id};
  const void *\plc{codeptr_ra};
\} ompt_record_master_t;
\end{boxedcode}
\ccppspecificend
}

\argdesc

\epdesc

The binding of \callbackarg{} \plc{parallel\_data} is the current parallel region.

The binding of \callbackarg{} \plc{task\_data} is the encountering task.
\codeptrdesc

%\effect
% ompt events have no effect

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type signature, see \specref{sec:ompt_data_t}.
\item \code{ompt\_scope\_endpoint\_t} type, see \specref{sec:ompt_scope_endpoint_t}.
\end{itemize}





\omptcallbacksignature{\code{ompt\_callback\_task\_create\_t}}
\index{ompt\_callback\_task\_create\_t@{\code{ompt\_callback\_task\_create\_t}}}
\label{sec:ompt_callback_task_create_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_task_create_t) (
  ompt_data_t *\plc{parent_task_data},
  const ompt_frame_t *\plc{parent_frame},
  ompt_data_t *\plc{new_task_data},
  ompt_task_type_t \plc{type},
  int \plc{has_dependences},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_task_create_s \{
  ompt_id_t \plc{parent_task_id};
  const ompt_frame_t *\plc{parent_frame};
  ompt_id_t \plc{new_task_id};
  ompt_task_type_t \plc{type};
  int \plc{has_dependences};
  const void *\plc{codeptr_ra};
\} ompt_record_task_create_t;
\end{boxedcode}
\ccppspecificend
}

\argdesc

The binding of \callbackarg{} \plc{parent\_task\_data} is the
encountering task.  
This parameter is \code{NULL} for an initial task.

The \callbackarg{} \plc{parent\_frame} points to the frame object
associated with the encountering task. 
This parameter is \code{NULL} for an initial task.

The binding of \callbackarg{} \plc{new\_task\_data} is the created
task.

The \callbackarg{} \plc{type} indicates the kind of the task: initial,
explicit or target.

The \callbackarg{} \plc{has\_dependences} indicates whether created
task has dependences.

\codeptrdesc

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_frame\_t} type, see
\specref{sec:ompt_frame_t}.
\item \code{ompt\_task\_type\_t} type, see
\specref{sec:ompt_task_type_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_task\_dependences\_t}}
\index{ompt\_callback\_task\_dependences\_t@{\code{ompt\_callback\_task\_dependences\_t}}}
\label{sec:ompt_callback_task_dependences_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_task_dependences_t) (
  ompt_data_t *\plc{task_data},
  const ompt_task_dependence_t *\plc{deps},
  int \plc{ndeps}
);
\end{boxedcode}
\ccppspecificend
}

\argdesc

The binding of \callbackarg{} \plc{task\_data} is the task being created.

The \callbackarg{} \plc{deps} lists all dependences of a new task.

The \callbackarg{} \plc{ndeps} specifies the length of the list.
The memory for \plc{deps} is owned by the caller; the tool cannot rely on
the data after the callback returns.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_task\_dependence\_t} type, see
\specref{sec:ompt_task_dependence_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_task\_dependence\_t}}
\index{ompt\_callback\_task\_dependence\_t@{\code{ompt\_callback\_task\_dependence\_t}}}
\label{sec:ompt_callback_task_dependence_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_task_dependence_t) (
  ompt_data_t *\plc{src_task_data},
  ompt_data_t *\plc{sink_task_data}
);
\end{boxedcode}
\ccppspecificend
}

\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_task_dependence_s \{
  ompt_id_t \plc{src_task_id};
  ompt_id_t \plc{sink_task_id};
\} ompt_record_task_dependence_t;
\end{boxedcode}
\ccppspecificend
}

\argdesc

The binding of \callbackarg{} \plc{src\_task\_data} is a running task
with an outgoing dependence.

The binding of \callbackarg{} \plc{sink\_task\_data} is a task with an
unsatisfied incoming dependence.


\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type signature, see
\specref{sec:ompt_data_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_task\_schedule\_t}}
\index{ompt\_callback\_task\_schedule\_t@{\code{ompt\_callback\_task\_schedule\_t}}}
\label{sec:ompt_callback_task_schedule_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_task_schedule_t) (
  ompt_data_t *\plc{prior_task_data},
  ompt_task_status_t \plc{prior_task_status},
  ompt_data_t *\plc{next_task_data}
);
\end{boxedcode}
\ccppspecificend
}

\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_task_schedule_s \{
  ompt_id_t \plc{prior_task_id};
  ompt_task_status_t \plc{prior_task_status},
  ompt_id_t \plc{next_task_id};
\} ompt_record_task_schedule_t;
\end{boxedcode}
\ccppspecificend
}

\argdesc

The \callbackarg{} \plc{prior\_task\_status} indicates the status of
the task that arrived at a task scheduling point.

The binding of \callbackarg{} \plc{prior\_task\_data} is the task that
arrived at the scheduling point.

The binding of \callbackarg{} \plc{next\_task\_data} is the task that
will resume at the scheduling point.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.

\item \code{ompt\_task\_status\_t} type, see
\specref{sec:ompt_task_status_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_implicit\_task\_t}}
\index{ompt\_callback\_implicit\_task\_t@{\code{ompt\_callback\_implicit\_task\_t}}}
\label{sec:ompt_callback_implicit_task_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_implicit_task_t) (
  ompt_scope_endpoint_t \plc{endpoint},
  ompt_data_t *\plc{parallel_data},
  ompt_data_t *\plc{task_data},
  unsigned int \plc{thread_num}
);
\end{boxedcode}
\ccppspecificend
}

\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_implicit_s \{
  ompt_scope_endpoint_t \plc{endpoint};
  ompt_id_t \plc{parallel_id};
  ompt_id_t \plc{task_id};
  unsigned int \plc{thread_num};
\} ompt_record_implicit_t;
\end{boxedcode}
\ccppspecificend
}

\argdesc

\epdesc

The binding of \callbackarg{} \plc{parallel\_data} is the current
parallel region.

The binding of \callbackarg{} \plc{task\_data} is the implicit task
executing the parallel region's structured block.

The \callbackarg{} \plc{thread\_num} indicates
the thread number of the calling thread, within the team executing the parallel
region to which the implicit region binds.


\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_scope\_endpoint\_t} enumeration type, see
\specref{sec:ompt_scope_endpoint_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_sync\_region\_t}}
\index{ompt\_callback\_sync\_region\_t@{\code{ompt\_callback\_sync\_region\_t}}}
\label{sec:ompt_callback_sync_region_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_sync_region_t) (
  ompt_sync_region_kind_t \plc{kind},
  ompt_scope_endpoint_t \plc{endpoint},
  ompt_data_t *\plc{parallel_data},
  ompt_data_t *\plc{task_data},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_sync_region_s \{
  ompt_sync_region_kind_t \plc{kind};
  ompt_scope_endpoint_t \plc{endpoint};
  ompt_id_t \plc{parallel_id};
  ompt_id_t \plc{task_id};
  const void *\plc{codeptr_ra};
\} ompt_record_sync_region_t;
\end{boxedcode}
\ccppspecificend
}

% \descr
% A tool executes a callback with type signature
% \code{ompt\_callback\_sync\_region\_t} to receive notification of
% event \code{ompt\_callback\_sync\_region\_t} when an OpenMP
% implementation starts and stops waiting in a barrier region, taskwait
% region, or taskgroup region.

\argdesc

The \callbackarg{} \plc{kind} indicates indicates the kind of
synchronization region.

\epdesc

The binding of \callbackarg{} \plc{parallel\_data} is the current
parallel region.

The binding of \callbackarg{} \plc{task\_data} is the current task.
\codeptrdesc

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_sync\_region\_kind\_t} type, see
\specref{sec:ompt_sync_region_kind_t}.
\item \code{ompt\_scope\_endpoint\_t} type, see
\specref{sec:ompt_scope_endpoint_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_lock\_init\_t}}
\index{ompt\_callback\_lock\_init\_t@{\code{ompt\_callback\_lock\_init\_t}}}
\label{sec:ompt_callback_lock_init_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_lock_init_t) (
  ompt_mutex_kind_t \plc{kind},
  unsigned int \plc{hint},
  unsigned int \plc{impl},
  ompt_wait_id_t \plc{wait_id},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_lock_init_s \{
  ompt_mutex_kind_t \plc{kind};
  unsigned int \plc{hint};
  unsigned int \plc{impl};
  ompt_wait_id_t \plc{wait_id};
  const void *\plc{codeptr_ra};
\} ompt_record_lock_init_t;
\end{boxedcode}
\ccppspecificend
}

\argdesc

The \callbackarg{} \plc{kind} indicates the kind of the lock.

The \callbackarg{} \plc{hint} indicates the hint provided when initializing
an implementation of mutual exclusion.

The \callbackarg{} \plc{impl} indicates the mechanism chosen by the
runtime to implement the mutual exclusion.

The \callbackarg{} \plc{wait\_id} indicates the object being awaited. 

\codeptrdesc


\crossreferences
\begin{itemize}
\item \code{ompt\_wait\_id\_t} type, see
\specref{sec:ompt_wait_id_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_lock\_destroy\_t}}
\index{ompt\_callback\_lock\_destroy\_t@{\code{ompt\_callback\_lock\_destroy\_t}}}
\label{sec:ompt_callback_lock_destroy_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_lock_destroy_t) (
  ompt_mutex_kind_t \plc{kind},
  ompt_wait_id_t \plc{wait_id},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_lock_destroy_s \{
  ompt_mutex_kind_t \plc{kind};
  ompt_wait_id_t \plc{wait_id};
  const void *\plc{codeptr_ra};
\} ompt_record_lock_destroy_t;
\end{boxedcode}
\ccppspecificend
}

\argdesc

The \callbackarg{} \plc{kind} indicates the kind of the lock.

The \callbackarg{} \plc{wait\_id} identifies the lock.

\codeptrdesc


\crossreferences
\begin{itemize}
\item \code{ompt\_wait\_id\_t} type, see
\specref{sec:ompt_wait_id_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_mutex\_acquire\_t}}
\index{ompt\_callback\_mutex\_acquire\_t@{\code{ompt\_callback\_mutex\_acquire\_t}}}
\label{sec:ompt_callback_mutex_acquire_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_mutex_acquire_t) (
  ompt_mutex_kind_t \plc{kind},
  unsigned int \plc{hint},
  unsigned int \plc{impl},
  ompt_wait_id_t \plc{wait_id},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_mutex_acquire_s \{
  ompt_mutex_kind_t \plc{kind};
  unsigned int \plc{hint};
  unsigned int \plc{impl};
  ompt_wait_id_t \plc{wait_id};
  const void *\plc{codeptr_ra};
\} ompt_record_mutex_acquire_t;
\end{boxedcode}
\ccppspecificend
}

\argdesc

The \callbackarg{} \plc{kind} indicates the kind of the lock.

The \callbackarg{} \plc{hint} indicates the hint provided when initializing
an implementation of mutual exclusion.

The \callbackarg{} \plc{impl} indicates the mechanism chosen by the
runtime to implement the mutual exclusion.

The \callbackarg{} \plc{wait\_id} indicates the object being awaited. 

\codeptrdesc

\crossreferences
\begin{itemize}
\item \code{ompt\_wait\_id\_t} type, see
\specref{sec:ompt_wait_id_t}.
\item \code{ompt\_mutex\_kind\_t} type, see
\specref{sec:ompt_mutex_kind_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_mutex\_t}}
\index{ompt\_callback\_mutex\_t@{\code{ompt\_callback\_mutex\_t}}}
\label{sec:ompt_callback_mutex_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_mutex_t) (
  ompt_mutex_kind_t \plc{kind},
  ompt_wait_id_t \plc{wait_id},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_mutex_s \{
  ompt_mutex_kind_t \plc{kind};
  ompt_wait_id_t \plc{wait_id};
  const void *\plc{codeptr_ra};
\} ompt_record_mutex_t;
\end{boxedcode}
\ccppspecificend
}

\argdesc

The \callbackarg{} \plc{kind} indicates the kind of mutual exclusion event.

The \callbackarg{} \plc{wait\_id} indicates the object being awaited. 

\codeptrdesc

\crossreferences
\begin{itemize}
\item \code{ompt\_wait\_id\_t} type signature, see
\specref{sec:ompt_wait_id_t}.
\item \code{ompt\_mutex\_kind\_t} type signature, see
\specref{sec:ompt_mutex_kind_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_nest\_lock\_t}}
\index{ompt\_callback\_nest\_lock\_t@{\code{ompt\_callback\_nest\_lock\_t}}}
\label{sec:ompt_callback_nest_lock_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_nest_lock_t) (
  ompt_scope_endpoint_t \plc{endpoint},
  ompt_wait_id_t \plc{wait_id},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_nest_lock_s \{
  ompt_scope_endpoint_t \plc{endpoint};
  ompt_wait_id_t \plc{wait_id};
  const void *\plc{codeptr_ra};
\} ompt_record_nest_lock_t;
\end{boxedcode}
\ccppspecificend
}

\argdesc

\epdesc

The \callbackarg{} \plc{wait\_id} indicates the object being awaited. 

\codeptrdesc

\crossreferences
\begin{itemize}
\item \code{ompt\_wait\_id\_t} type signature, see
\specref{sec:ompt_wait_id_t}.
\item \code{ompt\_scope\_endpoint\_t} type signature, see
\specref{sec:ompt_scope_endpoint_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_work\_t}}
\index{ompt\_callback\_work\_t@{\code{ompt\_callback\_work\_t}}}
\label{sec:ompt_callback_work_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_work_t) (
  ompt_work_type_t \plc{wstype},
  ompt_scope_endpoint_t \plc{endpoint},
  ompt_data_t *\plc{parallel_data},
  ompt_data_t *\plc{task_data},
  \longlongint{} \plc{count},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_work_s \{
  ompt_work_type_t \plc{wstype};
  ompt_scope_endpoint_t \plc{endpoint};
  ompt_id_t \plc{parallel_id};
  ompt_id_t \plc{task_id};
  \longlongint{} \plc{count};
  const void *\plc{codeptr_ra};
\} ompt_record_work_t;
\end{boxedcode}
\ccppspecificend
}

\argdesc

The \callbackarg{} \plc{wstype} indicates the kind of worksharing
region.

\epdesc

The binding of \callbackarg{} \plc{parallel\_data} is the current
parallel region.

The binding of \callbackarg{} \plc{task\_data} is the current task.

The \callbackarg{} \plc{count} is a measure of the quantity of work involved in the worksharing construct. 
For a loop construct, \plc{count} represents the number of iterations of the loop.
For a \code{taskloop} construct, \plc{count} represents the number of iterations in the iteration space, 
which may be the result of collapsing several associated loops.
For a \code{sections} construct, \plc{count} represents the number of sections. 
For a \code{workshare} construct, \plc{count} represents the units of work, as defined by the \code{workshare} construct.
For a \code{single} construct, \plc{count} is always 1.

\codeptrdesc


\crossreferences
\begin{itemize}
\item worksharing constructs, see \specref{sec:Worksharing Constructs}.
\item \code{ompt\_data\_t} type signature, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_scope\_endpoint\_t} type signature, see
\specref{sec:ompt_scope_endpoint_t}.
\item \code{ompt\_work\_type\_t} type signature, see
\specref{sec:ompt_work_type_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_flush\_t}}
\index{ompt\_callback\_flush\_t@{\code{ompt\_callback\_flush\_t}}}
\label{sec:ompt_callback_flush_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_flush_t) (
  ompt_data_t *\plc{thread_data},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_flush_s \{
  void *\plc{codeptr_ra};
\} ompt_record_flush_t;
\end{boxedcode}
\ccppspecificend
}

\argdesc

\codeptrdesc

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type signature, see
\specref{sec:ompt_data_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_target\_t}}
\index{ompt\_callback\_target\_t@{\code{ompt\_callback\_target\_t}}}
\label{sec:ompt_callback_target_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_target_t) (
  ompt_target_type_t \plc{kind},
  ompt_scope_endpoint_t \plc{endpoint},
  int \plc{device_id},
  ompt_data_t *\plc{task_data},
  ompt_id_t \plc{target_id},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_target_s \{
  ompt_target_type_t \plc{kind};
  ompt_scope_endpoint_t \plc{endpoint};
  int \plc{device_id};
  ompt_data_t *\plc{task_data};
  ompt_id_t \plc{target_id};
  const void *\plc{codeptr_ra};
\} ompt_record_target_t;
\end{boxedcode}
\ccppspecificend
}

\argdesc

The \callbackarg{} \plc{kind} indicates the kind of target region.

\epdesc

The \callbackarg{} \plc{device\_id} indicates the id of the device
which will execute the target region.

The binding of \callbackarg{} \plc{task\_data} is the target task.

The binding of \callbackarg{} \plc{target\_id} is the target region.

\codeptrdesc

\crossreferences
\begin{itemize}
\item \code{ompt\_id\_t} type, see
\specref{sec:ompt_id_t}.
\item \code{ompt\_data\_t} type signature, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_scope\_endpoint\_t} type signature, see
\specref{sec:ompt_scope_endpoint_t}.
\item \code{ompt\_target\_type\_t} type signature, see
\specref{sec:ompt_target_type_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_target\_data\_op\_t}}
\index{ompt\_callback\_target\_data\_op\_t@{\code{ompt\_callback\_target\_data\_op\_t}}}
\label{sec:ompt_callback_target_data_op_t}
\format

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_target_data_op_t) (
  ompt_id_t \plc{target_id},
  ompt_id_t \plc{host_op_id},
  ompt_target_data_op_t \plc{optype},
  void *\plc{host_addr},
  void *\plc{device_addr},
  size_t \plc{bytes}
);
\end{boxedcode}
\ccppspecificend
}

\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_target_data_op_s \{
  ompt_id_t \plc{host\_op\_id};
  ompt_target_data_op_t \plc{optype};
  void *\plc{host\_addr};
  void *\plc{device\_addr};
  size_t \plc{bytes};
  ompt_device_time_t \plc{end\_time};
\} ompt_record_target_data_op_t;
\end{boxedcode}
\ccppspecificend
}

\argdesc

The \callbackarg{} \plc{host\_op\_id} is a unique identifer for a data
operations on a target device.

The \callbackarg{} \plc{optype} indicates the kind of data mapping.

The \callbackarg{} \plc{host\_addr} indicates the address of data on
host side.

The \callbackarg{} \plc{device\_addr} indicates the address of data on
device side.

The \callbackarg{} \plc{bytes} indicates the size of data.

\crossreferences
\begin{itemize}
\item \code{ompt\_id\_t} type, see
\specref{sec:ompt_id_t}.
\item \code{ompt\_target\_data\_op\_t} type signature, see
\specref{sec:ompt_target_data_op_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_target\_map\_t}}
\index{ompt\_callback\_target\_map\_t@{\code{ompt\_callback\_target\_map\_t}}}
\label{sec:ompt_callback_target_map_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_target_map_t) (
  ompt_id_t \plc{target_id},
  unsigned int \plc{nitems},
  void **\plc{host_addr},
  void **\plc{device_addr},
  size_t *\plc{bytes},
  unsigned int *\plc{mapping_flags}
);
\end{boxedcode}
\ccppspecificend
}

\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_target_map_s \{
  ompt_id_t \plc{target_id};
  unsigned int \plc{nitems};
  void **\plc{host_addr};
  void **\plc{device_addr};
  size_t *\plc{bytes};
  unsigned int *\plc{mapping_flags};
\} ompt_record_target_map_t;
\end{boxedcode}
\ccppspecificend
}

\argdesc

The binding of \callbackarg{} \plc{target\_id} is the target region.

The \callbackarg{} \plc{nitems} indicates the number of data mappings.

The \callbackarg{} \plc{host\_addr} indicates an array of addresses of
data on host side.

The \callbackarg{} \plc{device\_addr} indicates an array of addresses
of data on device side.

The \callbackarg{} \plc{bytes} indicates an array of size of data.

The \callbackarg{} \plc{mapping\_flags} indicates the kind of data
mapping.


\crossreferences
\begin{itemize}
\item \code{ompt\_id\_t} type, see
\specref{sec:ompt_id_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_target\_submit\_t}}
\index{ompt\_callback\_target\_submit\_t@{\code{ompt\_callback\_target\_submit\_t}}}
\label{sec:ompt_callback_target_submit_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_target_submit_t) (
  ompt_id_t \plc{target_id},
  ompt_id_t \plc{host_op_id}
);
\end{boxedcode}
\ccppspecificend
}

\descr
This callback is invoked when a target task creates an initial task on a
target device. 

\argdesc

The \callbackarg{} \plc{target\_id} is a unique identifier for the
associated target region.

The \callbackarg{} \plc{host\_op\_id} is a unique identifer for the
initial task on the target device.

\constraints

The \callbackarg{} \plc{target\_id} indicates the instance of the
target construct to which the computation belongs.

The \callbackarg{} \plc{host\_op\_id} provides a unique host-side
identifier that represents the computation on the device.

\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_target_kernel_s \{
  ompt_id_t \plc{host_op_id};
  unsigned int \plc{requested_num_teams};
  unsigned int \plc{granted_num_teams};
  ompt_device_time_t \plc{end_time};
\} ompt_record_target_kernel_t;
\end{boxedcode}
\ccppspecificend
}

\crossreferences
\begin{itemize}
\item \code{ompt\_id\_t} type, see
\specref{sec:ompt_id_t}.
\end{itemize}


\omptcallbacksignature{\code{ompt\_callback\_buffer\_request\_t}}
\index{ompt\_callback\_buffer\_request\_t@{\code{ompt\_callback\_buffer\_request\_t}}}
\label{sec:ompt_callback_buffer_request_t}

\summary
The OpenMP runtime will invoke a callback with type signature  
\code{ompt\_callback\_buffer\_request\_t} to request a
buffer to store event records for a device.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_buffer_request_t) (
  int \plc{device_id},
  ompt_buffer_t **\plc{buffer},
  size_t *\plc{bytes}
);
\end{boxedcode}
\ccppspecificend
}

\descr
The callback requests a buffer to store trace records for the
specified device.

A buffer request callback may set \plc{*bytes} to 0 if it does not
want to provide a buffer for any reason. If a callback sets
\plc{*bytes} to 0, further recording of events for the device will be
disabled until the next invocation of \code{ompt\_start\_trace}.  This
will cause the device to drop future trace records until recording is
restarted.

The buffer request callback is not required to be \emph{async signal safe}.

\argdesc

The \callbackarg{} \plc{device\_id} specifies the device. 

A tool should set \plc{*buffer} to point to a buffer where device events
may be recorded and \plc{*bytes} to the length of that buffer.  

\crossreferences
\begin{itemize}
\item \code{ompt\_buffer\_t} type, see
\specref{sec:ompt_buffer_t}.
\end{itemize}

\omptcallbacksignature{\code{ompt\_callback\_buffer\_complete\_t}}
\index{ompt\_callback\_buffer\_complete\_t@{\code{ompt\_callback\_buffer\_complete\_t}}}
\label{sec:ompt_callback_buffer_complete_t}
\summary
A device triggers a call to \code{ompt\_callback\_buffer\_complete\_t} when no further records will be recorded in an event buffer and all records written to the buffer are valid. 

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_buffer_complete_t) (
  int \plc{device_id},
  const ompt_buffer_t *\plc{buf},
  size_t \plc{bytes},
  ompt_buffer_cursor_t \plc{begin},
  int \plc{buffer_owned}
);
\end{boxedcode}
\ccppspecificend
}

\descr 
The callback provides a tool with a buffer containing trace records for the
specified device. Typically, a tool will iterate through the records
in the buffer and process them.

The OpenMP implementation will make these callbacks
on a thread that is not an OpenMP master or worker. 

The callee may delete the buffer if the \callbackarg{}
\plc{buffer\_owned}=0.

The buffer completion callback is not 
required to be \emph{async signal safe}.

\argdesc

The \callbackarg{} \plc{device\_id} indicates the device whose events
the buffer contains.

The \callbackarg{} \plc{buffer} is the address of a buffer previously
allocated by a \emph{buffer request} callback.

The \callbackarg{} \plc{bytes} indicates the full size of the buffer.

The \callbackarg{} \plc{begin} is an opaque cursor that indicates the
position at the beginning of the first record in the buffer.

The \callbackarg{} \plc{buffer\_owned} is 1 if the data pointed to by
buffer can be deleted by the callback and 0 otherwise. If multiple
devices accumulate trace events into a single buffer, this callback
might be invoked with a pointer to one or more trace records in a
shared buffer with \plc{buffer\_owned} = 0. In this case, the callback
may not delete the buffer.

\crossreferences
\begin{itemize}
\item \code{ompt\_buffer\_t} type, see
\specref{sec:ompt_buffer_t}.
\item \code{ompt\_buffer\_cursor\_t} type, see
\specref{sec:ompt_buffer_cursor_t}.
\end{itemize}

\omptcallbacksignature{\code{ompt\_callback\_control\_tool\_t}}
\index{ompt\_callback\_control\_tool\_t@{\code{ompt\_callback\_control\_tool\_t}}}
\label{sec:ompt_callback_control_tool_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_callback_control\_tool_t) (
  \longlongint{} \plc{command},
  \longlongint{} \plc{modifier},
  void *\plc{arg}
);
\end{boxedcode}
\ccppspecificend
}

\descr

The tool control callback may return any non-negative value, which will be returned to the 
application by the OpenMP implementation as the return value of the 
\code{omp\_control\_tool} call that triggered the callback.

\argdesc 

The \callbackarg{} \plc{command} passes a command from an application
to a tool.  Standard values for \plc{command} are defined by
\code{omp\_control\_tool\_t}.  defined in \specref{sec:control_tool}.

The \callbackarg{} \plc{modifier} passes a command modifier from an
application to a tool.

The callback allows tool-specific values for \plc{command} and
\plc{modifier}.  Tools must ignore \plc{command} values that they are
not explicitly designed to handle.

The \callbackarg{} \plc{arg} is a void pointer that enables a tool and
an application to pass arbitrary state back and forth. 
The \callbackarg{} \plc{arg} may be \code{NULL}.



\constraints
Tool-specific values for \plc{command} must be $\geq$ 64.

\crossreferences
\begin{itemize}
\item \code{omp\_control\_tool\_t} enumeration type, see \specref{sec:control_tool}.
\end{itemize}

\omptcallbacksignature{\code{ompt\_callback\_cancel\_t}}
\index{ompt\_callback\_cancel\_t@{\code{ompt\_callback\_cancel\_t}}}
\label{sec:ompt_callback_cancel_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_cancel_t) (
  ompt_data_t *\plc{task_data},
  int \plc{flags},
  const void *\plc{codeptr_ra}
  );
\end{boxedcode}
\ccppspecificend
}

\argdesc 

The \callbackarg{} \plc{task\_data} corresponds to the task
encountering a \code{cancel} construct, a \code{cancellation point}
construct, or a construct defined as having an implicit cancellation
point.

The \callbackarg{} \plc{flags}, defined by the enumeration
\code{ompt\_cancel\_flag\_t}, indicates whether the cancel is
activated by the current task, or detected as being activated by
another task.  The construct being canceled is also described in the
\plc{flags}. When several constructs are detected as being
concurrently canceled, each corresponding bit in the flags will be
set.

\codeptrdesc

\crossreferences
\begin{itemize}
\item \code{omp\_cancel\_flag\_t} enumeration type, see \specref{sec:ompt_cancel_flag_t}.
\end{itemize}


\omptcallbacksignature{\code{ompt\_callback\_device\_initialize\_t}}
\index{ompt\_callback\_flush\_t@{\code{ompt\_callback\_device\_initialize\_t}}}
\label{sec:ompt_callback_device_initialize_t}

\summary The tool callback with type signature
\code{ompt\_callback\_device\_initialize\_t} initializes a
tool's tracing interface for a device.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_device_initialize_t) (
  int \plc{device_id},
  const char *\plc{type},
  ompt_device_t *\plc{device},
  ompt_function_lookup_t *\plc{lookup},
  const char *\plc{documentation}
);
\end{boxedcode}
\ccppspecificend
}

\descr 

A tool that wants to asynchronously collect a trace of
activities on a device should register a callback with type signature
\code{ompt\_callback\_device\_initialize\_t} for the
\code{ompt\_callback\_device\_initialize} OpenMP event. An OpenMP
implementation will invoke this callback for a device after OpenMP is
initialized for the device but before beginning execution of any
OpenMP construct on the device.

\argdesc

The \callbackarg{} \plc{device\_id} identifies the logical device
being initialized.

The \callbackarg{} \plc{type} is a character string indicating the
type of the device. A device type string is a semicolon separated
character string that includes at a minimum the vendor and model name
of the device. This may be followed by a semicolon-separated sequence
of properties that describe a device's hardware or software.

\devicedesc

The \callbackarg{} \plc{lookup} is a pointer to a runtime callback
that a tool must use to obtain pointers to runtime entry points in the
device's OMPT tracing interface. If a device does not support tracing,
it should provide \code{NULL} for \plc{lookup}.

The \callbackarg{} \plc{documentation} is a string that describes
how to use any device-specific runtime
entry points that can be obtained using \plc{lookup}. This
documentation string could simply be a pointer to external
documentation, or it could be inline descriptions 
that includes names and type signatures for any
device-specific interfaces that are available through \plc{lookup}
along with descriptions of how to use these interface functions to
control monitoring and analysis of device traces.

\constraints
The \callbackarg{}s \plc{type} and \plc{documentation} must be
immutable strings that are defined for the lifetime of a program
execution.

\effect

A tool's device initializer has several duties.  First, it should use
\plc{type} to determine whether the tool has any special knowledge
about a device's hardware and/or software.  Second, it should use
\plc{lookup} to look up pointers to runtime entry points in the OMPT tracing
interface for the device.  Finally, using these runtime entry points, it can
then set up tracing for a device.

Initializing tracing for a target device is described in section
\specref{sec:tracing-device-activity}. 

\crossreferences
\begin{itemize}
\item \code{ompt\_function\_lookup\_t}, see
  \specref{sec:ompt_function_lookup_t}.
\end{itemize}

\section{Runtime Entry Points for Tools}
\label{sec:entry-points}

The OMPT interface supports two principal sets of runtime entry points for tools. One
set of runtime entry points enables a tool to register callbacks for OpenMP
events and to inspect the state of an OpenMP thread while
executing in a tool callback or a signal handler. The second set of runtime entry points enables a
tool to trace activities on a device. When directed by the tracing
interface, an OpenMP implementation will trace activities on a device, collect
buffers full of trace records, and invoke callbacks on the host to
process these records. 
Runtime entry points for tools in an OpenMP implementation
should not be global symbols since tools cannot rely on the visibility
of such symbols in general.

In addition, the OMPT interface supports
runtime entry points for two classes of lookup routines. The first
class of lookup routines contains a single member: a
routine that returns runtime entry points in the OMPT callback interface. 
The second class of lookup routines includes 
a unique lookup routine for each kind of
device that can return runtime entry points in a device's OMPT tracing interface.

\subsection{Entry Points in the OMPT Callback Interface}
\label{sec:ompt-callback-entry-points}

Entry points in the OMPT callback interface enable a tool to register
callbacks for OpenMP events and to inspect the state of an OpenMP thread while
executing in a tool callback or a signal handler. 
A tool obtains pointers to these runtime entry points 
using the lookup function passed to the tool's initializer for the
callback interface.

\omptruntimeentrypoint{\code{ompt\_enumerate\_states\_t}}
\label{sec:ompt_enumerate_states_t}
\label{sec:ompt_enumerate_states}

\summary
A runtime entry point known as \code{ompt\_enumerate\_states} 
with type signature \code{ompt\_enumerate\_states\_t} 
enumerates the thread states supported by an OpenMP 
implementation.

\format

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_enumerate_states_t)(
  int \plc{current_state}, 
  int *\plc{next_state}, 
  const char **\plc{next_state_name}
);
\end{boxedcode}
\ccppspecificend
}

\descr
An OpenMP implementation may support only a subset of the states defined by 
the \code{omp\_states\_t} enumeration type. In addition, an
OpenMP implementation may support implementation-specific states.
The \code{ompt\_enumerate\_states} runtime entry point enables a tool to 
enumerate the thread states supported by an OpenMP implementation.
 
When a thread state supported by an OpenMP implementation is passed
as the first argument to the runtime entry point,
the runtime entry point will assign the next thread state in the enumeration to
the variable passed by reference as the runtime entry point's second argument
and assign the name associated with the next thread state
to the character pointer passed by reference as the third argument.
 
Whenever one or more states are left in the enumeration, 
the enumerate states runtime entry point will return $1$.
When the last state in the enumeration is passed 
as the first argument, the runtime entry point will return $0$ 
indicating that the enumeration is complete.

\begin{comment}
For instance, a particular OpenMP implementation may want to 
provide more detail about the nature of runtime overhead, 
e.g., to differentiate between overhead associated with setting up 
parallel regions
and overhead associated with setting up tasks. 
% A tool need not report all states defined herein, e.g., if state tracking for a particular state would be too expensive.
To enable a tool to identify all states that an OpenMP implementation
supports, the following interface for enumerating all states that may be reported by the runtime that is being used.
\end{comment}

\argdesc

The \callbackarg{} \plc{current\_state} must be a thread state
supported by the OpenMP implementation.  To begin enumerating the
states that an OpenMP implementation supports, a tool should pass
\code{omp\_state\_undefined} as \plc{current\_state}.  Subsequent
invocations of the runtime entry point by the tool should pass the
value assigned to the variable passed by reference as the second
argument to the previous call.

The \callbackarg{} \plc{next\_state} is a pointer to an integer where
the entry point will return the value of the next state in the
enumeration. 

The \callbackarg{} \plc{next\_state\_name} is a pointer to a 
character string pointer, where the entry point will return a string
describing the next state.

\constraints
Any string returned through the \callbackarg{}
\plc{next\_state\_name} must be immutable and defined 
for the lifetime of a program execution.

\vspace{2ex}

\needspace{6\baselineskip}\notestart
\noteheader -- The following example illustrates how a tool can 
enumerate all states supported by an OpenMP implementation.
The example assumes that a function pointer to enumerate
the thread states supported by an OpenMP implementation
has previously been assigned to \code{ompt\_enumerate\_states\_fn}.

\vbox{
\ccppspecificstart
\begin{boxedcode}
int state = omp_state_undefined;
const char *state_name;
while (ompt_enumerate_states_fn(state, &state, &state_name)) \{
  // note that the runtime supports a state value "state" 
  // associated with the name "state_name" 
\}
\end{boxedcode}
\ccppspecificend
\noteend
}

\crossreferences
\begin{itemize}
\item \code{omp\_state\_t}, see \specref{sec:thread-states}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_enumerate\_mutex\_impls\_t}}
\label{sec:ompt_enumerate_mutex_impls_t}
\label{sec:ompt_enumerate_mutex_impls}
\label{sec:ompt_mutex_impl_unknown}
 
\summary

A runtime entry point known as \code{ompt\_enumerate\_mutex\_impls} 
with type signature \code{ompt\_enumerate\_mutex\_impls\_t} 
enumerates the kinds of mutual exclusion implementations that
an OpenMP implementation employs.


\format

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_enumerate_mutex_impls_t)(
  int \plc{current_impl}, 
  int *\plc{next_impl}, 
  const char **\plc{next_impl_name}
);

#define ompt_mutex_impl_unknown 0
\end{boxedcode}
\ccppspecificend
}

\descr
An OpenMP implementation may implement mutual exclusion for locks,
nest locks, critical sections, and atomic regions in several different
ways.  The \code{ompt\_enumerate\_mutex\_impls} runtime entry point
enables a tool to enumerate the 
kinds of mutual exclusion implementations that an OpenMP implementation
employs.
The value \code{ompt\_mutex\_impl\_unknown} is reserved to indicate an invalid
implementation.

\begin{comment}
For that reason, a user program can provide hints
to help the runtime system to select appropriate implementations.
When a lock or nest lock is initialized, the \code{ompt\_callback\_init\_lock}
callback receives the argument \code{kind}---a small integer that
indicates the lock implementation chosen by the OpenMP runtime.
Similarly, the \code{ompt\_callback\_mutex\_acquire} callback receives
the argument \code{kind} to indicate the implementation of a lock,
critical section, atomic region, or ordered section. 
\end{comment}

When a mutex kind supported by an OpenMP implementation is passed
as the first argument to the runtime entry point,
the runtime entry point will assign the next mutex kind in the enumeration to
the variable passed by reference as the runtime entry point's second argument
and assign the name associated with the next mutex kind 
to the character pointer passed by reference as the third argument.

Whenever one or more mutex kinds are left in the enumeration, 
the runtime entry point to enumerate mutex implementations will return $1$.
When the last mutex kind in the enumeration is passed 
as the first argument, the runtime entry point will return $0$ 
indicating that the enumeration is complete.

\argdesc

The \callbackarg{} \plc{current\_impl} must be a mutex implementation
kind supported by an OpenMP implementation.  To begin enumerating the
mutex implementation kinds that an OpenMP implementation supports, a
tool should pass \code{ompt\_mutex\_impl\_unknown} as the first
argument of the enumerate mutex kinds runtime entry point.  Subsequent
invocations of the runtime entry point by the tool should pass the
value assigned to the variable passed by reference as the second
argument to the previous call.

The \callbackarg{} \plc{next\_impl} is a pointer to an integer where
the entry point will return the value of the next mutex implementation
in the enumeration.

The \callbackarg{} \plc{next\_impl\_name} is a pointer to a character
string pointer, where the entry point will return a string describing
the next mutex implementation.

\constraints
Any string returned through the \callbackarg{}
\plc{next\_impl\_name} must be immutable and defined 
for the lifetime of a program execution.

\needspace{6\baselineskip}\notestart
\noteheader -- The following example illustrates how a tool can 
enumerate all types of mutex implementations supported by an OpenMP runtime.
The example assumes that a function pointer to enumerate
the mutex implementations supported by an OpenMP runtime 
has previously been assigned to \code{ompt\_enumerate\_mutex\_impls\_fn}.
\vspace{2ex}

\vbox{
\ccppspecificstart
\begin{boxedcode}
int kind = ompt_mutex_impl_unknown;
const char *impl_name;
while (ompt_enumerate_mutex_impls_fn(impl, &impl, &impl_name)) \{
  // note that the runtime supports a mutex value "impl" 
  // associated with the name "impl_name" 
\}
\end{boxedcode}
\ccppspecificend
\noteend
}


\omptruntimeentrypoint{\code{ompt\_callback\_set\_t}}
\label{sec:ompt_callback_set_t}
\label{sec:ompt_callback_set}

\summary

A runtime entry point known as \code{ompt\_callback\_set} 
with type signature \code{ompt\_callback\_set\_t} registers a
pointer to a tool callback that an OpenMP implementation will invoke when a host
OpenMP event occurs.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_callback_set_t)(
  ompt_callbacks_t \plc{which},
  ompt_callback_t \plc{callback}
);
\end{boxedcode}
\ccppspecificend
}

\descr

OpenMP implementations can inform tools about events that occur during
the execution of an OpenMP program using callbacks.
To register a tool callback for an OpenMP event on the current device, 
a tool uses the runtime entry point 
known as \code{ompt\_callback\_set} 
with type signature \code{ompt\_callback\_set\_t}.

The return value of the \code{ompt\_callback\_set} runtime entry point may indicate several possible
outcomes. Callback registration may fail if it is called outside the initializer for the
callback interface, returning \code{omp\_set\_error}. 
Otherwise, the return value of \code{ompt\_callback\_set} 
indicates whether \emph{dispatching} a callback leads to its invocation.
A return value of \code{ompt\_set\_never} indicates that the callback
will never be invoked at runtime.
A return value of \code{ompt\_set\_sometimes} indicates that the callback
will be invoked at runtime for an implementation-defined subset of
associated event occurrences.
A return value of \code{ompt\_set\_sometimes\_paired} is similar to 
\code{ompt\_set\_sometimes}, but provides an additional guarantee for 
callbacks with an \plc{endpoint} parameter. Namely, it guarantees that a callback 
with an \plc{endpoint} value of \code{ompt\_scope\_begin} is invoked if and only if
the same callback with \plc{endpoint} value of \code{ompt\_scope\_end} will 
also be invoked sometime in the future.
A return value of \code{ompt\_set\_always} indicates that the callback
will be always invoked at runtime for associated event occurrences.

\argdesc

The \callbackarg{} \plc{which} indicates the callback being registered. 

The \callbackarg{} \plc{callback} is a tool callback function. 

A tool may pass a \code{NULL} value for \plc{callback} to disable
any callback associated with \plc{which}. If disabling was successful,
\code{ompt\_set\_always} is returned.

\constraints
When a tool registers a callback for an event, the type
signature for the callback must match the type signature appropriate for the
event. 
 
\begin{table}
\begin{boxedcode}
typedef enum ompt_set_result_e \{
  ompt_set_error            = 0,
  ompt_set_none             = 1,
  ompt_set_sometimes        = 2,
  ompt_set_sometimes_paired = 3,
  ompt_set_always           = 4
\} ompt_set_result_t;
\end{boxedcode}
\vskip 1ex
\caption{Return codes for \code{ompt\_callback\_set} and
  \code{ompt\_set\_trace\_ompt}.}
\label{table:ToolsSupport_set_rc}
\end{table}

\crossreferences
\begin{itemize}
\item \code{ompt\_callbacks\_t} enumeration type, see \specref{sec:ompt_callbacks_t}.
\item \code{ompt\_callback\_t} type, see \specref{sec:ompt_callback_t}.
\item \code{ompt\_callback\_get\_t} host callback type signature,
see \specref{sec:ompt_callback_get_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_callback\_get\_t}}
\label{sec:ompt_callback_get_t}
\label{sec:ompt_callback_get}

\summary

A runtime entry point known as \code{ompt\_callback\_get} 
with type signature \code{ompt\_callback\_get\_t} retrieves a pointer
to a tool callback routine (if any) 
that an OpenMP implementation will invoke when an OpenMP event occurs.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_callback_get_t)(
  ompt_callbacks_t \plc{which},
  ompt_callback_t *\plc{callback}
);
\end{boxedcode}
\ccppspecificend
}

\descr
A tool uses the runtime entry point known 
as \code{ompt\_callback\_get} 
with type signature \code{ompt\_callback\_get\_t} 
to obtain a pointer to the tool callback that 
an OpenMP implementation will invoke when a host OpenMP event occurs. 
If a non-\code{NULL} tool callback is registered for the specified event, 
the pointer to the tool callback will be assigned to the variable
passed by reference as the second argument and the entry
point will return 1; otherwise, it will return 0. If the entry point
returns 0, the value of the variable passed by reference as the second
argument is undefined.

\argdesc

The \callbackarg{} \plc{which} indicates the callback being inspected.

The \callbackarg{} \plc{callback} is a pointer to a return value that
will be assigned the value of the callback being inspected.

\constraints
The second argument passed to the entry point must be a reference
to a variable of specified type.

\crossreferences
\begin{itemize}
\item \code{ompt\_callbacks\_t} enumeration type, see \specref{sec:ompt_callbacks_t}.
\item \code{ompt\_callback\_t} type, see \specref{sec:ompt_callback_t}.
\item \code{ompt\_callback\_set\_t} type signature, 
see \specref{sec:ompt_callback_set_t}. 
\end{itemize}


\omptruntimeentrypoint{\code{ompt\_get\_thread\_data\_t}}
\label{sec:ompt_get_thread_data_t}
\label{sec:ompt_get_thread_data}

\summary
A runtime entry point known as \code{ompt\_get\_thread\_data}
with type signature \code{ompt\_get\_thread\_data\_t} 
returns the address of the thread data object for the current thread.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef ompt_data_t *(*ompt_get_thread_data_t)(void);
\end{boxedcode}
\ccppspecificend}

\descr

Each OpenMP thread has an associated thread data object of type
\code{ompt\_data\_t}. 
A tool uses the runtime entry point known as
\code{ompt\_get\_thread\_data} 
with type signature \code{ompt\_get\_thread\_data\_t}
to obtain a pointer to the thread data object, if any, associated with the
current thread. If the current thread is unknown to the OpenMP
runtime, the entry point returns \code{NULL}.

A tool may use a pointer to an OpenMP thread's data object 
obtained from this runtime entry point to 
inspect or modify the value of the data object.
When an OpenMP thread is created, its data object will be initialized
with value \code{ompt\_data\_none}.  

This runtime entry point is \emph{async signal safe}.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see \specref{sec:ompt_data_t}.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Alex new proc_bind calls

\omptruntimeentrypoint{\code{ompt\_get\_num\_places\_t}}
\label{sec:ompt_get_num_places_t}
\label{sec:ompt_get_num_place}

\summary 

A runtime entry point known as
\code{ompt\_get\_num\_places} with type signature
\code{ompt\_get\_num\_places\_t}  returns 
the number of places available to the execution
environment in the place list.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_get_num_places_t)(void);
\end{boxedcode}
\ccppspecificend
}

\binding

The binding thread set for the region 
of the runtime entry point known as \code{ompt\_get\_num\_places} 
is all threads on a device. The effect of executing this 
routine is not related to any specific region corresponding 
to any construct or API routine.

\descr

The runtime entry point known as  \code{ompt\_get\_num\_places} 
returns the number of places in the place list. 
This value is equivalent to the number of places in 
the  \plc{place-partition-var} ICV in the execution environment 
of the initial task.

This runtime entry point is \emph{async signal safe}.

\crossreferences
\begin{itemize}
\item \plc{place-partition-var} ICV, see 
\specref{sec:Internal Control Variables}.

\item \code{OMP\_PLACES} environment variable, see 
\specref{sec:OMP_PLACES}.
\end{itemize}




\omptruntimeentrypoint{\code{ompt\_get\_place\_proc\_ids\_t}}
\label{sec:ompt_get_place_proc_ids_t}
\label{sec:ompt_get_place_proc_ids}

\summary 

A runtime entry point known as
\code{ompt\_get\_place\_proc\_ids} with type signature
\code{ompt\_get\_place\_proc\_ids\_t} 
returns the numerical identifiers of the processors
available to the execution environment in the specified place.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_get_place_proc_ids_t)(
    int \plc{place\_num},
    int \plc{ids\_size},
    int *\plc{ids}
  );
\end{boxedcode}
\ccppspecificend
}

\binding

The binding thread set for the region 
of the runtime entry point known as \code{ompt\_get\_place\_proc\_ids} 
is all threads on a device. The effect of executing this 
routine is not related to any specific region corresponding 
to any construct or API routine.

\descr

The runtime entry point known as
\code{ompt\_get\_place\_proc\_ids} with type signature
\code{ompt\_get\_place\_proc\_ids\_t} returns
the numerical identifiers of each processor
associated with the specified place. 
The numerical identifiers returned are non-negative, and
their meaning is implementation defined. 

\argdesc

The \callbackarg{} \plc{place\_num} specifies the place being
queried.

The \callbackarg{} \plc{ids\_size} indicates the size of the result
array specified by \callbackarg{} \plc{ids}.

The \callbackarg{} \plc{ids} is an array where the routine can return
a vector of processor identifiers in the specified place. 

\effect

If the array \plc{ids} of size \plc{ids\_size} is large enough to
contain all identifiers, they are returned in \plc{ids} and
their order in the array is implementation defined.

Otherwise, if the \plc{ids} array is too small, the values in 
\plc{ids} are unchanged.  

In both cases, the routine returns the number of numerical identifiers
available to the execution environment in the specified place.
 
% This runtime entry point is \emph{async signal safe}.


\omptruntimeentrypoint{\code{ompt\_get\_place\_num\_t}}
\label{sec:ompt_get_place_num_t}
\label{sec:ompt_get_place_num}

\summary 

A runtime entry point known as
\code{ompt\_get\_place\_num} with type signature
\code{ompt\_get\_place\_num\_t} returns 
the place number of the place to which the encountering 
thread is bound.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_get_place_num_t)(void);
\end{boxedcode}
\ccppspecificend
}

\binding

The binding thread set for the region 
of the runtime entry point known as \code{ompt\_get\_place\_num} 
is the encountering thread.

\descr

When the encountering thread is bound to a place, 
the runtime entry point known as \code{ompt\_get\_place\_num} 
returns the place number associated with the thread. 
The returned value is between 0 and one less than the value returned 
by runtime entry point known as \code{ompt\_get\_num\_places}, inclusive. 
When the encountering thread is not bound to a place, the routine returns -1.

This runtime entry point is \emph{async signal safe}.


\omptruntimeentrypoint{\code{ompt\_get\_partition\_place\_nums\_t}}
\label{sec:ompt_get_partition_place_nums_t}
\label{sec:ompt_get_partition_place_nums}

\summary 

A runtime entry point known as
\code{ompt\_get\_partition\_place\_nums} with type signature
\code{ompt\_get\_partition\_place\_nums\_t} 
returns the list of place numbers corresponding to the places in the \plc{place-partition-var}
ICV of the innermost implicit task.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_get_partition_place_nums_t)(
    int \plc{place\_nums\_size},
    int *\plc{place\_nums}
  );
\end{boxedcode}
\ccppspecificend
}

\binding

The binding task set for the region 
of the runtime entry point known as \code{ompt\_get\_partition\_place\_nums}
is the encountering implicit task.

\descr

The runtime entry point known as
\code{ompt\_get\_partition\_place\_nums} with type signature
\code{ompt\_get\_partition\_place\_nums\_t} returns the list of place
numbers corresponding to the places in the \plc{place-partition-var}
ICV of the innermost implicit task.

This runtime entry point is \emph{async signal safe}.

\argdesc

The \callbackarg{} \plc{place\_nums\_size} indicates the size of the result
array specified by \callbackarg{} \plc{place\_nums}.

The \callbackarg{} \plc{place\_nums} is an array where the routine can return
a vector of place identifiers.

\effect

If the array \plc{place\_nums} of size \plc{place\_nums\_size} is
large enough to contain all identifiers, they are returned in
\plc{place\_nums} and their order in the array is implementation
defined.

In both cases, the routine returns the number of places in the
\plc{place-partition-var} ICV of the innermost implicit task.

\crossreferences
\begin{itemize}
\item \plc{place-partition-var} ICV, see 
\specref{sec:Internal Control Variables}.

\item \code{OMP\_PLACES} environment variable, see 
\specref{sec:OMP_PLACES}.

\end{itemize}





\omptruntimeentrypoint{\code{ompt\_get\_proc\_id\_t}}
\label{sec:ompt_get_proc_id_t}
\label{sec:ompt_get_proc_id}

\summary 

A runtime entry point known as
\code{ompt\_get\_proc\_id} with type signature
\code{ompt\_get\_proc\_id\_t} returns the numerical identifier 
of the processor of the encountering thread.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_get_proc_id_t)(void);
\end{boxedcode}
\ccppspecificend
}

\binding

The binding thread set for the region 
of the runtime entry point known as \code{ompt\_get\_proc\_id} 
is the encountering thread.

\descr

The runtime entry point known as 
\code{ompt\_get\_proc\_id} returns the numerical identifier 
of the processor of the encountering thread.
The numerical identifier is non-negative, and
its meaning is implementation defined. 

This runtime entry point is \emph{async signal safe}.




 

\omptruntimeentrypoint{\code{ompt\_get\_state\_t}}
\label{sec:ompt_get_state_t}
\label{sec:ompt_get_state}

\summary
A runtime entry point known as \code{ompt\_get\_state}
with type signature \code{ompt\_get\_state\_t} 
returns the state and the wait identifier of the 
current thread. 

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef omp_state_t (*ompt_get_state_t)(
  ompt_wait_id_t *\plc{wait_id}       
);
\end{boxedcode}
\ccppspecificend}

\descr

Each OpenMP thread has an associated state and a wait identifier.  If
a thread's state indicates that the thread is waiting for mutual
exclusion, the thread's wait identifier will contain an opaque handle
that indicates the data object upon which the thread is waiting.

To retrieve the state and wait identifier for the current thread,
a tool uses the runtime entry point known as
\code{ompt\_get\_state} with type signature \code{ompt\_get\_state\_t}.

If the returned state indicates that the thread is waiting for a
lock, nest lock, critical section, atomic region, or ordered region
the value of the thread's wait identifier will be assigned to a
non-\code{NULL} wait identifier passed as an argument.

This runtime entry point is \emph{async signal safe}.

\argdesc

The \callbackarg{} \plc{wait\_id} is a pointer to an opaque handle
available to receive the value of the thread's wait identifier.  If
the \plc{wait\_id} pointer is not \code{NULL}, the entry point
will assign the value of the thread's wait identifier 
*\plc{wait\_id}.  If the returned state is not one of the specified
wait states, the value of *\plc{wait\_id} is undefined after the call.

\constraints
The argument passed to the entry point must be a reference
to a variable of the specified type or \code{NULL}.

\crossreferences
\begin{itemize}
\item \code{ompt\_wait\_id\_t} type, see \specref{sec:ompt_wait_id_t}.
\end{itemize}


\omptruntimeentrypoint{\code{ompt\_get\_parallel\_info\_t}} 
\label{sec:ompt_get_parallel_info_t}
\label{sec:ompt_get_parallel_info}

\summary

A runtime entry point known as \code{ompt\_get\_parallel\_info} 
with type signature \code{ompt\_get\_parallel\_info\_t} 
returns information about
the parallel region, if any, at the specified ancestor level 
for the current execution context.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_get_parallel_info_t)(
  int \plc{ancestor_level},
  ompt_data_t **\plc{parallel_data},
  int *\plc{team_size}
);
\end{boxedcode}
\ccppspecificend}

\descr
During execution, an OpenMP program may employ nested parallel
regions. 
To obtain information about a parallel region, 
a tool uses the runtime entry point known as
\code{ompt\_get\_parallel\_info} 
with type signature \code{ompt\_get\_parallel\_info\_t}. 
This runtime entry point
can be used to obtain information about the current parallel region,
if any, and any enclosing parallel regions
for the current execution context.

The entry point returns 1 if there is a parallel region at the
specified ancestor level and 0 otherwise.

A tool may use the pointer to a parallel region's data object that it
obtains from this runtime entry point to inspect or modify the value
of the data object.  When a parallel region is created, its data
object will be initialized with the value \code{ompt\_data\_none}.

This runtime entry point is \emph{async signal safe}.

\argdesc

The \callbackarg{} \plc{ancestor\_level} specifies the parallel region
of interest to a tool by its ancestor level.  Ancestor level 0 refers
to the innermost parallel region; information about enclosing parallel
regions may be obtained using larger ancestor levels.  

If a parallel region exists at the specified ancestor level,
information will be returned in the variables \plc{parallel\_data} and
\plc{team\_size} passed by reference to the entry point.
Specifically, a reference to the parallel region's associated data
object will be assigned to *\plc{parallel\_data} and the number of
threads in the parallel region's team will be assigned to
*\plc{team\_size}.

If no enclosing parallel region exists at the specified ancestor
level, the values of variables passed by reference
*\plc{parallel\_data} and *\plc{team\_size} will be undefined when the
entry point returns.

\constraints
While \callbackarg{} \plc{ancestor\_level} is passed by
value, all other arguments to the entry point must be references
to variables of the specified types.


\restrictions
If a thread is in the state \code{omp\_state\_wait\_barrier\_implicit\_parallel},
a call to \code{ompt\_get\_parallel\_info}
may return a pointer to a copy of the specified parallel region's \plc{parallel\_data}
rather than a pointer to the data word for the region itself. This convention enables the master thread
for a parallel region to free storage for the region immediately after the region ends, yet
avoid having some other thread in the region's team
potentially reference the region's \plc{parallel\_data} object after it has been freed.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see \specref{sec:ompt_data_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_get\_task\_info\_t}}
\label{sec:ompt_get_task_info_t}
\label{sec:ompt_get_task_info}

\summary
A runtime entry point known as \code{ompt\_get\_task\_info} 
with type signature \code{ompt\_get\_task\_info\_t} provides information about the
task, if any, at the specified ancestor level in the current execution
context.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_get_task_info_t)(
  int \plc{ancestor_level},
  ompt_task_type_t *\plc{type},
  ompt_data_t **\plc{task_data},
  ompt_frame_t **\plc{task_frame},
  ompt_data_t **\plc{parallel_data},
  int *\plc{thread_num}
);
\end{boxedcode}
\ccppspecificend}

\descr
During execution, an OpenMP thread may be executing an OpenMP task.
Additionally, the thread's stack may contain
procedure frames associated with suspended OpenMP tasks or
OpenMP runtime system routines.
To obtain information about any task on the current thread's stack, 
a tool uses the runtime entry point known as
\code{ompt\_get\_task\_info} 
with type signature \code{ompt\_get\_task\_info\_t}. 

Ancestor level 0 refers to the active task; information about
other tasks with associated frames present on the stack in the current execution context may be queried at
higher ancestor levels.  The \code{ompt\_get\_task\_info} runtime entry point
returns 1 if there is a task region at the
specified ancestor level and 0 otherwise. 

If a task exists at the specified ancestor level, information
will be returned in the variables passed by reference to the entry
point.  If no task region exists at the specified ancestor level, the
values of variables passed by reference to the entry point will be
undefined when the entry point returns.

A tool may use a pointer to a data object for a task or parallel
region that it obtains from this runtime entry point to inspect or modify the
value of the data object.  When either a parallel region or a task
region is created, its data object will be initialized with the value
\code{ompt\_data\_none}.

This runtime entry point is \emph{async signal safe}.

\argdesc

The \callbackarg{} \plc{ancestor\_level} specifies the task region
of interest to a tool by its ancestor level.  Ancestor level 0 refers
to the active task; information about
ancestor tasks found in the current execution context may be queried at
higher ancestor levels.  

The \callbackarg{} \plc{type} is pointer to a task type return
value or a \code{NULL} if no task type return value is required.

The \callbackarg{} \plc{task\_data} is a pointer to a task data
pointer return value
or a \code{NULL} if no task data pointer return value is required.


The \callbackarg{} \plc{task\_frame} is a pointer to a task frame
pointer return value 
or a \code{NULL} if no task frame pointer return value is required.

The \callbackarg{} \plc{parallel\_data} is a pointer to a parallel
data pointer return value 
or a \code{NULL} if no parallel data pointer return value is required.

The \callbackarg{} \plc{thread\_num} is a pointer to a return value
for a thread number 
or a \code{NULL} if no thread number return value is required.

\effect
\begin{comment}
Task types that a tool may observe on a thread's stack include
initial, implicit, explicit, target, and degenerate tasks.  
In this
context, a degenerate task indicates a sequence of one or more
procedure frames from the OpenMP runtime system that appears on a
thread's stack between a pair of stack frames for user procedures that
are both associated with the same task.
\end{comment}

If the runtime entry point returns 0, no return values will be set.
Otherwise, the entry point has the effects described below.

If a non-\code{NULL} value was passed for \plc{type}, 
the value returned in *\plc{type} represents the type of the task
at the specified level.  
Task types that a tool may observe on a thread's stack include
initial, implicit, explicit, and target tasks.  

If a non-\code{NULL} value was passed for \plc{task\_data}, 
the value returned in *\plc{task\_data} is a pointer to a data word
associated with the task at the specified level.

If a non-\code{NULL} value was passed for \plc{task\_frame}, 
the value returned in *\plc{task\_frame} is a pointer to the 
\code{ompt\_frame\_t} structure associated with the task at the specified level.
Appendix~\ref{chap:frames} discusses an example that
illustrates the use of \code{ompt\_frame\_t} structures with multiple
threads and nested parallelism.

If a non-\code{NULL} value was passed for \plc{parallel\_data}, 
the value returned in *\plc{parallel\_data} is a pointer to a data word
associated with the parallel region containing the task at the specified level.  
If the task at the specified level is an initial task,
the value of *\plc{parallel\_data} will be \code{NULL}.

If a non-\code{NULL} value was passed for \plc{thread\_num}, 
the value returned in *\plc{thread\_num}
indicates the number of the thread in the parallel region executing the task.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see \specref{sec:ompt_data_t}.
\item \code{ompt\_frame\_t} type, see \specref{sec:ompt_frame_t}.
\item \code{ompt\_task\_type\_t} type, see
  \specref{sec:ompt_task_type_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_get\_target\_info\_t}}
\label{sec:ompt_get_target_info_t}
\label{sec:ompt_get_target_info}

\summary
A runtime entry point known as \code{ompt\_get\_target\_info} 
with type signature \code{ompt\_get\_target\_info\_t} returns identifiers that specify a
thread's current target region and target operation id, if any.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_get_target_info_t)(
  int *\plc{device_id},
  ompt_id_t *\plc{target_id},
  ompt_id_t *\plc{host_op_id}
);
\end{boxedcode}
\ccppspecificend}

\descr
A tool can query whether an OpenMP thread is in a target region by
invoking the entry point known as \code{ompt\_get\_target\_info} 
with type signature \code{ompt\_get\_target\_info\_t}.
This runtime entry point returns 1 if the invoking thread is
in a target region and 0 otherwise. If the entry point returns 0,
the values of the variables passed by reference as its arguments
are undefined.

If the invoking thread is in a target region, the entry point will
return information about the current device, active target region, and
active host operation, if any.

This runtime entry point is \emph{async signal safe}.

\argdesc

The \callbackarg{} \plc{device\_id} is a pointer to a return value for
the current device. If the host is in a \code{target} region, 
the target device will be returned in *\plc{device\_id}.

The \callbackarg{} \plc{target\_id} is a pointer to a return value for
the target region identifier. If the host is in a \code{target} region, 
the \code{target} region identifier will be returned in *\plc{target\_id}.

The \callbackarg{} \plc{host\_op\_id} is a pointer to a return value
for an identifer for an operation being initiated on a \code{target}
device.  If the invoking thread is in the process of initiating an
operation on a target device (e.g., copying data to or from an
accelerator or launching a kernel) the identifier for the operation
being initiated will be returned in *\plc{host\_op\_id}; otherwise,
*\plc{host\_op\_id}.  will be set to \code{ompt\_id\_none}.

\constraints

Arguments passed to the entry point must be valid
references to variables of the specified types.

\crossreferences
\begin{itemize}
\item \code{ompt\_id\_t} type, see \specref{sec:ompt_id_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_get\_num\_devices\_t}}
\label{sec:ompt_get_num_devices_t}
\label{sec:ompt_get_num_devices}

\summary
A runtime entry point known as \code{ompt\_get\_num\_devices} 
with type signature \code{ompt\_get\_num\_devices\_t} 
returns the number of available devices.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_get_num_devices_t)(void);
\end{boxedcode}
\ccppspecificend}

\descr

An OpenMP program may execute on one or more devices.
A tool may determine the number of devices available to an OpenMP
program by invoking a runtime entry point 
known as \code{ompt\_get\_num\_devices} 
with type signature \code{ompt\_get\_num\_devices\_t}.

This runtime entry point is \emph{async signal safe}.


\begin{comment}
%% this entry point became obsolete with the definition of 
%% ompt_get_target_info_t
\omptruntimeentrypoint{\code{ompt\_get\_device\_id\_t}}
\label{sec:ompt_get_device_id_t}
\label{sec:ompt_get_device_id}

\summary
A runtime entry point known as
\code{ompt\_get\_device\_id} 
with type signature \code{ompt\_get\_device\_id\_t} 
returns the device identifier for the active target device. 

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_get_device_id_t)(void);
\end{boxedcode}
\ccppspecificend}

\descr

A runtime entry point known as
\code{ompt\_get\_device\_id} with type signature
\code{ompt\_get\_device\_id\_t} returns the device identifier for the
active target device.  This routine is only supported on the
host. If the routine is invoked by a thread not executing in
the scope of a target, target data, or target update construct, then
it will return a value of -1.

This runtime entry point is \emph{async signal safe}.
\end{comment}

\subsection{Entry Points in the OMPT Device Tracing Interface}
\label{sec:ompt-tracing-entry-points}

\omptruntimeentrypoint{\code{ompt\_get\_device\_time\_t}}
\label{sec:ompt_get_device_time_t}

\summary
A runtime entry point for a device known 
as \code{ompt\_get\_device\_time} 
with type signature \code{ompt\_get\_device\_time\_t} 
returns the current time on the specified device.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef ompt_device_time_t (*ompt_get_device_time_t)(
  ompt_device_t *\plc{device}
);
\end{boxedcode}
\ccppspecificend}

\descr
Host and target devices are typically distinct and run independently.
If host and target devices are different hardware components, they
may use different clock generators. For this reason,  there may be
no common time base for ordering host-side and device-side events.

A runtime entry point for a device known 
as \code{ompt\_get\_device\_time} with type signature 
\code{ompt\_get\_device\_time\_t} 
returns the current time on the specified device.
A tool can use this information 
to align time stamps from different devices.

\argdesc

The \callbackarg{} \plc{device} is a pointer to an opaque object that
represents the target device instance. The pointer to the device
instance object is used by functions in the device tracing interface
to identify the device being addressed.

\crossreferences
\begin{itemize}
\item \code{ompt\_device\_t},
see \specref{sec:ompt_device_t}.
\item \code{ompt\_device\_time\_t},
see \specref{sec:ompt_device_time_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_translate\_time\_t}}
\label{sec:ompt_translate_time_t}

\summary
A runtime entry point for a device known 
as \code{ompt\_translate\_time} 
with type signature \code{ompt\_translate\_time\_t} translates
a time value obtained from the specified device to a corresponding time
value on the host device. 

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef double (*ompt_translate_time_t)(
  ompt_device_t *\plc{device},
  ompt_device_time_t \plc{time}
);
\end{boxedcode}
\ccppspecificend}

\descr
A runtime entry point for a device known as \code{ompt\_translate\_time} 
with type signature \code{ompt\_translate\_time\_t} translates
a time value obtained from the specified device to a corresponding time
value on the host device. The returned value for the host time has
the same meaning as the value returned from \code{omp\_get\_wtime}.

\needspace{6\baselineskip}\notestart
\noteheader -- 
The accuracy of time translations may degrade if they are not
performed promptly after a device time value is received if either
the host or device vary their clock speeds. Prompt translation of
device times to host times is recommended.
\noteend

\argdesc

The \callbackarg{} \plc{device} is a pointer to an opaque object that
represents the target device instance. The pointer to the device
instance object is used by functions in the device tracing interface
to identify the device being addressed.

The \callbackarg{} \plc{time} is a time from the specified device.

\crossreferences
\begin{itemize}
\item \code{ompt\_device\_t},
see \specref{sec:ompt_device_t}.
\item \code{ompt\_device\_time\_t},
see \specref{sec:ompt_device_time_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_set\_trace\_ompt\_t}}
\label{sec:ompt_set_trace_ompt_t}

\summary
A runtime entry point for a device known as \code{ompt\_set\_trace\_ompt} 
with type signature \code{ompt\_set\_trace\_ompt\_t} 
enables or disables the recording of trace records for one or more
types of OMPT events.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_set_trace_ompt_t)(
  ompt_device_t *\plc{device},
  unsigned int \plc{enable},
  unsigned int \plc{etype}
);
\end{boxedcode}
\ccppspecificend}

\argdesc

\devicedesc

The \callbackarg{} \plc{enable} indicates whether tracing should be
enabled or disabled for the event or events specified by
\callbackarg{} \plc{etype}. A positive value for \plc{enable}
indicates that recording of one or more events specified by
\plc{etype} should be enabled; a value of 0 for \plc{enable} indicates
that recording of events should be disabled by this invocation.

An \callbackarg{} \plc{etype} value 0 indicates that traces for all
event types will be enabled or disabled.  Passing a positive value for
\plc{etype} inidicates that recording should be enabled or disabled
for the event in \code{ompt\_callbacks\_t} that matches \plc{etype}.


\effect

Table~\ref{table:record_set} shows the possible return
codes for \code{ompt\_set\_trace\_ompt}.  If a single invocation
of \code{ompt\_set\_trace\_ompt} is used to enable or disable
more than one event (i.e., \code{etype}=0), the return code will
be 3 if tracing is possible for one or more events but not for
others.

\begin{table}
\centering
\begin{tabular}{|l|l|}
\hline
return code & meaning \\\hline
0 & error\\\hline
1 & event will never occur\\\hline
2 & event may occur but no tracing is possible\\\hline
3 & event may occur and will be traced when convenient\\\hline
4 & event may occur and will always be traced if event occurs\\\hline
\end{tabular}
\vskip 1ex
\caption{Meaning of return codes for \code{ompt\_trace\_set\_ompt} and
  \code{ompt\_set\_trace\_native}.}
\label{table:record_set}
\end{table}


\crossreferences
\begin{itemize}
\item \code{ompt\_callbacks\_t},
see \specref{sec:ompt_callbacks_t}.
\item \code{ompt\_device\_t},
see \specref{sec:ompt_device_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_set\_trace\_native\_t}}
\label{sec:ompt_set_trace_native_t}

\summary
A runtime entry point for a device known as \code{ompt\_set\_trace\_native} 
with type signature \code{ompt\_set\_trace\_native\_t} 
enables or disables the recording of native trace records for a device.


\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_set_trace_native_t)(
  ompt_device_t *\plc{device},
  int \plc{enable},
  int \plc{flags}
);
\end{boxedcode}
\ccppspecificend}

\descr
This interface is designed for use by a tool with no knowledge about
an attached device. If a tool knows how to program a particular
attached device, it may opt to invoke native control functions
directly using pointers obtained through the \plc{lookup} function
associated with the device and described in the \plc{documentation}
string that is provided to the device initializer callback.

\argdesc
\devicedesc

The \callbackarg{} \plc{enable} indicates whether recording of events
should be enabled or disabled by this invocation.  

The \callbackarg{} \plc{flags} specifies the kinds of native device
monitoring to enable or disable.
Each kind of monitoring is specified by a flag bit.
Flags can be composed by using logical {\ttfamily or}  to combine enumeration
values from type \code{ompt\_native\_mon\_flags\_t}.
Table~\ref{table:record_set} shows the possible return codes for
\code{ompt\_set\_trace\_native}.  If a single invocation of
\code{ompt\_set\_trace\_ompt} is used to enable/disable more
than one kind of monitoring, the return code will be 3 if tracing
is possible for one or more kinds of monitoring but not for others.

To start, pause, or stop tracing for a specific target device
associated with the handle \plc{device}, a tool calls the functions
\code{ompt\_start\_trace}, \code{ompt\_pause\_trace}, or
\code{ompt\_stop\_trace}.


\crossreferences
\begin{itemize}
\item \code{ompt\_device\_t},
see \specref{sec:ompt_device_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_start\_trace\_t}}
\label{sec:ompt_start_trace_t}

\summary
A runtime entry point for a device known as \code{ompt\_start\_trace} 
with type signature \code{ompt\_start\_trace\_t} 
starts tracing of activity on a specific device.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_start_trace_t)(
  ompt_device_t *\plc{device},
  ompt_callback_buffer_request_t \plc{request},
  ompt_callback_buffer_complete_t \plc{complete},
  ompt_callback_get_target_info_t \plc{get_info}
);
\end{boxedcode}
\ccppspecificend}

\descr
This runtime entry point enables tracing on a device. It provides tool
callbacks that the device uses to request a buffer from a tool for
recording events and a second calback that the device uses to return a
buffer containing events to the tool. 

Under normal operating conditions, every event buffer provided to
a device by the tool will be returned to the tool
before the OpenMP runtime shuts down. 
If an exceptional condition terminates  execution of an OpenMP
program, the OpenMP runtime may not return buffers provided to the
device.

\argdesc

\devicedesc

The \callbackarg{} \emph{buffer request} specifies a tool callback
that will supply a device with a buffer to deposit events.

The \callbackarg{} \emph{buffer complete} specifies a tool callback
that will be invoked by the OpenMP implmementation to empty a buffer
containing event records.

The \callbackarg{} \plc{get\_info} is a function that a device can use
to map device activity back to identifiers that indicate where the
activity was initiated by the host.

\crossreferences
\begin{itemize}
\item \code{ompt\_device\_t},
see \specref{sec:ompt_device_t}.
\item \code{ompt\_callback\_buffer\_request\_t},
see \specref{sec:ompt_callback_buffer_request_t}.
\item \code{ompt\_callback\_buffer\_complete\_t},
see \specref{sec:ompt_callback_buffer_complete_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_pause\_trace\_t}}
\label{sec:ompt_pause_trace_t}

\summary
A runtime entry point for a device known as \code{ompt\_pause\_trace} 
with type signature \code{ompt\_pause\_trace\_t} 
pauses or restarts activity tracing on a specific device.

\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_pause_trace_t)(
  ompt_device_t *\plc{device},
  int \plc{begin_pause}
);
\end{boxedcode}
\ccppspecificend}

\descr

A tool may pause or resume tracing on a device by invoking the device's
\code{ompt\_pause\_trace} runtime entry point.  

\argdesc

\devicedesc

The \callbackarg{} \plc{begin\_pause} indicates whether to pause or
resume tracing.
To resume tracing, zero should be supplied for \plc{begin\_pause}.
The entry point will
return 0 if the request fails, e.g., if tracing for a device has not
been started, and return a non-zero return code otherwise. 
Redundant pause or resume commands are idempotent and will
return a non-zero value indicating success.  

\crossreferences
\begin{itemize}
\item \code{ompt\_device\_t},
see \specref{sec:ompt_device_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_stop\_trace\_t}}
\label{sec:ompt_stop_trace_t}

\summary
A runtime entry point for a device known as \code{ompt\_stop\_trace} 
with type signature \code{ompt\_stop\_trace\_t} 
stops tracing for a device.

\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_stop_trace_t)(
  ompt_device_t *\plc{device}
);
\end{boxedcode}
\ccppspecificend}

\descr
Each invocation returns 1 if the command succeeded and 0 otherwise.
A call to \code{ompt\_stop\_trace} also implicitly requests that the device flush any buffers that it owns.

\argdesc

\devicedesc


%%? johnmc says: we should export one more function from a target device: ompt_target_scope(begin/end, host_id)
%% this function will be used by the OpenMP runtime when a target device is being monitored to signal the target device when 
%% (1) entering and leaving a target region
%% (2) before and after launching a kernel
%% (3) before and after performing a data operation: copy, allocation, release, ...
%% this function will enable the target device to associate device_activity_ids with some host_id that either represents a 
%% target region, target data operation, or target kernel submission

\crossreferences
\begin{itemize}
\item \code{ompt\_device\_t},
see \specref{sec:ompt_device_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_advance\_buffer\_cursor\_t}}
\label{sec:ompt_advance_buffer_cursor_t}

%There are several routines that need to be used together to process %target event records deposited in a buffer by a device. 

\summary
A runtime entry point for a device known as \code{ompt\_advance\_buffer\_cursor} 
with type signature \code{ompt\_advance\_buffer\_cursor\_t}
advances a trace buffer cursor to the next record.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_advance_buffer_cursor_t)(
  ompt_buffer_t *\plc{buffer},
  size_t \plc{size}, 
  ompt_buffer_cursor_t \plc{current}, 
  ompt_buffer_cursor_t *\plc{next}
); 
\end{boxedcode}
\ccppspecificend}

\descr
It returns \code{true} if the advance is successful and the next
position in the buffer is valid.

\argdesc

\devicedesc
 
The \callbackarg{} \plc{buffer} indicates a trace buffer associated
with the cursors.

The \callbackarg{} \plc{size} indicates the size of \plc{buffer} in
bytes.

The \callbackarg{} \plc{current} is an opaque buffer cursor.

The \callbackarg{} \plc{next} is a pointer to a return value for the
next value of a opaque buffer cursor.

\crossreferences
\begin{itemize}
\item \code{ompt\_device\_t},
see \specref{sec:ompt_device_t}.
\item \code{ompt\_buffer\_cursor\_t},
see \specref{sec:ompt_buffer_cursor_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_buffer\_get\_record\_type\_t}}
\label{sec:ompt_buffer_get_record_type_t}

\summary
A runtime entry point for a device known as
\code{ompt\_buffer\_get\_record\_type} with type signature
\code{ompt\_buffer\_get\_record\_type\_t} inspects the type
of a trace record for a device.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef ompt_record_type_t (*ompt_buffer_get_record_type_t)(
  ompt_buffer_t *\plc{buffer}, 
  ompt_buffer_cursor_t \plc{current}
);
\end{boxedcode}
\ccppspecificend}

\descr

Trace records for a device may be in one of two forms: a
\emph{native} record format, which may be device-specific,
or an \emph{OMPT} record format, where each trace record 
corresponds to an OpenMP \emph{event} and fields in the record
structure are mostly the arguments that would be passed to the
OMPT callback for the event. 

A runtime entry point for a device known as
\code{ompt\_buffer\_get\_record\_type} with type signature
\code{ompt\_buffer\_get\_record\_type\_t} inspects the type
of a trace record and indicates whether the record at the current
position in the provided trace buffer is an OMPT record, 
a native record, or an invalid record. An invalid record type
is returned if the cursor is out of bounds.

\argdesc
The \callbackarg{} \plc{buffer} indicates a trace buffer. 

The \callbackarg{} \plc{current} is an opaque buffer cursor.

\begin{comment}
\crossreferences
Appendix~\ref{appendix:ompt-records} defines the corresponding enumeration type for \code{ompt\_record\_kind\_t}. 
Section~\ref{sec:native-record-data} describes the interface to use for accessing native record types.
\end{comment}


\crossreferences
\begin{itemize}
\item \code{ompt\_buffer\_t},
see \specref{sec:ompt_buffer_t}.
\item \code{ompt\_buffer\_cursor\_t},
see \specref{sec:ompt_buffer_cursor_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_buffer\_get\_record\_ompt\_t}}
\label{sec:ompt_buffer_get_record_ompt_t}
 
\summary
A runtime entry point for a device known as \code{ompt\_buffer\_get\_record\_ompt} 
with type signature \code{ompt\_buffer\_get\_record\_ompt\_t} 
obtains a pointer to an OMPT trace record from a trace buffer associated with a device.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef ompt_record_ompt_t *(*ompt_buffer_get_record_ompt_t)(
  ompt_buffer_t *\plc{buffer}, 
  ompt_buffer_cursor_t \plc{current}
);
\end{boxedcode}
\ccppspecificend}

\descr

This function returns a pointer that may point to a record in the
trace buffer, or it may point to a record in thread local storage
where the information extracted from a record was assembled. The
information available for an event depends upon its type.

The return value of type \code{ompt\_record\_ompt\_t} 
defines a union type that can represent
information for any OMPT event record type.
Another call to the runtime entry point may overwrite the
contents of the fields in a record returned by a prior invocation.

\argdesc
The \callbackarg{} \plc{buffer} indicates a trace buffer. 

The \callbackarg{} \plc{current} is an opaque buffer cursor.

\crossreferences
\begin{itemize}
\item \code{ompt\_record\_ompt\_t},
see \specref{sec:ompt_record_ompt_t}. 
\item \code{ompt\_device\_t},
see \specref{sec:ompt_device_t}.
\item \code{ompt\_buffer\_cursor\_t},
see \specref{sec:ompt_buffer_cursor_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_buffer\_get\_record\_native\_t}}
\label{sec:ompt_buffer_get_record_native_t}

\summary

A runtime entry point for a device known as
\code{ompt\_buffer\_get\_record\_native} with type signature
\code{ompt\_buffer\_get\_record\_native\_t} 
obtains a pointer to a native trace record from a trace buffer associated with a device.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef void *(ompt_buffer_get_record_native_t)(
  ompt_buffer_t *\plc{buffer}, 
  ompt_buffer_cursor_t \plc{current},
  ompt_id_t *\plc{host_op_id}
);
\end{boxedcode}
\ccppspecificend}

\descr

The pointer returned  may point into the specified trace buffer, or into
thread local storage where the information extracted from a trace
record was assembled. The information available for a native event
depends upon its type. If the function returns a non-NULL result,
it will also set \code{*host\_op\_id} to identify host-side identifier
for the operation associated with the record.  A subsequent call
to \code{ompt\_buffer\_get\_record\_native} may overwrite the
contents of the fields in a record returned by a prior invocation.

\argdesc
The \callbackarg{} \plc{buffer} indicates a trace buffer. 

The \callbackarg{} \plc{current} is an opaque buffer cursor.

The \callbackarg{} \plc{host\_op\_id} is a pointer to an identifier
that will be returned by the function. The entry point will set 
*\plc{host\_op\_id} to the value of a host-side identifier for an operation on
a target device that was created when the operation was initiated by
the host. 


\crossreferences
\begin{itemize}
\item \code{ompt\_id\_t},
see \specref{sec:ompt_id_t}.
\item \code{ompt\_buffer\_t},
see \specref{sec:ompt_buffer_t}.
\item \code{ompt\_buffer\_cursor\_t},
see \specref{sec:ompt_buffer_cursor_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_buffer\_get\_record\_native\_abstract\_t}}
\label{sec:ompt_buffer_get_record_native_abstract_t}

\summary
A runtime entry point for a device known as
\code{ompt\_buffer\_get\_record\_native\_abstract} 
with type signature
\code{ompt\_buffer\_get\_record\_native\_abstract\_t} 
summarizes the context of a native (device-specific) trace record.  

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef ompt_record_native_abstract_t *
(*ompt_buffer_get_record_native_abstract_t)(
  void *\plc{native_record} 
);
\end{boxedcode}
\ccppspecificend}

\descr
An OpenMP implementation may execute on a device that logs 
trace records in a native (device-specific) format unknown to a tool.
A tool can use the \code{ompt\_buffer\_get\_record\_native\_abstract} 
runtime entry point for the device with type signature
\code{ompt\_buffer\_get\_record\_native\_abstract\_t} 
to decode a native trace record that it
does not understand into a standard form that it can interpret. 

\argdesc

The \callbackarg{} \plc{native\_record} is a pointer to a native trace
record.

\crossreferences
\begin{itemize}
\item \code{ompt\_record\_native\_abstract\_t},
see \specref{sec:ompt_record_native_abstract_t}.
\end{itemize}

\subsection{Lookup Entry Point}

\omptruntimeentrypoint{\code{ompt\_function\_lookup\_t}}
\label{sec:ompt_function_lookup_t}
\label{sec:ompt_function_lookup}

\summary
A tool uses a lookup routine with type signature 
\code{ompt\_function\_lookup\_t}
to obtain pointers to runtime entry points that are
part of the OMPT interface.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef ompt_interface_fn_t (*ompt_function_lookup_t) (
  const char *\plc{interface_function_name}
);
\end{boxedcode}
\ccppspecificend
}

\descr

An OpenMP implementation provides a pointer to a lookup routine as an
argument to tool callbacks used to initialize tool support for
monitoring an OpenMP device using either tracing or callbacks.

\begin{comment}
When an OpenMP runtime implementation is initialized for a device,
if a tool callback to initialize tracing for devices has been provided
to the OpenMP implementation by \code{ompt\_start\_tool}, 
it will be invoked on the host. The OpenMP implementation will pass the
tool's device tracing initializer callback a lookup routine that the tool
can use to obtain pointers to runtime entry points that implement
tracing control routines appropriate for that device. 

If a tool callback to initialize monitoring using the OMPT callback
interface has been provided to the OpenMP implementation by
\code{ompt\_start\_tool} and it is invoked on a device,
the initializer will be passed a lookup function that it can use   
to obtain pointers to runtime entry points.
\end{comment}

When an OpenMP implementation invokes a tool initializer to configure
the OMPT callback interface, the OpenMP implementation will pass the
initializer a lookup function that the tool can use to obtain 
pointers to runtime entry points that implement routines that are part of 
the OMPT callback interface.

When an OpenMP implementation invokes a tool initializer to configure
the OMPT tracing interface for a device, the Open implementation will
pass the device tracing initializer a lookup function that the tool
can use to obtain pointers to runtime entry points that implement
tracing control routines appropriate for that device. 

A tool can call the lookup function to obtain a pointer to a runtime
entry point.

\argdesc
The \callbackarg{} \plc{interface\_function\_name} is a C string
that represents the name of a runtime entry point.

\crossreferences
\begin{itemize}
\item Entry points in the OMPT callback interface, see
  \tabref{table:ompt-callback-interface-functions} for a list and
  \specref{sec:ompt-callback-entry-points} for detailed definitions.
\item Tool initializer for a device's OMPT tracing interface, \specref{sec:tracing-device-activity}.
\item Entry points in the OMPT tracing interface, see
  \tabref{table:ompt-tracing-interface-functions} for a list and
  \specref{sec:ompt-tracing-entry-points} for detailed definitions.
\item Tool initializer for the OMPT callback interface, \specref{sec:ompt_initialize_t}
\end{itemize}
% This is the end of ch4-toolsSupport.tex
