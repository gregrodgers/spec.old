% This is ch4-toolsSupport.tex of the OpenMP specification.
% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%

\newcommand{\ompttype}[1]{\subsubsection{#1}}  % section 4.5.7
\newcommand{\omptcallbacksignature}[1]{\subsubsection{#1}}  % section 4.8.2
\newcommand{\omptruntimeentrypoint}[1]{\subsubsection{#1}}  % sections 4.9.*
\newcommand{\ompteventswithoutdirectives}[1]{\littleheader{#1}}

\chapter{Tool Support}
\index{Tools Support}
\label{chap:ToolsSupport}

To enable development of high-quality, \emph{first-party} tools
that support monitoring and performance analysis of OpenMP programs
developed using any implementation of the OpenMP API, the OpenMP API
includes a tool interface known as OMPT. The OMPT interface can be
implemented entirely by an OpenMP runtime system, entirely by a
compiler, or with a hybrid strategy that employs a mixture of compiler
and runtime support. This chapter describes the OMPT interface.

This chapter begins with an overview of the OMPT tool interface in
Section~\ref{sec:ompt-overview}. Next,
Section~\ref{sec:ompt-initialization} describes how a tool can register itself to use the OMPT
interface. Subsequent sections describe details of the interface, including
data types shared between an OpenMP implementation and a tool
(Section~\ref{sec:ompt-data-types}), 
type signatures for tool callbacks 
that an OpenMP implementation may invoke for OpenMP events
(Section~\ref{sec:ompt-tool-callbacks}), and 
tool \emph{entry points}---function interfaces
provided by an OpenMP implementation for use by a tool
(Section~\ref{sec:entry-points}). 

\section{Overview}
\label{sec:ompt-overview}

The OMPT interface defines mechanisms for initializing a tool,
exploring the details of an OpenMP implementation, examining OpenMP state
associated with an OpenMP thread, interpreting an OpenMP thread's call stack,
receiving notification about OpenMP \emph{events}, tracing activity on 
OpenMP target devices, and controlling a tool from an OpenMP application.

\section{Activating a Tool}
\label{sec:ompt-initialization}

There are three steps to activating a tool. First, an OpenMP
implementation determines whether a tool should be initialized.  If
so, the OpenMP implmentation invokes the tool's initializer, enabling
the tool to prepare to monitor the execution on the host. Finally, a
tool may arrange to monitor execution of of computations offloaded
onto target devices. This section explains how the tool and an 
OpenMP implementation interact to accomplish accomplish these tasks.

\subsection{Determining Whether a Tool Should be Initialized}
\label{sec:ompt-check-tool}

A tool indicates its interest in using an OpenMP implementation's OMPT interface 
by providing a definition of the function symbol
\code{ompt\_tool} to the OpenMP implementation. There are three ways
that a tool can provide a definition of \code{ompt\_tool} to an
OpenMP implementation:

\begin{itemize}
\item statically-linking the tool's definition of \code{ompt\_tool}
  into an OpenMP application, 
\item introducing a dynamically-linked library that includes the tool's definition
  of \code{ompt\_tool} into the application's address space, or 
\item providing the name of a dynamically-linked library appropriate
  for the architecture and operating system used by the application
  in the \code{OMP\_TOOL\_LIBRARIES} environment variable.
\end{itemize}

Immediately before an OpenMP implementation initializes itself, it
checks to see if it should to check for the presence of a tool
interested in using the OMPT interface by examining the \plc{tool-var}
ICV.  If value of \plc{tool-var} is \plc{disabled}, the OpenMP
implementation will initialize itself without even checking whether a
tool is present and the functionality of the OMPT interface will be
unavailable as the program executes.
 
If the value of \plc{tool-var} is \plc{enabled}, the OpenMP
implementation will check to see if a tool has provided an
implmentation of \code{ompt\_tool}.  The OpenMP implementation first
checks if a tool-provided implementation of \code{ompt\_tool} is
available in the address space, either statically-linked into the
application or in a dynamically-linked library loaded in the address
space.

If no tool-provided implementation of \code{ompt\_tool} is found in
the address space, the OpenMP implementation will consult the
\plc{tool-libraries-var} ICV, which contains a (possibly empty) list
of dynamically-linked libraries.  As described in detail in
Section~\ref{ompt-libraries}, the libraries in
\plc{tool-libraries-var}, will be searched for the first usable
implementation of \code{ompt\_tool} provided by one of the libraries
in the list.

If a tool-provided definition of \code{ompt\_tool} is found using
either method, the OpenMP implementation will invoke it; if it returns
a non-\code{NULL} pointer to a tool initializer, with type signature
\code{ompt\_initialize\_fn\_t}, the OpenMP implementation will know
that a tool is present that wants to use the OMPT interface.

Next, the OpenMP implementation will initialize itself. If a tool
provided a pointer to a tool initializer to the OpenMP implementation
as described above by returning one from \code{ompt\_tool}, the OpenMP
runtime will prepare itself for use of the OMPT interface by a tool. 

\crossreferences
\begin{itemize}
\item \code{ompt\_tool}, see \specref{sec:ompt_tool}.
\item \code{ompt\_initialize\_fn\_t}, see \specref{sec:ompt_initialize_fn_t}.
\item \code{OMP\_TOOL\_LIBRARIES}, see \specref{sec:OMP_TOOL_LIBRARIES}.
\item \plc{tool-libraries-var} ICV, see \specref{sec:Internal Control Variables}.
\item \plc{tool-var} ICV, see \specref{sec:Internal Control Variables}.
\end{itemize}

\subsection{Tool Initialization}
\index{tool initialization}
\label{sec:tool-initialize}

If a tool-provided implementation of \code{ompt\_tool} returns a
pointer to a tool initializer with type signature
\code{ompt\_initialize\_fn\_t},
the OpenMP implementation will invoke the tool initializer prior to
the occurrence of any OpenMP \emph{event}. 

A tool's initializer, described in \specref{sec:ompt_initialize_fn_t}
has several duties.  First, it should use its third argument
\plc{ompt\_version} to determine whether it is compatibile with the
version of the OMPT interface that the OpenMP implementation supports.
Next, it must use its second argument \plc{lookup} to look up pointers
to OMPT interface tool entry points provided by the OpenMP
implementation; this process is described in \specref{sec:ompt-bind}.
After obtaining a pointer to the OpenMP tool entry point known as
known as \code{ompt\_callback\_set} with type signature
\code{ompt\_callback\_set\_t}, the tool initializer should use it to
register tool callbacks for OpenMP events, as described in
\specref{sec:ompt-register-callbacks}.

Finally, a tool initializer may wish to use the OMPT interface tool
entry points known as \code{ompt\_enumerate\_states} and
\code{ompt\_enumerate\_mutex\_impls}, which have type signatures
\code{ompt\_enumerate\_states\_t} and
\code{ompt\_enumerate\_mutex\_impls\_t}, to determine what thread
states and implementations of mutual exclusion a particular OpenMP
implementation employs. The definitions of the enumeration entry point
type signatures show how to use them to introspect an OpenMP
implementation's support for thread states and mutual exclusion.

\crossreferences
\begin{itemize}
\item \code{ompt\_initialize\_fn\_t}, see \specref{sec:ompt_initialize_fn_t}.
\item \code{ompt\_function\_lookup\_t}, see \specref{sec:ompt_function_lookup_t}.
\item \code{ompt\_callback\_set\_t}, see \specref{sec:ompt_callback_set_t}.
\item \code{ompt\_enumerate\_states\_t}, see \specref{sec:ompt_enumerate_states_t}.
\item \code{ompt\_enumerate\_mutex\_impls\_t}, see
  \specref{sec:ompt_enumerate_mutex_impls_t}.
\end{itemize}

After executing the tool initializer, an OpenMP implementation invokes
a registered \code{ompt\_callback\_thread\_begin} in the initial
thread. The callback occurs in the context of the thread.  The
callback has type signature \code{ompt\_callback\_thread\_begin\_t}.

\subsubsection{Binding Entry Points in the OMPT Callback Interface}
\label{sec:ompt-bind}

Functions that an OpenMP implementation provides to support the OMPT interface
are not defined as global function symbols. Instead, they are defined as entry points 
that a tool can only identify using the \plc{lookup} function provided as an
argument to the tool's initializer. This design avoids tool
implementations that
will fail in certain circumstances when functions defined as part of
the OpenMP runtime are not visible to a tool, even though the tool and
the OpenMP runtime are both present in the same address space.
 
A tool's initializer receives a function pointer to a
\plc{lookup} runtime entry point with type signature
\code{ompt\_function\_lookup\_t}  as its first argument. Using this
function, a tool initializer may obtain a pointer to
each of the runtime entry points that an OpenMP implementation provides to support
the OMPT interface.

For each runtime entry point in the OMPT interface for the host device, 
Table~\ref{table:ompt-callback-interface-functions} provides the string
name by which it is known and the type signature of the entry point. 
During initialization, a tool should look up each runtime entry point in the
OMPT interface by name and bind a pointer maintained by the tool
that it can use later to invoke the entry point as needed. The entry points
described in Table~\ref{table:ompt-callback-interface-functions}
enable a tool to introspect an OpenMP
implementation's support for thread states and mutual exclusion,
register tool callbacks with an OpenMP implementation, inspect 
callbacks registered with an OpenMP implementation, 
introspect OpenMP state associated with threads, and use tracing to monitor
computations offloaded onto target devices.

Detailed information about each runtime entry point listed in 
Table~\ref{table:ompt-callback-interface-functions} is included as
part of the description of its type signature.

\begin{table}
\begin{tabular}{ll}\hline
Entry Point String Name & Type signature\\\hline\hline
``\code{ompt\_enumerate\_states}'' & \code{ompt\_enumerate\_states\_t}\\
``\code{ompt\_enumerate\_mutex\_impls}'' & \code{ompt\_enumerate\_mutex\_impls\_t}\\
``\code{ompt\_callback\_set}'' & \code{ompt\_callback\_set\_t}\\
``\code{ompt\_callback\_get}'' & \code{ompt\_callback\_get\_t}\\
``\code{ompt\_get\_thread\_data}'' & \code{ompt\_get\_thread\_data\_t}\\
``\code{ompt\_get\_state}'' & \code{ompt\_get\_state\_t}\\
``\code{ompt\_get\_parallel\_info}'' & \code{ompt\_get\_parallel\_info\_t}\\
``\code{ompt\_get\_task\_info}'' & \code{ompt\_get\_task\_info\_t}\\
``\code{ompt\_get\_num\_devices}'' & \code{ompt\_get\_num\_devices\_t}\\
``\code{ompt\_get\_device\_id}'' & \code{ompt\_get\_device\_id\_t}\\
``\code{ompt\_callback\_device\_initialize}'' & \code{ompt\_callback\_device\_initialize\_t}\\\hline
\end{tabular}
\vskip 1ex
\caption{OMPT callback interface entry point names and their type signatures.}
\label{table:ompt-callback-interface-functions} 
\end{table}

\crossreferences
\begin{itemize}
\item \code{ompt\_enumerate\_states\_t}, see \specref{sec:ompt_enumerate_states_t}.
\item \code{ompt\_enumerate\_mutex\_impls\_t}, see
  \specref{sec:ompt_enumerate_mutex_impls_t}.
\item \code{ompt\_callback\_set\_t}, see \specref{sec:ompt_callback_set_t}.
\item \code{ompt\_callback\_get\_t}, see \specref{sec:ompt_callback_get_t}.
\item \code{ompt\_get\_thread\_data\_t}, see \specref{sec:ompt_get_thread_data_t}.
\item \code{ompt\_get\_state\_t}, see \specref{sec:ompt_get_state_t}.
\item \code{ompt\_get\_parallel\_info\_t}, see \specref{sec:ompt_get_parallel_info_t}.
\item \code{ompt\_get\_task\_info\_t}, see \specref{sec:ompt_get_task_info_t}.
\item \code{ompt\_get\_num\_devices\_t}, see \specref{sec:ompt_get_num_devices_t}.
\item \code{ompt\_get\_device\_id\_t}, see \specref{sec:ompt_get_device_id_t}.
\item \code{ompt\_callback\_device\_initialize\_t}, see
  \specref{sec:ompt_callback_device_initialize_t}.
\end{itemize}

\subsection{Monitoring Activity on the Host}
\index{event callback registration}
\label{sec:ompt-register-callbacks}

To monitor execution of an OpenMP program on the host device, a tool's
initializer must register to receive notification
of events that occur as an OpenMP program executes.  
A tool can register callbacks for OpenMP events using
an OpenMP implementation's tool entry point known by the name
\code{ompt\_callback\_set}.  The possible return codes for
\code{ompt\_callback\_set} and their meanings are shown in
Table~\ref{table:ToolsSupport_set_rc}.  Registration of supported
callbacks may fail if the \code{ompt\_callback\_set} entry point is
called outside a tool's initializer.

All callbacks registered with \code{ompt\_callback\_set} or returned
by \code{ompt\_callback\_get} use the dummy type signature
\code{ompt\_callback\_t}.  While this is a compromise, it is better
than providing unique entry points with a precise type signatures to
set and get the callback for each unique entry point type signature.

Table~\ref{table:valid_rc} indicates the return codes permissible when
trying to register a callback for different events.
Some events always need to invoke a registered callback.
For other events, its implementation-defined whether they invoke the registered
callback never, sometimes, or always.
The return code enables a tool to know what to expect for an event
that has an implementation-defined behavior.

\begin{table}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{lp{3em}p{3em}p{3em}p{3em}}
                                & \rot{event may occur; no callback is possible}
                                & \rot{event may occur; callback invoked when convenient}
                                & \rot{event may occur; callback always invoked when event occurs}\\
                                \midrule
\code{ompt\_callback\_thread\_begin}          &   &   & * \\
\code{ompt\_callback\_thread\_end}            &   &   & * \\
\code{ompt\_callback\_parallel\_begin}        &   &   & * \\
\code{ompt\_callback\_parallel\_end}          &   &   & * \\
\code{ompt\_callback\_task\_create}           &   &   & * \\
\code{ompt\_callback\_task\_schedule}         &   &   & * \\
\code{ompt\_callback\_implicit\_task}         &   &   & * \\
\code{ompt\_callback\_target}                 &   &   & * \\
\code{ompt\_callback\_target\_data}       &   &   & * \\
\code{ompt\_callback\_target\_submit}         &   &   & * \\
\code{ompt\_callback\_tcontrol}               &   &   & * \\
\code{ompt\_callback\_idle}                   & * & * & * \\
\code{ompt\_callback\_sync\_region\_wait}     & * & * & * \\
\code{ompt\_callback\_mutex\_release}         & * & * & * \\
\code{ompt\_callback\_task\_dependences}      & * & * & * \\
\code{ompt\_callback\_task\_dependence} & * & * & * \\
\code{ompt\_callback\_work}                   & * & * & * \\
\code{ompt\_callback\_master}                 & * & * & * \\
\code{ompt\_callback\_target\_map}            & * & * & * \\
\code{ompt\_callback\_sync\_region}           & * & * & * \\
\code{ompt\_callback\_init\_lock}             & * & * & * \\
\code{ompt\_callback\_destroy\_lock}          & * & * & * \\
\code{ompt\_callback\_mutex\_acquire}         & * & * & * \\
\code{ompt\_callback\_mutex\_acquired}        & * & * & * \\
\code{ompt\_callback\_nested\_lock}           & * & * & * \\
\code{ompt\_callback\_flush}                  & * & * & * \\
\code{ompt\_callback\_device\_initialize}     & * & * & * \\
\code{ompt\_callback\_cancel}                 & * & * & * \\
\bottomrule
\end{tabular}
\vskip 1ex
\caption{Valid return codes of \code{ompt\_callback\_set} for each callback.}
\label{table:valid_rc}
\end{table}

To avoid a tool interface specification that enables a tool to
register unique callbacks for an overwhelming number of events,
the interface was collapsed in several ways.
First, in cases where events are naturally paired, e.g., the beginning and
end of a region, and the arguments needed by the callback at each
endpoint were identical, the pair of events was collapsed so that a
a tool registers a single callback that will be invoked at both endpoints
with \code{ompt\_scope\_begin} or \code{ompt\_scope\_end} provided
as an argument to identify which endpoint the callback invocation reflects.
Second, when a whole class of events is amenable to uniform treatment, only a
single callback is provided for a family of events, e.g.,  a
\code{ompt\_callback\_sync\_region\_wait} callback is used for multiple
kinds of synchronization regions, i.e., barrier, taskwait, and taskgroup
regions. Some events involve both kinds of collapsing: the aforementioned
\code{ompt\_callback\_sync\_region\_wait} represents
a callback that will be invoked at each endpoint for different kinds
of synchronization regions.

\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_t} enumeration type, see
\specref{sec:ompt_callback_t}.
\item \code{ompt\_callback\_set\_t} type signature, see \specref{sec:ompt_callback_set_t}
\item \code{ompt\_callback\_t} type signature, see \specref{sec:ompt_callback_t}.

\item \code{ompt\_callback\_thread\_begin\_t}, see \specref{sec:ompt_callback_thread_begin}. 
\item \code{ompt\_callback\_thread\_end}, see \specref{sec:ompt_callback_thread_end}. 
\item {\em incomplete cross references stubbed out} 
\begin{comment}
\item \code{ompt\_callback\_parallel\_begin}, see \specref
\item \code{ompt\_callback\_parallel\_end}, see \specrefdependences
\item \code{ompt\_callback\_task\_create}, see \specref
\item \code{ompt\_callback\_task\_schedule}, see \specref
\item \code{ompt\_callback\_implicit\_task}, see \specref
\item \code{ompt\_callback\_target}, see \specref
\item \code{ompt\_callback\_target\_data}, see \specref
\item \code{ompt\_callback\_target\_submit}, see \specref
\item \code{ompt\_callback\_tcontrol}, see \specref
\end{comment}
\item \code{ompt\_callback\_idle}, see \specref{sec:ompt_callback_idle}. 
\item \code{ompt\_callback\_sync\_region\_wait}, see \specref{sec:ompt_callback_runtime_shutdown}.
\item {\em incomplete cross references stubbed out} 
\begin{comment}
\item \code{ompt\_callback\_mutex\_release}, see \specref
\item \code{ompt\_callback\_task\_dependences}, see \specref
\item \code{ompt\_callback\_task\_dependence}, see \specref
\item \code{ompt\_callback\_worksharing}, see \specref
\item \code{ompt\_callback\_master}, see \specref
\item \code{ompt\_callback\_target\_data\_map}, see \specref
\item \code{ompt\_callback\_sync\_region}, see \specref
\item \code{ompt\_callback\_init\_lock}, see \specref
\item \code{ompt\_callback\_destroy\_lock}, see \specref
\item \code{ompt\_callback\_mutex\_acquire}, see \specref
\item \code{ompt\_callback\_mutex\_acquired}, see \specref
\item \code{ompt\_callback\_nested\_lock}, see ...
\end{comment}
\item \code{ompt\_callback\_flush}, see \specref{subsec:flush Construct}.
\item \code{ompt\_callback\_device\_initialize}, see \specref{sec:Device Constructs}.
\item \code{ompt\_callback\_cancel}, see \specref{sec:Cancellation Constructs}.
\end{itemize}


\subsection{Tracing Activity on Target Devices}
\index{tracing device activity}
\label{sec:tracing-device-activity}

A target device may or may not initialize a full OpenMP runtime system.
Unless it does, it may not be possible to monitor activity 
on a device using a tool interface based on callbacks.
To accommodate such cases, the OMPT interface defines 
a performance monitoring interface for tracing activity on target
devices. Tracing activity on a target device involves the following
steps:

\begin{itemize}
\item To prepare to trace activity on a target device, when a tool
  initializer executes, it must register a tool callback for the
  \code{ompt\_callback\_device\_initialize} event.
\item When an OpenMP implementation initializes a target device, the
  OpenMP implementation will invoke the tool's device initialization
  callback. If the target device does not support tracing, it
  will provide a \code{NULL} to the device initializer for its
  \plc{lookup} argument; otherwise, the target device will pass the
  tool's device initializer a pointer to a runtime
  entry point with type signature \code{ompt\_function\_lookup\_t}.
\item If the device initializer for the tool receives a
  non-\code{NULL} \plc{lookup} pointer, the tool may use it to query
  entry points in the tracing interface provided by the target device
  and bind the function pointers returned to tool variables.
  Table~\ref{table:ompt-tracing-interface-functions} indicates the
  names of the entry points that a target device may provide for use
  by a tool.  If \plc{lookup} is non-\code{NULL}, the device will
  provide entry points that enable a tool to control the device's
  interface for collecting traces in its \emph{native} trace format,
  which may be device specific. Some devices may also allow a tool to
  collect traces of records in a standard format known as OMPT format,
  described in this document. If so, the \plc{lookup} function will
  return values for the entry points in the trace interface for
  collecting and decoding OMPT traces.\footnote{A device's native
    tracing format may be OMPT format. In that case, tracing can be
    controlled using either the entry points for native or OMPT
    tracing.}

\begin{table}
\addtocounter{footnote}{1}
{\small
\begin{tabular}{ll}\hline
Entry Point String Name & Type Signature\\\hline\hline
``\code{ompt\_get\_device\_time}'' & \code{ompt\_get\_device\_time\_t}\\
``\code{ompt\_translate\_time}'' & \code{ompt\_translate\_time\_t}\\
``\code{ompt\_set\_trace\_ompt}''\footnotemark[\value{footnote}] & \code{ompt\_set\_trace\_ompt\_t}\\
``\code{ompt\_set\_trace\_native}'' & \code{ompt\_set\_trace\_native\_t}\\
``\code{ompt\_start\_trace}'' & \code{ompt\_start\_trace\_t}\\
``\code{ompt\_pause\_trace}'' & \code{ompt\_pause\_trace\_t}\\
``\code{ompt\_stop\_trace}'' & \code{ompt\_stop\_trace\_t}\\
``\code{ompt\_advance\_buffer\_cursor}'' & \code{ompt\_advance\_buffer\_cursor\_t}\\
``\code{ompt\_buffer\_get\_record\_type}'' & \code{ompt\_buffer\_get\_record\_type\_t}\\
``\code{ompt\_buffer\_get\_record\_ompt}''\footnotemark[\value{footnote}] & \code{ompt\_buffer\_get\_record\_ompt\_t}\\
``\code{ompt\_buffer\_get\_record\_native}'' & \code{ompt\_buffer\_get\_record\_native\_t}\\
``\code{ompt\_buffer\_get\_record\_native\_abstract}'' & \code{ompt\_buffer\_get\_record\_native\_abstract\_t}\\\hline
\end{tabular}
}
\vskip 1ex
\caption{OMPT tracing interface entry point names and their type signatures.}
\label{table:ompt-tracing-interface-functions} 
\end{table}

\item The tool will use the \code{ompt\_set\_trace\_native}
  and/or the \code{ompt\_set\_trace\_ompt} entry point to specify what
  types of events or activities to monitor on the target device.
\item The tool will initiate tracing using \code{ompt\_start\_trace},
  providing the target device with two tool callbacks: one to allocate
  a buffer where the target device can deposit trace events and a
  second that will receive a buffer of trace events. 
\item When the target device needs a trace buffer, it invokes the
  tool-supplied callback function to request a new buffer.
\item The target device will monitor execution on the target device as
  directed and record a trace of events or activities into a trace
  buffer. If the device is capable, device trace records will be
  marked with a \plc{host\_op\_id}---an identifier used to associate
  device activities with the target operation initiated on the host
  that caused these activities.  To correlate activities on the host
  with activities on a device, a tool can register a
  callback for the \code{ompt\_callback\_target\_submit} event, which
  will notify the host thread when and where it is offloading work to a
  target device and provide the tool with the \plc{host\_op\_id} for
  the offloaded work.
\item When appropriate, e.g., when a trace buffer fills or needs to be
  flushed, the target device will invoke the tool-supplied buffer
  completion callback to process a non-empty sequence of
  records in a trace buffer. 

\footnotetext{These entry points will
  only be available for target devices that support collection of
  standard traces in OMPT format.}

\item The tool-supplied buffer completion callback may return
  immediately, ignoring records in the trace buffer, or it may iterate
  through them using the \code{ompt\_advance\_buffer\_cursor} entry
  point
  and inspect each one. A tool may inspect the type of the record at
  the current cursor position using the \code{ompt\_get\_record\_type}
  entry point.  A tool may choose to inspect the contents of some or
  all records in a trace buffer using the \code{ompt\_get\_record\_ompt},
  \code{ompt\_get\_record\_native}, or
  \code{ompt\_get\_record\_native\_abstract} entry point.  Presumably, a tool that
  chooses to use the \code{ompt\_get\_record\_native} entry point to
  inspect records will have some knowledge about a device's native
  trace format.  A tool may always use the
  \code{ompt\_get\_record\_native\_abstract} entry point to inspect a trace
  record; this entry point will decode the contents of a native trace
  and summarize them in a standard format, namely, a
  \code{ompt\_record\_native\_abstract\_t} record.
  Only a record in OMPT format can be retrieved using the
  \code{ompt\_get\_record\_ompt} entry point.
\item Once tracing has been started, a tool may pause or resume
  tracing on a device at any time by invoking
  \code{ompt\_pause\_trace} with an appropriate flag value as an
  argument.  
\item A tool may start or stop tracing at any time using the 
  \code{ompt\_start\_trace} or \code{ompt\_stop\_trace} entry points,
  respectively. When tracing is stopped, all trace records already
  collected will eventually be flushed and presented to the tool using
  its buffer completion callback.
\item It is legal to shut down OpenMP while device tracing 
is in progress.  
\item When OpenMP is shut down, any device tracing in progress will be
  stopped and all trace records collected on a device will be flushed
  and presented to the tool using its buffer completion callback.
\end{itemize}


\crossreferences
\begin{itemize}
\item \code{ompt\_get\_device\_time}, see \specref{sec:ompt_get_device_time_t}.
\item \code{ompt\_translate\_time}, see \specref{sec:ompt_translate_time_t}.
\item\code{ompt\_set\_trace\_ompt}, see \specref{sec:ompt_set_trace_ompt_t}.
\item \code{ompt\_set\_trace\_native}, see \specref{sec:ompt_set_trace_native_t}.
\item \code{ompt\_start\_trace}, see \specref{sec:ompt_start_trace_t}.
\item \code{ompt\_pause\_trace}, see \specref{sec:ompt_pause_trace_t}.
\item \code{ompt\_stop\_trace}, see \specref{sec:ompt_stop_trace_t}.
\item \code{ompt\_advance\_buffer\_cursor}, see \specref{sec:ompt_advance_buffer_cursor_t}.
\item \code{ompt\_buffer\_get\_record\_type}, see \specref{sec:ompt_buffer_get_record_type_t}.
\item \code{ompt\_buffer\_get\_record\_ompt}, see \specref{sec:ompt_buffer_get_record_ompt_t}.
\item \code{ompt\_buffer\_get\_record\_native}, see \specref{sec:ompt_buffer_get_record_native_t}.
\item \code{ompt\_buffer\_get\_record\_native\_abstract}, see \specref{sec:ompt_buffer_get_record_native_abstract_t}.
\end{itemize}

\section{Data Types}
\label{sec:ompt-data-types}
\subsection{Thread States}
\label{sec:thread-states}

To enable a tool to understand the behavior of an executing program, 
an OpenMP implementation maintains a state for each thread. 
The state maintained for a thread is an
approximation of the thread's instantaneous state. 

\vbox{
\ccppspecificstart
A thread's state will be one of the values of the  
enumeration type \code{omp\_state\_t} or
an implementation-defined state value of 512 or higher. 
Thread states in the enumeration fall into several classes: 
work, barrier wait, task wait, mutex wait, target wait, 
and miscellaneous. 

\begin{boxedcode}
typedef enum omp_state_t \{
  omp_state_work_serial            = 0x000,
  omp_state_work_parallel          = 0x001,
  omp_state_work_reduction         = 0x002,

  omp_state_wait_barrier           = 0x010,
  omp_state_wait_barrier_implicit  = 0x011,
  omp_state_wait_barrier_explicit  = 0x012,

  omp_state_wait_taskwait          = 0x020,
  omp_state_wait_taskgroup         = 0x021,

  omp_state_wait_mutex             = 0x040,
  omp_state_wait_lock              = 0x041,
  omp_state_wait_critical          = 0x042,
  omp_state_wait_atomic            = 0x043,
  omp_state_wait_ordered           = 0x044,

  omp_state_wait_target            = 0x080,
  omp_state_wait_target_map        = 0x081,
  omp_state_wait_target_update     = 0x082,

  omp_state_idle                   = 0x100, 
  omp_state_overhead               = 0x101, 
  omp_state_undefined              = 0x102
\} omp_state_t;
\end{boxedcode}
\ccppspecificend
}


A tool can query the OpenMP state of a thread at any time. 
If a tool queries the state of a thread that is not associated 
with OpenMP, the implementation reports the state as \code{omp\_state\_undefined}.

\begin{comment}
For each OpenMP thread the runtime maintains not only a state but also an \code{ompt\_wait\_id\_t}
identifier.  When a thread is waiting for a lock, critical region,
ordered, or atomic, and the thread is in a wait
state, then 
the thread's \code{wait\_id} field identifies the lock, critical construct, ordered construct, atomic construct, or internal variable
upon which the
thread is waiting. The semantics of the values used for a \code{wait\_id} are implementation defined.
A thread's \code{wait\_id} is undefined if the thread
is not in a wait state.
\end{comment}

Some values of the enumeration type \code{omp\_state\_t} are used by all 
OpenMP implementations, 
e.g., \code{omp\_state\_work\_serial}, 
which indicates that a thread is executing in a serial region, and  
\code{omp\_state\_work\_parallel}, 
which indicates that a thread is executing in a parallel region.
Other values of the enumeration type describe a thread's state at 
different levels of specificity. 
For instance, an OpenMP implementation may use 
the state \code{omp\_state\_wait\_barrier}  to represent all 
waiting at barriers; or it may differentiate between waiting at 
implicit and explicit barriers by using the pair of states
\code{omp\_state\_wait\_barrier\_implicit} and 
\code{omp\_state\_wait\_barrier\_explicit}. 

For states that represent waiting, an OpenMP implementation has the 
choice of transitioning a thread to such states early or late.
For instance, when an OpenMP thread is trying to acquire a lock,
there are several points at which an OpenMP implementation
transition the thread to the \code{omp\_state\_wait\_lock} state.
One implementation may transition the thread to the state 
early before the thread attempts to acquire a
lock. Another implementation may transition the thread to the state 
late, only if the thread begins to spin or
block to wait for an unavailable lock. A third implementation
may transition the thread to the state even later, e.g., only
after the thread waits for a significant amount of time. 

The following describes the classes and the states in each class.
\subsubsection{Work States}
An OpenMP implementation reports a thread in a work state 
when the thread is performing serial work, parallel work, or a reduction.

\begin{description}

\item \code{omp\_state\_work\_serial} 

  The thread is executing code outside all parallel regions. 

\item \code{omp\_state\_work\_parallel} 

  The thread is executing code within the scope of a parallel region construct.

\sloppy
\item \code{omp\_state\_work\_reduction} 
 
  The thread is combining partial reduction results from threads in its team. 
  An OpenMP implementation  
  might never report a thread in this state; a thread
  combining partial reduction results may have its state reported as
  \code{omp\_state\_work\_parallel} or \code{omp\_state\_overhead}.

\end{description}


\subsubsection{Barrier Wait States}

An OpenMP implementation reports that a thread is in a barrier wait state 
when the thread is is awaiting completion of a barrier.


\begin{description}

  \item \code{omp\_state\_wait\_barrier} 
  
  \sloppy
  The thread is waiting at either an implicit or explicit barrier.
  A thread may enter this state
  early, when the thread encounters a barrier, or late, when the
  thread begins to wait at the barrier. An implementation may never report a thread in this state; instead, a thread may have its state reported
  as \code{omp\_state\_wait\_barrier\_implicit}  or \code{omp\_state\_wait\_barrier\_explicit}, as appropriate.
  
  \item \code{omp\_state\_wait\_barrier\_implicit} 
  
  \sloppy
  The thread is waiting at an implicit barrier in a parallel region. 
  A  thread may enter this state
  early, when the thread encounters a barrier, or late, when the
  thread begins to wait at the barrier.
  An OpenMP implementation may report \code{omp\_state\_wait\_barrier} 
  for implicit barriers.
  
  \item \code{omp\_state\_wait\_barrier\_explicit} 

  The thread is waiting at an explicit barrier  in a parallel region. 
  A thread may enter this state
  early, when the thread encounters a barrier, or late, when the
  thread begins to wait at the barrier.
  An implementation may report \code{omp\_state\_wait\_barrier} 
  for explicit barriers.
  
\end{description}
  
\subsubsection{Task Wait States}

\begin{description}

\item \code{omp\_state\_wait\_taskwait} 

  The thread is waiting at a taskwait construct. A 
  thread may enter this state early, when the
  thread encounters a taskwait construct, or late, when the thread
  begins to wait for an uncompleted task.

\item \code{omp\_state\_wait\_taskgroup} 

  The thread is waiting at the end of a taskgroup construct. A 
  thread may enter this state early, when the
  thread encounters the end of a taskgroup construct, or late, when the thread
  begins to wait for an uncompleted task.

\end{description}


\subsubsection{Mutex Wait States}

OpenMP provides several mechanisms that enforce mutual exclusion:
locks as well as critical, atomic, and ordered sections.  This
grouping contains all states used to indicate that a thread is is
awaiting exclusive access to a lock, critical section, variable,
or ordered section.

An OpenMP implementation may report a thread waiting for any type
of mutual exclusion using either a state that precisely identifies
the type of mutual exclusion, or  a more generic state such as
\code{omp\_state\_wait\_mutex} or \code{omp\_state\_wait\_lock}.  This
flexibility may significantly simplify the maintenance of states
associated with mutual exclusion in the runtime when various
mechanisms for mutual exclusion rely on a common implementation,
e.g., locks.

% Section~\ref{sec:wait-identifier} describes how each thread maintains a wait identifier to identify what a thread is awaiting. Before a thread enters any state indicating that it is awaiting mutual exclusion, the OpenMP runtime will update the thread's wait identifier to indicate what the thread is awaiting. 

\begin{description}

\item \code{omp\_state\_wait\_mutex}

  The thread is waiting for a mutex of an unspecified type. A 
  thread may enter this state early, when a thread encounters a lock acquisition or a region that requires mutual exclusion, or late, when the thread begins to wait.

\item \code{omp\_state\_wait\_lock}

  The thread is waiting for a  lock  or nest lock. A 
  thread may enter this state early, when a thread
  encounters a lock \code{set} routine, or late, when the thread
  begins to wait for a lock.

\item \code{omp\_state\_wait\_critical} 

  The thread is waiting to enter a critical region. A 
  thread may enter this state early, when the
  thread encounters a critical construct, or late, when the thread
  begins to wait to enter the critical region. 


\item \code{omp\_state\_wait\_atomic} 

  The thread is waiting to enter an atomic region. A 
  thread may enter this state early, when the thread
  encounters an atomic construct, or late, when the thread begins
  to wait to enter the atomic region. 
  An implementation may opt not to report
  this state when using atomic hardware instructions that support non-blocking atomic implementations.
  

\item \code{omp\_state\_wait\_ordered} 

  The thread is waiting to enter an ordered region. A 
  thread may enter this state early, when the thread encounters
  an ordered construct, or late, when the thread begins
  to wait to enter the ordered region. 
  
\end{description}
  
\subsubsection{Target Wait States}

\begin{description}

\item \code{omp\_state\_wait\_target} 

  The thread is waiting for a target region to complete.
  
\item \code{omp\_state\_wait\_target\_map} 

  The thread is waiting for a target data mapping operation to complete. 
  An implementation may report \code{omp\_state\_wait\_target} 
  for target data constructs.

\item \code{omp\_state\_wait\_target\_update} 

  The thread is waiting for a target  update operation to complete. 
  An implementation may report \code{omp\_state\_wait\_target} 
  for target update constructs.

\end{description}


\subsubsection{Miscellaneous States}

\begin{description}
\item \code{omp\_state\_idle} 

  The thread is idle, waiting for work.

\item \code{omp\_state\_overhead} 

  A thread may be reported as being in the overhead state at any point while 
  executing within an OpenMP runtime, except while waiting indefinitely
  at a synchronization point.
%  e.g., while preparing to execute a parallel, task, or worksharing construct. 
  An OpenMP implementation report a thread's state as a work state for
  some or all of the time the thread spends in executing in the OpenMP runtime.

\item \code{omp\_state\_undefined} 

  This state is reserved for threads that are not user threads,
  initial threads, threads currently in an OpenMP team, or threads
  waiting to become part of an OpenMP team.

\end{description}

\subsection{Events}
\label{sec:ompt_callback_t}

The following enumeration type indicates the integer codes used to identify 
OpenMP events when registering or querying callbacks associated with them.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_callback_t \{
  ompt_callback_thread_begin             = 1,
  ompt_callback_thread_end               = 2,
  ompt_callback_parallel_begin           = 3,
  ompt_callback_parallel_end             = 4,
  ompt_callback_task_create              = 5,
  ompt_callback_task_schedule            = 6,
  ompt_callback_implicit_task            = 7,
  ompt_callback_target                   = 8,
  ompt_callback_target_data              = 9,
  ompt_callback_target_submit            = 10,
  ompt_callback_tcontrol                 = 11,
  ompt_callback_idle                     = 12,
  ompt_callback_sync_region_wait         = 13,
  ompt_callback_mutex_release            = 14,
  ompt_callback_task_dependences         = 15,
  ompt_callback_task_dependence     = 16,
  ompt_callback_work                     = 17,
  ompt_callback_master                   = 18,
  ompt_callback_target_map               = 19,
  ompt_callback_sync_region              = 20,
  ompt_callback_init_lock                = 21,
  ompt_callback_destroy_lock             = 22,
  ompt_callback_mutex_acquire            = 23,
  ompt_callback_mutex_acquired           = 24,
  ompt_callback_nested_lock              = 25,
  ompt_callback_flush                    = 26,
  ompt_callback_device_initialize        = 27,
  ompt_callback_cancel                   = 28
\} ompt_callback_t;
\end{boxedcode}
\ccppspecificend
}


%\subsubsection{Triggers for Miscellaneous Events}
%Most events trigger during the execution of OpenMP directives. Other
%events trigger when an application calls certain runtime library
%routines, e.g., those for setting and unsetting locks.
%This section describes events triggered during initialization and
%finialization of an OpenMP implementation. 
%
%\ompteventswithoutdirectives{\code{ompt\_callback\_thread\_begin}}
%\label{sec:ompt_callback_thread_begin}
%
%An OpenMP implementation invokes this callback in the context of an
%initial thread just after it initializes the runtime, or in the
%context of a new thread created by the runtime just after the thread
%initializes itself. In either case, this callback must be the first
%callback for a thread and must occur before the thread executes any
%OpenMP tasks. This callback has type signature
%\code{ompt\_callback\_thread\_begin\_t}.  The callback argument
%\code{thread\_type} indicates the type of the thread: initial, worker,
%or other.
%
%\ompteventswithoutdirectives{\code{ompt\_callback\_thread\_end}}
%\label{sec:ompt_callback_thread_end}
%
%An OpenMP implementation invokes this callback after an OpenMP thread
%completes all of its tasks but before the thread is destroyed. The
%callback executes in the context of the OpenMP thread. This callback
%must be the last callback event for any worker thread; it is optional
%for other types of threads.  This callback has type signature
%\code{ompt\_callback\_thread\_end\_t}.
%
%\ompteventswithoutdirectives{\code{ompt\_callback\_idle}}
%\label{sec:ompt_callback_idle}
%
%An OpenMP implementation invokes this callback with
%\code{endpoint=}\code{ompt\_scope\_begin} when a thread waits for work
%outside a parallel region.  The OpenMP runtime invokes this callback
%with \code{endpoint=}\code{ompt\_scope\_end} before the thread begins
%to execute an implicit task for a parallel region or terminates. The
%callback executes in the environment of the waiting thread.  This
%callback has type signature \code{ompt\_callback\_idle\_t}.
%
%\ompteventswithoutdirectives{\code{ompt\_callback\_sync\_region\_wait}}
%\label{sec:ompt_callback_sync_region_wait}
%
%If the \code{ompt\_callback\_sync\_region\_wait} callback is registered,
%an OpenMP implementation will invoke this callback when a task starts
%and stops waiting in a barrier region, taskwait region, or taskgroup
%region.  This callback has type signature
%\code{ompt\_callback\_sync\_region\_t}.  One region may generate
%multiple pairs of start/stop callbacks if another task is scheduled on
%the thread while the task awaiting completion of the region is
%stalled.  This callback executes in the context of the task that
%encountered the barrier, taskwait, or taskgroup construct.
%
%\ompteventswithoutdirectives{\code{ompt\_callback\_runtime\_shutdown}}
%\label{sec:ompt_callback_runtime_shutdown}
%
%An OpenMP implementation invokes this callback before it shuts down
%the runtime system.  This callback enables a tool to clean up its
%state and record or report information gathered. A runtime may later
%restart and reinitialize the tool by calling the tool initializer
%function (described in Section~\ref{sec:tool-initialize}) again.  This
%callback has type signature \code{ompt\_callback\_t}.

\begin{targetRecord}
\subsection{Tracing Support}
\label{sec:ompt-records}

\subsubsection{Record Kind}
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_record_kind_e \{
  ompt_record_ompt               = 1,
  ompt_record_native             = 2,
  ompt_record_invalid            = 3
\} ompt_record_kind_t; 
\end{boxedcode}
\ccppspecificend
}

\subsubsection{Native Record Kind}
\label{sec:ompt_record_native_kind_t}

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_record_native_kind_e \{
  ompt_record_native_info  = 1,
  ompt_record_native_event = 2
\} ompt_record_native_kind_t;
\end{boxedcode}
\ccppspecificend
}

\subsubsection{Native Record Abstract Type}
\label{sec:ompt_record_native_abstract_t}

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_native_abstract_s \{
  ompt_record_native_class_t \plc{rclass};
  const char *\plc{type};
  ompt_device_time_t \plc{start\_time};
  ompt_device_time_t \plc{end\_time};
  ompt_hwid_t \plc{hwid};
\} ompt_record_native_abstract_t;
\end{boxedcode}
\ccppspecificend
}

\descr

A \code{ompt\_record\_native\_abstract\_t} record contains several
pieces of information that a tool can use to process a native record
that it may not fully understand. The record \code{rclass} field
indicates whether the record is informational
or represents an event; knowing this can help a tool determine
how to present the record. The record \code{type} field points to
a statically-allocated, immutable character string that provides
a meaningful name that a tool might want to use to describe the event
to a user. The \code{start\_time} and \code{end\_time} fields are
used to place an event in time. The times are relative to the device
clock. If an event has no associated \code{start\_time} and/or
\code{end\_time}, its value will be 
\code{ompt\_time\_none}. The hardware id field,
\code{hwid},  is used to indicate the location on the device where
the event occurred. A \code{hwid} may represent a hardware abstraction
such as a core or a hardware thread id. The meaning of a \code{hwid}
value for a device is defined by the implementer of the software
stack for the device. If there is no hardware abstraction associated 
with the record, the value of \code{hwid} 
will be \code{ompt\_hwid\_none}.

\subsubsection{Record Type}
\label{sec:ompt_record_ompt_t}
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_ompt_s \{
  ompt_callback_t \plc{type};
  ompt_target_time\_t \plc{time};
  ompt_id_t \plc{thread_id};
  ompt_id_t \plc{target_id};
  union \{
    ompt_thread_begin_record_t \plc{thread_begin};
    ompt_idle_record_t \plc{idle};
    ompt_parallel_begin_record_t \plc{parallel_begin};
    ompt_parallel_end_record_t \plc{parallel_end};
    ompt_task_create_record_t \plc{task_create};
    ompt_task_dependence_record_t \plc{task_dep};
    ompt_task_schedule_record_t \plc{task_sched};
    ompt_implicit_record_t \plc{implicit};
    ompt_sync_region_record_t \plc{sync_region};
    ompt_target_record_t \plc{target_record};
    ompt_target_data_record_t \plc{target_data};
    ompt_target_map_record_t \plc{target_map};
    ompt_target_kernel_record_t \plc{kernel};
    ompt_lock_init_record_t \plc{lock_init};
    ompt_lock_destroy_record_t \plc{lock_destroy};
    ompt_mutex_acquire_record_t \plc{mutex_acquire};
    ompt_mutex_record_t \plc{mutex};
    ompt_nested_lock_record_t \plc{nested_lock};
    ompt_master_record_t \plc{master};
    ompt_work_record_t \plc{work};
    ompt_flush_record_t \plc{flush};
  \} \plc{record};
\} ompt_record_ompt_t;
\end{boxedcode}
\ccppspecificend
}

\end{targetRecord}

\subsection{Frames}
\index{Frames}

When executing an OpenMP program, at times procedure frames from
the OpenMP runtime appear on the call stack between procedure frames
for user code.  To enable a tool to determine whether each procedure
frame on the call stack represents user code or an OpenMP runtime
routine, an implementation of the OpenMP API must maintain an
instance of an \code{ompt\_frame\_t} for each 
task that has procedure frames on a thread's stack.  
A thread's stack is said to include a \emph{degenerate task} 
if it contains a sequence of one or more procedure 
frames from OpenMP runtime routines between a pair of frames for user
procedures that belong to the same
task.\footnote{A degenerate task may arise when a parallel
construct is encountered in a parallel region and nested parallelism
is not enabled or when an orphaned task directive 
is encountered outside a parallel region.  In such cases, the program
may invoke the OpenMP runtime and runtime procedure frames may remain
on the stack when the runtime 
invokes an outlined procedure.} 
An OpenMP implementation must
maintain an \code{ompt\_frame\_t} data structure 
for each initial, implicit, explicit, target, or degenerate task. 

\begin{comment}
The OpenMP API will maintain an
instance of an \code{ompt\_frame\_t} for each 
degenerate task as well. 
To simplify the following discussion, we omit the
qualifier ``possibly degenerate'' each time we use the term {\em
task}.
\end{comment}

An \code{ompt\_frame\_t} object for a task contains a pair of pointers:
\plc{enter\_frame}--the canonical frame address for the user frame that invoked the
OpenMP runtime system to create the task, and  
\plc{exit\_frame}--the canonical frame address for the frame that
invoked a user procedure for the task.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_frame_s \{\\
  void *\plc{exit_frame};
  void *\plc{enter_frame};
\} ompt_frame_t;
\end{boxedcode}
\ccppspecificend
}

An \code{ompt\_frame\_t}'s lifetime begins when a task is created
and ends when the task is destroyed. Tools should not assume that
a frame structure remains at a constant location in memory throughout
a task's lifetime. A task's frame object is passed to some callbacks; it
can also be retrieved asynchronously by invoking the
\code{ompt\_get\_task\_info} function (described in
Section~\ref{sec:ompt_get_task_info}) in a signal handler.

The value of \plc{exit\_frame} is \code{NULL} in a task's frame
object until just before an outlined procedure for the task is invoked.
When an outlined procedure for the task is invoked,
\plc{exit\_frame} is set to the canonical frame
address of the procedure that invokes the outlined procedure for the
task. 
The value of \plc{exit\_frame} is set to \code{NULL}
when the outlined procedure returns to the runtime, whether the task is finished or deferred.

The \plc{enter\_frame} field of a task's frame object is set each time the task re-enters the
runtime to create a new implicit, explicit, target or degenerate
task. When a task invokes an entry point in the
OpenMP runtime to create a task,
\plc{enter\_frame} of the task's frame object will be set to
the canonical frame address of the user function that invoked the runtime.
The value of \plc{enter\_frame} is cleared 
after the code for the invoked task returns, whether the task is finished or deferred.

\begin{table}
\begin{center}
\begin{tabular}{|p{1in}||p{2in}|p{2in}|}
\hline
\plc{exit\_frame} / \plc{enter\_frame} 	state & \plc{enter\_frame} is \code{NULL}										& \plc{enter\_frame} is defined \\
\hline
\hline
\plc{exit\_frame} is \code{NULL} & case 1)  initial task in user code\newline case 2) task that is created but not yet scheduled or already finished & initial task entered the runtime to schedule an implicit, explicit, or target task \\\hline
\plc{exit\_frame} is defined 	& non-initial task in (or soon to be
in) user code							&
non-initial task entered the runtime and scheduled an implicit,
explicit, target, or degenerate task\\
\hline
\end{tabular}
\vspace{1ex}
\end{center}
\caption{Meaning of various states of an \code{ompt\_frame\_t}
  record.}
\label{tab:frame}
\end{table}

Table~\ref{tab:frame} describes various states in which 
an \code{ompt\_frame\_t} object may be observed and their meaning.
In the presence of nested parallelism, a tool may
observe a sequence of \code{ompt\_frame\_t} records for a thread.
Appendix~\ref{app:frames} illustrates 
use of \code{ompt\_frame\_t} records with nested parallelism.

\littleheader{Advice to tool implementers:} 
A monitoring tool using asynchronous sampling can observe values
of \plc{exit\_frame} and \plc{enter\_frame} at inconvenient times.
Tools must be prepared to observe and handle frame exit and reenter
values that have not yet been set or reset as the program enters
or leaves the runtime.

\subsection{Miscellaneous Type Definitions}
\label{sec:ompt-types:misc}
This section describes miscellaneous types and enumerations used by the tool interface.

\ompttype{\code{ompt\_callback\_t}}
\label{sec:ompt_callback_t}

Pointers to tool callback functions with many different type
signatures are passed to the \code{ompt\_callback\_set} entry point and 
returned by the \code{ompt\_callback\_get} entry point. For convenience,
these entry points expect all type signatures to be cast to   
a dummy type \code{ompt\_callback\_t}.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_t)(void);
\end{boxedcode}
\ccppspecificend
}

% ompt_id_t

\ompttype{\code{ompt\_id\_t}}
\label{sec:ompt_id_t} 
When tracing asynchronous activity on OpenMP devices, tools need identifiers to correlate target regions and operations initiated by the host with 
associated activities on a target device. In addition, tools need identifiers to refer to parallel regions and tasks that execute on a device.
OpenMP implementations use identifiers of type \code{ompt\_id\_t} type for each of these purposes. 
The value \code{ompt\_id\_none} is
reserved to indicate an invalid id.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef unsigned long long int ompt_id_t;
#define ompt_id_none (~0ULL)
\end{boxedcode}
\ccppspecificend
}

Identifiers created on each device must be unique from the time an OpenMP implementation is initialized until it is shut down.  
Specifically, this means that (1) identifiers for each target region and target operation instance initiated by the host device must be unique over time on the host,
and (2) identifiers for parallel and task region instances that execute on a device must be unique over time within that device.

Tools should not assume that \code{ompt\_id\_t} values are small or densely allocated. 

% ompt_data_t

\ompttype{\code{ompt\_data\_t}}
\label{sec:ompt_data_t} 
Threads, parallel regions, and task regions 
each have an associated data object of type \code{ompt\_data\_t} reserved for use by a tool.
When an OpenMP implementation creates a thread or an instance of a parallel or task region, 
it will initialize its associated \code{ompt\_data\_t} object with the value \code{ompt\_data\_none}. 

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef union ompt_data_u \{\\
  unsigned long long value; /* value under tool control   */
  void *ptr;                /* pointer under tool control */
\} ompt_data_t;

ompt_data_t ompt_data_none = \{.value=0\};         
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_get\_parallel\_info} inquiry function, see \specref{sec:ompt_get_parallel_info}.
\item \code{ompt\_get\_task\_info} inquiry function, see \specref{sec:ompt_get_task_info}.
\item \code{ompt\_get\_thread\_data} inquiry function, see \specref{sec:ompt_get_thread_data}.
\item \code{ompt\_callback\_thread\_begin\_t} callback type, see \specref{sec:ompt_callback_thread_begin_t}.
\item \code{ompt\_callback\_thread\_begin\_t} callback type, see \specref{sec:ompt_callback_thread_begin_t}.
\item \code{ompt\_callback\_parallel\_end\_t} callback type, see
  \specref{sec:ompt_callback_parallel_end_t}.
\item \code{ompt\_callback\_parallel\_end\_t} callback type, see \specref{sec:ompt_callback_parallel_end_t}.
\item \code{ompt\_callback\_task\_create\_t} callback type, see \specref{sec:ompt_callback_task_create_t}.
\item \code{ompt\_callback\_task\_dependences\_t} callback type, see \specref{sec:ompt_callback_task_dependences_t}.
\item \code{ompt\_callback\_task\_dependence\_t} callback type, see \specref{sec:ompt_callback_task_dependence_t}.
\item \code{ompt\_callback\_task\_schedule\_t} callback type, see
  \specref{sec:ompt_callback_task_schedule_t}.
\item \code{ompt\_callback\_implicit\_task\_t} callback type, see
  \specref{sec:ompt_callback_task_implicit_task_t}.
\item \code{ompt\_callback\_task\_sync\_region} callback type, see
  \specref{sec:ompt_callback_task_sync_region_t}.
\item \code{ompt\_callback\_callback\_task\_master\_t} callback type,
  see \specref{sec:ompt_callback_task_master_d}.
\item \code{ompt\_callback\_task\_work\_t} callback type, see \specref{sec:ompt_callback_task_work_t}.
\item \code{ompt\_callback\_task\_target\_t} callback type, see \specref{sec:ompt_callback_task_target_t}.\item \code{ompt\_callback\_flush\_t} callback type, see \specref{sec:ompt_callback_flush_t}.
\end{itemize}
\end{comment}

% ompt_wait_id_t

\ompttype{\code{ompt\_wait\_id\_t}}
\label{sec:ompt_wait_id_t} 
\index{Wait Identifier}

Each thread instance maintains a \emph{wait identifier} of type \code{ompt\_wait\_id\_t}.
When a task executing on a thread is waiting for mutual exclusion, the thread's wait identifer indicates what the thread is awaiting.
A wait identifier may represent a critical section {\em name}, a lock, a program variable accessed in an atomic region, or a synchronization object internal to an OpenMP implementation.
% A thread's wait identifier can be retrieved on demand by invoking the \code{ompt\_get\_state} function (described in Section~\ref{sec:ompt_get_state}).

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef unsigned long long int ompt_wait_id_t;
\end{boxedcode}
\ccppspecificend
}

When a thread is not in a wait state, the value of the thread's wait identifier is undefined.

Tools should not assume that \code{ompt\_wait\_id\_t} values are small or densely allocated.

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_get\_state} inquiry function, see \specref{sec:ompt_get_state}.
\item \code{ompt\_callback\_lock\_init\_t} callback type, see \specref{sec:ompt_callback_lock_init_t}.
\item \code{ompt\_callback\_lock\_destroy\_t} callback type, see \specref{sec:ompt_callback_lock_destroy_t}.
\item \code{ompt\_callback\_mutex\_acquire\_t} callback type, see \specref{sec:ompt_callback_mutex_acquire_t}.
\item \code{ompt\_callback\_mutex\_t} callback type, see \specref{sec:ompt_callback_mutex_t}.
\item \code{ompt\_callback\_nested\_lock\_t} callback type, see \specref{sec:ompt_callback_nested_lock_t}.
\item \code{ompt\_record\_lock\_init\_t} data type, see \specref{sec:ompt_record_lock_init_t}.
\item \code{ompt\_record\_lock\_destroy\_t} data type, see \specref{sec:ompt_record_lock_destroy_t}.
\item \code{ompt\_record\_mutex\_acquire\_t} data type, see \specref{sec:ompt_record_mutex_acquire_t}.
\item \code{ompt\_record\_mutex\_t} data type, see \specref{sec:ompt_record_mutex_t}.
\item \code{ompt\_record\_nested\_lock\_t} data type, see \specref{sec:ompt_record_nested_lock_t}.
\end{itemize}
\end{comment}

% ompt_device_t

\ompttype{\code{ompt\_device\_t}}
\label{sec:ompt_device_t} 
\code{ompt\_device\_t} is an opaque object representing a device.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void ompt_device_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_get\_time} inquiry function, see \specref{sec:ompt_get_time}.
\item \code{ompt\_translate\_time} inquiry function, see \specref{sec:ompt_translate_time}.
\item \code{ompt\_set\_trace\_ompt} tool function, see \specref{sec:ompt_set_trace_ompt}.
\item \code{ompt\_set\_trace\_native} tool function, see \specref{sec:ompt_set_trace_native}.
\item \code{ompt\_start\_trace} tool function, see \specref{sec:ompt_start_trace}.
\item \code{ompt\_pause\_trace} tool function, see \specref{sec:ompt_pause_trace}.
\item \code{ompt\_stop\_trace} tool function, see \specref{sec:ompt_stop_trace}.
\end{itemize}
\end{comment}

% ompt_device_time_t

\ompttype{\code{ompt\_device\_time\_t}}
\label{sec:ompt_device_time_t} 
\code{ompt\_device\_time\_t} is an opaque object representing a raw time value from a device.
\label{sec:ompt_time_none} 
\code{ompt\_time\_none} refers to an uknown or unspecified time.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef unsigned long long int ompt_device_time_t;
#define ompt_time_none (~0ULL)
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_get\_device\_time} inquiry function, see \specref{sec:ompt_get_device_time}.
\item \code{ompt\_translate\_time} inquiry function, see \specref{sec:ompt_translate_time}.
\item \code{ompt\_record\_native\_abstract\_t} data type, see \specref{sec:ompt_record_native_abstract_t}.
\item \code{ompt\_record\_target\_data\_t} data type, see \specref{sec:ompt_record_target_data_t}.
\item \code{ompt\_record\_target\_kernel\_t} data type, see \specref{sec:ompt_record_target_kernel_t}.
\item \code{ompt\_record\_ompt\_t} data type, see \specref{sec:ompt_record_ompt_t}.
\end{itemize}
\end{comment}

% ompt_buffer_t

\ompttype{\code{ompt\_buffer\_t}}
\label{sec:ompt_buffer_t} 
\code{ompt\_buffer\_t} is an opaque object handle for a target buffer.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void ompt_buffer_t; 
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_buffer\_request\_t} callback type, see \specref{sec:ompt_callback_buffer_request_t}.
\item \code{ompt\_callback\_buffer\_complete\_t} callback type, see \specref{sec:ompt_callback_buffer_complete_t}.
\item \code{ompt\_advance\_buffer\_cursor} tool function, see \specref{sec:ompt_advance_buffer_cursor}.
\item \code{ompt\_buffer\_get\_record\_type} tool function, see \specref{sec:ompt_buffer_get_record_type}.
\item \code{ompt\_buffer\_get\_record\_ompt} tool function, see \specref{sec:ompt_buffer_get_record_ompt}.
\item \code{ompt\_buffer\_get\_record\_correlation} tool function, see \specref{sec:ompt_buffer_get_record_correlation}.
\item \code{ompt\_buffer\_get\_record\_native} tool function, see \specref{sec:ompt_buffer_get_record_native}.
\end{itemize}
\end{comment}

% ompt_buffer_cursor_t

\ompttype{\code{ompt\_buffer\_cursor\_t}}
\label{sec:ompt_buffer_cursor_t} 
\code{ompt\_buffer\_cursor\_t} is an opaque handle for a position in a target buffer.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef unsigned long long int ompt_buffer_cursor_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_buffer\_complete\_t} callback type, see \specref{sec:ompt_callback_buffer_complete_t}.
\item \code{ompt\_advance\_buffer\_cursor} tool function, see \specref{sec:ompt_advance_buffer_cursor}.
\item \code{ompt\_buffer\_get\_record\_type} tool function, see \specref{sec:ompt_buffer_get_record_type}.
\item \code{ompt\_buffer\_get\_record\_ompt} tool function, see \specref{sec:ompt_buffer_get_record_ompt}.
\item \code{ompt\_buffer\_get\_record\_correlation} tool function, see \specref{sec:ompt_buffer_get_record_correlation}.
\item \code{ompt\_buffer\_get\_record\_native} tool function, see \specref{sec:ompt_buffer_get_record_native}.
\end{itemize}
\end{comment}

% ompt_task_dependence_t

\ompttype{\code{ompt\_task\_dependence\_t}}
\label{sec:ompt_task_dependence_t} 
\code{ompt\_task\_dependence\_t} is a task dependence.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_task_dependence_s \{\\
  void *variable_addr;
  unsigned int dependence_flags;
\} ompt_task_dependence_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_task\_dependences\_t} callback type, see \specref{sec:ompt_callback_task_dependences_t}.
\item \code{ompt\_task\_dependence\_flag\_t} enumeration type, see \specref{sec:ompt_task_dependence_flag_t}.
\end{itemize}
\end{comment}

% ompt_frame_t

\ompttype{\code{ompt\_frame\_t}}
\label{sec:ompt_frame_t} 
\code{ompt\_frame\_t} is a structure to maintain the runtime frame that reenters
user code, and the user fram ethat enters the runtime.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_frame_s \{\\
  void *exit_frame;  /* runtime frame that reenters user code */
  void *enter_frame; /* user frame that enters the runtime    */
\} ompt_frame_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_get\_task\_info} inquiry function, see \specref{sec:ompt_get_task_info}.
\item \code{ompt\_callback\_parallel\_begin\_t} callback type, see
  \specref{sec:ompt_callback_parallel_begin_t}.
\item \code{ompt\_callback\_create\_t} callback type, see \specref{sec:ompt_callback_create_t}.
\item \code{ompt\_record\_parallel\_begin\_t} data type, see \specref{sec:ompt_record_parallel_begin_t}.
\item \code{ompt\_record\_task\_create\_t} data type, see \specref{sec:ompt_record_task_create_t}.
\end{itemize}
\end{comment}

% ompt_thread_type_t

\ompttype{\code{ompt\_thread\_type\_t}}
\label{sec:ompt_thread_type_t} 
\code{ompt\_thread\_type\_t} is an enumeration that defines the valid thread type values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_thread_type_e \{
  ompt_thread_initial                 = 1,
  ompt_thread_worker                  = 2,
  ompt_thread_other                   = 3,
  ompt_thread_unknown                 = 4
\} ompt_thread_type_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_thread\_begin\_t} callback type, see \specref{sec:ompt_callback_thread_begin_t}.
\item \code{ompt\_record\_thread\_begin\_t} data type, see \specref{sec:ompt_record_thread_begin_t}.
\end{itemize}
\end{comment}

% ompt_scope_endpoint_t

\ompttype{\code{ompt\_scope\_endpoint\_t}}
\label{sec:ompt_scope_endpoint_t} 
\code{ompt\_scope\_endpoint\_t} is an enumeration that defines valid scope endpoint values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_scope_endpoint_e \{
  ompt_scope_begin                    = 1,
  ompt_scope_end                      = 2
\} ompt_scope_endpoint_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_idle\_t} callback type, see \specref{sec:ompt_callback_idle_t}.
\item \code{ompt\_callback\_implicit\_task\_t} callback type, see
  \specref{sec:ompt_callback_implicit_task_t}.
\item \code{ompt\_callback\_sync\_region\_t} callback type, see \specref{sec:ompt_callback_sync_region_t}.
\item \code{ompt\_callback\_nested\_lock\_t} callback type, see \specref{sec:ompt_callback_nested_lock_t}.
\item \code{ompt\_callback\_master\_t} callback type, see \specref{sec:ompt_callback_master_t}.
\item \code{ompt\_callback\_work\_t} callback type, see \specref{sec:ompt_callback_work_t}.
\item \code{ompt\_callback\_target\_t} callback type, see \specref{sec:ompt_callback_target_t}.
\item \code{ompt\_record\_idle\_t} data type, see \specref{sec:ompt_record_idle_t}.
\item \code{ompt\_record\_implicit\_t} data type, see \specref{sec:ompt_record_implicit_t}.
\item \code{ompt\_sync\_region\_t} data type, see \specref{sec:ompt_sync_region_t}.
\item \code{ompt\_nested\_lock\_t} data type, see \specref{sec:ompt_nested_lock_t}.
\item \code{ompt\_master\_t} data type, see \specref{sec:ompt_master_t}.
\item \code{ompt\_work\_t} data type, see \specref{sec:ompt_work_t}.
\end{itemize}
\end{comment}

% ompt_sync_region_kind_t

\ompttype{\code{ompt\_sync\_region\_kind\_t}}
\label{sec:ompt_sync_region_kind_t} 
\code{ompt\_sync\_region\_kind\_t} is an enumeration that defines the valid sync region kind values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_sync_region_kind_e \{
  ompt_sync_region_barrier            = 1, 
  ompt_sync_region_taskwait           = 2,
  ompt_sync_region_taskgroup          = 3
\} ompt_sync_region_kind_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_sync\_region\_t} callback type, see \specref{sec:ompt_callback_sync_region_t}.
\item \code{ompt\_record\_sync\_region\_t} data type, see \specref{sec:ompt_record_sync_region_t}.
\end{itemize}
\end{comment}

% ompt_target_data_op_t

\ompttype{\code{ompt\_target\_data\_op\_t}}
\label{sec:ompt_target_data_op_t} 
\code{ompt\_target\_data\_op\_t} is an enumeration that defines the valid target data operation values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_target_data_op_e \{
  ompt_target_data_alloc              = 1,
  ompt_target_data_to_dev             = 2,
  ompt_target_data_from_dev           = 3,
  ompt_target_data_delete             = 4
\} ompt_target_data_op_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_target\_data\_t} callback type, see \specref{sec:ompt_callback_target_data_t}.
\item \code{ompt\_record\_target\_data\_t} data type, see \specref{sec:ompt_record_target_data_t}.
\end{itemize}
\end{comment}

% ompt_work_type_t

\ompttype{\code{ompt\_work\_type\_t}}
\label{sec:ompt_work_type_t} 
\code{ompt\_work\_type\_t} is an enumeration that defines the valid work type values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_work_type_e \{
  ompt_work_loop               = 1, 
  ompt_work_sections           = 2,
  ompt_work_single_executor    = 3,
  ompt_work_single_other       = 4,
  ompt_work_workshare          = 5,
  ompt_work_distribute         = 6,
  ompt_work_taskloop          = 7
\} ompt_work_type_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_work\_t} callback type, see \specref{sec:ompt_callback_work_t}.
\item \code{ompt\_record\_work\_t} data type, see \specref{sec:ompt_record_work_t}.
\end{itemize}
\end{comment}

% ompt_mutex_kind_t

\ompttype{\code{ompt\_mutex\_kind\_t}}
\label{sec:ompt_mutex_kind_t} 
\code{ompt\_mutex\_kind\_t} is an enumeration that defines the valid mutex kind values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_mutex_kind_e \{
  ompt_mutex                          = 0x10,
  ompt_mutex_lock                     = 0x11,
  ompt_mutex_nest_lock                = 0x12,
  ompt_mutex_critical                 = 0x13,
  ompt_mutex_atomic                   = 0x14,
  ompt_mutex_ordered                  = 0x20
\} ompt_mutex_kind_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_mutex\_acquire\_t} callback type, see \specref{sec:ompt_callback_mutex_acquire_t}.
\item \code{ompt\_callback\_mutex\_t} callback type, see \specref{sec:ompt_callback_mutex_t}.
\item \code{ompt\_record\_mutex\_acquire\_t} data type, see \specref{sec:ompt_record_mutex_acquire_t}.
\item \code{ompt\_record\_mutex\_t} data type, see \specref{sec:ompt_record_mutex_t}.
\end{itemize}
\end{comment}

% ompt_native_mon_flags_t

\ompttype{\code{ompt\_native\_mon\_flags\_t}}
\label{sec:ompt_native_mon_flags_t}
\code{ompt\_native\_mon\_flags\_t} is an enumeration that defines the valid native monitoring flag values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_native_mon_flags_e \{
  ompt_native_data_motion_explicit    = 1,
  ompt_native_data_motion_implicit    = 2,
  ompt_native_kernel_invocation       = 4,
  ompt_native_kernel_execution        = 8,
  ompt_native_driver                  = 16,
  ompt_native_runtime                 = 32,
  ompt_native_overhead                = 64,
  ompt_native_idleness                = 128
\} ompt_native_mon_flags_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_set\_trace\_native} tool function, see \specref{sec:ompt_set_trace_native}.
\end{itemize}
\end{comment}

% ompt_task_type_t

\ompttype{\code{ompt\_task\_type\_t}}
\label{sec:ompt_task_type_t}
\code{ompt\_task\_type\_t} is an enumeration that defines the valid task type values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum  ompt_task_type_e \{
  ompt_task_initial                   = 1,
  ompt_task_implicit                  = 2,
  ompt_task_explicit                  = 3,
  ompt_task_target                    = 4,
  ompt_task_degenerate                = 5
\} ompt_task_type_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_task\_create\_t} callback type, see \specref{sec:ompt_callback_task_create_t}.
\item \code{ompt\_get\_task\_info} inquiry function, see \specref{sec:ompt_get_task_info}.
\item \code{ompt\_record\_task\_create\_t} data type, see \specref{sec:ompt_record_task_create_t}.
\end{itemize}
\end{comment}

%xxx
% ompt_task_status

\ompttype{\code{ompt\_task\_status\_t}}
\label{sec:ompt_task_status_t}
\code{ompt\_task\_status\_t} is an enumeration that explains the
reasons for switching a task that reached  a task scheduling point. 

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum  ompt_task_status_e \{
  ompt_task_complete  = 1,
  ompt_task_yield     = 2,
  ompt_task_cancel    = 3,
  ompt_task_others    = 4
\} ompt_task_status_t;
\end{boxedcode}
\ccppspecificend
}

The \code{ompt\_task\_complete} indicates the completion of task that
encountered the task scheduling point. The \code{ompt\_task\_yield} indicates
that the task encountered a \code{taskyield} construct. The \code{ompt\_task\_cancel} indicates
that the taks is canceled due to the encountering of an active cancellation point resulting in the
cancelation of that task.
The \code{ompt\_task\_others} is used in the remaining cases.

% ompt_target_type_t

\ompttype{\code{ompt\_target\_type\_t}}
\label{sec:ompt_target_type_t}
\code{ompt\_target\_type\_t} is an enumeration that defines the valid target type values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_target_type_e \{
  ompt_target                         = 1,
  ompt_target_enter_data              = 2,
  ompt_target_exit_data               = 3,
  ompt_target_update                  = 4
\} ompt_target_type_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_target\_t} callback type, see \specref{sec:ompt_callback_target_t}.
\end{itemize}
\end{comment}

% ompt_invoker_t

\ompttype{\code{ompt\_invoker\_t}}
\label{sec:ompt_invoker_t}
\code{ompt\_invoker\_t} is an enumeration that defines the valid invoker values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_invoker_e \{
  ompt_invoker_program = 1, /* program invokes master task */
  ompt_invoker_runtime = 2  /* runtime invokes master task */
\} ompt_invoker_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_callback_parallel\_begin\_t}, see \specref{sec:ompt_callback_parallel_begin__t}.
\item \code{ompt\_record\_parallel\_begin\_t}, see \specref{sec:ompt_record_parallel_begin_t}.
\item \code{ompt\_callback\_parallel\_end\_t}, see \specref{sec:ompt_callback_parallel_end_t}.
\item \code{ompt\_record\_parallel\_end\_t}, see \specref{sec:ompt_record_parallel_end_t}.
\end{itemize}
\end{comment}

% ompt_target_map_flag_t

\ompttype{\code{ompt\_target\_map\_flag\_t}}
\label{sec:ompt_target_map_flag_t}
\code{ompt\_target\_map\_flag\_t} is an enumeration that defines the valid target map flag values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_target_map_flag_e \{
  ompt_target_map_flag_to             = 1,
  ompt_target_map_flag_from           = 2,
  ompt_target_map_flag_alloc          = 4,
  ompt_target_map_flag_release        = 8, 
  ompt_target_map_flag_delete         = 16
\} ompt_target_map_flag_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_target\_data\_map\_t} callback type, see \specref{sec:ompt_callback_target_data_map_t}.
\end{itemize}
\end{comment}

% ompt_task_dependence_flag_t

\ompttype{\code{ompt\_task\_dependence\_flag\_t}}
\label{sec:ompt_task_dependence_flag_t}
\code{ompt\_task\_dependence\_flag\_t} is an enumeration that defines the valid task dependence flag values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_task_dependence_flag_e \{
  // a two bit field for the dependence type
  ompt_task_dependence_type_out       = 1,
  ompt_task_dependence_type_in        = 2,
  ompt_task_dependence_type_inout     = 3
\} ompt_task_dependence_flag_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_task\_dependence\_t} data type, see \specref{sec:ompt_task_dependence_t}.
\end{itemize}
\end{comment}


% ompt_cancel_flag_t

\ompttype{\code{ompt\_cancel\_flag\_t}}
\label{sec:ompt_cancel_flag_t}
\code{ompt\_cancel\_flag\_t} is an enumeration that defines the valid cancel flag values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_cancel_flag_e \{
  ompt_cancel_parallel     = 0x1,
  ompt_cancel_sections     = 0x2,
  ompt_cancel_do           = 0x4,
  ompt_cancel_taskgroup    = 0x8,
  ompt_cancel_activated    = 0x10000000,
  ompt_cancel_detected     = 0x20000000
\} ompt_cancel_flag_t;
\end{boxedcode}
\ccppspecificend
}

\crossreferences
\begin{itemize}
\item \code{ompt\_cancel\_t} data type, see \specref{sec:ompt_callback_cancel_t}.
\end{itemize}

% ompt_hwid_t

\ompttype{\code{ompt\_hwid\_t}}
\label{sec:ompt_hwid_t}
\code{ompt\_hwid\_t} is an opaque object representing a hardware identifier for a target device.
\label{sec:ompt_hwid_none} 
\code{ompt\_hwid\_none} refers to an uknown or unspecified hardware id.
If there is no \code{hwid} associated with a
\code{ompt\_record\_native\_abstract\_t}, the value of \code{hwid} shall be
\code{ompt\_hwid\_none}.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef unsigned long long int ompt_hwid_t;
#define ompt_hwid_none (0ULL)
\end{boxedcode}
\ccppspecificend
}



% end miscellaneous types

\begin{comment}
% These "none" objects have been integrated into the relevant sections,
% rather than have a seperate section.
\subsection{Miscellaneous Constants}
This section describes miscellaneous constants used by the tool interface.
% ompt_hwid_none
% ompt_dev_task_none
% ompt_time_none 
% ompt_id_none
% ompt_data_none
% ompt_mutex_kind_none
% end miscellaneous constants
\end{comment}
\section{Tool Interface Routine}

\ompteventswithoutdirectives{\code{ompt\_tool}}
\label{sec:ompt_tool}

\summary
If a tool wants to use an OpenMP implementation's OMPT interface,
the tool must implement \code{ompt\_tool} to announce its interest.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
extern "C" \{
  ompt_initialize_fn_t ompt_tool(void);
\};
\end{boxedcode}
\ccppspecificend
}

\descr
For a tool to use an OpenMP implementation's OMPT interface,
the tool must define a globally-visible implementation of the
function \code{ompt\_tool}.

A tool may indicate its intent to use the OMPT interface provided
by an OpenMP implementation by having
\code{ompt\_tool} return a non-\code{NULL} pointer to a tool
initializer routine with type signature \code{ompt\_initialize\_fn\_t}.

\begin{comment}
If a tool so indicates its interest in OMPT, the OpenMP implementation
will maintain state information for each OpenMP thread and will
perform any OMPT event callbacks registered by the tool.
\end{comment}

If a tool implements \code{ompt\_tool} but has no interest in using
an OpenMP implementation's OMPT interface in a particular execution,
\code{ompt\_tool} should return \code{NULL}. 

\effect
If a tool returns a non-\code{NULL} pointer to a tool
initializer routine, an OpenMP implementation will 
call the tool initializer
after fully initializing itself but before
beginning execution of any OpenMP construct
or completing execution of any environment routine invocation. 

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_initialize\_fn\_t} type signature, see \specref{sec:ompt_initialize_fn_t}
\end{itemize}
\end{comment}

\section{Tool Callback Signatures and Trace Records}
\label{sec:ompt-tool-callbacks}
\subsection{Initializer Callback Signature}

\omptcallbacksignature{\code{ompt\_initialize\_fn\_t}}
\label{sec:ompt_initialize_fn_t}

\summary
A tool implements an initializer with the type signature
\code{ompt\_initialize\_fn\_t} to initialize the tool's use of
an OpenMP implementation's OMPT interface.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*\plc{ompt_initialize_fn_t}) (
  ompt_function_lookup_t \plc{lookup},
  const char *\plc{runtime_version},
  unsigned int \plc{ompt_version}
);
\end{boxedcode}
\ccppspecificend
}

\descr
For a tool to initialize an OpenMP implementation's OMPT interface,
the tool's implementation of \code{ompt\_tool} must return a 
pointer to a tool initializer with type signature \code{ompt\_initialize\_fn\_t}.
An OpenMP implementation will call the tool initializer returned by
\code{ompt\_tool} after fully initializing itself but before 
beginning execution of any OpenMP construct
or completing execution of any environment routine invocation.  

\argdesc
The first argument passed to a tool initializer 
is \plc{lookup}---a callback 
to an OpenMP runtime routine that a tool must use to 
obtain a pointer to each function in the runtime's OMPT interface.

\begin{comment}
All functions in the OMPT interface are marked with \code{OMPT\_API}, which
indicates that the only way a tool can obtain bindings for them
is using the \plc{lookup} callback.

% The language committee prefers to avoid rationale
The \code{lookup} callback is necessary in the case when an OpenMP runtime 
is dynamically loaded by a shared library. In this case, 
OMPT interface functions provided by the library may 
not be visible to a preloaded tool.
% Within a tool, one uses \code{lookup} to obtain function pointers to each function in the OMPT interface.
\end{comment}

The second argument passed to a tool initializer 
is a version string that unambiguously identifies the OpenMP implementation.

\begin{comment}
% The language committee prefers to avoid rationale
This argument is useful to tool developers trying to debug a statically-linked executable that contains both a tool implementation and an OpenMP implementation.
Knowing exactly what version of an OpenMP implementation is present 
may be helpful when diagnosing a problem, e.g., identifying an old runtime system that may be incompatible with a newer tool.
\end{comment}

The third argument an OpenMP implementation passed to a tool initializer 
is a version number that unambiguously identifies the version of the 
OMPT interface supported by the OpenMP implementation.  
The version of OMPT described by this document is 2.

The actions of a tool initializer are described in \specref{sec:tool-initialize}.

\crossreferences
\begin{itemize}
\item \code{ompt\_function\_lookup\_t}, see
  \specref{sec:ompt_function_lookup_t}.
\end{itemize}


\subsection{Event Callback Signatures and Trace Records}
\index{event callback signatures}
\label{sec:ToolsSupport_callback_signatures}

This section describes the signatures of tool callback functions that an OMPT
tool might register and that are called during runtime of an OpenMP program.

\omptcallbacksignature{\code{ompt\_callback\_thread\_begin\_t}}
\index{ompt\_callback\_thread\_begin\_t@{\code{ompt\_callback\_thread\_begin\_t}}}
\label{sec:ompt_callback_thread_begin_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_thread_begin_t) (
  ompt_thread_type_t \plc{thread_type},
  ompt_data_t *\plc{thread_data}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_thread_begin_record_s \{
  ompt_thread_type_t \plc{thread_type};
\} ompt_thread_begin_record_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr
The callback with type signature \code{ompt\_callback\_thread\_begin\_t},
includes a parameter \plc{thread\_type}
that indicates the type of the new thread: initial, worker, or other.
The binding of \plc{thread\_data} is the new thread.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_thread\_type\_t} type, see
\specref{sec:ompt_thread_type_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_thread\_end\_t}}
\index{ompt\_callback\_callback\_thread\_end\_t@{\code{ompt\_callback\_thread\_end\_t}}}
\label{sec:ompt_callback_thread_end_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_thread_end_s) (
  ompt_data_t *\plc{thread_data}
);
\end{boxedcode}
\ccppspecificend
}
\descr
The binding of \plc{thread\_data} is the finished thread.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_idle\_t}}
\index{ompt\_callback\_idle\_t@{\code{ompt\_callback\_idle\_t}}}
\label{sec:ompt_callback_idle_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback\_idle_t) (
  ompt_scope_endpoint_t \plc{endpoint}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_idle_record_s \{
  ompt_scope_endpoint_t \plc{endpoint};
\} ompt_idle_record_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr
The callback with type signature \code{ompt\_callback\_idle\_t},
includes a parameter \plc{endpoint}
that indicates whether the callback signals the begin or end of the scope.

\crossreferences
\begin{itemize}
\item \code{ompt\_scope\_endpoint\_t} type, see
\specref{sec:ompt_scope_endpoint_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_parallel\_begin\_t}}
\index{ompt\_callback\_parallel\_begin\_t@{\code{ompt\_callback\_parallel\_begin\_t}}}
\label{sec:ompt_callback_parallel_begin_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_parallel_begin_t) (
               ompt_data_t * \plc{parent_task_data},
               const ompt_frame_t * \plc{parent_frame},
               ompt_data_t * \plc{parallel_data},
               unsigned int \plc{requested_team_size},
               unsigned int \plc{actual_team_size},
               ompt_invoker_t \plc{invoker},
               const void * \plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_parallel_begin_record_s \{
  ompt_id_t \plc{parent_task_id};
  const ompt_frame_t *\plc{parent_frame};
  ompt_id_t \plc{parallel_id};
  unsigned int \plc{requested_team_size};
  ompt_invoker_t \plc{invoker};
  const void *\plc{codeptr_ra};
\} ompt_parallel_begin_record_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr
The callbacks with type signature \code{ompt\_callback\_parallel\_begin\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.
The binding of \plc{parent\_task\_data} is the enclosing task, the binding of
\plc{parallel\_data} is the new team.


\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see \specref{sec:ompt_data_t}.
\item \code{ompt\_frame\_t} type, see \specref{sec:ompt_frame_t}.
\item \code{ompt\_invoker\_t} type, see \specref{sec:ompt_invoker_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_parallel\_end\_t}}
\index{ompt\_callback\_parallel\_end\_t@{\code{ompt\_callback\_parallel\_end\_t}}}
\label{sec:ompt_callback_parallel_end_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_callback_parallel_end_t) (
               ompt_data_t *\plc{parallel_data},
               ompt_data_t *\plc{task_data},
               ompt_invoker_t \plc{invoker},
               const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_parallel_end_record_s \{
  ompt_id_t \plc{parallel_id}; 
  ompt_id_t \plc{task_id};
  ompt_invoker_t \plc{invoker};
  const void *\plc{codeptr_ra};
\} ompt_parallel_end_record_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr
The callbacks with type signature \code{ompt\_callback\_parallel\_begin\_t}
include a parameter \plc{invoker} which explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.
The binding of \plc{parallel\_data} is the finishing team.

%\effect
% ompt events have no effect

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type signature, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_invoker\_t} type signature, see
\specref{sec:ompt_invoker_t}.
\end{itemize}

\omptcallbacksignature{\code{ompt\_callback\_master\_t}}
\index{ompt\_callback\_master\_t@{\code{ompt\_callback\_master\_t}}}
\label{sec:ompt_callback_master_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (* ompt_callback_master_t) (
               ompt_scope_endpoint_t \plc{endpoint},
               ompt_data_t *\plc{parallel_data},
               ompt_data_t *\plc{task_data},
               const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_master_record_s \{
  ompt_scope_endpoint_t \plc{endpoint};
  ompt_id_t \plc{parallel_id};
  ompt_id_t  \plc{task_id};
  const void *\plc{codeptr_ra};
\} ompt_master_record_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr
The callbacks with type signature \code{ompt\_callback\_master\_t}
include a parameter \plc{codeptr\_ra} which contains the return address of the
call to the OpenMP runtime routine and a parameter \plc{endpoint}
that indicates whether the callback signals the begin or end of the scope.
The binding of \plc{task\_data} is the innermost enclosing implicit task,
the binding of \plc{parallel\_data} is the innermost enclosing parallel region.

%\effect
% ompt events have no effect

\crossreferences
\begin{itemize}
\item \code{ompt\_scope\_endpoint\_t} type, see
\specref{sec:ompt_scope_endpoint_t}.
\item \code{ompt\_data\_t} type signature, see
\specref{sec:ompt_data_t}.
\end{itemize}





\omptcallbacksignature{\code{ompt\_callback\_task\_create\_t}}
\index{ompt\_callback\_task\_create\_t@{\code{ompt\_callback\_task\_create\_t}}}
\label{sec:ompt_callback_task_create_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_task_create_t) (
  ompt_data_t *\plc{parent_task_data},
  const ompt_frame_t *\plc{parent_frame},
  ompt_data_t *\plc{new_task_data},
  ompt_task_type_t \plc{type},
  int \plc{has_dependences},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_task_create_record_s \{
  ompt_id_t \plc{parent_task_id};
  const ompt_frame_t *\plc{parent_frame};
  ompt_id_t \plc{new_task_id};
  ompt_task_type_t \plc{type};
  _Bool \plc{has_dependences};
  const void *\plc{codeptr_ra};
\} ompt_task_create_record_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr
The callbacks with type signature \code{ompt\_callback\_task\_create\_t},
include a parameter \plc{parent\_frame}
that indicates the frame information of the encountering task, and a parameter
\plc{type} that indicates the kind of the task: initial, explicit or target.
The binding of \plc{parent\_task\_data} is the encountering task,
the binding of \plc{new\_task\_data} is the created task.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_frame\_t} type, see
\specref{sec:ompt_frame_t}.
\item \code{ompt\_task\_type\_t} type, see
\specref{sec:ompt_task_type_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_task\_dependences\_t}}
\index{ompt\_callback\_task\_dependences\_t@{\code{ompt\_callback\_task\_dependences\_t}}}
\label{sec:ompt_callback_task_dependences_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_task_dependences_t) (
  ompt_data_t *\plc{task_data},
  const ompt_task_dependence_t *\plc{deps},
  int \plc{ndeps}
);
\end{boxedcode}
\ccppspecificend
}

%\begin{targetRecord}
%\record
%Note: not task dependences record since it points to data rather than containing it.
%\end{targetRecord}

\descr
The callback with type signature \code{ompt\_callback\_task\_dependences\_t},
includes a parameter \plc{deps} that lists all dependences of a new task and
a parameter \plc{ndeps} that specifies the length of the list.
The memory ownage of \plc{deps} remains at the caller, the tool cannot rely on
the data after the callback returns.
The binding of \plc{task\_data} is the created task.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_task\_dependence\_t} type, see
\specref{sec:ompt_task_dependence_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_task\_dependence\_t}}
\index{ompt\_callback\_task\_dependence\_t@{\code{ompt\_callback\_task\_dependence\_t}}}
\label{sec:ompt_callback_task_dependence_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_task_dependence_t) (
  ompt_data_t *\plc{src_task_data},
  ompt_data_t *\plc{sink_task_data}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_task_dependence_record_s \{
  ompt_id_t \plc{src_task_id};
  ompt_id_t \plc{sink_task_id};
\} ompt_task_dependence_record_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr
The binding of \plc{src\_task\_data} is a running task with an out dependency.
The binding of \plc{sink\_task\_data} is a task with a non-satisfied in dependency.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type signature, see
\specref{sec:ompt_data_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_task\_schedule\_t}}
\index{ompt\_callback\_task\_schedule\_t@{\code{ompt\_callback\_task\_schedule\_t}}}
\label{sec:ompt_callback_task_schedule_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_task_schedule_t) (
  ompt_data_t *\plc{prior_task_data},
  ompt_task_status_t \plc{prior_task_status},
  ompt_data_t *\plc{next_task_data}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_task_schedule_record_s \{
  ompt_id_t \plc{prior_task_id};
  ompt_task_status_t \plc{prior_task_status},
  ompt_id_t \plc{next_task_id};
\} ompt_task_schedule_record_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr
The callback with type signature \code{ompt\_callback\_task\_schedule\_t},
include a parameter \plc{prior\_task\_status}
that indicates the current status of the task that reached the task
scheduling point. 
The binding of \plc{prior\_task\_data} is the task that reached the task scheduling point.
The binding of \plc{next\_task\_data} is the task to be scheduled.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.

\item \code{ompt\_task\_status\_t} type, see
\specref{sec:ompt_task_status_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_implicit\_task\_t}}
\index{ompt\_callback\_implicit\_t@{\code{ompt\_callback\_implicit\_task\_t}}}
\label{sec:ompt_callback_implicit_task_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_implicit_task_t) (
  ompt_scope_endpoint_t \plc{endpoint},
  ompt_data_t *\plc{parallel_data},
  ompt_data_t *\plc{task_data},
  unsigned int \plc{thread_num}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_implicit_record_s \{
  ompt_scope_endpoint_t \plc{endpoint};
  ompt_id_t \plc{parallel_id};
  ompt_id_t \plc{task_id};
  unsigned int \plc{thread_num};
\} ompt_implicit_record_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr
The callback with type signature \code{ompt\_callback\_implicit\_task\_t},
includes a parameter \plc{endpoint} that indicates whether the callback signals
the begin or end of the scope and a parameter \plc{thread\_num} that indicates
the thread number of the calling thread, within the team executing the parallel
region to which the implicit region binds.
The binding of \plc{parallel\_data} is the innermost enclosing parallel region.
The binding of \plc{task\_data} is the implicit task executing the parallel
region's structured block.


\crossreferences
\begin{itemize}
\item \code{ompt\_scope\_endpoint\_t} enumeration type, see
\specref{sec:ompt_scope_endpoint_t}.
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_sync\_region\_t}}
\index{ompt\_callback\_sync\_region\_t@{\code{ompt\_callback\_sync\_region\_t}}}
\label{sec:ompt_callback_sync_region_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_sync_region_t) (
  ompt_sync_region_kind_t \plc{kind},
  ompt_scope_endpoint_t \plc{endpoint},
  ompt_data_t *\plc{parallel_data},
  ompt_data_t *\plc{task_data},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_sync_region_record_s \{
  ompt_sync_region_kind_t \plc{kind};
  ompt_scope_endpoint_t \plc{endpoint};
  ompt_id_t \plc{parallel_id};
  ompt_id_t  \plc{task_id};
  const void *\plc{codeptr_ra};
\} ompt_sync_region_record_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr 
A tool executes a callback with type signature
\code{ompt\_callback\_sync\_region\_t} to receive notification of
event \code{ompt\_callback\_sync\_region\_t} when an OpenMP
implementation starts and stops waiting in a barrier region, taskwait
region, or taskgroup region.

\constraints
The first argument indicates the kind of region causing the wait.  
The second argument indicates whether the callback indicates whether the
task is about to start waiting with value \code{ompt\_scope\_begin}, or about
to stop waiting, with value \code{ompt\_scope\_end}. 
The third argument is a pointer to the tool's data area for the
current parallel region.
The fourth argument is a pointer to the tool's data area for the
current task region.
The last argument, \code{codeptr\_ra}, is the return address following the
task's call to a routine to implement the waiting or invoke this
callback; \code{codeptr\_ra} may be NULL.  

\crossreferences
\begin{itemize}
\item \code{ompt\_sync\_region\_kind\_t} type, see
\specref{sec:ompt_sync_region_kind_t}.
\item \code{ompt\_scope\_endpoint\_t} type, see
\specref{sec:ompt_scope_endpoint_t}.
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_lock\_init\_t}}
\index{ompt\_callback\_lock\_init\_t@{\code{ompt\_callback\_lock\_init\_t}}}
\label{sec:ompt_callback_lock_init_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_lock_init_t) (
  int \plc{is_nest_lock},
  ompt_wait_id_t \plc{wait_id},
  unsigned int \plc{hint},
  unsigned int \plc{kind},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_lock_init_record_s \{
  _Bool \plc{is_nest_lock};
  ompt_wait_id_t wait_id;
  unsigned int hint;
  unsigned int kind;
  const void *\plc{codeptr_ra};
\} ompt_lock_init_record_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr
The callbacks with type signature \code{ompt\_callback\_lock\_init\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
%The \plc{invoker} argument explains whether the execution of the parallel
%region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_wait\_id\_t} type, see
\specref{sec:ompt_wait_id_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_lock\_destroy\_t}}
\index{ompt\_callback\_lock\_destroy\_t@{\code{ompt\_callback\_lock\_destroy\_t}}}
\label{sec:ompt_callback_lock_destroy_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_lock_destroy_t) (
  int \plc{is_nest_lock},
  ompt_wait_id_t \plc{wait_id},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_lock_destroy_record_s \{
  _Bool \plc{is_nest_lock};
  ompt_wait_id_t \plc{wait_id};
  const void *\plc{codeptr_ra};
\} ompt_lock_destroy_record_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr
The callbacks with type signature \code{ompt\_callback\_lock\_destroy\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
%The \plc{invoker} argument explains whether the execution of the parallel
%region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_wait\_id\_t} type, see
\specref{sec:ompt_wait_id_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_mutex\_acquire\_t}}
\index{ompt\_callback\_mutex\_acquire\_t@{\code{ompt\_callback\_mutex\_acquire\_t}}}
\label{sec:ompt_callback_mutex_acquire_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_mutex_acquire_t) (
  ompt_mutex_kind_t \plc{kind},
  unsigned int \plc{hint},
  unsigned int \plc{impl},
  ompt_wait_id_t \plc{wait_id},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_mutex_acquire_record_s \{
  ompt_mutex_kind_t \plc{kind};
  unsigned int \plc{hint};
  unsigned int \plc{impl};
  ompt_wait_id_t \plc{wait_id};
  const void *\plc{codeptr_ra};
\} ompt_mutex_acquire_record_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr
The callbacks with type signature \code{ompt\_callback\_mutex\_acquire\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
%The \plc{invoker} argument explains whether the execution of the parallel
%region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_mutex\_kind\_t} type, see
\specref{sec:ompt_mutex_kind_t}.
\item \code{ompt\_wait\_id\_t} type, see
\specref{sec:ompt_wait_id_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_mutex\_t}}
\index{ompt\_callback\_mutex\_t@{\code{ompt\_callback\_mutex\_t}}}
\label{sec:ompt_callback_mutex_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_mutex_t) (
  ompt_mutex_kind_t \plc{kind},
  ompt_wait_id_t \plc{wait_id},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_mutex_record_s \{
  ompt_mutex_kind_t \plc{kind};
  ompt_wait_id_t \plc{wait_id};
  const void *\plc{codeptr_ra};
\} ompt_mutex_record_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr
The callbacks with type signature \code{ompt\_callback\_mutex\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
%The \plc{invoker} argument explains whether the execution of the parallel
%region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_mutex\_kind\_t} type signature, see
\specref{sec:ompt_mutex_kind_t}.
\item \code{ompt\_wait\_id\_t} type signature, see
\specref{sec:ompt_wait_id_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_nested\_lock\_t}}
\index{ompt\_callback\_nested\_lock\_t@{\code{ompt\_callback\_nested\_lock\_t}}}
\label{sec:ompt_callback_nested_lock_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_nested_lock_t) (
  ompt_scope_endpoint_t \plc{endpoint},
  ompt_wait_id_t \plc{wait_id},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_nested_lock_record_s \{
  ompt_scope_endpoint_t \plc{endpoint};
  ompt_wait_id_t \plc{wait_id};
  const void *\plc{codeptr_ra};
\} ompt_nested_lock_record_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr
The callbacks with type signature \code{ompt\_callback\_nested\_lock\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
%The \plc{invoker} argument explains whether the execution of the parallel
%region code is inlined into the application code or started by the runtime.

include a parameter \plc{codeptr\_ra} which contains the return address of the
call to the OpenMP runtime routine and a parameter \plc{endpoint}
that indicates whether the callback signals the begin or end of the scope.

\crossreferences
\begin{itemize}
\item \code{ompt\_scope\_endpoint\_t} type signature, see
\specref{sec:ompt_scope_endpoint_t}.
\item \code{ompt\_wait\_id\_t} type signature, see
\specref{sec:ompt_wait_id_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_work\_t}}
\index{ompt\_callback\_work\_t@{\code{ompt\_callback\_work\_t}}}
\label{sec:ompt_callback_work_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_work_t) (
  ompt_work_type_t \plc{wstype},
  ompt_scope_endpoint_t \plc{endpoint},
  ompt_data_t *\plc{parallel_data},
  ompt_data_t *\plc{task_data},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_work_record_s \{
  ompt_work_type_t \plc{wstype};
  ompt_scope_endpoint_t \plc{endpoint};
  ompt_id_t \plc{parallel_id};
  ompt_id_t \plc{task_id};
  const void *\plc{codeptr_ra};
\} ompt_work_record_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr
The callbacks with type signature \code{ompt\_callback\_work\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
%The \plc{invoker} argument explains whether the execution of the parallel
%region code is inlined into the application code or started by the runtime.

include a parameter \plc{codeptr\_ra} which contains the return address of the
call to the OpenMP runtime routine and a parameter \plc{endpoint}
that indicates whether the callback signals the begin or end of the scope.

\crossreferences
\begin{itemize}
\item \code{ompt\_work\_type\_t} type signature, see
\specref{sec:ompt_work_type_t}.
\item \code{ompt\_scope\_endpoint\_t} type signature, see
\specref{sec:ompt_scope_endpoint_t}.
\item \code{ompt\_data\_t} type signature, see
\specref{sec:ompt_data_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_flush\_t}}
\index{ompt\_callback\_flush\_t@{\code{ompt\_callback\_flush\_t}}}
\label{sec:ompt_callback_flush_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_flush_t) (
  ompt_data_t *\plc{thread_data},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_flush_record_s \{
  void *\plc{codeptr_ra};
\} ompt_flush_record_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr
The callbacks with type signature \code{ompt\_callback\_flush\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
%The \plc{invoker} argument explains whether the execution of the parallel
%region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type signature, see
\specref{sec:ompt_data_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_target\_t}}
\index{ompt\_callback\_target\_t@{\code{ompt\_callback\_target\_t}}}
\label{sec:ompt_callback_target_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_target_t) (
  int \plc{device_id},
  ompt_target_type_t \plc{kind},
  ompt_data_t *\plc{task_data},
  ompt_scope_endpoint_t \plc{endpoint},
  ompt_id_t \plc{target_id},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_target_record_s \{
  int \plc{device_id};
  ompt_target_type_t \plc{kind};
  ompt_data_t *\plc{task_data};
  ompt_scope_endpoint_t \plc{endpoint};
  ompt_id_t \plc{target_id};
  const void *\plc{codeptr_ra};
\} ompt_target_record_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr
The callbacks with type signature \code{ompt\_callback\_target\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
%The \plc{invoker} argument explains whether the execution of the parallel
%region code is inlined into the application code or started by the runtime.

include a parameter \plc{codeptr\_ra} which contains the return address of the
call to the OpenMP runtime routine and a parameter \plc{endpoint}
that indicates whether the callback signals the begin or end of the scope.

\crossreferences
\begin{itemize}
\item \code{ompt\_target\_type\_t} type signature, see
\specref{sec:ompt_target_type_t}.
\item \code{ompt\_data\_t} type signature, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_scope\_endpoint\_t} type signature, see
\specref{sec:ompt_scope_endpoint_t}.
\item \code{ompt\_id\_t} type, see
\specref{sec:ompt_id_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_target\_data\_t}}
\index{ompt\_callback\_target\_data\_t@{\code{ompt\_callback\_target\_data\_t}}}
\label{sec:ompt_callback_target_data_t}
\format

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_target_data_t) (
  ompt_id_t \plc{target_id},
  ompt_id_t \plc{host_op_id},
  ompt_target_data_op_t \plc{optype},
  void *\plc{host_addr},
  void *\plc{device_addr},
  size_t \plc{bytes}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_target_data_record_s \{
  ompt_id_t \plc{host_op_id};
  ompt_target_data_op_t \plc{optype};
  void *\plc{host_addr};
  void *\plc{device_addr};
  size_t \plc{bytes};
  ompt_device_time_t \plc{end_time};
\} ompt_target_data_record_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr
The callbacks with type signature \code{ompt\_callback\_target\_data\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
%The \plc{invoker} argument explains whether the execution of the parallel
%region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_id\_t} type, see
\specref{sec:ompt_id_t}.
\item \code{ompt\_target\_data\_op\_t} type signature, see
\specref{sec:ompt_target_data_op_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_target\_map\_t}}
\index{ompt\_callback\_target\_map\_t@{\code{ompt\_callback\_target\_map\_t}}}
\label{sec:ompt_callback_target_map_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_target_map_t) (
  ompt_id_t \plc{target_id},
  unsigned int \plc{nitems},
  void **\plc{host_addr},
  void **\plc{device_addr},
  size_t *\plc{bytes},
  unsigned int *\plc{mapping_flags}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void ompt_target_map_record_s \{
  ompt_id_t \plc{target_id};
  unsigned int \plc{nitems};
  void **\plc{host_addr};
  void **\plc{device_addr};
  size_t *\plc{bytes};
  unsigned int *\plc{mapping_flags};
\} ompt_target_map_record_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr
The callbacks with type signature \code{ompt\_callback\_target\_map\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
%The \plc{invoker} argument explains whether the execution of the parallel
%region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_id\_t} type, see
\specref{sec:ompt_id_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_target\_submit\_t}}
\index{ompt\_callback\_target\_submit\_t@{\code{ompt\_callback\_target\_submit\_t}}}
\label{sec:ompt_callback_target_submit_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_target_submit_t) (
  ompt_id_t \plc{target_id},
  ompt_id_t \plc{host_op_id}
);
\end{boxedcode}
\ccppspecificend
}

\descr
This callback is invoked when a target task creates an initial task on a
target device. The \plc{target\_id} argument is a unique identifier for the
associated target region.
The \plc{host\_op\_id} used is a unique identifer for the initial task
on the target device.

\constraints
The callback argument \plc{target\_id} indicates the instance of the target
construct to which the computation belongs.  The callback argument
\plc{host\_op\_id} provides a unique host-side identifier that
represents the computation on the device.  

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_target_kernel_record_s \{
  ompt_id_t \plc{host_op_id};
  unsigned int \plc{requested_num_teams};
  unsigned int \plc{granted_num_teams};
  ompt_device_time_t \plc{end_time};
\} ompt_target_kernel_record_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\crossreferences
\begin{itemize}
\item \code{ompt\_id\_t} type, see
\specref{sec:ompt_id_t}.
\end{itemize}


\omptcallbacksignature{\code{ompt\_callback\_buffer\_request\_t}}
\index{ompt\_callback\_buffer\_request\_t@{\code{ompt\_callback\_buffer\_request\_t}}}
\label{sec:ompt_callback_buffer_request_t}

\summary
The OpenMP runtime will invoke a callback with type signature  
\code{ompt\_callback\_buffer\_request\_t} to request a
buffer to store event records for a device.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_buffer_request_t) (
  int \plc{device_id},
  ompt_buffer_t** \plc{buffer},
  size_t *\plc{bytes}
);
\end{boxedcode}
\ccppspecificend
}

\constraints 
The callback requests a buffer to store trace records for device \plc{device\_id}.  
A tool should set \plc{*buffer} to point to a buffer where device events
may be recorded and \plc{*bytes} to the length of that buffer.  A
buffer request callback  may set \plc{*bytes} to 0 if it does not
want to provide a buffer for any reason. If a callback sets
\plc{*bytes} to 0, further recording of events for the device will
be disabled until the next invocation of \code{ompt\_start\_trace}.
This will cause the device to drop future trace records until
recording is restarted.

Note: {\em buffer request and completion callbacks are not 
required to be async-signal safe.}

To start recording, a tool needs to register a \emph{buffer request}
callback that will supply a device with a buffer to deposit events
and a \emph{buffer complete} callback that will be invoked by the
OpenMP runtime to empty a buffer containing event records. A device's
offloading runtime library is responsible for invoking these callbacks
on a thread that is not an OpenMP master or worker. 

\crossreferences
\begin{itemize}
\item \code{ompt\_buffer\_t} type, see
\specref{sec:ompt_buffer_t}.
\end{itemize}

\omptcallbacksignature{\code{ompt\_callback\_buffer\_complete\_t}}
\index{ompt\_callback\_buffer\_complete\_t@{\code{ompt\_callback\_buffer\_complete\_t}}}
\label{sec:ompt_callback_buffer_complete_t}
\summary
A device triggers a call to \code{ompt\_callback\_buffer\_complete\_t} when no further records will be recorded in an event buffer and all records written to the buffer are valid. 

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_buffer_complete_t) (
  int \plc{device_id},
  const ompt_buffer_t *\plc{buf},
  size_t \plc{bytes},
  ompt_buffer_cursor_t \plc{begin},
  int \plc{buffer_owned}
);
\end{boxedcode}
\ccppspecificend
}
\descr ToDo
The callbacks with type signature \code{ompt\_callback\_buffer\_complete\_t},

\constraints

The argument \plc{device\_id} indicates the device whose events the
buffer contains. The argument \plc{buffer} is the address of a
buffer previously allocated by a \emph{buffer request} callback.
The argument \plc{bytes} indicates the full size of the buffer.
The argument \plc{begin} is an opaque cursor that indicates the
position at the beginning of the first record in the buffer. The
argument \plc{buffer\_owned} is 1 if the data
pointed to by buffer was allocated by a call to the buffer request
callback for that device and 0 otherwise. If multiple devices accumulate trace
events into a single buffer (as is the case for NVIDIA's CUPTI API),
this callback might be invoked with a pointer to one or more trace
records in a shared buffer with \plc{buffer\_owned} = 0. In this
case, the callback may not delete the buffer.

Under normal operating conditions, every event buffer provided to
a device by a \emph{buffer request} callback will receive a
\emph{buffer complete} callback before the OpenMP runtime shuts
down. If an exceptional condition terminates  execution of an OpenMP
program, the OpenMP runtime may choose not to provide a \emph{buffer
complete} callback for buffers provided to any device.


\crossreferences
\begin{itemize}
\item \code{ompt\_buffer\_t} type, see
\specref{sec:ompt_buffer_t}.
\item \code{ompt\_buffer\_cursor\_t} type, see
\specref{sec:ompt_buffer_cursor_t}.
\end{itemize}

\omptcallbacksignature{\code{ompt\_callback\_tcontrol\_t}}
\index{ompt\_callback\_tcontrol\_t@{\code{ompt\_callback\_tcontrol\_t}}}
\label{sec:ompt_callback_tcontrol_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_callback_tcontrol_t) (
  long long int \plc{command},
  long long int \plc{modifier},
  void *arg
);
\end{boxedcode}
\ccppspecificend
}
\descr 
The callback with type signature \code{ompt\_callback\_tcontrol\_t},
includes parameters \plc{command} and \plc{modifier}. Standard values for
\plc{command} are defined by \code{omp\_tcontrol\_t}. 
defined in \specref{sec:tool_tcontrol}.
The callback also allows tool-specific values for \plc{command} and \plc{modifier}.
Tool-specific values for \plc{command} must be $\geq$ 64.
Tools must ignore \plc{command} values that they are not 
explicitly designed to handle.

\crossreferences
\begin{itemize}
\item \code{omp\_tcontrol\_t} enumeration type, see \specref{sec:tool_tcontrol}.
\end{itemize}

\omptcallbacksignature{\code{ompt\_callback\_cancel\_t}}
\index{ompt\_callback\_cancel\_t@{\code{ompt\_callback\_cancel\_t}}}
\label{sec:ompt_callback_cancel_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_cancel_t) (
  ompt_data_t *\plc{task_data},
  int \plc{flags},
  const void *\plc{codeptr_ra}
  );
\end{boxedcode}
\ccppspecificend
}
\descr 
The callback with type signature \code{ompt\_callback\_cancel\_t},
includes \plc{flags} defined by the enumeration  \code{ompt\_cancel\_flag\_t}, which determines
whether the cancel is activated by the current task, or detected as being activated by another task. 
The construct being canceled is also described in the \plc{flags}.
When several constructs are detected as being concurrently canceled, each corresponding 
bit in the flags will be set. The \plc{task\_data} and \plc{codeptr\_ra} corresponds to 
the task encountering the cancel construct, 
the cancellation point construct, or the construct defined as having an implicit cancellation point construct.

\crossreferences
\begin{itemize}
\item \code{omp\_cancel\_flag\_t} enumeration type, see \specref{sec:ompt_cancel_flag_t}.
\end{itemize}


\omptcallbacksignature{\code{ompt\_callback\_device\_initialize\_t}}
\index{ompt\_callback\_flush\_t@{\code{ompt\_callback\_device\_initialize\_t}}}
\label{sec:ompt_callback_device_initialize_t}

\summary The tool callback with type signature
\code{ompt\_callback\_device\_initialize\_t} initializes a
tool's tracing interface for a device.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_device_initialize_t) (
  int \plc{device_id},
  const char *\plc{type},
  ompt_device_t *\plc{device},
  ompt_function_lookup_t *\plc{lookup},
  const char *\plc{documentation}
);
\end{boxedcode}
\ccppspecificend
}

\descr 

A tool that wants to asynchronously collect a trace of
activities on a device should register a callback with type signature
\code{ompt\_callback\_device\_initialize\_t} for the
\code{ompt\_callback\_device\_initialize} OpenMP event. An OpenMP
implementation will invoke this callback for a device after OpenMP is
initialized for the device but before beginning execution of any
OpenMP construct on the device.

\argdesc

The first argument identifies the logical device being initialized.

The second argument is a character string indicating the type of the
device. A device type string is a semicolon separated character string
that includes at a minimum the vendor and model name of the
device. This may be followed by a semicolon-separated sequence of
properties that describe a device's hardware or software.  An example
type string in this format is the following: ``NVIDIA; Tesla M2050;
compute capability 2.0; CUDA 8.0''.

The third argument is a pointer to an opaque object that represents
the target device instance. The pointer to the device instance object
is used by functions in the device tracing interface to identify the
device being addressed.

The fourth argument is \plc{lookup}---a pointer to a runtime callback
that a tool must use to obtain pointers to entry points in the
device's OMPT tracing interface.

The last argument is a string that describes names and type signatures
of any additional device-specific entry points that can be obtained
using \plc{lookup}. Ideally, the documentation string should include
not only the type signature but also descriptive text for how to use
the device-specific API or pointers to external documentation about
it.

\effect

A tool's device initializer has several duties.  First, it should use
\plc{type} to determine whether the tool has any special knowledge
about a device's hardware and/or software.  Second, it should use
\plc{lookup} to look up pointers to entry points in the OMPT tracing
interface for the device.  Finally, using these entry points, it can
then set up tracing for a device.

Initializing tracing for a target device is described in section
\specref{sec:tracing-device-activity}. 

\crossreferences
\begin{itemize}
\item \code{ompt\_function\_lookup\_t}, see
  \specref{sec:ompt_function_lookup_t}.
\end{itemize}

\section{Runtime Entry Points for Tools}
\label{sec:entry-points}

The OMPT interface supports two principal sets of entry points for tools. One
set of entry points enables a tool to register callbacks for OpenMP
events and to inspect the state of an OpenMP thread while
executing in a tool callback or a signal handler. The second set of entry points enables a
tool to trace activities on a device. When directed by the tracing
interface, an OpenMP implementation will trace activities on a device, collect
buffers full of trace records, and invoke callbacks on the host to
process these records. 
Runtime entry points for tools in an OpenMP implementation
should not be global symbols since tools cannot rely on the visibility
of such symbols in general.

In addition, the OMPT interface supports
entry points for two classes of lookup routines. The first
class of lookup routines contains a single member: a
routine that returns entry points in the OMPT callback interface. 
The second class of lookup routines includes 
a unique lookup routine for each kind of
device that can return entry points in a device's OMPT tracing interface.

\subsection{Entry Points in the OMPT Callback Interface}
\label{sec:ompt-callback-entry-points}

Entry points in the OMPT callback interface enable a tool to register
callbacks for OpenMP events and to inspect the state of an OpenMP thread while
executing in a tool callback or a signal handler. 
A tool obtains pointers to these entry points 
using the lookup function passed to the tool's initializer for the
callback interface.

{\em All entry points in the OMPT callback interface that 
  inspect an OpenMP thread's state must be async signal safe} so
that tools can call them from a signal handler.

\begin{comment}
OpenMP Runtime Library Routines are not guaranteed to be async
signal safe. That means that they might acquire and release 
a lock as part of their normal operation. For that reason,
is unsafe to call OpenMP Runtime Library Routines 
within an OMPT callback because doing
so may cause deadlock.
\end{comment}


\omptruntimeentrypoint{\code{ompt\_enumerate\_states\_t}}
\label{sec:ompt_enumerate_states_t}
\label{sec:ompt_enumerate_states}

\summary
An OpenMP implementation's 
tool entry point known as \code{ompt\_enumerate\_states} 
with type signature \code{ompt\_enumerate\_states\_t} 
enumerates the thread states supported by an OpenMP 
implementation.

\format

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_enumerate_states_t)(
  int \plc{current_state}, 
  int *\plc{next_state}, 
  const char **\plc{next_state_name}
);
\end{boxedcode}
\ccppspecificend
}

\descr
An OpenMP implementation may support only a subset of the states defined by 
the \code{omp\_states\_t} enumeration type. In addition, an
OpenMP implementation may support implementation-specific states.
The \code{ompt\_enumerate\_states} entry point enables a tool to 
enumerate the thread states supported by an OpenMP implementation.
 
When a thread state supported by an OpenMP implementation is passed
as the first argument to the entry point,
the entry point will assign the next thread state in the enumeration to
the variable passed by reference as the entry point's second argument
and assign the name associated with the next thread state
to the character pointer passed by reference as the third argument.
 
Whenever one or more states are left in the enumeration, 
the enumerate states entry point will return $1$.
When the last state in the enumeration is passed 
as the first argument, the entry point will return $0$ 
indicating that the enumeration is complete.

\begin{comment}
For instance, a particular OpenMP implementation may want to 
provide more detail about the nature of runtime overhead, 
e.g., to differentiate between overhead associated with setting up 
parallel regions
and overhead associated with setting up tasks. 
% A tool need not report all states defined herein, e.g., if state tracking for a particular state would be too expensive.
To enable a tool to identify all states that an OpenMP implementation
supports, the following interface for enumerating all states that may be reported by the runtime that is being used.
\end{comment}

\constraints

The first argument passed to the enumerate states entry point must be
a thread state supported by the OpenMP implementation.  
To begin enumerating the states that an OpenMP implementation supports,
a tool should pass \code{omp\_state\_undefined} as the
first argument to the enumerate states entry point.
Subsequent invocations of the entry point by the tool
should pass the value 
assigned to the variable passed by reference as the second argument to the previous call.

The second and third arguments to the entry point must be valid
references to variables of the specified types.

\vspace{2ex}

\needspace{6\baselineskip}\notestart
\noteheader -- The following example illustrates how a tool can 
enumerate all states supported by an OpenMP implementation.
The example assumes that a pointer to an OpenMP implementation's enumerate
states entry point has previously been assigned to a function pointer
\code{ompt\_enumerate\_states\_fn}.

\vbox{
\ccppspecificstart
\begin{boxedcode}
int state = omp_state_undefined;
const char *state_name;
while (ompt_enumerate_states_fn(state, &state, &state_name)) \{
  // note that the runtime supports a state value "state" 
  // associated with the name "state_name" 
\}
\end{boxedcode}
\ccppspecificend
\noteend
}

\crossreferences
\begin{itemize}
\item \code{omp\_state\_t}, see \specref{sec:thread-states}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_enumerate\_mutex\_impls\_t}}
\label{sec:ompt_enumerate_mutex_impls_t}
\label{sec:ompt_enumerate_mutex_impls}
\label{sec:ompt_mutex_impl_unknown}
 
\summary

An OpenMP implementation's tool entry point known as \code{ompt\_enumerate\_mutex\_impls} 
with type signature \code{ompt\_enumerate\_mutex\_impls\_t} 
enumerates the kinds of mutual exclusion implementations that
an OpenMP implementation employs.


\format

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_enumerate_mutex_impls_t)(
  int \plc{current_impl}, 
  int *\plc{next_impl}, 
  const char **\plc{next_impl_name}
);

#define ompt_mutex_impl_unknown 0
\end{boxedcode}
\ccppspecificend
}

\descr
An OpenMP implementation may implement mutual exclusion for locks,
nest locks, critical sections, and atomic regions in several different
ways.  The \code{ompt\_enumerate\_mutex\_impls} entry point
enables a tool to enumerate the 
kinds of mutual exclusion implementations that an OpenMP implementation
employs.
The value \code{ompt\_mutex\_impl\_unknown} is reserved to indicate an invalid
implementation.

\begin{comment}
For that reason, a user program can provide hints
to help the runtime system to select appropriate implementations.
When a lock or nest lock is initialized, the \code{ompt\_callback\_init\_lock}
callback receives the argument \code{kind}---a small integer that
indicates the lock implementation chosen by the OpenMP runtime.
Similarly, the \code{ompt\_callback\_mutex\_acquire} callback receives
the argument \code{kind} to indicate the implementation of a lock,
critical section, atomic region, or ordered section. 
\end{comment}

When a mutex kind supported by an OpenMP implementation is passed
as the first argument to the entry point,
the entry point will assign the next mutex kind in the enumeration to
the variable passed by reference as the entry point's second argument
and assign the name associated with the next mutex kind 
to the character pointer passed by reference as the third argument.

Whenever one or more mutex kinds are left in the enumeration, 
the enumerate mutex kinds entry point will return $1$.
When the last mutex kind in the enumeration is passed 
as the first argument, the entry point will return $0$ 
indicating that the enumeration is complete.

\constraints
The first argument passed to the enumerate mutex kinds entry point must be
a mutex implementation kind supported
by an OpenMP implementation.  To begin enumerating the mutex
implementation kinds that an OpenMP implementation supports, a tool
should pass \code{ompt\_mutex\_impl\_unknown} as the first
argument of the enumerate mutex kinds entry point.  Subsequent invocations
of the entry point by the tool should pass the
value assigned to the variable passed by reference as the second
argument to the previous call.

The second and third arguments to the entry point must be valid
references to variables of the specified types.

\needspace{6\baselineskip}\notestart
\noteheader -- The following example illustrates how a tool can 
enumerate all types of mutex implementations supported by an OpenMP runtime.
The example assumes that a pointer to an OpenMP implementation's enumerate
mutex kinds callback has previously been assigned to a function pointer
\code{ompt\_enumerate\_mutex\_impls\_fn}.

\vspace{2ex}

\vbox{
\ccppspecificstart
\begin{boxedcode}
int kind = ompt_mutex_impl_unknown;
const char *impl_name;
while (ompt_enumerate_mutex_impls_fn(impl, &impl, &impl_name)) \{
  // note that the runtime supports a mutex value "impl" 
  // associated with the name "impl_name" 
\}
\end{boxedcode}
\ccppspecificend
\noteend
}


\omptruntimeentrypoint{\code{ompt\_callback\_set\_t}}
\label{sec:ompt_callback_set_t}
\label{sec:ompt_callback_set}

\summary

An OpenMP implementation's tool entry point known as \code{ompt\_callback\_set} 
with type signature \code{ompt\_callback\_set\_t} registers a
pointer to a tool callback that an OpenMP implementation will invoke when a host
OpenMP event occurs.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_callback_set_t)(
  ompt_callback_t \plc{event},
  ompt_callback_t \plc{callback}
);
\end{boxedcode}
\ccppspecificend
}

\descr

OpenMP implementations can inform tools about events that occur during
the execution of an OpenMP program using callbacks.
To register a tool callback for an OpenMP event on the current device, 
a tool uses an OpenMP implementation's tool entry point 
known as \code{ompt\_callback\_set} 
with type signature \code{ompt\_callback\_set\_t}.

The return value of the \code{ompt\_callback\_set} entry point may indicate several possible
outcomes. Callback registration may fail if it is called outside the initializer for the
callback interface. Otherwise, the return value of set callback 
indicates whether or not the event may occur during execution and
whether or not the callback will always be invoked or not.

\constraints
When a tool registers a callback for an event, the type
signature for the callback must match the type signature appropriate for the
event. 
For an event with enumeration value name {\ttfamily\bfseries ompt\_callback\_{\em xxx}}, 
the type signature for the event is {\ttfamily\bfseries ompt\_{\em xxx}\_callback\_t}. 
 
\begin{table}
\centering
\begin{tabular}{ll}
\hline
Return code & Meaning \\
\hline
0 & callback registration error\\
1 & event may occur; no callback is possible\\
2 & event may occur; callback invoked when convenient\\
3 & event may occur; callback always invoked when event occurs\\
\hline
\end{tabular}
\vskip 1ex
\caption{Meaning of return codes for \code{ompt\_callback\_set}.}
\label{table:ToolsSupport_set_rc}
\end{table}

\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_t} enumeration type, see \specref{sec:ompt_callback_t}.
\item \code{ompt\_callback\_t} type, see \specref{sec:ompt_callback_t}.
\item \code{ompt\_callback\_get\_t} host callback ftype signature,
see \specref{sec:ompt_callback_get_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_callback\_get\_t}}
\label{sec:ompt_callback_get_t}
\label{sec:ompt_callback_get}

\summary

An OpenMP implementation's tool entry point known as \code{ompt\_callback\_get} 
with type signature \code{ompt\_callback\_get\_t} retrieves a pointer
to a tool callback routine (if any) 
that an OpenMP implementation will invoke when an OpenMP event occurs.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_callback_get_t)(
  ompt_callback_t \plc{event},
  ompt_callback_t *\plc{callback}
);
\end{boxedcode}
\ccppspecificend
}

\descr
A tool uses an OpenMP implementation's tool entry point known 
as \code{ompt\_callback\_get} 
with type signature \code{ompt\_callback\_get\_t} 
to obtain a pointer to the tool callback that 
an OpenMP implementation will invoke when a host OpenMP event occurs. 
If a non-\code{NULL} tool callback is registered for the specified event, 
the pointer to the tool callback will be assigned to the variable
passed by reference as the second argument and the entry
point will return 1; otherwise, it will return 0. If the entry point
returns 0, the value of the variable passed by reference as the second
argument is undefined.

\constraints
The second argument passed to the entry point must be a reference
to a variable of specified type.

\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_t} enumeration type, see \specref{sec:ompt_callback_t}.
\item \code{ompt\_callback\_t} type, see \specref{sec:ompt_callback_t}.
\item \code{ompt\_callback\_set\_t} type signature, 
see \specref{sec:ompt_callback_set_t}. 
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_get\_thread\_data\_t}}
\label{sec:thread-inquiry}
\label{sec:ompt_get_thread_data_t}
\label{sec:ompt_get_thread_data}

\summary
An OpenMP implementation's tool entry point known as \code{ompt\_get\_thread\_data}
with type signature \code{ompt\_get\_thread\_data\_t} 
returns the address of the thread data object for the current thread.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef ompt_data_t *(*ompt_get_thread_data_t)(void);
\end{boxedcode}
\ccppspecificend}

\descr

Each OpenMP thread has an associated thread data object of type
\code{ompt\_data\_t}. 
A tool uses an OpenMP implementation's tool entry point known as
\code{ompt\_get\_thread\_data} 
with type signature \code{ompt\_get\_thread\_data\_t}
to obtain a pointer to the thread data object, if any, associated with the
current thread. If the current thread is unknown to the OpenMP
runtime, the entry point returns \code{NULL}.

A tool may use a pointer to an OpenMP thread's data object 
obtained from this entry point to 
inspect or modify the value of the data object.
When an OpenMP thread is created, its data object will be initialized
with value \code{ompt\_data\_none}.  

{\em This entry point is async signal safe.}

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see \specref{sec:ompt_data_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_get\_state\_t}}
\label{sec:ompt_get_state_t}
\label{sec:ompt_get_state}

\summary
An OpenMP implementation's tool entry point known as \code{ompt\_get\_state}
with type signature \code{ompt\_get\_state\_t} 
returns the state and the wait identifier of the 
current thread. 

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef omp_state_t (*ompt_get_state_t)(
  ompt_wait_id_t *\plc{wait_id}       
);
\end{boxedcode}
\ccppspecificend}

\descr

Each OpenMP thread has an associated state and a wait identifier.  If
a thread's state indicates that the thread is waiting for mutual
exclusion, the thread's wait identifier will contain an opaque handle
that indicates the data object upon which the thread is waiting.

To retrieve the state and wait identifier for the current thread,
a tool uses an OpenMP implementation's tool entry point known as
\code{ompt\_get\_state} with type signature \code{ompt\_get\_state\_t}.

If the returned state indicates that the thread is waiting for a
lock, nest lock, critical section, atomic region, or ordered region
and the pointer passed as the argument to the
entry point is not \code{NULL}, 
the entry point will assign the value of the thread's wait identifier to the
wait identifier passed by reference.
If the returned state is not one of the specified wait states,
the value of a wait identifier passed by reference to the entry
point is undefined following the call.

{\em This entry point is async signal safe.}

\constraints
The argument passed to the entry point must be a reference
to a variable of the specified type or \code{NULL}.

\crossreferences
\begin{itemize}
\item \code{ompt\_wait\_id\_t} type, see \specref{sec:ompt_wait_id_t}.
\end{itemize}


\omptruntimeentrypoint{\code{ompt\_get\_parallel\_info\_t}} 
\label{sec:ompt_get_parallel_info_t}
\label{sec:ompt_get_parallel_info}

\summary

An OpenMP implementation's tool entry point known as \code{ompt\_get\_parallel\_info} 
with type signature \code{ompt\_get\_parallel\_info\_t} 
returns information about
the parallel region, if any, at the specified ancestor level 
for the current execution context.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_get_parallel_info_t)(
  int \plc{ancestor_level},
  ompt_data_t **\plc{parallel_data},
  int *\plc{team_size}
);
\end{boxedcode}
\ccppspecificend}

\descr
During execution, an OpenMP program may employ nested parallel
regions. 
To obtain information about a parallel region, 
a tool uses an OpenMP implementation's tool entry point known as
\code{ompt\_get\_parallel\_info} 
with type signature \code{ompt\_get\_parallel\_info\_t}. 
This entry point
can be used to obtain information about the current parallel region,
if any, and any enclosing parallel regions
for the current execution context.

The first argument to the entry point specifies the parallel region of
interest to a tool by its ancestor level.
Ancestor level 0 refers to the innermost parallel region; information
about enclosing parallel regions may be obtained using larger
ancestor levels.  The \code{ompt\_get\_parallel\_info} entry point
returns 1 if there is a parallel region at the
specified ancestor level and 0 otherwise. 

If a parallel region exists at the specified ancestor
level, information will be returned in the variables passed by
reference as the second and third arguments to the entry point. 
Specifically, a reference to the parallel region's associated 
data object will be assigned to the pointer passed by reference 
as the second argument and the number of 
threads in the parallel region's team 
will be assigned to the variable passed as the third
argument.

If no enclosing parallel region exists at the specified ancestor
level, the values of variables passed by reference as the second
and third arguments to the entry point will be undefined when the
entry point returns.

A tool may use the pointer to a parallel region's data object that it
obtains from this entry point to inspect or modify the value of the
data object.
When a parallel region is created, its data object will be initialized
with the value \code{ompt\_data\_none}.  

{\em This entry point is async signal safe.}

\constraints
The second and third arguments to the entry point must be references
to variables of the specified types.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see \specref{sec:ompt_data_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_get\_task\_info\_t}}
\label{sec:ompt_get_task_info_t}
\label{sec:ompt_get_task_info}

\summary
An OpenMP implementation's tool entry point known as \code{ompt\_get\_task\_info} 
with type signature \code{ompt\_get\_task\_info\_t} provides information about the
task, if any, at the specified ancestor level in the current execution
context.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_get_task_info_t)(
  int \plc{ancestor_level},
  ompt_task_type_t *\plc{type},
  ompt_data_t **\plc{task_data},
  ompt_frame_t **\plc{task_frame},
  ompt_data_t **\plc{parallel_data},
  int *\plc{thread_num}
);
\end{boxedcode}
\ccppspecificend}

\descr
During execution, an OpenMP thread may be executing an OpenMP task.
Additionally, the thread's stack may contain
procedure frames associated with suspended OpenMP tasks or
OpenMP runtime system routines.
To obtain information about any task on the current thread's stack, 
a tool uses an OpenMP implementation's tool entry point known as
\code{ompt\_get\_task\_info} 
with type signature \code{ompt\_get\_task\_info\_t}. 

Ancestor level 0 refers to the active task; information about
ancestor tasks found in the current execution context may be queried at
higher ancestor levels.  The \code{ompt\_get\_task\_info} entry point
returns 1 if there is a task region at the
specified ancestor level and 0 otherwise. 

If a task exists at the specified ancestor level, information
will be returned in the variables passed by reference to the entry
point.  If no task region exists at the specified ancestor level, the
values of variables passed by reference to the entry point will be
undefined when the entry point returns.

Task types that a tool may observe on a thread's stack include 
initial, implicit, explicit, target, and degenerate tasks. 
In this context, 
a degenerate task indicates a sequence of one or more procedure frames 
from the OpenMP runtime system that appears on a thread's stack between
a pair of stack frames for user procedures that are both associated 
with the same task. 

If the task at the specified ancestor level is degenerate, the
pointer returned in \code{task\_data} will be NULL.  A degenerate
task will be associated with the enclosing parallel region.  

The pointer returned in \code{task\_frame} represents an
\code{ompt\_frame\_t} structure, which
a tool can use to distinguish between frames in the call stack 
associated with user code and those associated with
the OpenMP runtime system.\footnote{A frame 
on the call stack is said to be associated with 
the OpenMP runtime if it is a frame for a runtime system
routine or it belongs to a library function called by a runtime
system routine, directly or indirectly.} 
The \code{enter\_frame} field in this structure contains the
canonical frame pointer for the procedure that invoked 
user code for the task. 
For ancestor levels $>$ 0, the 
\code{exit\_frame} field of
the structure will contain the canonical frame pointer for the 
stack frame of the task procedure that invoked the runtime system to
create a new task. At ancestor level 0, the \code{exit\_frame} may or
may not be non-\code{NULL}. 
By inspecting the tasks on a thread's stack and their associated frame
structures,
a tool can map from an implementation-level view of the call stack
back to a source-level view.
Appendix~\ref{app:frame} discusses an example that
illustrates the use of \code{ompt\_frame\_t} structures with multiple
threads and nested parallelism.

If the thread invoking this function is outside any parallel region,
the pointer returned in \code{parallel\_data} will be NULL.  

The value returned in \code{thread\_num} indicates the number of the
OpenMP thread executing the task in the parallel region to which the
task belongs.

A tool may use a pointer to a data object for a task or parallel
region that it obtains from this entry point to inspect or modify the
value of the data object.  When either a parallel region or a task
region is created, its data object will be initialized with the value
\code{ompt\_data\_none}.

{\em This entry point is async signal safe.}

\constraints
With the exception of \code{ancestor\_level}, which is passed by
value, all other arguments to the entry point must be references
to variables of the specified types.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see \specref{sec:ompt_data_t}.
\item \code{ompt\_frame\_t} type, see \specref{sec:ompt_frame_t}.
\item \code{ompt\_task\_type\_t} type, see
  \specref{sec:ompt_task_type_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_get\_target\_info\_t}}
\label{sec:ompt_get_target_info_t}
\label{sec:ompt_get_target_info}

\summary
An OpenMP implementation's tool entry point known as \code{ompt\_get\_target\_info} 
with type signature \code{ompt\_get\_target\_info\_t} returns identifiers that specify a
thread's current target region and target operation id, if any.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_get_target_info_t)(
  int *\plc{device_id},
  ompt_id_t *\plc{target_id},
  ompt_id_t *\plc{host_op_id}
);
\end{boxedcode}
\ccppspecificend}

\descr
A tool can query whether an OpenMP thread is in a target region by
invoking the entry point known as \code{ompt\_get\_target\_info} 
with type signature \code{ompt\_get\_target\_info\_t}.
This entry point returns 1 if the invoking thread is
in a target region and 0 otherwise. If the entry point returns 0,
the values of the variables passed by reference as its arguments
are undefined.

If the invoking thread is in a target region, the device number for
the target device will be returned in the variable passed by reference
as the first argument and
the identifier for the target region instance will be returned in
the variable passed as the second argument. 
If the invoking thread
is in the process of initiating an operation on a target device
(e.g., copying data to or from an accelerator or launching a kernel)
the identifier for the operation being initiated will be returned in
the variable passed by reference as the third argument; 
otherwise, the third argument will be set to \code{ompt\_id\_none}.

{\em This entry point is async signal safe.}

\constraints

Arguments passed to the entry point must be valid
references to variables of the specified types.

\crossreferences
\begin{itemize}
\item \code{ompt\_id\_t} type, see \specref{sec:ompt_id_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_get\_num\_devices\_t}}
\label{sec:ompt_get_num_devices_t}
\label{sec:ompt_get_num_devices}

\summary
An OpenMP implementation's tool entry point known as \code{ompt\_get\_num\_devices} 
with type signature \code{ompt\_get\_num\_devices\_t} 
returns the number of available devices.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_get_num_devices_t)(void);
\end{boxedcode}
\ccppspecificend}

\descr

An OpenMP program may execute on one or more devices.
A tool may determine the number of devices available to an OpenMP
program by invoking an OpenMP implementation's tool entry point 
known as \code{ompt\_get\_num\_devices} 
with type signature \code{ompt\_get\_num\_devices\_t}.

{\em This entry point is async signal safe.}


\omptruntimeentrypoint{\code{ompt\_get\_device\_id\_t}}
\label{sec:ompt_get_device_id_t}
\label{sec:ompt_get_device_id}

\summary
An OpenMP implementation's tool entry point known as
\code{ompt\_get\_device\_id} 
with type signature \code{ompt\_get\_device\_id\_t} 
returns the device identifier for the active target device. 

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_get_device_id_t)(void);
\end{boxedcode}
\ccppspecificend}

\descr

An OpenMP implementation's tool entry point known as
\code{ompt\_get\_device\_id} with type signature
\code{ompt\_get\_device\_id\_t} returns the device identifier for the
active target device.  This inquiry function is only supported on the
host. If the inquiry function is invoked by a thread not executing in
the scope of a target, target data, or target update construct, then
it will return a value of -1.

{\em This entry point is async signal safe.}


\begin{comment}
\omptruntimeentrypoint{\code{ompt\_get\_device\_info\_t}}
\label{sec:ompt_get_device_info_t}
\label{sec:ompt_get_device_info}

\summary
An OpenMP implementation's tool entry point known as \code{ompt\_get\_device\_info} 
with type signature \code{ompt\_get\_device\_info\_t} r
returns information about a specified device.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_get_device_info_t)(
  int32_t \plc{device_id}, 
  const char **\plc{type}, 
  ompt_device_t **\plc{device},
  ompt_function_lookup_t *\plc{lookup},
  const char **\plc{documentation}
);
\end{boxedcode}
\ccppspecificend}

\descr
If \code{device\_id} refers to a valid device, the function will
return \code{true} indicating success; otherwise, it will return
\code{false} and the values of its return parameters are undefined.
The runtime will set \code{*type} to point to a character string
that identifies at a minimum the  type of the device. It might also
indicate the software stack it is running and perhaps even the
version number of one or more components in that stack. An example
string could be ``NVIDIA Tesla M2050, compute capability 2.0, CUDA
5.5.'' A tool can use such a type string to determine if it has any
special knowledge about hardware and software of the specific device.
The OpenMP runtime will set \code{*device} to point to an opaque
object that represents the target device instance. The device pointer
returned will need to be supplied as an argument to calls to
device-specific functions in the target interface to identify the
device being addressed.

The OpenMP runtime will set the value of \code{*lookup} to point
to a function that can be used to look up device-specific API
functions.  The \code{lookup} function for a device will enable a
tool to look up all functions marked \code{OMPT\_TARG\_API}.  If a
named function is not available in an OpenMP runtime's implementation
of OMPT, lookup will return NULL. Documentation for the names and
type signatures of any additional device-specific API functions
available through \code{lookup} should be provided in the form of
a single character string \code{*documentation}. Ideally, the
documentation string should include not only the type signature but
also necessary descriptive text for how to use the device-specific
API or pointers to external documentation.
\end{comment}

\begin{comment}
\omptruntimeentrypoint{\code{ompt\_get\_device\_id\_t}}
\label{sec:ompt_get_device_id_t}
\label{sec:ompt_get_device_id}

\summary
An OpenMP implementation's tool entry point known as \code{ompt\_get\_device\_id} 
with type signature \code{ompt\_get\_device\_id} returns the device
identifier for the active target device.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_get_device_id_t)(void);
\end{boxedcode}
\ccppspecificend}

\descr
This inquiry function is only supported on the host. If the inquiry
function is invoked by a thread not executing in the scope of a
\code{target}, \code{target data}, or \code{target update} construct,
then it will return a value of -1. 

{\em This entry point is async signal safe.}
\end{comment}

\subsection{Entry Points in the OMPT Device Tracing Interface}
\label{sec:ompt-tracing-entry-points}.

\omptruntimeentrypoint{\code{ompt\_get\_device\_time\_t}}
\label{sec:ompt_get_device_time_t}

\summary
An OpenMP implementation's tool entry point for a device known 
as \code{ompt\_get\_device\_time} 
with type signature \code{ompt\_get\_device\_time\_t} 
returns the current time on the specified device.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef ompt_device_time_t (*ompt_get_device_time_t)(
  ompt_device_t *\plc{device}
);
\end{boxedcode}
\ccppspecificend}

\descr
Host and target devices are typically distinct and run independently.
If host and target devices are different hardware components, they
may use different clock generators. For this reason,  there may be
no common time base for ordering host-side and device-side events.

An OpenMP implementation's tool entry point for a device known 
as \code{ompt\_get\_device\_time} with type signature 
\code{ompt\_get\_device\_time\_t} 
returns the current time on the specified device.
A tool can use this information 
to align time stamps from different devices.

\crossreferences
\begin{itemize}
\item \code{ompt\_device\_t},
see \specref{sec:ompt_device_t}.
\item \code{ompt\_device\_time\_t},
see \specref{sec:ompt_device_time_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_translate\_time\_t}}
\label{sec:ompt_translate_time_t}

\summary
An OpenMP implementation's tool entry point for a device known 
as \code{ompt\_translate\_time} 
with type signature \code{ompt\_translate\_time\_t} translates
a time value obtained from the specified device to a corresponding time
value on the host device. 

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef double (*ompt_translate_time_t)(
  ompt_device_t *\plc{device},
  ompt_device_time_t \plc{time}
);
\end{boxedcode}
\ccppspecificend}

\descr
An OpenMP implementation's tool entry point for a device known as \code{ompt\_translate\_time} 
with type signature \code{ompt\_translate\_time\_t} translates
a time value obtained from the specified device to a corresponding time
value on the host device. The returned value for the host time has
the same meaning as the value returned from \code{omp\_get\_wtime}.

\needspace{6\baselineskip}\notestart
\noteheader -- 
The accuracy of time translations may degrade if they are not
performed promptly after a device time value is received if either
the host or device vary their clock speeds. Prompt translation of
device times to host times is recommended.
\noteend

\crossreferences
\begin{itemize}
\item \code{ompt\_device\_t},
see \specref{sec:ompt_device_t}.
\item \code{ompt\_device\_time\_t},
see \specref{sec:ompt_device_time_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_set\_trace\_ompt\_t}}
\label{sec:ompt_set_trace_ompt_t}

\summary
An OpenMP implementation's tool entry point for a device known as \code{ompt\_set\_trace\_ompt} 
with type signature \code{ompt\_set\_trace\_ompt\_t} 
enables or disables the recording of trace records for one or more
types of OMPT events.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_set_trace_ompt_t)(
  ompt_device_t *\plc{device},
  unsigned int \plc{enable},
  unsigned int \plc{etype}
);
\end{boxedcode}
\ccppspecificend}

\constraints
The argument \code{device} identifies the device
whose tracing may be altered by invoking this function.

A positive value for
\code{enable} indicates that recording of one or more events specified 
by \code{etype}
should be enabled; a value of 0 for \code{enable} indicates that
recording of events should be disabled by this invocation.

An \code{etype} value 0 indicates that traces for all event types will be enabled or disabled.  
Passing a positive value for \code{etype} inidicates that recording
should be enabled or disabled for the event in \code{ompt\_callback\_t}
that matches \code{etype}.

Table~\ref{table:record_set} shows the possible return
codes for \code{ompt\_set\_trace\_ompt}.  If a single invocation
of \code{ompt\_set\_trace\_ompt} is used to enable or disable
more than one event (i.e., \code{etype}=0), the return code will
be 3 if tracing is possible for one or more events but not for
others.

\begin{table}
\centering
\begin{tabular}{|l|l|}
\hline
return code & meaning \\\hline
0 & error\\\hline
1 & event will never occur\\\hline
2 & event may occur but no tracing is possible\\\hline
3 & event may occur and will be traced when convenient\\\hline
4 & event may occur and will always be traced if event occurs\\\hline
\end{tabular}
\vskip 1ex
\caption{Meaning of return codes for \code{ompt\_trace\_set\_ompt} and
  \code{ompt\_set\_trace\_native}.}
\label{table:record_set}
\end{table}


\crossreferences
\begin{itemize}
\item \code{ompt\_device\_t},
see \specref{sec:ompt_device_t}.
\item \code{ompt\_callback\_t},
see \specref{sec:ompt_callback_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_set\_trace\_native\_t}}
\label{sec:ompt_set_trace_native_t}

\summary
An OpenMP implementation's tool entry point for a device known as \code{ompt\_set\_trace\_native} 
with type signature \code{ompt\_set\_trace\_native\_t} 
enables or disables the recording of native trace records for a device.


\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_set_trace_native_t)(
  ompt_device_t *\plc{device},
  int \plc{enable},
  int  \plc{flags}
);
\end{boxedcode}
\ccppspecificend}

\descr
This interface is designed for use by a tool with no knowledge about
an attached device. If a tool knows how to program a particular
attached device, it may opt to invoke native control functions
directly using pointers obtained through the \code{lookup} function
associated with the device and described in the \code{documentation}
string that is returned by \code{ompt\_get\_device\_info}.

\constraints
The argument \code{device} is a handle to identify the target device
whose performance monitoring may be altered by invoking this function.
The boolean \code{enable} indicates whether recording of events
should be enabled or disabled by this invocation.  The kinds of
native device monitoring to enable or disable are specified by
\code{flags}. Each kind of monitoring is specified by a flag bit.
Flags can be composed by using logical {\ttfamily or}  to combine enumeration
values from type \code{ompt\_native\_mon\_flags\_t}.
Table~\ref{table:record_set} shows the possible return codes for
\code{ompt\_set\_trace\_native}.  If a single invocation of
\code{ompt\_set\_trace\_ompt} is used to enable/disable more
than one kind of monitoring, the return code will be 3 if tracing
is possible for one or more kinds of monitoring but not for others.


To start, pause, or stop tracing for a specific target device associated with the handle \code{device}, 
a tool calls the functions \code{ompt\_start\_trace}, \code{ompt\_pause\_trace}, or \code{ompt\_stop\_trace}.


\crossreferences
\begin{itemize}
\item \code{ompt\_device\_t},
see \specref{sec:ompt_device_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_start\_trace\_t}}
\label{sec:ompt_start_trace_t}

\summary
An OpenMP implementation's tool entry point for a device known as \code{ompt\_start\_trace} 
with type signature \code{ompt\_start\_trace\_t} 
starts tracing of activity on a specific device.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_start_trace_t)(
  ompt_device_t *\plc{device},
  ompt_callback_buffer_request_t \plc{request},
  ompt_callback_buffer_complete_t \plc{complete},
  ompt_callback_get_target_info_t \plc{get_info}
);
\end{boxedcode}
\ccppspecificend}

\crossreferences
\begin{itemize}
\item \code{ompt\_device\_t},
see \specref{sec:ompt_device_t}.
\item \code{ompt\_callback\_buffer\_request\_t},
see \specref{sec:ompt_callback_buffer_request_t}.
\item \code{ompt\_callback\_buffer\_complete\_t},
see \specref{sec:ompt_callback_buffer_complete_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_pause\_trace\_t}}
\label{sec:ompt_pause_trace_t}

\summary
An OpenMP implementation's tool entry point for a device known as \code{ompt\_pause\_trace} 
with type signature \code{ompt\_pause\_trace\_t} 
pauses or restarts activity tracing on a specific device.

\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_pause_trace_t)(
  ompt_device_t *\plc{device},
  int \plc{begin_pause}
);
\end{boxedcode}
\ccppspecificend}

\descr

A tool may pause or resume tracing on a device by invoking the device's
\code{ompt\_pause\_trace} entry point.  
To pause tracing, a non-zero value should be supplied for
\plc{begin\_pause}.
To resume tracing, zero should be supplied for \plc{begin\_pause}.
The entry point will
return 0 if the request fails, e.g., if tracing for a device has not
been started, and return a non-zero return code otherwise. 
Redundant pause or resume commands are idempotent and will
return a non-zero value indicating success.  

\crossreferences
\begin{itemize}
\item \code{ompt\_device\_t},
see \specref{sec:ompt_device_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_stop\_trace\_t}}
\label{sec:ompt_stop_trace_t}

\summary
An OpenMP implementation's tool entry point for a device known as \code{ompt\_stop\_trace} 
with type signature \code{ompt\_stop\_trace\_t} 
stops tracing for a device.

\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_stop_trace_t)(
  ompt_device_t *\plc{device}
);
\end{boxedcode}
\ccppspecificend}

\descr
Each invocation returns 1 if the command succeeded and 0 otherwise.
A call to \code{ompt\_stop\_trace} also implicitly requests that the device flush any buffers that it owns.

%%? johnmc says: we should export one more function from a target device: ompt_target_scope(begin/end, host_id)
%% this function will be used by the OpenMP runtime when a target device is being monitored to signal the target device when 
%% (1) entering and leaving a target region
%% (2) before and after launching a kernel
%% (3) before and after performing a data operation: copy, allocation, release, ...
%% this function will enable the target device to associate device_activity_ids with some host_id that either represents a 
%% target region, target data operation, or target kernel submission

\crossreferences
\begin{itemize}
\item \code{ompt\_device\_t},
see \specref{sec:ompt_device_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_advance\_buffer\_cursor\_t}}
\label{sec:ompt_advance_buffer_cursor_t}

%There are several routines that need to be used together to process %target event records deposited in a buffer by a device. 

\summary
An OpenMP implementation's tool entry point for a device known as \code{ompt\_advance\_buffer\_cursor} 
with type signature \code{ompt\_advance\_buffer\_cursor\_t}
advances a trace buffer cursor to the next record.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_advance_buffer_cursor_t)(
  ompt_buffer_t *\plc{buffer},
  size_t \plc{size}, 
  ompt_buffer_cursor_t \plc{current}, 
  ompt_buffer_cursor_t *\plc{next}
); 
\end{boxedcode}
\ccppspecificend}

\descr
It returns \code{true} if the advance is successful and the returned value \code{*next} is valid.

\crossreferences
\begin{itemize}
\item \code{ompt\_device\_t},
see \specref{sec:ompt_device_t}.
\item \code{ompt\_buffer\_cursor\_t},
see \specref{sec:ompt_buffer_cursor_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_buffer\_get\_record\_type\_t}}
\label{sec:ompt_buffer_get_record_type_t}

\summary
An OpenMP implementation's tool entry point for a device known as
\code{ompt\_buffer\_get\_record\_type} with type signature
\code{ompt\_buffer\_get\_record\_type\_t} inspects the type
of a trace record for a device.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef ompt_record_type_t (*ompt_buffer_get_record_type_t)(
  ompt_buffer_t *\plc{buffer}, 
  ompt_buffer_cursor_t \plc{current}
);
\end{boxedcode}
\ccppspecificend}

\descr

Trace records for a device may be in one of two forms: a
\emph{native} record format, which may be device-specific,
or an \emph{OMPT} record format, where each trace record 
corresponds to an OpenMP \emph{event} and fields in the record
structure are mostly the arguments that would be passed to the
OMPT callback for the event. 

An OpenMP implementation's tool entry point for a device known as
\code{ompt\_buffer\_get\_record\_type} with type signature
\code{ompt\_buffer\_get\_record\_type\_t} inspects the type
of a trace record and indicates whether the record at the current
position in the provided trace buffer is an OMPT record, 
a native record, or an invalid record. An invalid record type
is returned if the cursor is out of bounds.

\begin{comment}
\crossreferences
Appendix~\ref{appendix:ompt-records} defines the corresponding enumeration type for \code{ompt\_record\_kind\_t}. 
Section~\ref{sec:native-record-data} describes the interface to use for accessing native record types.
\end{comment}


\crossreferences
\begin{itemize}
\item \code{ompt\_buffer\_t},
see \specref{sec:ompt_buffer_t}.
\item \code{ompt\_buffer\_cursor\_t},
see \specref{sec:ompt_buffer_cursor_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_buffer\_get\_record\_ompt\_t}}
\label{sec:ompt_buffer_get_record_ompt_t}
 
\summary
An OpenMP implementation's tool entry point for a device known as \code{ompt\_buffer\_get\_record\_ompt} 
with type signature \code{ompt\_buffer\_get\_record\_ompt\_t} 
obtains a pointer to an OMPT trace record from a trace buffer associated with a device.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef ompt_record_ompt_t *(*ompt_buffer_get_record_ompt_t)(
  ompt_buffer_t *\plc{buffer}, 
  ompt_buffer_cursor_t \plc{current}
);
\end{boxedcode}
\ccppspecificend}

\descr

This function returns a pointer that may point to a record in the trace
buffer, or it may point to a record in thread local storage where the information
extracted from a record was assembled. The information available
for an event depends upon its type. 

The return value of type \code{ompt\_record\_ompt\_t} 
defines a union type that can represent
information for any OMPT event record type.
Another call to the entry point may overwrite the
contents of the fields in a record returned by a prior invocation.

\crossreferences
\begin{itemize}
\item \code{ompt\_device\_t},
see \specref{sec:ompt_device_t}.
\item \code{ompt\_buffer\_cursor\_t},
see \specref{sec:ompt_buffer_cursor_t}.
\item \code{ompt\_record\_ompt\_t},
see \specref{sec:ompt_record_ompt_t}. 
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_buffer\_get\_record\_native\_t}}
\label{sec:ompt_buffer_get_record_native_t}

\summary

An OpenMP implementation's tool entry point for a device known as
\code{ompt\_buffer\_get\_record\_native} with type signature
\code{ompt\_buffer\_get\_record\_native\_t} 
obtains a pointer to a native trace record from a trace buffer associated with a device.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef void *(ompt_buffer_get_record_native_t)(
  ompt_buffer_t *\plc{buffer}, 
  ompt_buffer_cursor_t \plc{current},
  ompt_id_t *\plc{host_op_id}
);
\end{boxedcode}
\ccppspecificend}

\descr

The pointer returned  may point into the specified trace buffer, or into
thread local storage where the information extracted from a trace
record was assembled. The information available for a native event
depends upon its type. If the function returns a non-NULL result,
it will also set \code{*host\_op\_id} to identify host-side identifier
for the operation associated with the record.  A subsequent call
to \code{ompt\_buffer\_get\_record\_native} may overwrite the
contents of the fields in a record returned by a prior invocation.


\crossreferences
\begin{itemize}
\item \code{ompt\_buffer\_t},
see \specref{sec:ompt_buffer_t}.
\item \code{ompt\_buffer\_cursor\_t},
see \specref{sec:ompt_buffer_cursor_t}.
\item \code{ompt\_id\_t},
see \specref{sec:ompt_id_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_buffer\_get\_record\_native\_abstract\_t}}
\label{sec:ompt_buffer_get_record_native_abstract_t}

\summary
An OpenMP implementation's tool entry point for a device known as
\code{ompt\_buffer\_get\_record\_native\_abstract} 
with type signature
\code{ompt\_buffer\_get\_record\_native\_abstract\_t} 
summarizes the context of a native (device-specific) trace record.  

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef ompt_record_native_abstract_t *
(*ompt_buffer_get_record_native_abstract_t)(
  void *\plc{native_record} 
);
\end{boxedcode}
\ccppspecificend}

\descr
An OpenMP implementation may execute on a device that logs 
trace records in a native (device-specific) format unknown to a tool.
A tool can use an OpenMP implementation's tool entry point for the
device known as
\code{ompt\_buffer\_get\_record\_native\_abstract} 
with type signature
\code{ompt\_buffer\_get\_record\_native\_abstract\_t} 
to decode a native trace record that it
does not understand into a standard form that it can interpret. 

\crossreferences
\begin{itemize}
\item \code{ompt\_record\_native\_abstract\_t},
see \specref{sec:ompt_record_native_abstract_t}.
\end{itemize}

\subsection{Lookup Entry Point}

\omptruntimeentrypoint{\code{ompt\_function\_lookup\_t}}
\label{sec:ompt_function_lookup_t}
\label{sec:ompt_function_lookup}

\summary
A tool uses a lookup routine with type signature 
\code{ompt\_function\_lookup\_t}
to obtain pointers to entry points that are
part of an OpenMP implementation's OMPT interface.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef ompt_interface_fn_t (*\plc{ompt_function_lookup_t}) (
  const char *\plc{interface_function_name}
);
\end{boxedcode}
\ccppspecificend
}

\descr

An OpenMP implementation provides a pointer to a lookup routine as an
argument to tool callbacks used to initialize tool support for
monitoring an OpenMP device using either tracing or callbacks.

\begin{comment}
When an OpenMP runtime implementation is initialized for a device,
if a tool callback to initialize tracing for devices has been provided
to the OpenMP implementation by \code{ompt\_tool}, 
it will be invoked on the host. The OpenMP implementation will pass the
tool's device tracing initializer callback a lookup routine that the tool
can use to obtain pointers to runtime entry points that implement
tracing control routines appropriate for that device. 

If a tool callback to initialize monitoring using the OMPT callback
interface has been provided to the OpenMP implementation by
\code{ompt\_tool} and it is invoked on a device,
the initializer will be passed a lookup function to   
obtain pointers to runtime entry points that implement
routines used by the OpenMP implementation's callback interface.
\end{comment}

When an OpenMP implementation invokes a tool initializer to configure
the OMPT callback interface, the OpenMP implementation will pass the
initializer a lookup function that the tool can use to obtain 
pointers to entry points that implement routines that are part of 
the OpenMP implementation's callback interface.

When an OpenMP implementation invokes a tool initializer to configure
the OMPT tracing interface for a device, the Open implementation will
pass the device tracing initializer a lookup function that the tool
can use to obtain pointers to entry points that implement
tracing control routines appropriate for that device. 

\constraints
A lookup routine with type
signature \code{ompt\_function\_lookup\_t} takes a C string
that represents the name of an entry point in an interface
and returns a pointer to the corresponding entry point.

\crossreferences
\begin{itemize}
\item Tool initializer for the OMPT callback interface, \specref{sec:ompt_initialize_fn_t}
\item Entry points in the OMPT callback interface, see
  \tabref{table:ompt-callback-interface-functions} for a list and
  \specref{sec:ompt-callback-entry-points} for detailed definitions.
\item Tool initializer for a device's OMPT tracing interface, \specref{sec:tracing-device-activity}.
\item Entry points in the OMPT tracing interface, see
  \tabref{table:ompt-tracing-interface-functions} for a list and
  \specref{sec:ompt-tracing-entry-points} for detailed definitions.
\end{itemize}
% This is the end of ch4-toolsSupport.tex
