% This is ch4-toolsSupport.tex of the OpenMP specification.
% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%


\chapter{Tool Interface}
\index{Tools Support}
\label{chap:ToolsSupport}

This chapter describes the OMPT interface provided by the OpenMP API
to support third-party monitoring and performance analysis tools.
The chapter first explains if and how an implementation of
the OpenMP API will attempt to register a tool prior to initializing the 
OpenMP implementation and
how a registered tool will use the OMPT interface to initialize tool state maintained by
an implementation of the OpenMP API.
It concludes with a description of data types
used to identify entities managed by an OpenMP runtime and to interpret the
call stack of an OpenMP thread.

\section{Tool Registration}
\index{tool registration}
\label{sec:ToolsSupport_Registration}

The \code{OMP\_TOOL} environment variable sets the \plc{tool-var} ICV, which controls whether or not an
implementation of the OpenMP API will attempt to register a tool.
The value of \code{OMP\_TOOL} is case insensitive and may have leading and trailing white space.
The only legal values of \code{OMP\_TOOL} are \code{enabled} or \code{disabled}.
If the value of \plc{tool-var} is \code{enabled},
the OpenMP API implementation will attempt to register a tool by determining if
an implementation of the function \code{ompt\_tool} exists in a program's address space and, if so,
calling \code{ompt\_tool} before initializing the OpenMP implementation.
If the value of \plc{tool-var} is \code{disabled}, the OpenMP API implementation will not
call \code{ompt\_tool}, regardless of whether or not an implementation of \code{ompt\_tool} exists in the
address space.
If \code{OMP\_TOOL} is set to any other value, an implementation of the OpenMP API
will print a fatal error to the standard error file descriptor indicating that an illegal value had been supplied for \code{OMP\_TOOL} and the program's execution will terminate.
If \code{OMP\_TOOL} is not defined, the default value for \plc{tool-var} is \code{enabled}.

\begin{comment}
\begin{table}
\begin{center}
\begin{tabular}{|c|p{4in}|}
\hline
 {\em tool-var} value & action \\\hline
enabled & an OpenMP implementation will call \code{ompt\_tool} before initializing itself.\\\hline
disabled & an OpenMP implementation will not call \code{ompt\_tool}, regardless of whether a tool is present or not.\\\hline
\end{tabular}
\end{center}
\caption{Actions in response to settings of the {\em tool-var} ICV.}
\label{table:ToolsSupport_env-var}
\end{table}

\sloppy
Table~\ref{table:ToolsSupport_env-var} describes the action that an OpenMP 
implementation will take in response to possible values of \plc{tool-var}.
If the value of \plc{tool-var} is \code{enabled}, the runtime will attempt to register a tool by calling the function \code{ompt\_tool} before performing runtime initialization.
\end{comment}

The signature for \code{ompt\_tool} is shown below:
\vbox{
\ccppspecificstart
\begin{boxedcode}
extern "C" \{
  ompt\_initialize\_fn\_t ompt\_tool(void);
\};
\end{boxedcode}
\ccppspecificend
}
If a tool provides an implementation of \code{ompt\_tool} in the
application's address space, \code{ompt\_tool} may return \code{NULL}
indicating that the tool declines to register itself with the
runtime; otherwise, the tool may register itself with the runtime
by returning a non-\code{NULL} pointer to a function with type
signature \code{ompt\_initialize\_fn\_t}, which is in
Section~\ref{sec:ToolsSupport_init}.

Since only one tool-provided definition of \code{ompt\_tool} will be seen by an OpenMP implementation, only one tool may register itself.
If a tool-supplied implementation of \code{ompt\_tool} returns a non-\code{NULL} initializer,
an implementation of the OpenMP API will maintain state information for each OpenMP thread and will perform
any OMPT event callbacks registered during tool initialization.

After a process fork, if OpenMP is re-initialized in the child process,
an implementation of the OpenMP API in the child process will call \code{ompt\_tool}
under the same conditions as it would for any process.

\section{Tool Initialization}
\label{sec:ToolsSupport_init}

When an OpenMP implementation receives a non-\code{NULL} pointer to a tool initializer function with signature \code{ompt\_initialize\_fn\_t} as the return value from a call to a tool-provided implementation of \code{ompt\_tool}, the runtime will call the tool initializer immediately after the runtime fully initializes itself.
The initializer must be called before beginning execution of any OpenMP construct or completing any execution environment routine invocation.
The signature for the tool initializer callback is shown below:

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*\plc{ompt\_initialize\_fn\_t}) (
  ompt\_function\_lookup\_t \plc{lookup},
  const char *\plc{runtime\_version},
  unsigned int \plc{ompt\_version}
);
\end{boxedcode}
\ccppspecificend
}

The second argument to a tool initializer is a version string that unambiguously identifies an OpenMP implementation.
This argument is useful to tool developers trying to debug a statically-linked executable that contains both a tool implementation and an OpenMP implementation.
Knowing exactly what version of an OpenMP implementation is present in a binary may be helpful when diagnosing a problem, e.g., identifying an old runtime system that may be incompatible with a newer tool.

The third argument \code{ompt\_version} indicates the version of the OMPT interface supported by a runtime system.
The version of OMPT described by this document is 2.

The two principal duties of a tool initializer are looking up pointers to all OMPT interface functions that the tool uses and registering tool callbacks.
These two operations are described below.

\subsection{Looking up OMPT Interface Functions}
The first argument to a tool initializer is \code{lookup}---a callback that a tool must use to interrogate the runtime system to obtain pointers to all OMPT interface functions.
The type signature for \code{lookup} is:

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef ompt\_interface\_fn\_t (*\plc{ompt\_function\_lookup\_t}) (
  const char *\plc{interface\_function\_name}
);
\end{boxedcode}
\ccppspecificend
}

The \code{lookup} callback is necessary in the case when an OpenMP runtime 
is dynamically loaded by a shared library. In this case, 
OMPT interface functions provided by the library may 
not be visible to a preloaded tool.
Within a tool, one uses \code{lookup} to obtain function pointers to each function in the OMPT interface.
All functions in the OMPT interface are marked with \code{OMPT\_API}.
These functions should not be global symbols in an OpenMP implementation to avoid tempting tool developers to call them directly.

The following example shows how to use the \code{lookup} function to obtain a pointer to the OMPT interface function \code{ompt\_get\_thread\_id}:

\vbox{
\ccppspecificstart
\begin{boxedcode}
ompt\_interface\_fn\_t \plc{ompt\_get\_thread\_id\_fn} =
                        \plc{lookup}("ompt\_get\_thread\_id");
\end{boxedcode}
\ccppspecificend
}
Other functions in the OMPT API may be looked up analogously.
If a named function is not available in an OpenMP implementation, \code{lookup} will return \code{NULL}.

\subsection{Registering Callbacks}
\index{event callback registration}
\label{sec:ToolsSupport_callback_registration}

Tools register callbacks to receive notification of various events that occur as
an OpenMP program executes by using the OMPT API function \code{ompt\_set\_callback}.
The signature for this function is
\vbox{
\ccppspecificstart
\begin{boxedcode}
OMPT\_API int ompt\_set\_callback(
  ompt\_event\_t \plc{event},
  ompt\_callback\_t \plc{callback}
);
\end{boxedcode}
\ccppspecificend
}


\begin{table}
\centering
\begin{tabular}{ll}
\hline
return code & meaning \\
\hline
0 & callback registration error (e.g., callbacks cannot be registered at this time).\\
1 & event may occur; no callback is possible\\
2 & event will never occur in runtime\\
3 & event may occur; callback invoked when convenient\\
4 & event may occur; callback always invoked when event occurs\\
\hline
\end{tabular}
\caption{Meaning of return codes for \code{ompt\_set\_callback}.}
\label{table:ToolsSupport_set_rc}
\end{table}

The  function \code{ompt\_set\_callback}  may only be called within the implementation of a tool's initializer.
The possible return codes for \code{ompt\_set\_callback} and their meaning is shown in Table~\ref{table:ToolsSupport_set_rc}.
Registration of supported callbacks may fail if this function is
called outside  \code{ompt\_initialize\_fn\_t}.
The \code{ompt\_callback\_t} type for a callback does not reflect the actual signature of the callback; OMPT uses  this generic type
 to avoid the need to declare a separate registration function for each actual callback type.
The valid return codes for each event are listed in Table~\ref{table:valid_rc}.
Some events always need to invoke the registered callback.
For other events, its implementation defined whether they invoke the registered
callback never, sometimes, or always.
The return code makes this implementation defined behaviour machine readable to
the connected tool.

The  OMPT API function \code{ompt\_get\_callback} may be called at any time to determine whether a callback has been registered or not.

\vbox{
\ccppspecificstart
\begin{boxedcode}
OMPT\_API int ompt\_get\_callback(
  ompt\_event\_t \plc{event},
  ompt\_callback\_t *\plc{callback}
);
\end{boxedcode}
\ccppspecificend
}

If a callback has been registered,  \code{ompt\_get\_callback}  will return 1
and set \code{callback} to the address of the callback function;
otherwise \code{ompt\_get\_callback} will return 0.

\begin{table}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{lp{3em}p{3em}p{3em}p{3em}p{3em}}
                                & \rot{callback registration error}
                                & \rot{event may occur; no callback is possible}
                                & \rot{event will never occur in runtime}
                                & \rot{event may occur; callback invoked when convenient}
                                & \rot{event may occur; callback always invoked when event occurs}\\
                                \midrule
ompt\_event\_thread\_begin          & * &   &   &   & * \\
ompt\_event\_thread\_end            & * &   &   &   & * \\
ompt\_event\_parallel\_begin        & * &   &   &   & * \\
ompt\_event\_parallel\_end          & * &   &   &   & * \\
ompt\_event\_task\_create           & * &   &   &   & * \\
ompt\_event\_task\_schedule         & * &   &   &   & * \\
ompt\_event\_implicit\_task         & * &   &   &   & * \\
ompt\_event\_target                 & * &   &   &   & * \\
ompt\_event\_target\_data           & * &   &   &   & * \\
ompt\_event\_target\_submit         & * &   &   &   & * \\
ompt\_event\_control                & * &   &   &   & * \\
ompt\_event\_runtime\_shutdown      & * &   &   &   & * \\
ompt\_event\_idle                   & * & * & * & * & * \\
ompt\_event\_sync\_region\_wait     & * & * & * & * & * \\
ompt\_event\_mutex\_release         & * & * & * & * & * \\
ompt\_event\_task\_dependences      & * & * & * & * & * \\
ompt\_event\_task\_dependence\_pair & * & * & * & * & * \\
ompt\_event\_worksharing            & * & * & * & * & * \\
ompt\_event\_master                 & * & * & * & * & * \\
ompt\_event\_target\_data\_map      & * & * & * & * & * \\
ompt\_event\_sync\_region           & * & * & * & * & * \\
ompt\_event\_init\_lock             & * & * & * & * & * \\
ompt\_event\_destroy\_lock          & * & * & * & * & * \\
ompt\_event\_mutex\_acquire         & * & * & * & * & * \\
ompt\_event\_mutex\_acquired        & * & * & * & * & * \\
ompt\_event\_nested\_lock           & * & * & * & * & * \\
ompt\_event\_flush                  & * & * & * & * & * \\
\bottomrule
\end{tabular}
\caption{Valid return codes of \code{ompt\_set\_callback} for each input event argument.}
\label{table:valid_rc}
\end{table}

\clearpage
\section{Thread States}
\label{sec:runtimeStates}

To enable a tool to understand the behavior of an executing program, 
an OpenMP implementation maintains a state for each thread. 
The state maintained for a thread is an
approximation of the thread's instantaneous state. 

\vbox{
\ccppspecificstart
A thread's state will be one of the values of the  
enumeration type \code{omp\_state\_t} or
an implementation-defined state value of 0x81 or higher. 
Thread states in the enumeration fall into several classes: 
idleness, work, overhead, barrier wait, task wait, mutex wait, target wait, 
and undefined. 

\begin{boxedcode}
typedef enum omp_state_t \{
  omp_state_idle                   = 0x00, 

  omp_state_work_serial            = 0x10,
  omp_state_work_parallel          = 0x11,
  omp_state_work_reduction         = 0x12,

  omp_state_overhead               = 0x20, 

  omp_state_wait_barrier           = 0x40,
  omp_state_wait_barrier_implicit  = 0x41,
  omp_state_wait_barrier_explicit  = 0x42,

  omp_state_wait_taskwait          = 0x50,
  omp_state_wait_taskgroup         = 0x51,

  omp_state_wait_mutex             = 0x60,
  omp_state_wait_lock              = 0x61,
  omp_state_wait_critical          = 0x62,
  omp_state_wait_atomic            = 0x63,
  omp_state_wait_ordered           = 0x64,

  omp_state_wait_target            = 0x70,
  omp_state_wait_target_data       = 0x71,
  omp_state_wait_target_update     = 0x72,

  omp_state_undefined              = 0x80
\} omp_state_t;
\end{boxedcode}
\ccppspecificend
}


A tool can query the OpenMP state of a thread at any time. 
If a tool queries the state of a thread that is not associated 
with OpenMP, the implementation reports the state as \code{omp\_state\_undefined}.

\begin{comment}
For each OpenMP thread the runtime maintains not only a state but also an \code{ompt\_wait\_id\_t}
identifier.  When a thread is waiting for a lock, critical region,
ordered, or atomic, and the thread is in a wait
state, then 
the thread's \code{wait\_id} field identifies the lock, critical construct, ordered construct, atomic construct, or internal variable
upon which the
thread is waiting. The semantics of the values used for a \code{wait\_id} are implementation defined.
A thread's \code{wait\_id} is undefined if the thread
is not in a wait state.
\end{comment}

Some values of the enumeration type \code{omp\_state\_t} are used by all 
OpenMP implementations, 
e.g., \code{omp\_state\_work\_serial}, 
which indicates that a thread is executing in a serial region, and  
\code{omp\_state\_work\_parallel}, 
which indicates that a thread is executing in a parallel region.
Other values of the enumeration type describe a thread's state at 
different levels of specificity. 
For instance, an OpenMP implementation may use 
the state \code{omp\_state\_wait\_barrier}  to represent all 
waiting at barriers; or it may differentiate between waiting at 
implicit and explicit barriers by using the pair of states
\code{omp\_state\_wait\_barrier\_implicit} and 
\code{omp\_state\_wait\_barrier\_explicit}. 

For states that represent waiting, an OpenMP implementation has the 
choice of transitioning a thread to such states early or late.
For instance, when an OpenMP thread is trying to acquire a lock,
there are several points at which an OpenMP implementation
transition the thread to the \code{omp\_state\_wait\_lock} state.
One implementation may transition the thread to the state 
early before the thread attempts to acquire a
lock. Another implementation may transition the thread to the state 
late, only if the thread begins to spin or
block to wait for an unavailable lock. A third implementation
may transition the thread to the state even later, e.g., only
after the thread waits for a significant amount of time. 

The following describes the classes and the states in each class.

\littleheader{Idleness State}


\begin{description}
\item \code{omp\_state\_idle} 

  The thread is idle, waiting for work.

\end{description}

\littleheader{Overhead State}

\begin{description}
\item \code{omp\_state\_overhead} 

  A thread may be reported as being in the overhead state at any point while 
  executing within an OpenMP runtime, except while waiting indefinitely
  at a synchronization point.
%  e.g., while preparing to execute a parallel, task, or worksharing construct. 
  An OpenMP implementation report a thread's state as a work state for
  some or all of the time the thread spends in executing in the OpenMP runtime.
\end{description}

\littleheader{Work States}
An OpenMP implementation reports a thread in a work state 
when the thread is performing serial work, parallel work, or a reduction.

\begin{description}

\item \code{omp\_state\_work\_serial} 

  The thread is executing code outside all parallel regions. 

\item \code{omp\_state\_work\_parallel} 

  The thread is executing code within the scope of a parallel region construct.

\sloppy
\item \code{omp\_state\_work\_reduction} 
 
  The thread is combining partial reduction results from threads in its team. A compliant
  runtime might never report a thread in this state; a thread
  combining partial reduction results may  report its state as
  \code{omp\_state\_work\_parallel} or \code{omp\_state\_overhead}.

\end{description}


\littleheader{Barrier Wait States}

An OpenMP implementation reports that a thread is in a barrier wait state 
when the thread is is awaiting completion of a barrier.


\begin{description}

  \item \code{omp\_state\_wait\_barrier} 
  
  \sloppy
  The thread is waiting at either an implicit or explicit barrier.
  A  compliant implementation may have a thread enter this state
  early, when the thread encounters a barrier, or late, when the
  thread begins to wait at the barrier. A  compliant implementation may never report a thread in this state; instead, a thread might report its state as \code{omp\_state\_wait\_barrier\_implicit}  or \code{omp\_state\_wait\_barrier\_explicit}, as appropriate.
  
  \item \code{omp\_state\_wait\_barrier\_implicit} 
  
\sloppy
  The thread is waiting at an implicit barrier in a parallel region. 
  A  compliant implementation may have a thread enter this state
  early, when the thread encounters a barrier, or late, when the
  thread begins to wait at the barrier.
  A  compliant implementation may report \code{omp\_state\_wait\_barrier} for implicit barriers.
  
    \item \code{omp\_state\_wait\_barrier\_explicit} 

  The thread is waiting at an explicit barrier  in a parallel region. 
  A  compliant implementation may have a thread enter this state
  early, when the thread encounters a barrier, or late, when the
  thread begins to wait at the barrier.
  A  compliant implementation may report \code{omp\_state\_wait\_barrier} for explicit barriers.
  
\end{description}
  
\littleheader{Task Wait States}

\begin{description}

\item \code{omp\_state\_wait\_taskwait} 

  The thread is waiting at a taskwait construct. A compliant
  implementation may have a thread enter this state early, when the
  thread encounters a taskwait construct, or late, when the thread
  begins to wait for an uncompleted task.

\item \code{omp\_state\_wait\_taskgroup} 

  The thread is waiting at the end of a taskgroup construct. A compliant
  implementation may have a thread enter this state early, when the
  thread encounters the end of a taskgroup construct, or late, when the thread
  begins to wait for an uncompleted task.

\end{description}


\littleheader{Mutex Wait States}

OpenMP provides several mechanisms that enforce mutual exclusion:
locks as well as critical, atomic, and ordered sections.  This
grouping contains all states used to indicate that a thread is is
awaiting exclusive access to a lock, critical section, variable,
or ordered section.

An OpenMP implementation may report a thread waiting for any type
of mutual exclusion using either a state that precisely identifies
the type of mutual exclusion, or  a more generic state such as
\code{omp\_state\_wait\_mutex} or \code{omp\_state\_wait\_lock}.  This
flexibility may significantly simplify the maintenance of states
associated with mutual exclusion in the runtime when various
mechanisms for mutual exclusion rely on a common implementation,
e.g., locks.

% Section~\ref{sec:wait-identifier} describes how each thread maintains a wait identifier to identify what a thread is awaiting. Before a thread enters any state indicating that it is awaiting mutual exclusion, the OpenMP runtime will update the thread's wait identifier to indicate what the thread is awaiting. 

\begin{description}

\item \code{omp\_state\_wait\_mutex}

  The thread is waiting for a mutex of an unspecified type. A compliant implementation
  may have a thread enter this state early, when a thread encounters a lock acquisition or a region that requires mutual exclusion, or late, when the thread begins to wait.

\item \code{omp\_state\_wait\_lock}

  The thread is waiting for a  lock  or nest lock. A compliant implementation
  may have a thread enter this state early, when a thread
  encounters a lock \code{set} routine, or late, when the thread
  begins to wait for a lock.

\item \code{omp\_state\_wait\_critical} 

  The thread is waiting to enter a critical region. A compliant
  implementation may have a thread enter this state early, when the
  thread encounters a critical construct, or late, when the thread
  begins to wait to enter the critical region. 


\item \code{omp\_state\_wait\_atomic} 

  The thread is waiting to enter an atomic region. A compliant
  implementation may have a thread enter this state early, when the thread
  encounters an atomic construct, or late, when the thread begins
  to wait to enter the atomic region. 
  A compliant implementation may opt not to report
  this state, for example, when using atomic hardware instructions that support non-blocking atomic implementations.
  

\item \code{omp\_state\_wait\_ordered} 

  The thread is waiting to enter an ordered region. A compliant
  implementation may have a thread enter this state early, when the thread encounters
  an ordered construct, or late, when the thread begins
  to wait to enter the ordered region. 
  
\end{description}
  
\littleheader{Target Wait States}

\begin{description}

\item \code{omp\_state\_wait\_target} 

  The thread is waiting for a target region to complete.
  
\item \code{omp\_state\_wait\_target\_data} 

  The thread is waiting for a target data mapping operation to complete. 
  A  compliant implementation may report \code{omp\_state\_wait\_target} for target data constructs.

\item \code{omp\_state\_wait\_target\_update} 

  The thread is waiting for a target  update operation to complete. 
  A  compliant implementation may report \code{omp\_state\_wait\_target} for target update constructs.

\end{description}


\littleheader{Undefined State}

\begin{description}
\item \code{omp\_state\_undefined} 

  This state is reserved for threads that are not user threads,
  initial threads, threads currently in an OpenMP team, or threads
  waiting to become part of an OpenMP team.

\end{description}

\begin{comment}
\section{OMPT Inquiry Functions}
\label{sec:omptFunctions}


 Inquiry functions retrieve data from the execution environment for
 the tools. 
 All functions in the inquiry API are marked with \code{OMPT\_API}. These functions should not be global symbols in an OpenMP implementation to avoid tempting tool developers to call them directly. Section~\ref{sec:init} describes how a tool should obtain pointers to these inquiry functions.
 {\em All inquiry functions are async signal safe.} 
 Note that it is unsafe to call OpenMP Execution Environment Routines within an OMPT callback because doing so may cause deadlock. 
 Specifically, since OpenMP Execution Library Routines are not guaranteed to be async signal safe, they might acquire a lock that may already be held when an OMPT callback is involved.
\end{comment}
 
 \subsection{\code{ompt\_enumerate\_states}}
 \label{ompt_enumerate_states}
 \summary
 
An OpenMP implementation may support implementation-specific states in 
addition to those specified in the \code{ompt\_states\_t} enumeration.
The \code{ompt\_enumerate\_states} routine enables a tool 
to determine all thread states supported by a particular OpenMP 
implementation.

\format

\ccppspecificstart
\begin{boxedcode}
OMPT_API int ompt_enumerate_states(
  int \plc{current_state}, 
  int *\plc{next_state}, 
  const char **\plc{next_state_name}
);
\end{boxedcode}
\ccppspecificend

\effect

When a thread state supported by an OpenMP implementation is passed
as the first argument of  
a call to \code{ompt\_enumerate\_states}, the call will 
assign the next thread state in an enumeration of all thread states
supported by the implementation to the pointer passed as the second
argument of the call.
The third argument of a call to \code{ompt\_enumerate\_states}
is the address of a character pointer
that will be assigned a pointer to the name associated with 
the state value assigned to the pointer passed as the second argument of 
the call.
Whenever one or more states are left in the enumeration, 
\code{ompt\_enumerate\_states} will return $1$.
When the last state in the enumeration is passed 
to \code{ompt\_enumerate\_states} the first argument, 
the function will return $0$ 
indicating that the enumeration is complete.


\begin{comment}
For instance, a particular OpenMP implementation may want to 
provide more detail about the nature of runtime overhead, 
e.g., to differentiate between overhead associated with setting up 
parallel regions
and overhead associated with setting up tasks. 
% A tool need not report all states defined herein, e.g., if state tracking for a particular state would be too expensive.
To enable a tool to identify all states that an OpenMP implementation
supports, the following interface for enumerating all states that may be reported by the runtime that is being used.
\end{comment}

\constraints

The first argument passed to a call to \code{ompt\_enumerate\_states} must
be the numerical code for a valid thread state supported by an OpenMP
implementation.  
To begin enumerating the states that an OpenMP implementation supports,
the value \code{omp\_state\_undefined} should be passed as the
first argument of a call to \code{ompt\_enumerate\_states}.
Subsequent invocations of \code{ompt\_enumerate\_states},
should pass the value 
assigned to the pointer passed as the second argument to the prior call.

An example that illusrates how a tool can enumerate all states 
supported by an OpenMP implementation is shown below:

\ccppspecificstart
\begin{boxedcode}
int _state = omp_state_undefined;
const char *_state_name;
while (ompt_enumerate_states(_state, &_state, &_state_name)) \{
  // note that the runtime supports a state value _state 
  // associated with the name _state_name 
\}
\end{boxedcode}
\ccppspecificend

\section{OMPT Data Types}
\label{sec:data}

\littleheader{Thread Identifier}
\index{Thread Identifier}

Each OpenMP thread  has an associated identifier of type \code{ompt\_thread\_id\_t}.
\begin{comment}
\begin{boxedcode}
typedef uint64\_t ompt\_thread\_id\_t;
\end{boxedcode}
\end{comment}
  A thread's identifier is assigned when the thread is created.
  Identifiers assigned to threads on each device are unique from the time an OpenMP implementation is initialized until it is shut down.
  A thread identifier can be retrieved
  on demand by invoking the  \code{ompt\_get\_thread\_id}
  function (described in Section~\ref{sec:thread-inquiry}).
  Tools should not assume that \code{ompt\_thread\_id\_t} values are small or densely allocated.
  The value \code{ompt\_thread\_id\_none} is reserved to indicate an invalid thread id.

\littleheader{Parallel Region Identifiers}
\index{Parallel Region Identifiers}
Each OpenMP parallel region has an associated identifier of type
\code{ompt\_parallel\_id\_t}.
\begin{comment}
\begin{boxedcode}
typedef uint64\_t ompt\_parallel\_id\_t;
\end{boxedcode}
\end{comment}
  A parallel region's identifier is assigned
  when the region is created.  Identifiers assigned to parallel regions on each device are unique from the time an
  OpenMP implementation is initialized until it is shut down.
  A parallel region identifer can be retrieved for an enclosing parallel region
  on demand using the function \code{ompt\_get\_parallel\_info}  (described in Section~\ref{sec:parallel-inquiry}).
  Tools should not assume that \code{ompt\_parallel\_id\_t} values are small or densely allocated.
  The value \code{ompt\_parallel\_id\_none} is reserved to indicate an invalid parallel id.


\littleheader{Task Region Identifiers}
\index{Task Region Identifiers}
Each OpenMP task has an associated identifier of type
\code{ompt\_task\_id\_t}. Task identifiers are assigned to
initial, implicit, explicit, and target tasks.
\begin{comment}
\begin{boxedcode}
typedef uint64\_t ompt\_task\_id\_t;
\end{boxedcode}
\end{comment}
  A task's identifier is assigned
  when the task is created.
  Identifiers assigned to tasks on each device are unique from the time an
  OpenMP implementation is initialized until it is shut down.
  A task's identifier can be retrieved
  on demand by invoking the \code{ompt\_get\_task\_info}  function (described in Section~\ref{sec:task-region}).
  Tools should not assume that \code{ompt\_task\_id\_t} values are small or densely allocated.
  The value \code{ompt\_task\_id\_none} is reserved to indicate an invalid task identifier.

\littleheader{Target Region and Operation Identifiers}
\index{Target Region and Operation Identifiers}
Each OpenMP target region and target operation has an associated identifier of type \code{ompt\_target\_id\_t}.
A unique target identifier is assigned on the host each time an instance of a target construct is encountered.
Each operation within a target region, e.g., transferring data to/from a device or launching a kernel launch
on a device, is also assigned a unique target identifier.
Identifiers assigned to target regions or operations
are unique from the time an OpenMP implementation is initialized until it is shut down.
The current target region and operation identifiers can be retrieved by invoking the \code{ompt\_get\_target\_info} function (described in Section~\ref{sec:target-region}).
Tools should not assume that \code{ompt\_target\_id\_t} values are small or densely allocated.
The value \code{ompt\_target\_id\_none} is reserved to indicate an invalid target identifier.
The value \code{ompt\_target\_id\_none} will be returned for (a) the target region identifier if \code{ompt\_get\_target\_info} is invoked outside a target region and (b) the target operation identifier if \code{ompt\_get\_target\_info} is invoked while no target operation is in progress.

\littleheader{Wait Identifiers}
\index{Wait Identifiers}

Each thread instance maintains a {\em wait identifier} of type \code{ompt\_wait\_id\_t}.
When a task executing on a thread is waiting for something, the thread's wait identifer indicates what the thread is awaiting.
A wait identifier may represent a critical section {\em name}, a lock,  a program variable accessed in an atomic region, or a synchronization object internal to an OpenMP implementation.
\begin{comment}
\begin{boxedcode}
typedef uint64\_t ompt\_wait\_id\_t;
\end{boxedcode}
\end{comment}
A thread's wait identifier can be retrieved on demand by invoking the \code{ompt\_get\_state} function (described in Section~\ref{sec:thread-inquiry}).
Tools should not assume that \code{ompt\_wait\_id\_t} values are small or densely allocated.
When a thread is not in a wait state, a thread's wait identifier has an undefined value.
%%? Does that mean that the value is undefined and cannot sensibley be read, or that it has a specific value which we have
%%? defined somewhere, whose name is (something like) ompt_wait_id_undefined  ?
%%johnmc says: a wait_id typically is set to the address of a lock on which you are spinning. If you aren't spinning on a lock, this value is undefined.
%%             we could zero it out, but that would cost more.

\littleheader{Frames}
\index{Frames}

When executing an OpenMP program, at times procedure frames from the OpenMP runtime appear on the call stack between procedure frames for user code.
To enable a tool to determine whether each procedure frame on the call stack represents
user code or an OpenMP runtime routine,
an implementation of the OpenMP API must maintains an instance of an \code{ompt\_frame\_t}
for each (possibly degenerate\footnote{
A task is considered degenerate if a call to the OpenMP runtime to create a parallel
region or task does not create a new task.
A degenerate task may arise when a parallel construct is encountered
in a parallel region and nested parallelism is not enabled or when an orphaned directive that would create a task is encountered outside a parallel region.
A degenerate task region may add runtime frames to the call stack before
invoking an outlined function for the degenerate task and thus require an \code{ompt\_frame\_t}
data structure.}) task that is active on a thread's stack.
To simplify discussion that follows,
we omit the qualifier ``possibly degenerate'' each time we use the term {\em task}.

  Each initial, implicit, explicit, or target task maintains an \code{ompt\_frame\_t} data structure
  that contains a pair of pointers.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_frame_s \{\\
  void * \plc{exit_frame};  /* runtime frame that calls user code */
  void * \plc{enter_frame}; /* user frame that calls the runtime  */
\} ompt_frame_t;
\end{boxedcode}
\ccppspecificend
}

An \code{ompt\_frame\_t}'s  lifetime begins when a task  is
created and ends when the task is destroyed.  Tools should not assume that a frame structure remains at a constant location in memory
throughout a task's lifetime.
A frame object is passed to some callbacks; it can also be retrieved
asynchronously
by invoking the \code{ompt\_get\_task\_info}  function (described in Section~\ref{sec:task-region}) in a signal handler.
A task's frame object contains two fields: \code{exit\_frame} and \code{enter\_frame}.

The \code{exit\_frame} field of a task's frame object
is set just before the task starts executing the structred block of the task region.
The field contains the canonical frame address of the procedure that invoked the outlined function.
In cases where the an outlined procedure is invoked directly from a user code frame,
\code{exit\_frame} will contain the canonical frame address of a procedure containing  user code
that belongs to the enclosing task.
The value of \code{exit\_frame} is \code{NULL} in a task's frame object until just
before the task calls an outlined function to begin execution. The value of
\code{exit\_frame} is set to \code{NULL} when the task returns to the runtime,
whether finished or deferred.

The \code{enter\_frame} field of a task's frame object is set each time the task re-enters the
runtime to create a new implicit, explicit, or target task. When a task invokes an entry point in the
OpenMP runtime to create a task,
the \code{enter\_frame} field of the task's frame object will be set to
the canonical frame address of the user function that invoked the runtime.
The value of \code{enter\_frame} is set when a task enters the OpenMP runtime
and cleared before the OpenMP runtime returns control to the task.

\begin{table}
\begin{center}
\begin{tabular}{p{1in}p{2in}p{2in}}
\hline
\code{exit\_frame} / \code{enter\_frame} 	& \code{enter\_frame} is \code{NULL}										& \code{enter\_frame} is defined \\
\hline
\code{exit\_frame} is \code{NULL} & case 1)  initial task in user code\newline case 2) task that is created but not yet scheduled or already finished & initial task entered the runtime to schedule an implicit, explicit, or target task \\\hline
\code{exit\_frame} is defined 	& non-initial task in (or soon to be in) user code							& non-initial task entered the runtime and scheduled an implicit, explicit, or target task\\
\hline
\end{tabular}
\vspace{1ex}
\end{center}
\caption{Meaning of various values for \code{exit\_frame} and \code{enter\_frame}.}
\label{tab:frame}
\end{table}

Table~\ref{tab:frame} describes the meaning of this structure with various values.
In the presence of nested parallelism, a tool may observe a sequence of \code{ompt\_frame\_t} records for a thread. Appendix~\ref{app:frame} discusses  an example that illustrates the use of \code{ompt\_frame\_t} records with nested parallelism.

\littleheader{Advice to tool implementers:} A monitoring tool using
      asynchronous sampling can observe values of
      \code{exit\_frame} and \code{enter\_frame} at inconvenient times.
      Tools must be prepared to observe and handle frame exit and reenter values that have not yet been set or reset as the program enters or leaves the runtime.


\section{Events without Directives}
\subsection{\code{ompt\_event\_thread\_begin}}
An OpenMP implementation invokes this callback in the context of an initial thread just after it initializes the runtime, or in the context of a new thread created by the runtime just after the thread initializes itself. In either case, this callback must be the first callback for a thread
and must occur before the thread executes any OpenMP tasks. This callback has type signature \code{ompt\_thread\_begin\_callback\_t}.
The callback argument \code{thread\_type} indicates the type of the thread: initial, worker, or other.

\subsection{\code{ompt\_event\_thread\_end}}
An OpenMP implementation invokes this callback
after an OpenMP thread completes all of
its tasks but before the thread is destroyed. The callback
executes in the context of the OpenMP thread. This callback must be the last callback event for any worker thread; it is optional for other types of threads.
This callback has type signature \code{ompt\_thread\_end\_callback\_t}.

\subsection{\code{ompt\_event\_target\_submit}}

An OpenMP implementation invokes this callback prior to submitting a kernel for execution on a target device.
This callback has type signature \code{ompt\_target\_submit\_callback\_t}.
The callback argument \code{target\_id} indicates the instance of the target construct associated with this operation.
The callback argument \code{host\_op\_id} provides a unique host-side identifier that represents the activity on the device.
The callback arguments \code{requested\_num\_teams}  \code{granted\_num\_teams} indicate, respectively, the number of teams requested by the user and granted by the runtime.

\subsection{\code{ompt\_event\_control}}
\label{subsec:ompt_event_control}
If the user program calls \code{ompt\_control}, an
OpenMP implementation invokes this callback.
The callback executes in the context that the call occurs in the user program.
This callback has type signature \code{ompt\_control\_callback\_t}.
Arguments passed to the callback are those passed by the user to \code{ompt\_control}.

\subsection{\code{ompt\_event\_runtime\_shutdown}}
An OpenMP implementation invokes this callback before it shuts down the
 runtime system.  This callback enables a tool to clean up its
 state and record or report information gathered. A runtime may later restart and reinitialize the tool by
calling the tool initializer
function (described in Section~\ref{sec:init}) again.
 This callback has type signature \code{ompt\_callback\_t}.

\subsection{\code{ompt\_event\_idle}}
An OpenMP implementation invokes this callback with \code{endpoint=}\code{ompt\_scope\_begin} when a thread waits for work outside a parallel region.
  The OpenMP runtime invokes this callback with \code{endpoint=}\code{ompt\_scope\_end} before the thread  begins to execute an implicit task for
   a parallel region or terminates. The callback executes in the environment of the waiting thread.
  This callback has type signature \code{ompt\_idle\_callback\_t}.

\subsection{\code{ompt\_event\_sync\_region\_wait}}

  An OpenMP implementation invokes this callback with \code{endpoint=}\code{ompt\_scope\_begin} when a task starts waiting in a barrier region, taskwait region, or taskgroup region.
   An OpenMP implementation invokes this callback with the \code{endpoint=}\code{ompt\_scope\_end} when the task stops waiting in the region.
  This callback has type signature \code{ompt\_scoped\_sync\_region\_callback\_t}.
   The argument \code{kind} indicates the kind of region causing the wait.
   One region may generate multiple pairs of begin/end callbacks if another task is scheduled on the thread while the task awaiting completion of the region is stalled.
   The callback argument \code{codeptr\_ra} may be NULL.
   This callback executes in the context of the task that encountered the barrier, taskwait, or taskgroup construct.


\section{Event Callback Signatures}
\index{event callback signatures}
\label{sec:ToolsSupport_callback_signatures}

This section describes the signatures of tool callback functions that an OMPT
tool might register and that are called during runtime of an OpenMP program.

\subsection{\code{ompt\_thread\_begin\_callback\_t}}
\index{ompt\_thread\_begin\_callback\_t@{\code{ompt\_thread\_begin\_callback\_t}}}
\label{subsec:ompt_thread_begin_callback_t}
\format
\begin{boxedcode}
typedef void (*ompt\_thread\_begin\_callback\_t) (
  ompt\_thread\_type\_t \plc{thread\_type},
  ompt\_data\_t *\plc{thread\_data}
);
\end{boxedcode}
\descr
The callback with type signature \code{ompt\_thread\_begin\_callback\_t},
includes a parameter \plc{thread\_type}
that indicates the type of the new thread: initial, worker, or other.
The binding of \plc{thread\_data} is the new thread.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type signature, see
\specref{subsec:ompt_data_t}.
\item \code{ompt\_thread\_type\_t} type signature, see
\specref{subsec:ompt_thread_type_t}.
\end{itemize}



\subsection{\code{ompt\_thread\_end\_callback\_t}}
\index{ompt\_thread\_end\_callback\_t@{\code{ompt\_thread\_end\_callback\_t}}}
\label{subsec:ompt_thread_end_callback_t}
\format
\begin{boxedcode}
typedef void (*ompt\_thread\_end\_callback\_t) (
  ompt\_data\_t *\plc{thread\_data}
);
\end{boxedcode}
\descr
The binding of \plc{thread\_data} is the finished thread.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type signature, see
\specref{subsec:ompt_data_t}.
\end{itemize}



\subsection{\code{ompt\_idle\_callback\_t}}
\index{ompt\_idle\_callback\_t@{\code{ompt\_idle\_callback\_t}}}
\label{subsec:ompt_idle_callback_t}
\format
\begin{boxedcode}
typedef void (*ompt\_idle\_callback\_t) (
  ompt\_scope\_endpoint\_t \plc{endpoint}
);
\end{boxedcode}
\descr
The callback with type signature \code{ompt\_idle\_callback\_t},
includes a parameter \plc{endpoint}
that indicates whether the callback signals the begin or end of the scope.

\crossreferences
\begin{itemize}
\item \code{ompt\_scope\_endpoint\_t} type signature, see
\specref{subsec:ompt_scope_endpoint_t}.
\end{itemize}



\subsection{\code{ompt\_parallel\_begin\_callback\_t}}
\index{ompt\_parallel\_begin\_callback\_t@{\code{ompt\_parallel\_begin\_callback\_t}}}
\label{subsec:ompt_parallel_begin_callback_t}
\format
\begin{boxedcode}
typedef void (*ompt\_parallel\_begin\_callback\_t) (
               ompt\_data\_t * \plc{parent\_task\_data},
               const ompt\_frame\_t * \plc{parent\_frame},
               ompt\_data\_t * \plc{parallel\_data},
               uint32\_t \plc{requested\_team\_size},
               uint32\_t \plc{actual\_team\_size},
               ompt\_invoker\_t \plc{invoker},
               const void * \plc{codeptr\_ra}
);
\end{boxedcode}

\descr
The callbacks with type signature \code{ompt\_parallel\_begin\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.
The binding of \plc{parent\_task\_data} is the enclosing task, the binding of
\plc{parallel\_data} is the new team.


\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type signature, see
\specref{subsec:ompt_data_t}.
\item \code{ompt\_frame\_t} type signature, see
\specref{subsec:ompt_frame_t}.
\item \code{ompt\_invoker\_t} type signature, see
\specref{subsec:ompt_invoker_t}.
\end{itemize}



\subsection{\code{ompt\_parallel\_end\_callback\_t}}
\index{ompt\_parallel\_end\_callback\_t@{\code{ompt\_parallel\_end\_callback\_t}}}
\label{subsec:ompt_parallel_end_callback_t}
\format
\begin{boxedcode}
typedef void (*ompt\_parallel\_end\_callback\_t) (
               ompt\_data\_t * \plc{parallel\_data},
               ompt\_data\_t * \plc{task\_data},
               ompt\_invoker\_t \plc{invoker},
               const void * \plc{codeptr\_ra}
);
\end{boxedcode}

\descr
The callbacks with type signature \code{ompt\_parallel\_begin\_callback\_t}
include a parameter \plc{invoker} which explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.
The binding of \plc{parallel\_data} is the finishing team.

%\effect
% ompt events have no effect

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type signature, see
\specref{subsec:ompt_data_t}.
\item \code{ompt\_invoker\_t} type signature, see
\specref{subsec:ompt_invoker_t}.
\end{itemize}

\subsection{\code{ompt\_scoped\_master\_callback\_t}}
\index{ompt\_scoped\_master\_callback\_t@{\code{ompt\_scoped\_master\_callback\_t}}}
\label{subsec:ompt_scoped_master_callback_t}
\format
\begin{boxedcode}
typedef void (*\plc{ompt\_scoped\_master\_callback\_t}) (
               ompt\_scope\_endpoint\_t \plc{endpoint},
               ompt\_data\_t *\plc{parallel\_data},
               ompt\_data\_t *\plc{task\_data},
               const void *\plc{codeptr\_ra}
);
\end{boxedcode}

\descr
The callbacks with type signature \code{ompt\_scoped\_master\_callback\_t}
include a parameter \plc{codeptr\_ra} which contains the return address of the
call to the OpenMP runtime routine and a parameter \plc{endpoint}
that indicates whether the callback signals the begin or end of the scope.
The binding of \plc{task\_data} is the innermost enclosing implicit task,
the binding of \plc{parallel\_data} is the innermost enclosing parallel region.

%\effect
% ompt events have no effect

\crossreferences
\begin{itemize}
\item \code{ompt\_scope\_endpoint\_t} type signature, see
\specref{subsec:ompt_scope_endpoint_t}.
\item \code{ompt\_data\_t} type signature, see
\specref{subsec:ompt_data_t}.
\end{itemize}





\subsection{\code{ompt\_task\_create\_callback\_t}}
\index{ompt\_task\_create\_callback\_t@{\code{ompt\_task\_create\_callback\_t}}}
\label{subsec:ompt_task_create_callback_t}
\format
\begin{boxedcode}
typedef void (*ompt\_task\_create\_callback\_t) (
  ompt\_data\_t *\plc{parent\_task\_data},
  const ompt\_frame\_t *\plc{parent\_frame},
  ompt\_data\_t *\plc{new\_task\_data},
  ompt\_task\_type\_t \plc{type},
  \_Bool \plc{has\_dependences},
  const void *\plc{codeptr\_ra}
);
\end{boxedcode}
\descr
The callbacks with type signature \code{ompt\_task\_create\_callback\_t},
include a parameter \plc{parent\_frame}
that indicates the frame information of the encountering task, and a parameter
\plc{type} that indicates the kind of the task: initial, explicit or target.
The binding of \plc{parent\_task\_data} is the encountering task,
the binding of \plc{new\_task\_data} is the created task.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type signature, see
\specref{subsec:ompt_data_t}.
\item \code{ompt\_frame\_t} type signature, see
\specref{subsec:ompt_frame_t}.
\item \code{ompt\_task\_type\_t} type signature, see
\specref{subsec:ompt_task_type_t}.
\end{itemize}



\subsection{\code{ompt\_task\_dependences\_callback\_t}}
\index{ompt\_task\_dependences\_callback\_t@{\code{ompt\_task\_dependences\_callback\_t}}}
\label{subsec:ompt_task_dependences_callback_t}
\format
\begin{boxedcode}
typedef void (*ompt\_task\_dependences\_callback\_t) (
  ompt\_data\_t *\plc{task\_data},
  const ompt\_task\_dependence\_t *\plc{deps},
  int \plc{ndeps}
);
\end{boxedcode}
\descr
The callback with type signature \code{ompt\_task\_dependences\_callback\_t},
includes a parameter \plc{deps} that lists all dependences of a new task and
a parameter \plc{ndeps} that specifies the length of the list.
The memory ownage of \plc{deps} remains at the caller, the tool cannot rely on
the data after the callback returns.
The binding of \plc{task\_data} is the created task.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type signature, see
\specref{subsec:ompt_data_t}.
\item \code{ompt\_task\_dependence\_t} type signature, see
\specref{subsec:ompt_task_dependence_t}.
\end{itemize}



\subsection{\code{ompt\_task\_dependence\_callback\_t}}
\index{ompt\_task\_dependence\_callback\_t@{\code{ompt\_task\_dependence\_callback\_t}}}
\label{subsec:ompt_task_dependence_callback_t}
\format
\begin{boxedcode}
typedef void (*ompt\_task\_dependence\_callback\_t) (
  ompt\_data\_t *\plc{src\_task\_data},
  ompt\_data\_t *\plc{sink\_task\_data}
);
\end{boxedcode}
\descr
The binding of \plc{src\_task\_data} is a running task with an out dependency.
The binding of \plc{sink\_task\_data} is a task with a non-satisfied in dependency.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type signature, see
\specref{subsec:ompt_data_t}.
\end{itemize}



\subsection{\code{ompt\_task\_schedule\_callback\_t}}
\index{ompt\_task\_schedule\_callback\_t@{\code{ompt\_task\_schedule\_callback\_t}}}
\label{subsec:ompt_task_schedule_callback_t}
\format
\begin{boxedcode}
typedef void (*ompt\_task\_schedule\_callback\_t) (
  ompt\_data\_t *\plc{prior\_task\_data},
  \_Bool \plc{prior\_completed},
  ompt\_data\_t *\plc{next\_task\_data}
);
\end{boxedcode}
\descr
The callback with type signature \code{ompt\_task\_schedule\_callback\_t},
include a parameter \plc{prior\_completed}
that indicates whether the task that reached the task scheduling point finished
execution its task region.
The binding of \plc{prior\_task\_data} is the task that reached the task scheduling point.
The binding of \plc{next\_task\_data} is the task to be scheduled.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type signature, see
\specref{subsec:ompt_data_t}.
\end{itemize}



\subsection{\code{ompt\_scoped\_implicit\_callback\_t}}
\index{ompt\_scoped\_implicit\_callback\_t@{\code{ompt\_scoped\_implicit\_callback\_t}}}
\label{subsec:ompt_scoped_implicit_callback_t}
\format
\begin{boxedcode}
typedef void (*ompt\_scoped\_implicit\_callback\_t) (
  ompt\_scope\_endpoint\_t \plc{endpoint},
  ompt\_data\_t *\plc{parallel\_data},
  ompt\_data\_t *\plc{task\_data},
  uint32\_t \plc{thread\_num}
);
\end{boxedcode}
\descr
The callback with type signature \code{ompt\_scoped\_implicit\_callback\_t},
includes a parameter \plc{endpoint} that indicates whether the callback signals
the begin or end of the scope and a parameter \plc{thread\_num} that indicates
the thread number of the calling thread, within the team executing the parallel
region to which the implicit region binds.
The binding of \plc{parallel\_data} is the innermost enclosing parallel region.
The binding of \plc{task\_data} is the implicit task executing the parallel
region's structured block.


\crossreferences
\begin{itemize}
\item \code{ompt\_scope\_endpoint\_t} type signature, see
\specref{subsec:ompt_scope_endpoint_t}.
\item \code{ompt\_data\_t} type signature, see
\specref{subsec:ompt_data_t}.
\end{itemize}



\subsection{\code{ompt\_scoped\_sync\_region\_callback\_t}}
\index{ompt\_scoped\_sync\_region\_callback\_t@{\code{ompt\_scoped\_sync\_region\_callback\_t}}}
\label{subsec:ompt_scoped_sync_region_callback_t}
\format
\begin{boxedcode}
typedef void (*ompt\_scoped\_sync\_region\_callback\_t) (
  ompt\_sync\_region\_kind\_t \plc{kind},
  ompt\_scope\_endpoint\_t \plc{endpoint},
  ompt\_data\_t *\plc{parallel\_data},
  ompt\_data\_t *\plc{task\_data},
  const void *\plc{codeptr\_ra}
);
\end{boxedcode}
\descr ToDo
The callbacks with type signature \code{ompt\_scoped\_sync\_region\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

include a parameter \plc{codeptr\_ra} which contains the return address of the
call to the OpenMP runtime routine and a parameter \plc{endpoint}
that indicates whether the callback signals the begin or end of the scope.

\crossreferences
\begin{itemize}
\item \code{ompt\_sync\_region\_kind\_t} type signature, see
\specref{subsec:ompt_sync_region_kind_t}.
\item \code{ompt\_scope\_endpoint\_t} type signature, see
\specref{subsec:ompt_scope_endpoint_t}.
\item \code{ompt\_data\_t} type signature, see
\specref{subsec:ompt_data_t}.
\end{itemize}



\subsection{\code{ompt\_lock\_init\_callback\_t}}
\index{ompt\_lock\_init\_callback\_t@{\code{ompt\_lock\_init\_callback\_t}}}
\label{subsec:ompt_lock_init_callback_t}
\format
\begin{boxedcode}
typedef void (*ompt\_lock\_init\_callback\_t) (
  \_Bool \plc{is\_nest\_lock},
  ompt\_wait\_id\_t \plc{wait\_id},
  uint32\_t \plc{hint},
  uint32\_t \plc{kind},
  const void *\plc{codeptr\_ra}
);
\end{boxedcode}
\descr ToDo
The callbacks with type signature \code{ompt\_lock\_init\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_wait\_id\_t} type signature, see
\specref{subsec:ompt_wait_id_t}.
\end{itemize}



\subsection{\code{ompt\_lock\_destroy\_callback\_t}}
\index{ompt\_lock\_destroy\_callback\_t@{\code{ompt\_lock\_destroy\_callback\_t}}}
\label{subsec:ompt_lock_destroy_callback_t}
\format
\begin{boxedcode}
typedef void (*ompt\_lock\_destroy\_callback\_t) (
  \_Bool \plc{is\_nest\_lock},
  ompt\_wait\_id\_t \plc{wait\_id},
  const void *\plc{codeptr\_ra}
);
\end{boxedcode}
\descr ToDo
The callbacks with type signature \code{ompt\_lock\_destroy\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_wait\_id\_t} type signature, see
\specref{subsec:ompt_wait_id_t}.
\end{itemize}



\subsection{\code{ompt\_mutex\_acquire\_callback\_t}}
\index{ompt\_mutex\_acquire\_callback\_t@{\code{ompt\_mutex\_acquire\_callback\_t}}}
\label{subsec:ompt_mutex_acquire_callback_t}
\format
\begin{boxedcode}
typedef void (*ompt\_mutex\_acquire\_callback\_t) (
  ompt\_mutex\_kind\_t \plc{kind},
  uint32\_t \plc{hint},
  uint32\_t \plc{impl},
  ompt\_wait\_id\_t \plc{wait\_id},
  const void *\plc{codeptr\_ra}
);
\end{boxedcode}
\descr ToDo
The callbacks with type signature \code{ompt\_mutex\_acquire\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_mutex\_kind\_t} type signature, see
\specref{subsec:ompt_mutex_kind_t}.
\item \code{ompt\_wait\_id\_t} type signature, see
\specref{subsec:ompt_wait_id_t}.
\end{itemize}



\subsection{\code{ompt\_mutex\_callback\_t}}
\index{ompt\_mutex\_callback\_t@{\code{ompt\_mutex\_callback\_t}}}
\label{subsec:ompt_mutex_callback_t}
\format
\begin{boxedcode}
typedef void (*ompt\_mutex\_callback\_t) (
  ompt\_mutex\_kind\_t \plc{kind},
  ompt\_wait\_id\_t \plc{wait\_id},
  const void *\plc{codeptr\_ra}
);
\end{boxedcode}
\descr ToDo
The callbacks with type signature \code{ompt\_mutex\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_mutex\_kind\_t} type signature, see
\specref{subsec:ompt_mutex_kind_t}.
\item \code{ompt\_wait\_id\_t} type signature, see
\specref{subsec:ompt_wait_id_t}.
\end{itemize}



\subsection{\code{ompt\_scoped\_nested\_lock\_callback\_t}}
\index{ompt\_scoped\_nested\_lock\_callback\_t@{\code{ompt\_scoped\_nested\_lock\_callback\_t}}}
\label{subsec:ompt_scoped_nested_lock_callback_t}
\format
\begin{boxedcode}
typedef void (*ompt\_scoped\_nested\_lock\_callback\_t) (
  ompt\_scope\_endpoint\_t \plc{endpoint},
  ompt\_wait\_id\_t \plc{wait\_id},
  const void *\plc{codeptr\_ra}
);
\end{boxedcode}
\descr ToDo
The callbacks with type signature \code{ompt\_scoped\_nested\_lock\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

include a parameter \plc{codeptr\_ra} which contains the return address of the
call to the OpenMP runtime routine and a parameter \plc{endpoint}
that indicates whether the callback signals the begin or end of the scope.

\crossreferences
\begin{itemize}
\item \code{ompt\_scope\_endpoint\_t} type signature, see
\specref{subsec:ompt_scope_endpoint_t}.
\item \code{ompt\_wait\_id\_t} type signature, see
\specref{subsec:ompt_wait_id_t}.
\end{itemize}



\subsection{\code{ompt\_scoped\_worksharing\_callback\_t}}
\index{ompt\_scoped\_worksharing\_callback\_t@{\code{ompt\_scoped\_worksharing\_callback\_t}}}
\label{subsec:ompt_scoped_worksharing_callback_t}
\format
\begin{boxedcode}
typedef void (*ompt\_scoped\_worksharing\_callback\_t) (
  ompt\_worksharing\_type\_t \plc{wstype},
  ompt\_scope\_endpoint\_t \plc{endpoint},
  ompt\_data\_t *\plc{parallel\_data},
  ompt\_data\_t *\plc{task\_data},
  const void *\plc{codeptr\_ra}
);
\end{boxedcode}
\descr ToDo
The callbacks with type signature \code{ompt\_scoped\_worksharing\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

include a parameter \plc{codeptr\_ra} which contains the return address of the
call to the OpenMP runtime routine and a parameter \plc{endpoint}
that indicates whether the callback signals the begin or end of the scope.

\crossreferences
\begin{itemize}
\item \code{ompt\_worksharing\_type\_t} type signature, see
\specref{subsec:ompt_worksharing_type_t}.
\item \code{ompt\_scope\_endpoint\_t} type signature, see
\specref{subsec:ompt_scope_endpoint_t}.
\item \code{ompt\_data\_t} type signature, see
\specref{subsec:ompt_data_t}.
\end{itemize}



\subsection{\code{ompt\_flush\_callback\_t}}
\index{ompt\_flush\_callback\_t@{\code{ompt\_flush\_callback\_t}}}
\label{subsec:ompt_flush_callback_t}
\format
\begin{boxedcode}
typedef void (*ompt\_flush\_callback\_t) (
  ompt\_data\_t *\plc{thread\_data},
  const void *\plc{codeptr\_ra}
);
\end{boxedcode}
\descr ToDo
The callbacks with type signature \code{ompt\_flush\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type signature, see
\specref{subsec:ompt_data_t}.
\end{itemize}



\subsection{\code{ompt\_scoped\_target\_callback\_t}}
\index{ompt\_scoped\_target\_callback\_t@{\code{ompt\_scoped\_target\_callback\_t}}}
\label{subsec:ompt_scoped_target_callback_t}
\format
\begin{boxedcode}
typedef void (*ompt\_scoped\_target\_callback\_t) (
  int32\_t \plc{device\_id},
  ompt\_target\_type\_t \plc{kind},
  ompt\_data\_t *\plc{task\_data},
  ompt\_scope\_endpoint\_t \plc{endpoint},
  ompt\_id\_t \plc{target\_id},
  const void *\plc{codeptr\_ra}
);
\end{boxedcode}
\descr ToDo
The callbacks with type signature \code{ompt\_scoped\_target\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

include a parameter \plc{codeptr\_ra} which contains the return address of the
call to the OpenMP runtime routine and a parameter \plc{endpoint}
that indicates whether the callback signals the begin or end of the scope.

\crossreferences
\begin{itemize}
\item \code{ompt\_target\_type\_t} type signature, see
\specref{subsec:ompt_target_type_t}.
\item \code{ompt\_data\_t} type signature, see
\specref{subsec:ompt_data_t}.
\item \code{ompt\_scope\_endpoint\_t} type signature, see
\specref{subsec:ompt_scope_endpoint_t}.
\item \code{ompt\_id\_t} type signature, see
\specref{subsec:ompt_id_t}.
\end{itemize}



\subsection{\code{ompt\_target\_data\_callback\_t}}
\index{ompt\_target\_data\_callback\_t@{\code{ompt\_target\_data\_callback\_t}}}
\label{subsec:ompt_target_data_callback_t}
\format
\begin{boxedcode}
typedef void (*ompt\_target\_data\_callback\_t) (
  ompt\_id\_t \plc{target\_id},
  ompt\_id\_t \plc{host\_op\_id},
  ompt\_target\_data\_op\_t \plc{optype},
  void *\plc{host\_addr},
  void *\plc{device\_addr},
  size\_t \plc{bytes}
);
\end{boxedcode}
\descr ToDo
The callbacks with type signature \code{ompt\_target\_data\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_id\_t} type signature, see
\specref{subsec:ompt_id_t}.
\item \code{ompt\_target\_data\_op\_t} type signature, see
\specref{subsec:ompt_target_data_op_t}.
\end{itemize}



\subsection{\code{ompt\_target\_data\_map\_callback\_t}}
\index{ompt\_target\_data\_map\_callback\_t@{\code{ompt\_target\_data\_map\_callback\_t}}}
\label{subsec:ompt_target_data_map_callback_t}
\format
\begin{boxedcode}
typedef void (*ompt\_target\_data\_map\_callback\_t) (
  ompt\_id\_t \plc{target\_id},
  uint32\_t \plc{nitems},
  void **\plc{host\_addr},
  void **\plc{device\_addr},
  size\_t *\plc{bytes},
  uint32\_t *\plc{mapping\_flags}
);
\end{boxedcode}
\descr ToDo
The callbacks with type signature \code{ompt\_target\_data\_map\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_id\_t} type signature, see
\specref{subsec:ompt_id_t}.
\end{itemize}



\subsection{\code{ompt\_target\_submit\_callback\_t}}
\index{ompt\_target\_submit\_callback\_t@{\code{ompt\_target\_submit\_callback\_t}}}
\label{subsec:ompt_target_submit_callback_t}
\format
\begin{boxedcode}
typedef void (*ompt\_target\_submit\_callback\_t) (
  ompt\_id\_t \plc{target\_id},
  ompt\_id\_t \plc{host\_op\_id},
  uint32\_t \plc{requested\_num\_teams},
  uint32\_t \plc{granted\_num\_teams}
);
\end{boxedcode}
\descr ToDo
The callbacks with type signature \code{ompt\_target\_submit\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_id\_t} type signature, see
\specref{subsec:ompt_id_t}.
\end{itemize}


\begin{targetRecord}
\subsection{\code{ompt\_target\_buffer\_request\_callback\_t}}
\index{ompt\_target\_buffer\_request\_callback\_t@{\code{ompt\_target\_buffer\_request\_callback\_t}}}
\label{subsec:ompt_target_buffer_request_callback_t}
\format
\begin{boxedcode}
typedef void (*ompt\_target\_buffer\_request\_callback\_t) (
  int32\_t \plc{device\_id},
  ompt\_target\_buffer\_t** \plc{buffer},
  size\_t *\plc{bytes}
);
\end{boxedcode}
\descr ToDo
The callbacks with type signature \code{ompt\_target\_buffer\_request\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_target\_buffer\_t} type signature, see
\specref{subsec:ompt_target_buffer_t}.
\end{itemize}



\subsection{\code{ompt\_target\_buffer\_complete\_callback\_t}}
\index{ompt\_target\_buffer\_complete\_callback\_t@{\code{ompt\_target\_buffer\_complete\_callback\_t}}}
\label{subsec:ompt_target_buffer_complete_callback_t}
\format
\begin{boxedcode}
typedef void (*ompt\_target\_buffer\_complete\_callback\_t) (
  int32\_t \plc{device\_id},
  const ompt\_target\_buffer\_t *\plc{buf},
  size\_t \plc{bytes},
  ompt\_target\_buffer\_cursor\_t \plc{begin},
  \_Bool \plc{buffer\_owned}
);
\end{boxedcode}
\descr ToDo
The callbacks with type signature \code{ompt\_target\_buffer\_complete\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_target\_buffer\_t} type signature, see
\specref{subsec:ompt_target_buffer_t}.
\item \code{ompt\_target\_buffer\_cursor\_t} type signature, see
\specref{subsec:ompt_target_buffer_cursor_t}.
\end{itemize}



\subsection{\code{ompt\_get\_target\_info\_inquiry\_t}}
\index{ompt\_get\_target\_info\_inquiry\_t@{\code{ompt\_get\_target\_info\_inquiry\_t}}}
\label{subsec:ompt_get_target_info_inquiry_t}
\format
\begin{boxedcode}
typedef void (*ompt\_get\_target\_info\_inquiry\_t) (
  ompt\_id\_t *\plc{target\_id},
  ompt\_id\_t *\plc{host\_op\_id}
);
\end{boxedcode}
\descr ToDo
The callbacks with type signature \code{ompt\_get\_target\_info\_inquiry\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_id\_t} type signature, see
\specref{subsec:ompt_id_t}.
\end{itemize}
\end{targetRecord}


\subsection{\code{ompt\_control\_callback\_t}}
\index{ompt\_control\_callback\_t@{\code{ompt\_control\_callback\_t}}}
\label{subsec:ompt_control_callback_t}
\format
\begin{boxedcode}
typedef void (*ompt\_control\_callback\_t) (
  uint64\_t \plc{command},
  uint64\_t \plc{modifier},
  const void *\plc{codeptr\_ra}
);
\end{boxedcode}
\descr ToDo
The callbacks with type signature \code{ompt\_control\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.











% This is the end of ch5-toolsSupport.tex
