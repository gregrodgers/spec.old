% This is ch4-toolsSupport.tex of the OpenMP specification.
% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of 
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%


\chapter{Tool Interface}
\index{Tools Support}
\label{chap:ToolsSupport}

This chapter describes the OMPT interface provided by the OpenMP API 
to support third-party monitoring and performance analysis tools.
The chapter first explains if and how an implementation of
the OpenMP API will attempt to register a tool prior to initializing the OpenMP runtime and
how a registered tool will use the OMPT interface to initialize tool state maintained by 
an implementation of the OpenMP API. 
It concludes with a description of data types 
used to identify entities managed by an OpenMP runtime and to interpret the
call stack of an OpenMP thread.

\section{Tool Registration}
\index{tool registration}
\label{sec:ToolsSupport_Registration}

The \code{OMP\_TOOL} environment variable sets the \plc{omp-tool-var} ICV, which controls whether or not an 
implementation of the OpenMP API will attempt to register a tool.
The value of \code{OMP\_TOOL} is case insensitive and may have leading and trailing white space.
The only legal values of \code{OMP\_TOOL} are \code{enabled} or \code{disabled}.
If the value of \plc{omp-tool-var} is \code{enabled},
the OpenMP API implementation will attempt to register a tool by determining if 
an implementation of the function \code{ompt\_tool} exists in a program's address space and, if so, 
calling \code{ompt\_tool} before initializing the OpenMP runtime.
If the value of \plc{omp-tool-var} is \code{disabled}, the OpenMP API implementation will not 
call \code{ompt\_tool}, regardless of whether or not an implementation of \code{ompt\_tool} exists in the 
address space.
If \code{OMP\_TOOL} is set to any other value, an implementation of the OpenMP API 
will print a fatal error to the standard error file descriptor indicating that an illegal value had been supplied for \code{OMP\_TOOL} and the program's execution will terminate.
If \code{OMP\_TOOL} is not defined, the default value for \plc{omp-tool-var} is \code{enabled}.

\begin{comment}
\begin{table}
\begin{center}
\begin{tabular}{|c|p{4in}|}
\hline
 {\em omp-tool-var} value & action \\\hline
enabled & the OpenMP runtime will call \code{ompt\_tool} before initializing itself.\\\hline
disabled & the OpenMP runtime will not call \code{ompt\_tool}, regardless of whether a tool is present or not.\\\hline
\end{tabular}
\end{center}
\caption{OpenMP runtime responses to settings of the {\em omp-tool-var} ICV.}
\label{table:ToolsSupport_env-var}
\end{table}

\sloppy
Table~\ref{table:ToolsSupport_env-var} describes the action that an implementation of the OpenMP API 
will take in response to possible values of \plc{omp-tool-var}.
\end{comment}


% The signature for \code{ompt\_tool} is shown below:
% The signature for \code{ompt\_tool} is shown below:

\vbox{
\ccppspecificstart
\begin{boxedcode}
extern "C" \{\\
  ompt_initialize_fn_t ompt_tool(void);\\
\};
\end{boxedcode}
\ccppspecificend
}

If a tool provides an implementation of \code{ompt\_tool} in a program's address space, \code{ompt\_tool} may return \code{NULL} indicating that the tool declines to register itself; otherwise, the tool may register itself by having \code{ompt\_tool} return a non-\code{NULL} pointer to a function with type signature \code{ompt\_initialize\_fn\_t}.
The type signature for \code{ompt\_initialize\_fn\_t} is described in Section~\ref{sec:ToolsSupport_init}. 
Since only one tool-provided definition of \code{ompt\_tool} will be seen by an OpenMP runtime, only one tool may register itself. 
If a tool-supplied implementation of \code{ompt\_tool} returns a non-\code{NULL} initializer, 
an implementation of the OpenMP API will maintain state information for each OpenMP thread and will perform 
any OMPT event callbacks registered during tool initialization. 

After a process fork, if OpenMP is re-initialized in the child process,
an implementation of the OpenMP API in the child process will call \code{ompt\_tool} 
under the same conditions as it would for any process. 

\section{Tool Initialization}
\label{sec:ToolsSupport_init}

When an OpenMP runtime receives a non-\code{NULL} pointer to a tool initializer function with signature \code{ompt\_initialize\_fn\_t} as the return value from a call to a tool-provided implementation of \code{ompt\_tool}, the runtime will call the tool initializer immediately after the runtime fully initializes itself.
The initializer must be called before beginning execution of any OpenMP construct or completing any execution environment routine invocation.
The signature for the tool initializer callback is shown below:

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_initialize_fn_t) (
  ompt_function_lookup_t \plc{lookup},
  const char * \plc{runtime_version}, 
  unsigned int \plc{ompt_version}
);
\end{boxedcode}
\ccppspecificend
}

The second argument to a tool initializer is a version string that unambiguously identifies an OpenMP runtime implementation.
This argument is useful to tool developers trying to debug a statically-linked executable that contains both a tool implementation and an OpenMP runtime implementation.
Knowing exactly what version of an OpenMP runtime is present in a binary may be helpful when diagnosing a problem, e.g., identifying an old runtime system that may be incompatible with a newer tool.

The third argument \code{ompt\_version} indicates the version of the OMPT interface supported by a runtime system.
The version of OMPT described by this document is 2.

The two principal duties of a tool initializer are looking up pointers to all OMPT interface functions that the tool uses and registering tool callbacks.
These two operations are described below.

\subsection{Looking up OMPT Interface Functions}
The first argument to a tool initializer is \code{lookup}---a callback that a tool must use to interrogate the runtime system to obtain pointers to all OMPT interface functions.
The type signature for \code{lookup} is:

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef ompt_interface_fn_t (*ompt_function_lookup_t) (
  const char * \plc{interface_function_name}
);
\end{boxedcode}
\ccppspecificend
}

\noindent
The \code{lookup} callback is necessary because, when the OpenMP runtime is dynamically loaded by a shared library, the OMPT interface functions provided by the library may not be visible to a preloaded tool.
Within a tool, one uses \code{lookup} to obtain function pointers to each function in the OMPT interface.
All functions in the OMPT interface are marked with \code{OMPT\_API}.
These functions should not be global symbols in an OpenMP runtime implementation to avoid tempting tool developers to call them directly. 

The following example shows how to use the \code{lookup} function to obtain a pointer to the OMPT interface function \code{ompt\_get\_thread\_id}:

\vbox{
\ccppspecificstart
\begin{boxedcode}
ompt_interface_fn_t ompt_get_thread_id_fn =
                        lookup("ompt_get_thread_id");
\end{boxedcode}
\ccppspecificend
}

Other functions in the OMPT interface may be looked up analogously.
If a named function is not available in an OpenMP runtime's implementation of OMPT, \code{lookup} will return \code{NULL}.

\subsection{Registering Callbacks} 
Tools register callbacks to receive notification of various events that occur as an OpenMP program executes by using the OMPT interface function \code{ompt\_set\_callback}.

\vbox{
\ccppspecificstart
\begin{boxedcode}
OMPT_API int ompt_set_callback(
  ompt_event_t \plc{event}, 
  ompt_callback_t \plc{callback}
);
\end{boxedcode}
\ccppspecificend
}

\begin{table}
\centering
\begin{tabular}{|l|l|}
\hline
return code & meaning \\\hline
0 & callback registration error (e.g., callbacks cannot be registered at this time).\\\hline
1 & event may occur; no callback is possible\\\hline
2 & event will never occur in runtime\\\hline
3 & event may occur; callback invoked when convenient\\\hline
4 & event may occur; callback always invoked when event occurs\\\hline
\end{tabular}
\vspace{1ex}
\caption{Meaning of return codes for \code{ompt\_set\_callback}.}
\label{table:ToolsSupport_set_rc}
\end{table}

\noindent
The  function \code{ompt\_set\_callback} may only be called within the implementation of a tool's initializer.
The possible return codes for \code{ompt\_set\_callback} and their meaning is shown in Table~\ref{table:ToolsSupport_set_rc}.
Registration of supported callbacks may fail if this function is called outside a tool's initializer.
The \code{ompt\_callback\_t} type for a callback does not reflect the actual signature of the callback; OMPT uses this generic type to avoid the need to declare a separate registration function for each actual callback type.

The OMPT interface function \code{ompt\_get\_callback} may be called at any time to determine whether a callback has been registered or not. 

\vbox{
\ccppspecificstart
\begin{boxedcode}
OMPT_API int ompt_get_callback(
  ompt_event_t \plc{event}, 
  ompt_callback_t * \plc{callback}
);
\end{boxedcode}
\ccppspecificend
}

\noindent
If a callback has been registered, \code{ompt\_get\_callback} will return 1 and set \code{callback} to the address of the callback function; otherwise \code{ompt\_get\_callback} will return 0.



\section{OMPT Data Types}
\label{sec:data}

\littleheader{Thread Identifier}
\index{Thread Identifier}

Each OpenMP thread  has an associated identifier of type \verb|ompt_thread_id_t|. 
\begin{comment}
\begin{quote}
\begin{verbatim}
typedef uint64_t ompt_thread_id_t;
\end{verbatim}
\end{quote}
\end{comment}
  A thread's identifier is assigned when the thread is created. 
  Identifiers assigned to threads on each device are unique from the time an OpenMP runtime is initialized until it is shut down.
  A thread identifier can be retrieved
  on demand by invoking the  \verb|ompt_get_thread_id|   
  function (described in Section~\ref{sec:thread-inquiry}).
  Tools should not assume that \verb|ompt_thread_id_t| values are small or densely allocated. 
  The value \verb|ompt_thread_id_none| is reserved to indicate an invalid thread id.

\littleheader{Parallel Region Identifiers}
\index{Parallel Region Identifiers}
Each OpenMP parallel region has an associated identifier of type
\verb|ompt_parallel_id_t|. 
\begin{comment}
\begin{quote}
\begin{verbatim}
typedef uint64_t ompt_parallel_id_t;
\end{verbatim}
\end{quote}
\end{comment}
\noindent
  A parallel region's identifier is assigned
  when the region is created.  Identifiers assigned to parallel regions on each device are unique from the time an 
  OpenMP runtime is initialized until it is shut down. 
  A parallel region identifer can be retrieved for an enclosing parallel region
  on demand using the function \verb|ompt_get_parallel_info|  (described in Section~\ref{sec:parallel-inquiry}).
  Tools should not assume that \verb|ompt_parallel_id_t| values are small or densely allocated.
  The value \verb|ompt_parallel_id_none| is reserved to indicate an invalid parallel id.
 
 
\littleheader{Task Region Identifiers}
\index{Task Region Identifiers}
Each OpenMP task has an associated identifier of type
\verb|ompt_task_id_t|. Task identifiers are assigned to
initial, implicit, explicit, and target tasks.
\begin{comment}
\begin{quote}
\begin{verbatim}
typedef uint64_t ompt_task_id_t;
\end{verbatim}
\end{quote}
\end{comment} 
  A task's identifier is assigned
  when the task is created. 
  Identifiers assigned to tasks on each device are unique from the time an 
  OpenMP runtime is initialized until it is shut down. 
  A task's identifier can be retrieved
  on demand by invoking the \verb|ompt_get_task_info|  function (described in Section~\ref{sec:task-region}).
  Tools should not assume that \verb|ompt_task_id_t| values are small or densely allocated. 
  The value \verb|ompt_task_id_none| is reserved to indicate an invalid task identifier.
  
\littleheader{Target Region and Operation Identifiers}
\index{Target Region and Operation Identifiers}
Each OpenMP target region and target operation has an associated identifier of type \verb|ompt_target_id_t|. 
A unique target identifier is assigned on the host each time an instance of a target construct is encountered.
Each operation within a target region, e.g., transferring data to/from a device or launching a kernel launch 
on a device, is also assigned a unique target identifier. 
Identifiers assigned to target regions or operations 
are unique from the time an OpenMP runtime is initialized until it is shut down. 
The current target region and operation identifiers can be retrieved by invoking the \verb|ompt_get_target_info| function (described in Section~\ref{sec:target-region}).
Tools should not assume that \verb|ompt_target_id_t| values are small or densely allocated. 
The value \verb|ompt_target_id_none| is reserved to indicate an invalid target identifier. 
The value \verb|ompt_target_id_none| will be returned for (a) the target region identifier if \verb|ompt_get_target_info| is invoked outside a target region and (b) the target operation identifier if \verb|ompt_get_target_info| is invoked while no target operation is in progress.

\littleheader{Wait Identifiers}
\index{Wait Identifiers}

Each thread instance maintains a {\em wait identifier} of type \verb|ompt_wait_id_t|. 
When a task executing on a thread is waiting for something, the thread's wait identifer indicates what the thread is awaiting. 
A wait identifier may represent a critical section {\em name}, a lock,  a program variable accessed in an atomic region, or a synchronization object internal to an OpenMP runtime implementation. 
\begin{comment}
\begin{quote}
\begin{verbatim}
typedef uint64_t ompt_wait_id_t;
\end{verbatim}
\end{quote}
\end{comment}
A thread's wait identifier can be retrieved on demand by invoking the \verb|ompt_get_state| function (described in Section~\ref{sec:thread-inquiry}).
Tools should not assume that \verb|ompt_wait_id_t| values are small or densely allocated. 
When a thread is not in a wait state, a thread's wait identifier has an undefined value.
%%? Does that mean that the value is undefined and cannot sensibley be read, or that it has a specific value which we have
%%? defined somewhere, whose name is (something like) ompt_wait_id_undefined  ?
%%johnmc says: a wait_id typically is set to the address of a lock on which you are spinning. If you aren't spinning on a lock, this value is undefined.
%%             we could zero it out, but that would cost more.
 
\littleheader{Frames}
\index{Frames}

When executing an OpenMP program, at times procedure frames from the OpenMP runtime appear on the call stack between procedure frames for user code.
To enable a tool to determine whether each procedure frame on the call stack represents 
user code or an OpenMP runtime routine,
an implementation of the OpenMP API must maintains an instance of an \verb|ompt_frame_t| 
for each (possibly degenerate\footnote{
A task is considered degenerate if a call to the OpenMP runtime to create a parallel 
region or task does not create a new task. 
A degenerate task may arise when a parallel construct is encountered
in a parallel region and nested parallelism is not enabled or when an orphaned directive that would create a task is encountered outside a parallel region.
A degenerate task region may add runtime frames to the call stack before 
invoking an outlined function for the degenerate task and thus require an \code{ompt\_frame\_t} 
data structure.}) task that is active on a thread's stack.
To simplify discussion that follows, 
we omit the qualifier ``possibly degenerate'' each time we use the term {\em task}.

  Each initial, implicit, explicit, or target task maintains an \verb|ompt_frame_t| data structure
  that contains a pair of pointers.   
  
\vbox{    
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_frame_s \{\\
  void * \plc{exit_frame};  /* runtime frame that calls user code */
  void * \plc{enter_frame}; /* user frame that calls the runtime  */
\} ompt_frame_t;
\end{boxedcode}
\ccppspecificend
}

\noindent
An \verb|ompt_frame_t|'s  lifetime begins when a task  is
created and ends when the task is destroyed.  Tools should not assume that a frame structure remains at a constant location in memory
throughout a task's lifetime.
A frame object is passed to some callbacks; it can also be retrieved
asynchronously
by invoking the \verb|ompt_get_task_info|  function (described in Section~\ref{sec:task-region}) in a signal handler.
A task's frame object contains two fields: \code{exit\_frame} and \code{enter\_frame}.

The \code{exit\_frame} field of a task's frame object 
is set just before the task invokes an outlined function to begin execution 
of user code. 
The field contains the canonical frame address of the procedure that invoked the outlined function. 
For compilers that generate code where the master thread for a parallel region invokes an 
outlined procedure directly, 
\code{exit\_frame} will contain the canonical frame address of a procedure containing  user code 
that belongs to the enclosing task.
The value of \code{exit\_frame} is \code{NULL} in a task's frame object until just 
before the task calls an outlined function to begin execution. 

The \code{enter\_frame} field of a task's frame object is set each time the task re-enters the 
runtime to create a new implicit, explicit, or target task. When a task invokes an entry point in the
OpenMP runtime to create a task,
the \code{enter\_frame} field of the task's frame object will be set to 
the canonical frame address of the user function that invoked the runtime.
The value of \code{enter\_frame} is set when a task enters the OpenMP runtime 
and cleared before the OpenMP runtime returns control to the task.

\begin{table}
\begin{center}
\begin{tabular}{|p{1in}|p{2in}|p{2in}|}
\hline
\code{exit\_frame} / \code{enter\_frame} 	& \code{enter\_frame} is \code{NULL}										& \code{enter\_frame} is defined \\\hline\hline
\code{exit\_frame} is \code{NULL} & case 1)  initial task in user code case 2) task that is created but not yet scheduled &  task entered the runtime to schedule an implicit, explicit, or target task \\\hline
\code{exit\_frame} is defined 	& non-initial task in (or soon to be in) user code							& non-initial task entered the runtime and scheduled an implicit, explicit, or target task\\\hline
\end{tabular}
\vspace{1ex}
\end{center}
\caption{Meaning of various values for \code{exit\_frame} and \code{enter\_frame}.}
\label{tab:frame}
\end{table}

\noindent
Table~\ref{tab:frame} describes the meaning of this structure with various values.
In the presence of nested parallelism, a tool may observe a sequence of \verb|ompt_frame_t| records for a thread. Appendix~\ref{app:frame} discusses  an example that illustrates the use of \verb|ompt_frame_t| records with nested parallelism.

\paragraph{Advice to tool implementers:} A monitoring tool using
      asynchronous sampling can observe values of 
      \verb|exit_frame| and \verb|enter_frame| at inconvenient times. 
      Tools must be prepared to observe and handle frame exit and reenter values that have not yet been set or reset as the program enters or leaves the runtime. 



% This is the end of ch5-toolsSupport.tex
