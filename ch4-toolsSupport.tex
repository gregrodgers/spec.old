% This is ch4-toolsSupport.tex of the OpenMP specification.
% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%

\newcommand{\ompttype}[1]{\subsection*{#1}}  % section 4.5.7
\newcommand{\omptcallbacksignature}[1]{\subsubsection{#1}}  % section 4.8.2
\newcommand{\omptruntimeentrypoint}[1]{\subsubsection{#1}}  % sections 4.9.*
\newcommand{\ompteventswithoutdirectives}[1]{\subsection{#1}} % section 4.6

\chapter{Tool Support}
\index{Tools Support}
\label{chap:ToolsSupport}

The OpenMP API includes support for
runtime tools running in the same
address space as the OpenMP program through the OpenMP Tools Interface (OMPT).
This typically includes, but is not limited to performance analysis and correctness tools.
The interface is split into two subparts, a tracing interface that can be used to record
series of events in the system, and a callback interface that can be used to register
callbacks for specific events.

In addition to the specific events described in previous chapters alongside the OpenMP
constructs the refer to, this interface also includes dedicated functionality to bootstrap
tools, as well as for tools to query information from the OpenMP implementation. This
dedicated functionality is described in the following chapter.

In particular,
the chapter first explains if and how an implementation of
the OpenMP API will attempt to register a tool prior to initializing the 
OpenMP implementation and
how a registered tool will use the OMPT interface to initialize tool state maintained by
an implementation of the OpenMP API.
It concludes with a description of data types
used to identify entities managed by an OpenMP runtime and to interpret the
call stack of an OpenMP thread.

\section{Activating a Tool}
Activating a tool, that is, the procedure necessary to use a tool during the
execution of an OpenMP application, is a five step hand-shake process: 

\begin{enumerate}

\item Before
the initialization of the OpenMP implementation, the tools makes itself available by
providing an initialization routine using a known-symbol

\item The OpenMP
implementation during its initialization, detects the tool and activates by calling
the function with the known symbol

\item The tool registers itself by returning 
two initialization function, one to register a tracing tool and one to register a tool
utilizing the callback interface.

\item Immediately after its complete initialization the OpenMP implementation
executes the tool
initialization function

\item The tool uses this invocation to initialize
itself and setup its state as well as register the needed event callbacks. 

\end{enumerate}

After these steps
are completed, the tool is activated for the rest of the execution of the OpenMP
application.
%
%
%
%, binding pointers to OMPT interface functions 
%in the tool, and registering tool callbacks for OpenMP events. 
%Finally, to understand what information dynamic measurements might yield
%about thread states and implementations of mutual exclusion, a tool can
%enumerate the thread states and implementations of mutual exclusion 
%that a particular OpenMP implementation implementation employs.
%The following subsections explain each of these steps in turn.

\subsection{Step 1: Tool Availability}
\index{tool availability}
\label{sec:ToolsSupport_Available}

In order to be available during the execution of an application, a tool provides
an implementation a function using the name \code{ompt\_tool}. The mechanism
of how this is done is left to the implementation of the tool and can be system
specific. Typical examples are the static linking of a library containing this
function or the dynamic preloading of a dynamically linked library containing
this function.

Since only one tool-provided definition of \code{ompt\_tool} will be seen by an OpenMP implementation, only one tool may make itself available.


\subsection{Step 2: Tool Detection}
\index{tool detection}
\label{sec:ToolsSupport_Detection}

Once an OpenMP implementation initializes itself, it triggers the process to check for and, possibly, include a tool in the execution of an application. For this, it will first check if tool support is enabled by the user by examining the \plc{tool-var} ICV. If the
If the value of this ICV is \code{enabled} (when an OpenMP implementation begins to initialize itself), the OpenMP implementation 
searches if a tool is available by checking if 
%the OpenMP implementation will attempt to register a tool by first 
%determining if
%an implementation of the 
function \code{ompt\_tool} exists in a program's address space or within any of the dynamic libraries specified by the ICV \plc{ompt\_librararies\_list}.



If the value of \plc{tool-var} is \code{disabled}, an OpenMP 
implementation will neither check for the existence of an implementation of
\code{ompt\_tool} in the address space nor try to call any that might exist.

For any separate OpenMP implementation initialized later, for example, after a process fork or for accelerators that maintain
their own OpenMP runtime, this process repeats and the OpenMP API in the new process will call \code{ompt\_tool}
under the same conditions as it would for any process.


\subsection{Step 3: Tool Registration}
\index{tool registration}
\label{sec:ToolsSupport_Registration}

As part of the call to a detected code{ompt\_tool} function, the OpenMP runtime passes
a lookup function of type \code{ompt\_function\_lookup\_t} (described in Section~\ref{ompt_function_lookup_t}),
which allows a tool to find all entry points into the OMPT interface. A tool should store the pointer for
future use. Further, the OpenMP implementation provides versioning information.

Once called, the tool can use the function with the known symbol  \code{ompt\_tool} to
return two pointers to two functions with type signature 
\code{ompt\_initialize\_fn\_t} (described in  Section~\ref{sec:ompt_initialize_fn_t}) and
\code{ompt\_initialize\_trace\_fn\_t} (described in  Section~\ref{sec:ompt_initialize_trace_fn_t}).
Each of the returned function pointers
can either be \code{NULL}, if the tool (for example, after checking the OpenMP environment
or after verifying versioning information) 
decides to not register itself, or be a pointer to the tool's initialization function, either using 
the tracing interface or the callback interface.

\subsection{Step 4: Tool Invocation}
\index{tool invocation}
\label{sec:tool-invocation}

If one of the values returned by the tool is a non-\code{NULL} pointer to a tool initializer function, 
the runtime will call this function immediately after the runtime fully initializes itself, but
%The initializer must be called 
before beginning execution of any OpenMP construct or completing any execution 
environment routine invocation. If both are returned, the trace interface is preferred.

If both pointers are \code{NULL}, the search continues down the list of libraries identified in Step 2.

\subsection{Step 5: Tool Initialization}
\index{tool initialization}
\label{sec:tool-initialize}

Once called by the OpenMP implementation, the tool initialization function completes
the tool's initialization, which has to include the registration of callback to events triggered
by OpenMP directives, as described in Section~\ref{directives}. Further, tools typically
query the capabilities of the OpenMP runtime in order to determine the capabilities they can
rely on and they bind pointers to all OMPT interface functions that the tool uses. Note,
while the registration of callbacks has to be done during the initialization, the latter two items
can be done at any time (although doing them during initialization is likely to be the most
efficient option). 

%and registering tool callbacks. These
%two operations are described in the next two sections.

\section{Initialization Procedure of the Tracing Interfaces}
\index{tool trace initialization tasks}
\label{sec:tool-trace-initialize-tasks}

TODO JOHN

\section{Initialization Procedure of the Callback Interfaces}
\index{tool cb initialization tasks}
\label{sec:tool-cb-initialize-tasks}

TODO MARTIN

Tools typically execute the following three tasks during their initialization: binding of OMPT interface function, registering callbacks, and determining OMPT capabilities. These tasks are described in more detail below.

\subsection{Binding OMPT Interface Functions}
\label{sec:ToolsSupport_bind}

OMPT runtime functions are not directly exposed in the OpenMP runtime API to avoid their usage as application codes. Instead, OpenMP implementation provides a lookup function as part of the invocation of the \code{ompt\_tool} function. This function is of
type~\code{ompt\_function\_lookup\_t} and allows the translation of an OMPT runtime routine based on its name.

Tools should, during initialization, query all OMPT runtime functions they will use during their runtime and store that information for further use. While this is not required, extracting all these lookups at startup is useful and efficient.
%The first duty of a tool initializer is binding pointers to the 
%an OpenMP implementation's OMPT interface functions.
Table~\ref{table:host-ompt-interface-functions} 
indicates functions in the host implementation of the 
OMPT interface of an OpenMP runtime and their
type signatures.

\begin{table}
\begin{tabular}{ll}\hline
Entry Point String Name & Type signature\\\hline\hline
\code{``ompt\_enumerate\_states''}  & \code{ompt\_enumerate\_states\_t}\\
\code{``ompt\_enumerate\_mutex\_kinds''} & \code{ompt\_enumerate\_mutex\_kinds\_t}\\
\code{``ompt\_set\_callback''} & \code{ompt\_set\_callback\_t}\\
\code{``ompt\_get\_callback''} & \code{ompt\_get\_callback\_t}\\
\code{``ompt\_get\_thread\_data''} & \code{ompt\_get\_thread\_data\_t}\\
\code{``ompt\_get\_state''} & \code{ompt\_get\_state\_t}\\
\code{``ompt\_get\_parallel\_info''} & \code{ompt\_get\_parallel\_info\_t}\\
\code{``ompt\_get\_task\_info''} & \code{ompt\_get\_task\_info\_t}\\
\code{``ompt\_get\_num\_devices''} & \code{ompt\_get\_num\_devices\_t}\\
% \code{``ompt\_get\_device\_info''} & \code{ompt\_get\_device\_info\_t}\\
\code{``ompt\_get\_device\_id''} & \code{ompt\_get\_device\_id\_t}\\\hline
\end{tabular}
\vskip 1ex
\caption{OMPT callback interface entry point names and their type signatures.}
\label{table:ompt-callback-interface-functions} 
\end{table}

The following example shows how to use the \plc{lookup} callback 
passed to a tool's initializer to obtain a pointer to the 
OMPT interface function \code{ompt\_get\_thread\_id}:




\vbox{
\ccppspecificstart
\begin{boxedcode}
ompt_interface_fn_t \plc{ompt_get_thread_id_fn} =
                        \plc{lookup}("ompt_get_thread_id");
\end{boxedcode}
\ccppspecificend
}

Other routines in the OMPT interface may be looked up analogously.
If a particular OMPT interface function is not supported by 
an OpenMP implementation, \plc{lookup} will return \code{NULL} when 
invoked with the function's name as an argument. 

\subsection{Registering Tool Callbacks}
\index{event callback registration}
\label{sec:ToolsSupport_callback_registration}

Tools register callbacks to receive notification of events that occur as
an OpenMP program executes by invoking the runtime callback known by the name
\code{ompt\_set\_callback}.
The \code{ompt\_set\_callback} routine may only be called within
the implementation of a tool's initializer.  The possible return
codes for \code{ompt\_set\_callback} and their meaning is shown in
Table~\ref{table:ToolsSupport_set_rc}.  Registration of supported
callbacks may fail, returning 0, if this routine is called outside
a tool's initializer.  

The \code{ompt\_callback\_t} type for a callback to be registered 
does not reflect the actual signature of the callback; 
OMPT uses this generic type
to avoid the need to declare a separate registration function for each actual callback type.
The valid return codes for each event are listed in Table~\ref{table:valid_rc}.
Some events always need to invoke the registered callback.
For other events, its implementation defined whether they invoke the registered
callback never, sometimes, or always.
The return code makes this implementation defined behaviour machine readable to
the connected tool.

\begin{table}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{lp{3em}p{3em}p{3em}p{3em}}
                                & \rot{event may occur; no callback is possible}
                                & \rot{event will never occur in runtime}
                                & \rot{event may occur; callback invoked when convenient}
                                & \rot{event may occur; callback always invoked when event occurs}\\
                                \midrule
ompt\_event\_thread\_begin          &   &   &   & * \\
ompt\_event\_thread\_end            &   &   &   & * \\
ompt\_event\_parallel\_begin        &   &   &   & * \\
ompt\_event\_parallel\_end          &   &   &   & * \\
ompt\_event\_task\_create           &   &   &   & * \\
ompt\_event\_task\_schedule         &   &   &   & * \\
ompt\_event\_implicit\_task         &   &   &   & * \\
ompt\_event\_target                 &   &   &   & * \\
ompt\_event\_target\_data           &   &   &   & * \\
ompt\_event\_target\_submit         &   &   &   & * \\
ompt\_event\_tcontrol               &   &   &   & * \\
ompt\_event\_runtime\_shutdown      &   &   &   & * \\
ompt\_event\_idle                   & * & * & * & * \\
ompt\_event\_sync\_region\_wait     & * & * & * & * \\
ompt\_event\_mutex\_release         & * & * & * & * \\
ompt\_event\_task\_dependences      & * & * & * & * \\
ompt\_event\_task\_dependence\_pair & * & * & * & * \\
ompt\_event\_worksharing            & * & * & * & * \\
ompt\_event\_master                 & * & * & * & * \\
ompt\_event\_target\_data\_map      & * & * & * & * \\
ompt\_event\_sync\_region           & * & * & * & * \\
ompt\_event\_init\_lock             & * & * & * & * \\
ompt\_event\_destroy\_lock          & * & * & * & * \\
ompt\_event\_mutex\_acquire         & * & * & * & * \\
ompt\_event\_mutex\_acquired        & * & * & * & * \\
ompt\_event\_nested\_lock           & * & * & * & * \\
ompt\_event\_cancel           & * & * & * & * \\
ompt\_event\_flush                  & * & * & * & * \\
\bottomrule
\end{tabular}
\caption{Valid return codes of \code{ompt\_set\_callback} for each input event argument.}
\label{table:valid_rc}
\end{table}

\crossreferences
\begin{itemize}
\item \code{ompt\_event\_t} enumeration type, see
\specref{sec:ompt_event_t}.
\end{itemize}

\clearpage

\subsection{Enumerating States and Implementations}
Using the OMPT interface, a tool may interrogate an OpenMP implementation to 
determine what thread states it supports and what mechanisms it employs to 
implement mutual exclusion for various purposes.

\section{Tracing Device Activity}
\label{sec:tracing-device-activity}

Target devices typically operate asynchronously with respect to a
host. It may not be practical or possible to make event callbacks
on a target device. These characteristics motivate the design of a
performance monitoring interface for target devices where:

\begin{itemize}
\item the target device records events that occur during its execution in a trace buffer,
\item when a trace buffer fills on a device (or it is otherwise useful to flush the buffer),  the device provides it to a tool on the host, by invoking a tool-supplied callback function to process and empty the buffer,
\item when the target device needs a new trace buffer, it invokes a tool-supplied callback function to request a new buffer,
\end{itemize}


Section~\ref{sec:ompt_set_trace_ompt_t}  describes how to enable or disable
tracing on a target device for specific OMPT events.
Section~\ref{sec:ompt_set_trace_native_t}  describes how to enable or
disable tracing on a target device for specific native events.
The Sections~\ref{sec:ompt_start_trace_t}, \ref{sec:ompt_pause_trace_t} 
and \ref{sec:ompt_stop_trace_t}  describe how to start, pause and
stop event tracing on a device.

Some functions in the target device tracing control API described
in this section are marked with \code{OMPT\_TARG\_API}. These represent
function pointers that should be obtained from a target device by
invoking the \code{lookup} function (provided by the target  as a
return value to function \code{ompt\_get\_device\_info}) and
passing it the name of the function of interest.


\section{Data Types}
\label{sec:data}
\subsection{Thread States}
\label{sec:thread-states}

To enable a tool to understand the behavior of an executing program, 
an OpenMP implementation maintains a state for each thread. 
The state maintained for a thread is an
approximation of the thread's instantaneous state. 

\vbox{
\ccppspecificstart
A thread's state will be one of the values of the  
enumeration type \code{omp\_state\_t} or
an implementation-defined state value of 512 or higher. 
Thread states in the enumeration fall into several classes: 
work, barrier wait, task wait, mutex wait, target wait, 
and miscellaneous. 

\begin{boxedcode}
typedef enum omp_state_t \{
  omp_state_work_serial            = 0x000,
  omp_state_work_parallel          = 0x001,
  omp_state_work_reduction         = 0x002,

  omp_state_wait_barrier           = 0x010,
  omp_state_wait_barrier_implicit  = 0x011,
  omp_state_wait_barrier_explicit  = 0x012,

  omp_state_wait_taskwait          = 0x020,
  omp_state_wait_taskgroup         = 0x021,

  omp_state_wait_mutex             = 0x040,
  omp_state_wait_lock              = 0x041,
  omp_state_wait_critical          = 0x042,
  omp_state_wait_atomic            = 0x043,
  omp_state_wait_ordered           = 0x044,

  omp_state_wait_target            = 0x080,
  omp_state_wait_target_data       = 0x081,
  omp_state_wait_target_update     = 0x082,

  omp_state_idle                   = 0x100, 
  omp_state_overhead               = 0x101, 
  omp_state_undefined              = 0x102
\} omp_state_t;
\end{boxedcode}
\ccppspecificend
}


A tool can query the OpenMP state of a thread at any time. 
If a tool queries the state of a thread that is not associated 
with OpenMP, the implementation reports the state as \code{omp\_state\_undefined}.

\begin{comment}
For each OpenMP thread the runtime maintains not only a state but also an \code{ompt\_wait\_id\_t}
identifier.  When a thread is waiting for a lock, critical region,
ordered, or atomic, and the thread is in a wait
state, then 
the thread's \code{wait\_id} field identifies the lock, critical construct, ordered construct, atomic construct, or internal variable
upon which the
thread is waiting. The semantics of the values used for a \code{wait\_id} are implementation defined.
A thread's \code{wait\_id} is undefined if the thread
is not in a wait state.
\end{comment}

Some values of the enumeration type \code{omp\_state\_t} are used by all 
OpenMP implementations, 
e.g., \code{omp\_state\_work\_serial}, 
which indicates that a thread is executing in a serial region, and  
\code{omp\_state\_work\_parallel}, 
which indicates that a thread is executing in a parallel region.
Other values of the enumeration type describe a thread's state at 
different levels of specificity. 
For instance, an OpenMP implementation may use 
the state \code{omp\_state\_wait\_barrier}  to represent all 
waiting at barriers; or it may differentiate between waiting at 
implicit and explicit barriers by using the pair of states
\code{omp\_state\_wait\_barrier\_implicit} and 
\code{omp\_state\_wait\_barrier\_explicit}. 

For states that represent waiting, an OpenMP implementation has the 
choice of transitioning a thread to such states early or late.
For instance, when an OpenMP thread is trying to acquire a lock,
there are several points at which an OpenMP implementation
transition the thread to the \code{omp\_state\_wait\_lock} state.
One implementation may transition the thread to the state 
early before the thread attempts to acquire a
lock. Another implementation may transition the thread to the state 
late, only if the thread begins to spin or
block to wait for an unavailable lock. A third implementation
may transition the thread to the state even later, e.g., only
after the thread waits for a significant amount of time. 

The following describes the classes and the states in each class.
\subsubsection{Work States}
An OpenMP implementation reports a thread in a work state 
when the thread is performing serial work, parallel work, or a reduction.

\begin{description}

\item \code{omp\_state\_work\_serial} 

  The thread is executing code outside all parallel regions. 

\item \code{omp\_state\_work\_parallel} 

  The thread is executing code within the scope of a parallel region construct.

\sloppy
\item \code{omp\_state\_work\_reduction} 
 
  The thread is combining partial reduction results from threads in its team. 
  An OpenMP implementation  
  might never report a thread in this state; a thread
  combining partial reduction results may have its state reported as
  \code{omp\_state\_work\_parallel} or \code{omp\_state\_overhead}.

\end{description}


\subsubsection{Barrier Wait States}

An OpenMP implementation reports that a thread is in a barrier wait state 
when the thread is is awaiting completion of a barrier.


\begin{description}

  \item \code{omp\_state\_wait\_barrier} 
  
  \sloppy
  The thread is waiting at either an implicit or explicit barrier.
  A thread may enter this state
  early, when the thread encounters a barrier, or late, when the
  thread begins to wait at the barrier. An implementation may never report a thread in this state; instead, a thread may have its state reported
  as \code{omp\_state\_wait\_barrier\_implicit}  or \code{omp\_state\_wait\_barrier\_explicit}, as appropriate.
  
  \item \code{omp\_state\_wait\_barrier\_implicit} 
  
  \sloppy
  The thread is waiting at an implicit barrier in a parallel region. 
  A  thread may enter this state
  early, when the thread encounters a barrier, or late, when the
  thread begins to wait at the barrier.
  An OpenMP implementation may report \code{omp\_state\_wait\_barrier} 
  for implicit barriers.
  
  \item \code{omp\_state\_wait\_barrier\_explicit} 

  The thread is waiting at an explicit barrier  in a parallel region. 
  A thread may enter this state
  early, when the thread encounters a barrier, or late, when the
  thread begins to wait at the barrier.
  An implementation may report \code{omp\_state\_wait\_barrier} 
  for explicit barriers.
  
\end{description}
  
\subsubsection{Task Wait States}

\begin{description}

\item \code{omp\_state\_wait\_taskwait} 

  The thread is waiting at a taskwait construct. A 
  thread may enter this state early, when the
  thread encounters a taskwait construct, or late, when the thread
  begins to wait for an uncompleted task.

\item \code{omp\_state\_wait\_taskgroup} 

  The thread is waiting at the end of a taskgroup construct. A 
  thread may enter this state early, when the
  thread encounters the end of a taskgroup construct, or late, when the thread
  begins to wait for an uncompleted task.

\end{description}


\subsubsection{Mutex Wait States}

OpenMP provides several mechanisms that enforce mutual exclusion:
locks as well as critical, atomic, and ordered sections.  This
grouping contains all states used to indicate that a thread is is
awaiting exclusive access to a lock, critical section, variable,
or ordered section.

An OpenMP implementation may report a thread waiting for any type
of mutual exclusion using either a state that precisely identifies
the type of mutual exclusion, or  a more generic state such as
\code{omp\_state\_wait\_mutex} or \code{omp\_state\_wait\_lock}.  This
flexibility may significantly simplify the maintenance of states
associated with mutual exclusion in the runtime when various
mechanisms for mutual exclusion rely on a common implementation,
e.g., locks.

% Section~\ref{sec:wait-identifier} describes how each thread maintains a wait identifier to identify what a thread is awaiting. Before a thread enters any state indicating that it is awaiting mutual exclusion, the OpenMP runtime will update the thread's wait identifier to indicate what the thread is awaiting. 

\begin{description}

\item \code{omp\_state\_wait\_mutex}

  The thread is waiting for a mutex of an unspecified type. A 
  thread may enter this state early, when a thread encounters a lock acquisition or a region that requires mutual exclusion, or late, when the thread begins to wait.

\item \code{omp\_state\_wait\_lock}

  The thread is waiting for a  lock  or nest lock. A 
  thread may enter this state early, when a thread
  encounters a lock \code{set} routine, or late, when the thread
  begins to wait for a lock.

\item \code{omp\_state\_wait\_critical} 

  The thread is waiting to enter a critical region. A 
  thread may enter this state early, when the
  thread encounters a critical construct, or late, when the thread
  begins to wait to enter the critical region. 


\item \code{omp\_state\_wait\_atomic} 

  The thread is waiting to enter an atomic region. A 
  thread may enter this state early, when the thread
  encounters an atomic construct, or late, when the thread begins
  to wait to enter the atomic region. 
  An implementation may opt not to report
  this state when using atomic hardware instructions that support non-blocking atomic implementations.
  

\item \code{omp\_state\_wait\_ordered} 

  The thread is waiting to enter an ordered region. A 
  thread may enter this state early, when the thread encounters
  an ordered construct, or late, when the thread begins
  to wait to enter the ordered region. 
  
\end{description}
  
\subsubsection{Target Wait States}

\begin{description}

\item \code{omp\_state\_wait\_target} 

  The thread is waiting for a target region to complete.
  
\item \code{omp\_state\_wait\_target\_data} 

  The thread is waiting for a target data mapping operation to complete. 
  An implementation may report \code{omp\_state\_wait\_target} 
  for target data constructs.

\item \code{omp\_state\_wait\_target\_update} 

  The thread is waiting for a target  update operation to complete. 
  An implementation may report \code{omp\_state\_wait\_target} 
  for target update constructs.

\end{description}


\subsubsection{Miscellaneous States}

\begin{description}
\item \code{omp\_state\_idle} 

  The thread is idle, waiting for work.

\item \code{omp\_state\_overhead} 

  A thread may be reported as being in the overhead state at any point while 
  executing within an OpenMP runtime, except while waiting indefinitely
  at a synchronization point.
%  e.g., while preparing to execute a parallel, task, or worksharing construct. 
  An OpenMP implementation report a thread's state as a work state for
  some or all of the time the thread spends in executing in the OpenMP runtime.

\item \code{omp\_state\_undefined} 

  This state is reserved for threads that are not user threads,
  initial threads, threads currently in an OpenMP team, or threads
  waiting to become part of an OpenMP team.

\end{description}

\subsection{Events}
\label{sec:ompt_event_t}

The following enumeration type indicates the integer codes used to identify 
OpenMP events when registering or querying callbacks associated with them.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_event_t \{
  ompt_event_thread_begin             = 1,
  ompt_event_thread_end               = 2,
  ompt_event_parallel_begin           = 3,
  ompt_event_parallel_end             = 4,
  ompt_event_task_create              = 5,
  ompt_event_task_schedule            = 6,
  ompt_event_implicit_task            = 7,
  ompt_event_target                   = 8,
  ompt_event_target_data              = 9,
  ompt_event_target_submit            = 10,
  ompt_event_tcontrol                 = 11,
  ompt_event_runtime_shutdown         = 12,
  ompt_event_idle                     = 13,
  ompt_event_sync_region_wait         = 14,
  ompt_event_mutex_release            = 15,
  ompt_event_task_dependences         = 16,
  ompt_event_task_dependence_pair     = 17,
  ompt_event_worksharing              = 18,
  ompt_event_master                   = 19,
  ompt_event_target_data_map          = 20,
  ompt_event_sync_region              = 21,
  ompt_event_init_lock                = 22,
  ompt_event_destroy_lock             = 23,
  ompt_event_mutex_acquire            = 24,
  ompt_event_mutex_acquired           = 25,
  ompt_event_nested_lock              = 26,
  ompt_event_flush                    = 27,
  ompt_event_device_initialize        = 28
  ompt_event_cancel                   = 29
\} ompt_event_t;
\end{boxedcode}
\ccppspecificend
}
\begin{targetRecord}
\subsection{Tracing Support}
\label{sec:ompt-records}

\subsubsection{Record Kind}
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_record_kind_e \{
  ompt_record_ompt               = 1,
  ompt_record_native             = 2,
  ompt_record_invalid            = 3
\} ompt_record_kind_t; 
\end{boxedcode}
\ccppspecificend
}

\subsubsection{Native Record Kind}
\label{sec:ompt_record_native_kind_t}

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_record_native_kind_e \{
  ompt_record_native_info  = 1,
  ompt_record_native_event = 2
\} ompt_record_native_kind_t;
\end{boxedcode}
\ccppspecificend
}

\subsubsection{Native Record Abstract Type}
\label{sec:ompt_record_native_abstract_t}

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_native_abstract_s \{
  ompt_record_native_class_t \plc{rclass};
  const char *\plc{type};
  ompt_device_time_t \plc{start\_time};
  ompt_device_time_t \plc{end\_time};
  ompt_hwid_t \plc{hwid};
\} ompt_record_native_abstract_t;
\end{boxedcode}
\ccppspecificend
}

\descr

A \code{ompt\_record\_native\_abstract\_t} record contains several
pieces of information that a tool can use to process a native record
that it may not fully understand. The record \code{rclass} field
indicates whether the record is informational
or represents an event; knowing this can help a tool determine
how to present the record. The record \code{type} field points to
a statically-allocated, immutable character string that provides
a meaningful name that a tool might want to use to describe the event
to a user. The \code{start\_time} and \code{end\_time} fields are
used to place an event in time. The times are relative to the device
clock. If an event has no associated \code{start\_time} and/or
\code{end\_time}, its value will be 
\code{ompt\_time\_none}. The hardware id field,
\code{hwid},  is used to indicate the location on the device where
the event occurred. A \code{hwid} may represent a hardware abstraction
such as a core or a hardware thread id. The meaning of a \code{hwid}
value for a device is defined by the implementer of the software
stack for the device. If there is no hardware abstraction associated 
with the record, the value of \code{hwid} 
will be \code{ompt\_hwid\_none}.

\subsubsection{Record Type}
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_ompt_s \{
  ompt_event_t \plc{type};
  ompt_target_time\_t \plc{time};
  ompt_id_t \plc{thread_id};
  ompt_id_t \plc{target_id};
  union \{
    ompt_record_thread_begin_t \plc{thread_begin};
    ompt_record_idle_t \plc{idle};
    ompt_record_parallel_begin_t \plc{parallel_begin};
    ompt_record_parallel_end_t \plc{parallel_end};
    ompt_record_task_create_t \plc{task_create};
    ompt_record_task_dependence_t \plc{task_dep};
    ompt_record_task_schedule_t \plc{task_sched};
    ompt_record_implicit_t \plc{implicit};
    ompt_record_sync_region_t \plc{sync_region};
    ompt_record_target_data_t \plc{data};
    ompt_record_target_data_map_t \plc{data_map};
    ompt_record_target_kernel_t \plc{kernel};
    ompt_record_init_lock_t \plc{lock_init};
    ompt_record_lock_destroy_t \plc{lock_destroy};
    ompt_record_mutex_acquire_t \plc{mutex_acquire};
    ompt_record_mutex_t \plc{mutex};
    ompt_record_nested_lock_t \plc{nested_lock};
    ompt_record_master_t \plc{master};
    ompt_record_worksharing_t \plc{worksharing};
    ompt_record_flush_t \plc{flush};
  \} \plc{record};
\} ompt_record_ompt_t;
\end{boxedcode}
\ccppspecificend
}

\end{targetRecord}

\subsection{Frames}
\index{Frames}

When executing an OpenMP program, at times procedure frames from
the OpenMP runtime appear on the call stack between procedure frames
for user code.  To enable a tool to determine whether each procedure
frame on the call stack represents user code or an OpenMP runtime
routine, an implementation of the OpenMP API must maintain an
instance of an \code{ompt\_frame\_t} for each 
task that has procedure frames on a thread's stack.  
A thread's stack is said to include a \emph{degenerate task} 
if it contains a sequence of one or more procedure 
frames from OpenMP runtime routines between a pair of frames for user
procedures that belong to the same
task.\footnote{A degenerate task may arise when a parallel
construct is encountered in a parallel region and nested parallelism
is not enabled or when an orphaned task directive 
is encountered outside a parallel region.  In such cases, the program
may invoke the OpenMP runtime and runtime procedure frames may remain
on the stack when the runtime 
invokes an outlined procedure.} 
An OpenMP implementation must
maintain an \code{ompt\_frame\_t} data structure 
for each initial, implicit, explicit, target, or degenerate task. 

\begin{comment}
The OpenMP API will maintain an
instance of an \code{ompt\_frame\_t} for each 
degenerate task as well. 
To simplify the following discussion, we omit the
qualifier ``possibly degenerate'' each time we use the term {\em
task}.
\end{comment}

An \code{ompt\_frame\_t} object for a task contains a pair of pointers:
\plc{enter\_frame}--the canonical frame address for the user frame that invoked the
OpenMP runtime system to create the task, and  
\plc{exit\_frame}--the canonical frame address for the frame that
invoked a user procedure for the task.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_frame_s \{\\
  void *\plc{exit_frame};
  void *\plc{enter_frame};
\} ompt_frame_t;
\end{boxedcode}
\ccppspecificend
}

An \code{ompt\_frame\_t}'s lifetime begins when a task is created
and ends when the task is destroyed. Tools should not assume that
a frame structure remains at a constant location in memory throughout
a task's lifetime. A task's frame object is passed to some callbacks; it
can also be retrieved asynchronously by invoking the
\code{ompt\_get\_task\_info} function (described in
Section~\ref{sec:ompt_get_task_info}) in a signal handler.

The value of \plc{exit\_frame} is \code{NULL} in a task's frame
object until just before an outlined procedure for the task is invoked.
When an outlined procedure for the task is invoked,
\plc{exit\_frame} is set to the canonical frame
address of the procedure that invokes the outlined procedure for the
task. 
The value of \plc{exit\_frame} is set to \code{NULL}
when the outlined procedure returns to the runtime, whether the task is finished or deferred.

The \plc{enter\_frame} field of a task's frame object is set each time the task re-enters the
runtime to create a new implicit, explicit, target or degenerate
task. When a task invokes an entry point in the
OpenMP runtime to create a task,
\plc{enter\_frame} of the task's frame object will be set to
the canonical frame address of the user function that invoked the runtime.
The value of \plc{enter\_frame} is cleared 
after the code for the invoked task returns, whether the task is finished or deferred.

\begin{table}
\begin{center}
\begin{tabular}{|p{1in}||p{2in}|p{2in}|}
\hline
\plc{exit\_frame} / \plc{enter\_frame} 	state & \plc{enter\_frame} is \code{NULL}										& \plc{enter\_frame} is defined \\
\hline
\hline
\plc{exit\_frame} is \code{NULL} & case 1)  initial task in user code\newline case 2) task that is created but not yet scheduled or already finished & initial task entered the runtime to schedule an implicit, explicit, or target task \\\hline
\plc{exit\_frame} is defined 	& non-initial task in (or soon to be
in) user code							&
non-initial task entered the runtime and scheduled an implicit,
explicit, target, or degenerate task\\
\hline
\end{tabular}
\vspace{1ex}
\end{center}
\caption{Meaning of various states of an \code{ompt\_frame\_t}
  record.}
\label{tab:frame}
\end{table}

Table~\ref{tab:frame} describes various states in which 
an \code{ompt\_frame\_t} object may be observed and their meaning.
In the presence of nested parallelism, a tool may
observe a sequence of \code{ompt\_frame\_t} records for a thread.
Appendix~\ref{app:frames} illustrates 
use of \code{ompt\_frame\_t} records with nested parallelism.

\littleheader{Advice to tool implementers:} 
A monitoring tool using asynchronous sampling can observe values
of \plc{exit\_frame} and \plc{enter\_frame} at inconvenient times.
Tools must be prepared to observe and handle frame exit and reenter
values that have not yet been set or reset as the program enters
or leaves the runtime.

\subsection{Miscellaneous Type Definitions}
\label{sec:ompt-types:misc}
This section describes miscellaneous types and enumerations used by the tool interface.

\ompttype{\code{ompt\_callback\_t}}
\label{sec:ompt_callback_t}

Pointers to tool callback functions with many different type
signatures are passed to the \code{ompt\_set\_callback} entry point and 
returned by the \code{ompt\_get\_callback} entry point. For convenience,
these entry points expect all type signatures to be cast to   
a dummy type \code{ompt\_callback\_t}.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_callback_t)(void);
\end{boxedcode}
\ccppspecificend
}

% ompt_id_t

\ompttype{\code{ompt\_id\_t}}
\label{sec:ompt_id_t} 
When tracing asynchronous activity on OpenMP devices, tools need identifiers to correlate target regions and operations initiated by the host with 
associated activities on a target device. In addition, tools need identifiers to refer to parallel regions and tasks that execute on a device.
OpenMP implementations use identifiers of type \code{ompt\_id\_t} type for each of these purposes. 
The value \code{ompt\_id\_none} is
reserved to indicate an invalid id.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef unsigned long long int ompt_id_t;
#define ompt_id_none (~0ULL)
\end{boxedcode}
\ccppspecificend
}

Identifiers created on each device must be unique from the time an OpenMP implementation is initialized until it is shut down.  
Specifically, this means that (1) identifiers for each target region and target operation instance initiated by the host device must be unique over time on the host,
and (2) identifiers for parallel and task region instances that execute on a device must be unique over time within that device.

Tools should not assume that \code{ompt\_id\_t} values are small or densely allocated. 

% ompt_data_t

\ompttype{\code{ompt\_data\_t}}
\label{sec:ompt_data_t} 
Threads, parallel regions, and task regions 
each have an associated data object of type \code{ompt\_data\_t} reserved for use by a tool.
When an OpenMP implementation creates a thread or an instance of a parallel or task region, 
it will initialize its associated \code{ompt\_data\_t} object with the value \code{ompt\_data\_none}. 

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef union ompt_data_u \{\\
  unsigned long long value; /* value under tool control   */
  void *ptr;                /* pointer under tool control */
\} ompt_data_t;

ompt_data_t ompt_data_none = \{.value=0\};         
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_get\_parallel\_info} inquiry function, see \specref{sec:ompt_get_parallel_info}.
\item \code{ompt\_get\_task\_info} inquiry function, see \specref{sec:ompt_get_task_info}.
\item \code{ompt\_get\_thread\_data} inquiry function, see \specref{sec:ompt_get_thread_data}.
\item \code{ompt\_thread\_begin\_callback\_t} callback type, see \specref{sec:ompt_thread_begin_callback_t}.
\item \code{ompt\_thread\_begin\_callback\_t} callback type, see \specref{sec:ompt_thread_begin_callback_t}.
\item \code{ompt\_parallel\_end\_callback\_t} callback type, see \specref{sec:ompt_parallel_end_callback_t}.
\item \code{ompt\_parallel\_end\_callback\_t} callback type, see \specref{sec:ompt_parallel_end_callback_t}.
\item \code{ompt\_task\_create\_callback\_t} callback type, see \specref{sec:ompt_task_create_callback_t}.
\item \code{ompt\_task\_dependencies\_callback\_t} callback type, see \specref{sec:ompt_task_dependencies_callback_t}.
\item \code{ompt\_task\_dependence\_callback\_t} callback type, see \specref{sec:ompt_task_dependence_callback_t}.
\item \code{ompt\_task\_schedule\_callback\_t} callback type, see \specref{sec:ompt_task_schedule_callback_t}.
\item \code{ompt\_task\_implicit\_callback\_t} callback type, see \specref{sec:ompt_task_implicit_callback_t}.
\item \code{ompt\_task\_sync\_region\_callback\_t} callback type, see \specref{sec:ompt_task_sync_region_callback_t}.
\item \code{ompt\_task\_master\_callback\_t} callback type, see \specref{sec:ompt_task_master_callback_t}.
\item \code{ompt\_task\_worksharing\_callback\_t} callback type, see \specref{sec:ompt_task_worksharing_callback_t}.
\item \code{ompt\_task\_target\_callback\_t} callback type, see \specref{sec:ompt_task_target_callback_t}.
\item \code{ompt\_flush\_callback\_t} callback type, see \specref{sec:ompt_flush_callback_t}.
\end{itemize}
\end{comment}

% ompt_wait_id_t

\ompttype{\code{ompt\_wait\_id\_t}}
\label{sec:ompt_wait_id_t} 
\index{Wait Identifier}

Each thread instance maintains a \emph{wait identifier} of type \code{ompt\_wait\_id\_t}.
When a task executing on a thread is waiting for mutual exclusion, the thread's wait identifer indicates what the thread is awaiting.
A wait identifier may represent a critical section {\em name}, a lock, a program variable accessed in an atomic region, or a synchronization object internal to an OpenMP implementation.
% A thread's wait identifier can be retrieved on demand by invoking the \code{ompt\_get\_state} function (described in Section~\ref{sec:ompt_get_state}).

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef unsigned long long int ompt_wait_id_t;
\end{boxedcode}
\ccppspecificend
}

When a thread is not in a wait state, the value of the thread's wait identifier is undefined.

Tools should not assume that \code{ompt\_wait\_id\_t} values are small or densely allocated.

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_get\_state} inquiry function, see \specref{sec:ompt_get_state}.
\item \code{ompt\_lock\_init\_callback\_t} callback type, see \specref{sec:ompt_lock_init_callback_t}.
\item \code{ompt\_lock\_destroy\_callback\_t} callback type, see \specref{sec:ompt_lock_destroy_callback_t}.
\item \code{ompt\_mutex\_acquire\_callback\_t} callback type, see \specref{sec:ompt_mutex_acquire_callback_t}.
\item \code{ompt\_mutex\_callback\_t} callback type, see \specref{sec:ompt_mutex_callback_t}.
\item \code{ompt\_nested\_lock\_callback\_t} callback type, see \specref{sec:ompt_nested_lock_callback_t}.
\item \code{ompt\_record\_lock\_init\_t} data type, see \specref{sec:ompt_record_lock_init_t}.
\item \code{ompt\_record\_lock\_destroy\_t} data type, see \specref{sec:ompt_record_lock_destroy_t}.
\item \code{ompt\_record\_mutex\_acquire\_t} data type, see \specref{sec:ompt_record_mutex_acquire_t}.
\item \code{ompt\_record\_mutex\_t} data type, see \specref{sec:ompt_record_mutex_t}.
\item \code{ompt\_record\_nested\_lock\_t} data type, see \specref{sec:ompt_record_nested_lock_t}.
\end{itemize}
\end{comment}

% ompt_device_t

\ompttype{\code{ompt\_device\_t}}
\label{sec:ompt_device_t} 
\code{ompt\_device\_t} is an opaque object representing a device.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void ompt_device_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_get\_time} inquiry function, see \specref{sec:ompt_get_time}.
\item \code{ompt\_translate\_time} inquiry function, see \specref{sec:ompt_translate_time}.
\item \code{ompt\_set\_trace\_ompt} tool function, see \specref{sec:ompt_set_trace_ompt}.
\item \code{ompt\_set\_trace\_native} tool function, see \specref{sec:ompt_set_trace_native}.
\item \code{ompt\_start\_trace} tool function, see \specref{sec:ompt_start_trace}.
\item \code{ompt\_pause\_trace} tool function, see \specref{sec:ompt_pause_trace}.
\item \code{ompt\_stop\_trace} tool function, see \specref{sec:ompt_stop_trace}.
\end{itemize}
\end{comment}

% ompt_device_time_t

\ompttype{\code{ompt\_device\_time\_t}}
\label{sec:ompt_device_time_t} 
\code{ompt\_device\_time\_t} is an opaque object representing a raw time value from a device.
\label{sec:ompt_time_none} 
\code{ompt\_time\_none} refers to an uknown or unspecified time.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef unsigned long long int ompt_device_time_t;
#define ompt_time_none (~0ULL)
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_get\_device\_time} inquiry function, see \specref{sec:ompt_get_device_time}.
\item \code{ompt\_translate\_time} inquiry function, see \specref{sec:ompt_translate_time}.
\item \code{ompt\_record\_native\_abstract\_t} data type, see \specref{sec:ompt_record_native_abstract_t}.
\item \code{ompt\_record\_target\_data\_t} data type, see \specref{sec:ompt_record_target_data_t}.
\item \code{ompt\_record\_target\_kernel\_t} data type, see \specref{sec:ompt_record_target_kernel_t}.
\item \code{ompt\_record\_ompt\_t} data type, see \specref{sec:ompt_record_ompt_t}.
\end{itemize}
\end{comment}

% ompt_buffer_t

\ompttype{\code{ompt\_buffer\_t}}
\label{sec:ompt_buffer_t} 
\code{ompt\_buffer\_t} is an opaque object handle for a target buffer.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void ompt_buffer_t; 
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_buffer\_request\_callback\_t} callback type, see \specref{sec:ompt_buffer_request_callback_t}.
\item \code{ompt\_buffer\_complete\_callback\_t} callback type, see \specref{sec:ompt_buffer_complete_callback_t}.
\item \code{ompt\_advance\_buffer\_cursor} tool function, see \specref{sec:ompt_advance_buffer_cursor}.
\item \code{ompt\_buffer\_get\_record\_type} tool function, see \specref{sec:ompt_buffer_get_record_type}.
\item \code{ompt\_buffer\_get\_record\_ompt} tool function, see \specref{sec:ompt_buffer_get_record_ompt}.
\item \code{ompt\_buffer\_get\_record\_correlation} tool function, see \specref{sec:ompt_buffer_get_record_correlation}.
\item \code{ompt\_buffer\_get\_record\_native} tool function, see \specref{sec:ompt_buffer_get_record_native}.
\end{itemize}
\end{comment}

% ompt_buffer_cursor_t

\ompttype{\code{ompt\_buffer\_cursor\_t}}
\label{sec:ompt_buffer_cursor_t} 
\code{ompt\_buffer\_cursor\_t} is an opaque handle for a position in a target buffer.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef unsigned long long int ompt_buffer_cursor_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_buffer\_complete\_callback\_t} callback type, see \specref{sec:ompt_buffer_complete_callback_t}.
\item \code{ompt\_advance\_buffer\_cursor} tool function, see \specref{sec:ompt_advance_buffer_cursor}.
\item \code{ompt\_buffer\_get\_record\_type} tool function, see \specref{sec:ompt_buffer_get_record_type}.
\item \code{ompt\_buffer\_get\_record\_ompt} tool function, see \specref{sec:ompt_buffer_get_record_ompt}.
\item \code{ompt\_buffer\_get\_record\_correlation} tool function, see \specref{sec:ompt_buffer_get_record_correlation}.
\item \code{ompt\_buffer\_get\_record\_native} tool function, see \specref{sec:ompt_buffer_get_record_native}.
\end{itemize}
\end{comment}

% ompt_task_dependence_t

\ompttype{\code{ompt\_task\_dependence\_t}}
\label{sec:ompt_task_dependence_t} 
\code{ompt\_task\_dependence\_t} is a task dependence.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_task_dependence_s \{\\
  void *variable_addr;
  unsigned int dependence_flags;
\} ompt_task_dependence_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_task\_dependences\_callback\_t} callback type, see \specref{sec:ompt_task_dependences_callback_t}.
\item \code{ompt\_task\_dependence\_flag\_t} enumeration type, see \specref{sec:ompt_task_dependence_flag_t}.
\end{itemize}
\end{comment}

% ompt_frame_t

\ompttype{\code{ompt\_frame\_t}}
\label{sec:ompt_frame_t} 
\code{ompt\_frame\_t} is a structure to maintain the runtime frame that reenters
user code, and the user fram ethat enters the runtime.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_frame_s \{\\
  void *exit_frame;  /* runtime frame that reenters user code */
  void *enter_frame; /* user frame that enters the runtime    */
\} ompt_frame_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_get\_task\_info} inquiry function, see \specref{sec:ompt_get_task_info}.
\item \code{ompt\_parallel\_begin\_callback\_t} callback type, see \specref{sec:ompt_parallel_begin_callback_t}.
\item \code{ompt\_create\_callback\_t} callback type, see \specref{sec:ompt_create_callback_t}.
\item \code{ompt\_record\_parallel\_begin\_t} data type, see \specref{sec:ompt_record_parallel_begin_t}.
\item \code{ompt\_record\_task\_create\_t} data type, see \specref{sec:ompt_record_task_create_t}.
\end{itemize}
\end{comment}

% ompt_thread_type_t

\ompttype{\code{ompt\_thread\_type\_t}}
\label{sec:ompt_thread_type_t} 
\code{ompt\_thread\_type\_t} is an enumeration that defines the valid thread type values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_thread_type_e \{
  ompt_thread_initial                 = 1,
  ompt_thread_worker                  = 2,
  ompt_thread_other                   = 3,
  ompt_thread_unknown                 = 4
\} ompt_thread_type_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_thread\_begin\_callback\_t} callback type, see \specref{sec:ompt_thread_begin_callback_t}.
\item \code{ompt\_record\_thread\_begin\_t} data type, see \specref{sec:ompt_record_thread_begin_t}.
\end{itemize}
\end{comment}

% ompt_scope_endpoint_t

\ompttype{\code{ompt\_scope\_endpoint\_t}}
\label{sec:ompt_scope_endpoint_t} 
\code{ompt\_scope\_endpoint\_t} is an enumeration that defines valid scope endpoint values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_scope_endpoint_e \{
  ompt_scope_begin                    = 1,
  ompt_scope_end                      = 2
\} ompt_scope_endpoint_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_idle\_callback\_t} callback type, see \specref{sec:ompt_idle_callback_t}.
\item \code{ompt\_implicit\_callback\_t} callback type, see \specref{sec:ompt_implicit_callback_t}.
\item \code{ompt\_sync\_region\_callback\_t} callback type, see \specref{sec:ompt_sync_region_callback_t}.
\item \code{ompt\_nested\_lock\_callback\_t} callback type, see \specref{sec:ompt_nested_lock_callback_t}.
\item \code{ompt\_master\_callback\_t} callback type, see \specref{sec:ompt_master_callback_t}.
\item \code{ompt\_worksharing\_callback\_t} callback type, see \specref{sec:ompt_worksharing_callback_t}.
\item \code{ompt\_target\_callback\_t} callback type, see \specref{sec:ompt_target_callback_t}.
\item \code{ompt\_record\_idle\_t} data type, see \specref{sec:ompt_record_idle_t}.
\item \code{ompt\_record\_implicit\_t} data type, see \specref{sec:ompt_record_implicit_t}.
\item \code{ompt\_sync\_region\_t} data type, see \specref{sec:ompt_sync_region_t}.
\item \code{ompt\_nested\_lock\_t} data type, see \specref{sec:ompt_nested_lock_t}.
\item \code{ompt\_master\_t} data type, see \specref{sec:ompt_master_t}.
\item \code{ompt\_worksharing\_t} data type, see \specref{sec:ompt_worksharing_t}.
\end{itemize}
\end{comment}

% ompt_sync_region_kind_t

\ompttype{\code{ompt\_sync\_region\_kind\_t}}
\label{sec:ompt_sync_region_kind_t} 
\code{ompt\_sync\_region\_kind\_t} is an enumeration that defines the valid sync region kind values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_sync_region_kind_e \{
  ompt_sync_region_barrier            = 1, 
  ompt_sync_region_taskwait           = 2,
  ompt_sync_region_taskgroup          = 3
\} ompt_sync_region_kind_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_sync\_region\_callback\_t} callback type, see \specref{sec:ompt_sync_region_callback_t}.
\item \code{ompt\_record\_sync\_region\_t} data type, see \specref{sec:ompt_record_sync_region_t}.
\end{itemize}
\end{comment}

% ompt_target_data_op_t

\ompttype{\code{ompt\_target\_data\_op\_t}}
\label{sec:ompt_target_data_op_t} 
\code{ompt\_target\_data\_op\_t} is an enumeration that defines the valid target data operation values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_target_data_op_e \{
  ompt_target_data_alloc              = 1,
  ompt_target_data_transfer_to_dev    = 2,
  ompt_target_data_transfer_from_dev  = 3,
  ompt_target_data_delete             = 4
\} ompt_target_data_op_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_target\_data\_callback\_t} callback type, see \specref{sec:ompt_target_data_callback_t}.
\item \code{ompt\_record\_target\_data\_t} data type, see \specref{sec:ompt_record_target_data_t}.
\end{itemize}
\end{comment}

% ompt_worksharing_type_t

\ompttype{\code{ompt\_worksharing\_type\_t}}
\label{sec:ompt_worksharing_type_t} 
\code{ompt\_worksharing\_type\_t} is an enumeration that defines the valid worksharing type values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_worksharing_type_e \{
  ompt_worksharing_loop               = 1, 
  ompt_worksharing_sections           = 2,
  ompt_worksharing_single_executor    = 3,
  ompt_worksharing_single_other       = 4,
  ompt_worksharing_workshare          = 5,
  ompt_worksharing_distribute         = 6
\} ompt_worksharing_type_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_worksharing\_callback\_t} callback type, see \specref{sec:ompt_worksharing_callback_t}.
\item \code{ompt\_record\_worksharing\_t} data type, see \specref{sec:ompt_record_worksharing_t}.
\end{itemize}
\end{comment}

% ompt_mutex_kind_t

\ompttype{\code{ompt\_mutex\_kind\_t}}
\label{sec:ompt_mutex_kind_t} 
\code{ompt\_mutex\_kind\_t} is an enumeration that defines the valid mutex kind values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_mutex_kind_e \{
  ompt_mutex                          = 0x10,
  ompt_mutex_lock                     = 0x11,
  ompt_mutex_nest_lock                = 0x12,
  ompt_mutex_critical                 = 0x13,
  ompt_mutex_atomic                   = 0x14,
  ompt_mutex_ordered                  = 0x20
\} ompt_mutex_kind_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_mutex\_acquire\_callback\_t} callback type, see \specref{sec:ompt_mutex_acquire_callback_t}.
\item \code{ompt\_mutex\_callback\_t} callback type, see \specref{sec:ompt_mutex_callback_t}.
\item \code{ompt\_record\_mutex\_acquire\_t} data type, see \specref{sec:ompt_record_mutex_acquire_t}.
\item \code{ompt\_record\_mutex\_t} data type, see \specref{sec:ompt_record_mutex_t}.
\end{itemize}
\end{comment}

% ompt_native_mon_flags_t

\ompttype{\code{ompt\_native\_mon\_flags\_t}}
\label{sec:ompt_native_mon_flags_t}
\code{ompt\_native\_mon\_flags\_t} is an enumeration that defines the valid native monitoring flag values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_native_mon_flags_e \{
  ompt_native_data_motion_explicit    = 1,
  ompt_native_data_motion_implicit    = 2,
  ompt_native_kernel_invocation       = 4,
  ompt_native_kernel_execution        = 8,
  ompt_native_driver                  = 16,
  ompt_native_runtime                 = 32,
  ompt_native_overhead                = 64,
  ompt_native_idleness                = 128
\} ompt_native_mon_flags_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_set\_trace\_native} tool function, see \specref{sec:ompt_set_trace_native}.
\end{itemize}
\end{comment}

% ompt_task_type_t

\ompttype{\code{ompt\_task\_type\_t}}
\label{sec:ompt_task_type_t}
\code{ompt\_task\_type\_t} is an enumeration that defines the valid task type values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum  ompt_task_type_e \{
  ompt_task_initial                   = 1,
  ompt_task_implicit                  = 2,
  ompt_task_explicit                  = 3,
  ompt_task_target                    = 4,
  ompt_task_degenerate                = 5
\} ompt_task_type_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_task\_create\_callback\_t} callback type, see \specref{sec:ompt_task_create_callback_t}.
\item \code{ompt\_get\_task\_info} inquiry function, see \specref{sec:ompt_get_task_info}.
\item \code{ompt\_record\_task\_create\_t} data type, see \specref{sec:ompt_record_task_create_t}.
\end{itemize}
\end{comment}

% ompt_target_type_t

\ompttype{\code{ompt\_target\_type\_t}}
\label{sec:ompt_target_type_t}
\code{ompt\_target\_type\_t} is an enumeration that defines the valid target type values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_target_type_e \{
  ompt_target                         = 1,
  ompt_target_enter_data              = 2,
  ompt_target_exit_data               = 3,
  ompt_target_update                  = 4
\} ompt_target_type_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_target\_callback\_t} callback type, see \specref{sec:ompt_target_callback_t}.
\end{itemize}
\end{comment}

% ompt_invoker_t

\ompttype{\code{ompt\_invoker\_t}}
\label{sec:ompt_invoker_t}
\code{ompt\_invoker\_t} is an enumeration that defines the valid invoker values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_invoker_e \{
  ompt_invoker_program = 1, /* program invokes master task */
  ompt_invoker_runtime = 2  /* runtime invokes master task */
\} ompt_invoker_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_parallel\_begin\_callback\_t} callback type, see \specref{sec:ompt_parallel_begin_callback_t}.
\item \code{ompt\_parallel\_end\_callback\_t} callback type, see \specref{sec:ompt_parallel_end_callback_t}.
\item \code{ompt\_record\_parallel\_begin\_t} data type, see \specref{sec:ompt_record_parallel_begin_t}.
\item \code{ompt\_record\_parallel\_end\_t} data type, see \specref{sec:ompt_record_parallel_end_t}.
\end{itemize}
\end{comment}

% ompt_target_map_flag_t

\ompttype{\code{ompt\_target\_map\_flag\_t}}
\label{sec:ompt_target_map_flag_t}
\code{ompt\_target\_map\_flag\_t} is an enumeration that defines the valid target map flag values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_target_map_flag_e \{
  ompt_target_map_flag_to             = 1,
  ompt_target_map_flag_from           = 2,
  ompt_target_map_flag_alloc          = 4,
  ompt_target_map_flag_release        = 8, 
  ompt_target_map_flag_delete         = 16
\} ompt_target_map_flag_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_target\_data\_map\_callback\_t} callback type, see \specref{sec:ompt_target_data_map_callback_t}.
\end{itemize}
\end{comment}

% ompt_task_dependence_flag_t

\ompttype{\code{ompt\_task\_dependence\_flag\_t}}
\label{sec:ompt_task_dependence_flag_t}
\code{ompt\_task\_dependence\_flag\_t} is an enumeration that defines the valid task dependence flag values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_task_dependence_flag_e \{
  // a two bit field for the dependence type
  ompt_task_dependence_type_out       = 1,
  ompt_task_dependence_type_in        = 2,
  ompt_task_dependence_type_inout     = 3
\} ompt_task_dependence_flag_t;
\end{boxedcode}
\ccppspecificend
}

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_task\_dependence\_t} data type, see \specref{sec:ompt_task_dependence_t}.
\end{itemize}
\end{comment}


% ompt_cancel_flag_t

\ompttype{\code{ompt\_cancel\_flag\_t}}
\label{sec:ompt_cancel_flag_t}
\code{ompt\_cancel\_flag\_t} is an enumeration that defines the valid cancel flag values.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum ompt_cancel_flag_e \{
  ompt_cancel_parallel     = 0x1,
  ompt_cancel_sections     = 0x2,
  ompt_cancel_do           = 0x4,
  ompt_cancel_taskgroup    = 0x8,
  ompt_cancel_activated    = 0x10000000,
  ompt_cancel_detected     = 0x20000000
\} ompt_cancel_flag_t;
\end{boxedcode}
\ccppspecificend
}

\crossreferences
\begin{itemize}
\item \code{ompt\_cancel\_t} data type, see \specref{sec:ompt_cancel_callback_t}.
\end{itemize}

% ompt_hwid_t

\ompttype{\code{ompt\_hwid\_t}}
\label{sec:ompt_hwid_t}
\code{ompt\_hwid\_t} is an opaque object representing a hardware identifier for a target device.
\label{sec:ompt_hwid_none} 
\code{ompt\_hwid\_none} refers to an uknown or unspecified hardware id.
If there is no \code{hwid} associated with a
\code{ompt\_record\_native\_abstract\_t}, the value of \code{hwid} shall be
\code{ompt\_hwid\_none}.

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef unsigned long long int ompt_hwid_t;
#define ompt_hwid_none (0ULL)
\end{boxedcode}
\ccppspecificend
}



% end miscellaneous types

\begin{comment}
% These "none" objects have been integrated into the relevant sections,
% rather than have a seperate section.
\subsection{Miscellaneous Constants}
This section describes miscellaneous constants used by the tool interface.
% ompt_hwid_none
% ompt_dev_task_none
% ompt_time_none 
% ompt_id_none
% ompt_data_none
% ompt_mutex_kind_none
% end miscellaneous constants
\end{comment}

\section{Events without Directives}
\ompteventswithoutdirectives{\code{ompt\_event\_thread\_begin}}
\label{sec:ompt_event_thread_begin}
An OpenMP implementation invokes this callback in the context of an initial thread just after it initializes the runtime, or in the context of a new thread created by the runtime just after the thread initializes itself. In either case, this callback must be the first callback for a thread
and must occur before the thread executes any OpenMP tasks. This callback has type signature \code{ompt\_thread\_begin\_callback\_t}.
The callback argument \code{thread\_type} indicates the type of the thread: initial, worker, or other.

\ompteventswithoutdirectives{\code{ompt\_event\_thread\_end}}
\label{sec:ompt_event_thread_end}
An OpenMP implementation invokes this callback
after an OpenMP thread completes all of
its tasks but before the thread is destroyed. The callback
executes in the context of the OpenMP thread. This callback must be the last callback event for any worker thread; it is optional for other types of threads.
This callback has type signature \code{ompt\_thread\_end\_callback\_t}.

\ompteventswithoutdirectives{\code{ompt\_event\_target\_submit}}
\label{sec:ompt_event_target_submit}
An OpenMP implementation invokes this callback prior to submitting a kernel for execution on a target device.
This callback has type signature \code{ompt\_target\_submit\_callback\_t}.
The callback argument \code{target\_id} indicates the instance of the target construct associated with this operation.
The callback argument \code{host\_op\_id} provides a unique host-side identifier that represents the activity on the device.
The callback arguments \code{requested\_num\_teams}  \code{granted\_num\_teams} indicate, respectively, the number of teams requested by the user and granted by the runtime.

\ompteventswithoutdirectives{\code{ompt\_event\_tcontrol}}
\label{sec:ompt_event_tcontrol}
If the user program calls \code{omp\_tcontrol}, an
OpenMP implementation invokes this callback.
The callback executes in the context that the call occurs in the user program.
This callback has type signature \code{ompt\_tcontrol\_callback\_t}.
Arguments passed to the callback are those passed by the user to \code{omp\_tcontrol}.

\ompteventswithoutdirectives{\code{ompt\_event\_runtime\_shutdown}}
\label{sec:ompt_event_runtime_shutdown}
An OpenMP implementation invokes this callback before it shuts down the
 runtime system.  This callback enables a tool to clean up its
 state and record or report information gathered. A runtime may later restart and reinitialize the tool by
calling the tool initializer
function (described in Section~\ref{sec:tool-initialize}) again.
 This callback has type signature \code{ompt\_callback\_t}.

\ompteventswithoutdirectives{\code{ompt\_event\_idle}}
\label{sec:ompt_event_idle}
An OpenMP implementation invokes this callback with \code{endpoint=}\code{ompt\_scope\_begin} when a thread waits for work outside a parallel region.
  The OpenMP runtime invokes this callback with \code{endpoint=}\code{ompt\_scope\_end} before the thread  begins to execute an implicit task for
   a parallel region or terminates. The callback executes in the environment of the waiting thread.
  This callback has type signature \code{ompt\_idle\_callback\_t}.

\ompteventswithoutdirectives{\code{ompt\_event\_sync\_region\_wait}}
\label{sec:ompt_event_sync_region_wait}

If the \code{ompt\_event\_sync\_region\_wait} callback is registered,
an OpenMP implementation will invoke this callback when a task starts
and stops waiting in a barrier region, taskwait region, or taskgroup
region. 
This callback has
type signature \code{ompt\_sync\_region\_callback\_t}.  
One region may
generate multiple pairs of start/stop callbacks if another task is
scheduled on the thread while the task awaiting completion of the
region is stalled. 
This callback executes in the context of the task
that encountered the barrier, taskwait, or taskgroup construct.

\ompteventswithoutdirectives{\code{ompt\_event\_device\_initialize}}
\label{sec:ompt_event_device_initialize}

If the \code{ompt\_event\_device\_initialize} callback is registered,
an OpenMP implementation will invoke the this callback for a device
after OpenMP is initialized for the device but before beginning
execution of any OpenMP construct on the device.
This callback has
type signature \code{ompt\_device\_initialize\_callback\_t}.  

\section{Tool Interface Routine}

\ompteventswithoutdirectives{\code{ompt\_tool}}
\label{sec:ompt_tool}

\summary
If a tool wants to use an OpenMP implementation's OMPT interface,
the tool must implement \code{ompt\_tool} to announce its interest.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
extern "C" \{
  ompt_initialize_fn_t ompt_tool(void);
\};
\end{boxedcode}
\ccppspecificend
}

\descr
For a tool to use an OpenMP implementation's OMPT interface,
the tool must define a globally-visible implementation of the
function \code{ompt\_tool}.

A tool may indicate its intent to use the OMPT interface provided
by an OpenMP implementation by having
\code{ompt\_tool} return a non-\code{NULL} pointer to a tool
initializer routine with type signature \code{ompt\_initialize\_fn\_t}.

\begin{comment}
If a tool so indicates its interest in OMPT, the OpenMP implementation
will maintain state information for each OpenMP thread and will
perform any OMPT event callbacks registered by the tool.
\end{comment}

If a tool implements \code{ompt\_tool} but has no interest in using
an OpenMP implementation's OMPT interface in a particular execution,
\code{ompt\_tool} should return \code{NULL}. 

\effect
If a tool returns a non-\code{NULL} pointer to a tool
initializer routine, an OpenMP implementation will 
call the tool initializer
after fully initializing itself but before
beginning execution of any OpenMP construct
or completing execution of any environment routine invocation. 

\begin{comment}
\crossreferences
\begin{itemize}
\item \code{ompt\_initialize\_fn\_t} type signature, see \specref{sec:ompt_initialize_fn_t}
\end{itemize}
\end{comment}

\section{Tool Callback Signatures and Trace Records}
\subsection{Initializer Callback Signature}

\omptcallbacksignature{\code{ompt\_initialize\_fn\_t}}
\label{sec:ompt_initialize_fn_t}

\summary
A tool implements an initializer with the type signature
\code{ompt\_initialize\_fn\_t} to initialize the tool's use of
an OpenMP implementation's OMPT interface.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*\plc{ompt_initialize_fn_t}) (
  ompt_function_lookup_t \plc{lookup},
  const char *\plc{runtime_version},
  unsigned int \plc{ompt_version}
);
\end{boxedcode}
\ccppspecificend
}

\descr
For a tool to initialize an OpenMP implementation's OMPT interface,
the tool's implementation of \code{ompt\_tool} must return a 
pointer to a tool initializer with type signature \code{ompt\_initialize\_fn\_t}.
An OpenMP implementation will call the tool initializer returned by
\code{ompt\_tool} after fully initializing itself but before 
beginning execution of any OpenMP construct
or completing execution of any environment routine invocation.  

\argdesc
The first argument passed to a tool initializer 
is \plc{lookup}---a callback 
to an OpenMP runtime routine that a tool must use to 
obtain a pointer to each function in the runtime's OMPT interface.

\begin{comment}
All functions in the OMPT interface are marked with \code{OMPT\_API}, which
indicates that the only way a tool can obtain bindings for them
is using the \plc{lookup} callback.

% The language committee prefers to avoid rationale
The \code{lookup} callback is necessary in the case when an OpenMP runtime 
is dynamically loaded by a shared library. In this case, 
OMPT interface functions provided by the library may 
not be visible to a preloaded tool.
% Within a tool, one uses \code{lookup} to obtain function pointers to each function in the OMPT interface.
\end{comment}

The second argument passed to a tool initializer 
is a version string that unambiguously identifies the OpenMP implementation.

\begin{comment}
% The language committee prefers to avoid rationale
This argument is useful to tool developers trying to debug a statically-linked executable that contains both a tool implementation and an OpenMP implementation.
Knowing exactly what version of an OpenMP implementation is present 
may be helpful when diagnosing a problem, e.g., identifying an old runtime system that may be incompatible with a newer tool.
\end{comment}

The third argument an OpenMP implementation passed to a tool initializer 
is a version number that unambiguously identifies the version of the 
OMPT interface supported by the OpenMP implementation.  
The version of OMPT described by this document is 2.

\effect
A tool's initializer has several duties.  First, it should use
\plc{ompt\_version} to determine whether it is compatibile
with the version of the OMPT interface that the OpenMP implementation
supports.  Second, it should use \plc{lookup} 
to look up pointers to OMPT interface callbacks provided by the
OpenMP runtime on the host. 
Third, it should use the OMPT interface 
callback known as \code{ompt\_set\_callback} 
to register tool callbacks for OpenMP events.  Fourth, the tool
should use the OMPT interface callback known as \code{ompt\_num\_devices} 
to identify whether any target devices are present
and then use the OMPT interface callback known as 
\code{ompt\_get\_device\_info} to interrogate each device.
Using information returned by the \code{ompt\_get\_device\_info} callback,
a tool initializer can then set up tracing for a device, 
as described in \specref{sec:tracing-device-activity}. 
Finally, a tool initializer can use OMPT interface callbacks known as 
\code{ompt\_enumerate\_states} and \code{ompt\_enumerate\_mutex\_kinds} to
enumerate the thread states and implementations of mutual exclusion
that a particular OpenMP implementation employs.

\crossreferences
\begin{itemize}
\item The actions of a tool initializer are described in 
\specref{sec:tool-initialize}.
\item \code{ompt\_tool}, see \specref{sec:ompt_tool}
\item \code{ompt\_function\_lookup\_t} type signature, see \specref{sec:ompt_function_lookup_t}
\item \code{ompt\_set\_callback\_t} type signature, see \specref{sec:ompt_set_callback_t}
\item \code{ompt\_get\_num\_devices\_t} type signature, see \specref{sec:ompt_get_num_devices_t}
\end{itemize}


\subsection{Event Callback Signatures and Trace Records}
\index{event callback signatures}
\label{sec:ToolsSupport_callback_signatures}

This section describes the signatures of tool callback functions that an OMPT
tool might register and that are called during runtime of an OpenMP program.

\omptcallbacksignature{\code{ompt\_thread\_begin\_callback\_t}}
\index{ompt\_thread\_begin\_callback\_t@{\code{ompt\_thread\_begin\_callback\_t}}}
\label{sec:ompt_thread_begin_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_thread_begin_callback_t) (
  ompt_thread_type_t \plc{thread_type},
  ompt_data_t *\plc{thread_data}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_thread_begin_s \{
  ompt_thread_type_t \plc{thread_type};
\} ompt_record_thread_begin_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr
The callback with type signature \code{ompt\_thread\_begin\_callback\_t},
includes a parameter \plc{thread\_type}
that indicates the type of the new thread: initial, worker, or other.
The binding of \plc{thread\_data} is the new thread.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_thread\_type\_t} type, see
\specref{sec:ompt_thread_type_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_thread\_end\_callback\_t}}
\index{ompt\_thread\_end\_callback\_t@{\code{ompt\_thread\_end\_callback\_t}}}
\label{sec:ompt_thread_end_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_thread_end_callback_t) (
  ompt_data_t *\plc{thread_data}
);
\end{boxedcode}
\ccppspecificend
}
\descr
The binding of \plc{thread\_data} is the finished thread.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_idle\_callback\_t}}
\index{ompt\_idle\_callback\_t@{\code{ompt\_idle\_callback\_t}}}
\label{sec:ompt_idle_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_idle_callback_t) (
  ompt_scope_endpoint_t \plc{endpoint}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_idle_s \{
  ompt_scope_endpoint_t \plc{endpoint};
\} ompt_record_idle_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr
The callback with type signature \code{ompt\_idle\_callback\_t},
includes a parameter \plc{endpoint}
that indicates whether the callback signals the begin or end of the scope.

\crossreferences
\begin{itemize}
\item \code{ompt\_scope\_endpoint\_t} type, see
\specref{sec:ompt_scope_endpoint_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_parallel\_begin\_callback\_t}}
\index{ompt\_parallel\_begin\_callback\_t@{\code{ompt\_parallel\_begin\_callback\_t}}}
\label{sec:ompt_parallel_begin_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_parallel_begin_callback_t) (
               ompt_data_t * \plc{parent_task_data},
               const ompt_frame_t * \plc{parent_frame},
               ompt_data_t * \plc{parallel_data},
               unsigned int \plc{requested_team_size},
               unsigned int \plc{actual_team_size},
               ompt_invoker_t \plc{invoker},
               const void * \plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_parallel_begin_s \{
  ompt_id_t \plc{parent_task_id};
  const ompt_frame_t *\plc{parent_frame};
  ompt_id_t \plc{parallel_id};
  unsigned int \plc{requested_team_size};
  ompt_invoker_t \plc{invoker};
  const void *\plc{codeptr_ra};
\} ompt_record_parallel_begin_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr
The callbacks with type signature \code{ompt\_parallel\_begin\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.
The binding of \plc{parent\_task\_data} is the enclosing task, the binding of
\plc{parallel\_data} is the new team.


\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see \specref{sec:ompt_data_t}.
\item \code{ompt\_frame\_t} type, see \specref{sec:ompt_frame_t}.
\item \code{ompt\_invoker\_t} type, see \specref{sec:ompt_invoker_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_parallel\_end\_callback\_t}}
\index{ompt\_parallel\_end\_callback\_t@{\code{ompt\_parallel\_end\_callback\_t}}}
\label{sec:ompt_parallel_end_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_parallel_end_callback_t) (
               ompt_data_t *\plc{parallel_data},
               ompt_data_t *\plc{task_data},
               ompt_invoker_t \plc{invoker},
               const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_parallel_end_s \{
  ompt_id_t \plc{parallel_id}; 
  ompt_id_t \plc{task_id};
  ompt_invoker_t \plc{invoker};
  const void *\plc{codeptr_ra};
\} ompt_record_parallel_end_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr
The callbacks with type signature \code{ompt\_parallel\_begin\_callback\_t}
include a parameter \plc{invoker} which explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.
The binding of \plc{parallel\_data} is the finishing team.

%\effect
% ompt events have no effect

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type signature, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_invoker\_t} type signature, see
\specref{sec:ompt_invoker_t}.
\end{itemize}

\omptcallbacksignature{\code{ompt\_master\_callback\_t}}
\index{ompt\_master\_callback\_t@{\code{ompt\_master\_callback\_t}}}
\label{sec:ompt_master_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*\plc{ompt_master_callback_t}) (
               ompt_scope_endpoint_t \plc{endpoint},
               ompt_data_t *\plc{parallel_data},
               ompt_data_t *\plc{task_data},
               const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_master_s \{
  ompt_scope_endpoint_t \plc{endpoint};
  ompt_id_t \plc{parallel_id};
  ompt_id_t  \plc{task_id};
  const void *\plc{codeptr_ra};
\} ompt_record_master_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr
The callbacks with type signature \code{ompt\_master\_callback\_t}
include a parameter \plc{codeptr\_ra} which contains the return address of the
call to the OpenMP runtime routine and a parameter \plc{endpoint}
that indicates whether the callback signals the begin or end of the scope.
The binding of \plc{task\_data} is the innermost enclosing implicit task,
the binding of \plc{parallel\_data} is the innermost enclosing parallel region.

%\effect
% ompt events have no effect

\crossreferences
\begin{itemize}
\item \code{ompt\_scope\_endpoint\_t} type, see
\specref{sec:ompt_scope_endpoint_t}.
\item \code{ompt\_data\_t} type signature, see
\specref{sec:ompt_data_t}.
\end{itemize}





\omptcallbacksignature{\code{ompt\_task\_create\_callback\_t}}
\index{ompt\_task\_create\_callback\_t@{\code{ompt\_task\_create\_callback\_t}}}
\label{sec:ompt_task_create_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_task_create_callback_t) (
  ompt_data_t *\plc{parent_task_data},
  const ompt_frame_t *\plc{parent_frame},
  ompt_data_t *\plc{new_task_data},
  ompt_task_type_t \plc{type},
  int \plc{has_dependences},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_task_create_s \{
  ompt_id_t \plc{parent_task_id};
  const ompt_frame_t *\plc{parent_frame};
  ompt_id_t \plc{new_task_id};
  ompt_task_type_t \plc{type};
  _Bool \plc{has_dependences};
  const void *\plc{codeptr_ra};
\} ompt_record_task_create_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr
The callbacks with type signature \code{ompt\_task\_create\_callback\_t},
include a parameter \plc{parent\_frame}
that indicates the frame information of the encountering task, and a parameter
\plc{type} that indicates the kind of the task: initial, explicit or target.
The binding of \plc{parent\_task\_data} is the encountering task,
the binding of \plc{new\_task\_data} is the created task.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_frame\_t} type, see
\specref{sec:ompt_frame_t}.
\item \code{ompt\_task\_type\_t} type, see
\specref{sec:ompt_task_type_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_task\_dependences\_callback\_t}}
\index{ompt\_task\_dependences\_callback\_t@{\code{ompt\_task\_dependences\_callback\_t}}}
\label{sec:ompt_task_dependences_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_task_dependences_callback_t) (
  ompt_data_t *\plc{task_data},
  const ompt_task_dependence_t *\plc{deps},
  int \plc{ndeps}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
/* note: not task dependences record since it points to data       */
/*        rather than containing it                                */
\end{targetRecord}

\descr
The callback with type signature \code{ompt\_task\_dependences\_callback\_t},
includes a parameter \plc{deps} that lists all dependences of a new task and
a parameter \plc{ndeps} that specifies the length of the list.
The memory ownage of \plc{deps} remains at the caller, the tool cannot rely on
the data after the callback returns.
The binding of \plc{task\_data} is the created task.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_task\_dependence\_t} type, see
\specref{sec:ompt_task_dependence_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_task\_dependence\_callback\_t}}
\index{ompt\_task\_dependence\_callback\_t@{\code{ompt\_task\_dependence\_callback\_t}}}
\label{sec:ompt_task_dependence_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_task_dependence_callback_t) (
  ompt_data_t *\plc{src_task_data},
  ompt_data_t *\plc{sink_task_data}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_task_dependence_s \{
  ompt_id_t \plc{src_task_id};
  ompt_id_t \plc{sink_task_id};
\} ompt_record_task_dependence_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr
The binding of \plc{src\_task\_data} is a running task with an out dependency.
The binding of \plc{sink\_task\_data} is a task with a non-satisfied in dependency.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type signature, see
\specref{sec:ompt_data_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_task\_schedule\_callback\_t}}
\index{ompt\_task\_schedule\_callback\_t@{\code{ompt\_task\_schedule\_callback\_t}}}
\label{sec:ompt_task_schedule_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_task_schedule_callback_t) (
  ompt_data_t *\plc{prior_task_data},
  int \plc{prior_completed},
  ompt_data_t *\plc{next_task_data}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_task_schedule_s \{
  ompt_id_t \plc{prior_task_id};
  _Bool \plc{prior_completed};
  ompt_id_t \plc{next_task_id};
\} ompt_record_task_schedule_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr
The callback with type signature \code{ompt\_task\_schedule\_callback\_t},
include a parameter \plc{prior\_completed}
that indicates whether the task that reached the task scheduling point finished
execution its task region.
The binding of \plc{prior\_task\_data} is the task that reached the task scheduling point.
The binding of \plc{next\_task\_data} is the task to be scheduled.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_implicit\_callback\_t}}
\index{ompt\_implicit\_callback\_t@{\code{ompt\_implicit\_callback\_t}}}
\label{sec:ompt_implicit_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_implicit_callback_t) (
  ompt_scope_endpoint_t \plc{endpoint},
  ompt_data_t *\plc{parallel_data},
  ompt_data_t *\plc{task_data},
  unsigned int \plc{thread_num}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_implicit_s \{
  ompt_scope_endpoint_t \plc{endpoint};
  ompt_id_t \plc{parallel_id};
  ompt_id_t \plc{task_id};
  unsigned int \plc{thread_num};
\} ompt_record_implicit_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr
The callback with type signature \code{ompt\_implicit\_callback\_t},
includes a parameter \plc{endpoint} that indicates whether the callback signals
the begin or end of the scope and a parameter \plc{thread\_num} that indicates
the thread number of the calling thread, within the team executing the parallel
region to which the implicit region binds.
The binding of \plc{parallel\_data} is the innermost enclosing parallel region.
The binding of \plc{task\_data} is the implicit task executing the parallel
region's structured block.


\crossreferences
\begin{itemize}
\item \code{ompt\_scope\_endpoint\_t} enumeration type, see
\specref{sec:ompt_scope_endpoint_t}.
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_sync\_region\_callback\_t}}
\index{ompt\_sync\_region\_callback\_t@{\code{ompt\_sync\_region\_callback\_t}}}
\label{sec:ompt_sync_region_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_sync_region_callback_t) (
  ompt_sync_region_kind_t \plc{kind},
  ompt_scope_endpoint_t \plc{endpoint},
  ompt_data_t *\plc{parallel_data},
  ompt_data_t *\plc{task_data},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_sync_region_s \{
  ompt_sync_region_kind_t \plc{kind};
  ompt_scope_endpoint_t \plc{endpoint};
  ompt_id_t \plc{parallel_id};
  ompt_id_t  \plc{task_id};
  const void *\plc{codeptr_ra};
\} ompt_record_sync_region_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr 
A tool executes a callback with type signature
\code{ompt\_sync\_region\_callback\_t} to receive notification of
event \code{ompt\_sync\_region\_callback\_t} when an OpenMP
implementation starts and stops waiting in a barrier region, taskwait
region, or taskgroup region.

\constraints
The first argument indicates the kind of region causing the wait.  
The second argument indicates whether the callback indicates whether the
task is about to start waiting with value \code{ompt\_scope\_begin}, or about
to stop waiting, with value \code{ompt\_scope\_end}. 
The third argument is a pointer to the tool's data area for the
current parallel region.
The fourth argument is a pointer to the tool's data area for the
current task region.
The last argument, \code{codeptr\_ra}, is the return address following the
task's call to a routine to implement the waiting or invoke this
callback; \code{codeptr\_ra} may be NULL.  

\crossreferences
\begin{itemize}
\item \code{ompt\_sync\_region\_kind\_t} type, see
\specref{sec:ompt_sync_region_kind_t}.
\item \code{ompt\_scope\_endpoint\_t} type, see
\specref{sec:ompt_scope_endpoint_t}.
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_lock\_init\_callback\_t}}
\index{ompt\_lock\_init\_callback\_t@{\code{ompt\_lock\_init\_callback\_t}}}
\label{sec:ompt_lock_init_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_lock_init_callback_t) (
  int \plc{is_nest_lock},
  ompt_wait_id_t \plc{wait_id},
  unsigned int \plc{hint},
  unsigned int \plc{kind},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_lock_init_s \{
  _Bool \plc{is_nest_lock};
  ompt_wait_id_t wait_id;
  unsigned int hint;
  unsigned int kind;
  const void *\plc{codeptr_ra};
\} ompt_record_lock_init_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr ToDo
The callbacks with type signature \code{ompt\_lock\_init\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_wait\_id\_t} type, see
\specref{sec:ompt_wait_id_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_lock\_destroy\_callback\_t}}
\index{ompt\_lock\_destroy\_callback\_t@{\code{ompt\_lock\_destroy\_callback\_t}}}
\label{sec:ompt_lock_destroy_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_lock_destroy_callback_t) (
  int \plc{is_nest_lock},
  ompt_wait_id_t \plc{wait_id},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_lock_destroy_s \{
  _Bool \plc{is_nest_lock};
  ompt_wait_id_t \plc{wait_id};
  const void *\plc{codeptr_ra};
\} ompt_record_lock_destroy_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr ToDo
The callbacks with type signature \code{ompt\_lock\_destroy\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_wait\_id\_t} type, see
\specref{sec:ompt_wait_id_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_mutex\_acquire\_callback\_t}}
\index{ompt\_mutex\_acquire\_callback\_t@{\code{ompt\_mutex\_acquire\_callback\_t}}}
\label{sec:ompt_mutex_acquire_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_mutex_acquire_callback_t) (
  ompt_mutex_kind_t \plc{kind},
  unsigned int \plc{hint},
  unsigned int \plc{impl},
  ompt_wait_id_t \plc{wait_id},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_mutex_acquire_s \{
  ompt_mutex_kind_t \plc{kind};
  unsigned int \plc{hint};
  unsigned int \plc{impl};
  ompt_wait_id_t \plc{wait_id};
  const void *\plc{codeptr_ra};
\} ompt_record_mutex_acquire_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr ToDo
The callbacks with type signature \code{ompt\_mutex\_acquire\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_mutex\_kind\_t} type, see
\specref{sec:ompt_mutex_kind_t}.
\item \code{ompt\_wait\_id\_t} type, see
\specref{sec:ompt_wait_id_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_mutex\_callback\_t}}
\index{ompt\_mutex\_callback\_t@{\code{ompt\_mutex\_callback\_t}}}
\label{sec:ompt_mutex_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_mutex_callback_t) (
  ompt_mutex_kind_t \plc{kind},
  ompt_wait_id_t \plc{wait_id},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_mutex_s \{
  ompt_mutex_kind_t \plc{kind};
  ompt_wait_id_t \plc{wait_id};
  const void *\plc{codeptr_ra};
\} ompt_record_mutex_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr ToDo
The callbacks with type signature \code{ompt\_mutex\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_mutex\_kind\_t} type signature, see
\specref{sec:ompt_mutex_kind_t}.
\item \code{ompt\_wait\_id\_t} type signature, see
\specref{sec:ompt_wait_id_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_nested\_lock\_callback\_t}}
\index{ompt\_nested\_lock\_callback\_t@{\code{ompt\_nested\_lock\_callback\_t}}}
\label{sec:ompt_nested_lock_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_nested_lock_callback_t) (
  ompt_scope_endpoint_t \plc{endpoint},
  ompt_wait_id_t \plc{wait_id},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_nested_lock_s \{
  ompt_scope_endpoint_t \plc{endpoint};
  ompt_wait_id_t \plc{wait_id};
  const void *\plc{codeptr_ra};
\} ompt_record_nested_lock_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr ToDo
The callbacks with type signature \code{ompt\_nested\_lock\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

include a parameter \plc{codeptr\_ra} which contains the return address of the
call to the OpenMP runtime routine and a parameter \plc{endpoint}
that indicates whether the callback signals the begin or end of the scope.

\crossreferences
\begin{itemize}
\item \code{ompt\_scope\_endpoint\_t} type signature, see
\specref{sec:ompt_scope_endpoint_t}.
\item \code{ompt\_wait\_id\_t} type signature, see
\specref{sec:ompt_wait_id_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_worksharing\_callback\_t}}
\index{ompt\_worksharing\_callback\_t@{\code{ompt\_worksharing\_callback\_t}}}
\label{sec:ompt_worksharing_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_worksharing_callback_t) (
  ompt_worksharing_type_t \plc{wstype},
  ompt_scope_endpoint_t \plc{endpoint},
  ompt_data_t *\plc{parallel_data},
  ompt_data_t *\plc{task_data},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_worksharing_s \{
  ompt_worksharing_type_t \plc{wstype};
  ompt_scope_endpoint_t \plc{endpoint};
  ompt_id_t \plc{parallel_id};
  ompt_id_t \plc{task_id};
  const void *\plc{codeptr_ra};
\} ompt_record_worksharing_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr ToDo
The callbacks with type signature \code{ompt\_worksharing\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

include a parameter \plc{codeptr\_ra} which contains the return address of the
call to the OpenMP runtime routine and a parameter \plc{endpoint}
that indicates whether the callback signals the begin or end of the scope.

\crossreferences
\begin{itemize}
\item \code{ompt\_worksharing\_type\_t} type signature, see
\specref{sec:ompt_worksharing_type_t}.
\item \code{ompt\_scope\_endpoint\_t} type signature, see
\specref{sec:ompt_scope_endpoint_t}.
\item \code{ompt\_data\_t} type signature, see
\specref{sec:ompt_data_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_flush\_callback\_t}}
\index{ompt\_flush\_callback\_t@{\code{ompt\_flush\_callback\_t}}}
\label{sec:ompt_flush_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_flush_callback_t) (
  ompt_data_t *\plc{thread_data},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_flush_s \{
  void *\plc{codeptr_ra};
\} ompt_record_flush_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr ToDo
The callbacks with type signature \code{ompt\_flush\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type signature, see
\specref{sec:ompt_data_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_target\_callback\_t}}
\index{ompt\_target\_callback\_t@{\code{ompt\_target\_callback\_t}}}
\label{sec:ompt_target_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_target_callback_t) (
  int \plc{device_id},
  ompt_target_type_t \plc{kind},
  ompt_data_t *\plc{task_data},
  ompt_scope_endpoint_t \plc{endpoint},
  ompt_id_t \plc{target_id},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_target_s \{
  int \plc{device_id};
  ompt_target_type_t \plc{kind};
  ompt_data_t *\plc{task_data};
  ompt_scope_endpoint_t \plc{endpoint};
  ompt_id_t \plc{target_id};
  const void *\plc{codeptr_ra};
\} ompt_record_target_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr ToDo
The callbacks with type signature \code{ompt\_target\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

include a parameter \plc{codeptr\_ra} which contains the return address of the
call to the OpenMP runtime routine and a parameter \plc{endpoint}
that indicates whether the callback signals the begin or end of the scope.

\crossreferences
\begin{itemize}
\item \code{ompt\_target\_type\_t} type signature, see
\specref{sec:ompt_target_type_t}.
\item \code{ompt\_data\_t} type signature, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_scope\_endpoint\_t} type signature, see
\specref{sec:ompt_scope_endpoint_t}.
\item \code{ompt\_id\_t} type, see
\specref{sec:ompt_id_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_target\_data\_callback\_t}}
\index{ompt\_target\_data\_callback\_t@{\code{ompt\_target\_data\_callback\_t}}}
\label{sec:ompt_target_data_callback_t}
\format

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_target_data_callback_t) (
  ompt_id_t \plc{target_id},
  ompt_id_t \plc{host_op_id},
  ompt_target_data_op_t \plc{optype},
  void *\plc{host_addr},
  void *\plc{device_addr},
  size_t \plc{bytes}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_target_data_s \{
  ompt_id_t \plc{host_op_id};
  ompt_target_data_op_t \plc{optype};
  void *\plc{host_addr};
  void *\plc{device_addr};
  size_t \plc{bytes};
  ompt_device_time_t \plc{end_time};
\} ompt_record_target_data_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr ToDo
The callbacks with type signature \code{ompt\_target\_data\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_id\_t} type, see
\specref{sec:ompt_id_t}.
\item \code{ompt\_target\_data\_op\_t} type signature, see
\specref{sec:ompt_target_data_op_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_target\_data\_map\_callback\_t}}
\index{ompt\_target\_data\_map\_callback\_t@{\code{ompt\_target\_data\_map\_callback\_t}}}
\label{sec:ompt_target_data_map_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_target_data_map_callback_t) (
  ompt_id_t \plc{target_id},
  unsigned int \plc{nitems},
  void **\plc{host_addr},
  void **\plc{device_addr},
  size_t *\plc{bytes},
  unsigned int *\plc{mapping_flags}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void ompt_record_target_data_map_s \{
  ompt_id_t \plc{target_id};
  unsigned int \plc{nitems};
  void **\plc{host_addr};
  void **\plc{device_addr};
  size_t *\plc{bytes};
  unsigned int *\plc{mapping_flags};
\} ompt_record_target_data_map_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr ToDo
The callbacks with type signature \code{ompt\_target\_data\_map\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_id\_t} type, see
\specref{sec:ompt_id_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_target\_submit\_callback\_t}}
\index{ompt\_target\_submit\_callback\_t@{\code{ompt\_target\_submit\_callback\_t}}}
\label{sec:ompt_target_submit_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_target_submit_callback_t) (
  ompt_id_t \plc{target_id},
  ompt_id_t \plc{host_op_id},
  unsigned int \plc{requested_num_teams},
  unsigned int \plc{granted_num_teams}
);
\end{boxedcode}
\ccppspecificend
}

\begin{targetRecord}
\record
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_target_submit_s \{
  ompt_id_t \plc{target_id};
  ompt_id_t \plc{host_op_id};
  unsigned int \plc{requested_num_teams};
  unsigned int \plc{granted_num_teams};
\} ompt_record_target_submit_t;
\end{boxedcode}
\ccppspecificend
}
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct ompt_record_target_kernel_s \{
  ompt_id_t \plc{host_op_id};
  unsigned int \plc{granted_num_teams};
  ompt_device_time_t \plc{end_time};
\} ompt_record_target_kernel_t;
\end{boxedcode}
\ccppspecificend
}
\end{targetRecord}

\descr ToDo
The callbacks with type signature \code{ompt\_target\_submit\_callback\_t},
include a parameter \plc{requested\_team\_size}
that indicates the number of threads requested by the user, and a parameter
\plc{actual\_team\_size} that indicates the number of threads in the team.
The \plc{invoker} argument explains whether the execution of the parallel
region code is inlined into the application code or started by the runtime.

\crossreferences
\begin{itemize}
\item \code{ompt\_id\_t} type, see
\specref{sec:ompt_id_t}.
\end{itemize}


\omptcallbacksignature{\code{ompt\_buffer\_request\_callback\_t}}
\index{ompt\_buffer\_request\_callback\_t@{\code{ompt\_buffer\_request\_callback\_t}}}
\label{sec:ompt_buffer_request_callback_t}

\summary
The OpenMP runtime will invoke a callback with type signature  
\code{ompt\_buffer\_request\_callback\_t} to request a
buffer to store event records for a device.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_buffer_request_callback_t) (
  int \plc{device_id},
  ompt_buffer_t** \plc{buffer},
  size_t *\plc{bytes}
);
\end{boxedcode}
\ccppspecificend
}

\constraints 
The callback requests a buffer to store trace records for device \plc{device\_id}.  
A tool should set \plc{*buffer} to point to a buffer where device events
may be recorded and \plc{*bytes} to the length of that buffer.  A
buffer request callback  may set \plc{*bytes} to 0 if it does not
want to provide a buffer for any reason. If a callback sets
\plc{*bytes} to 0, further recording of events for the device will
be disabled until the next invocation of \code{ompt\_start\_trace}.
This will cause the device to drop future trace records until
recording is restarted.

Note: {\em buffer request and completion callbacks are not 
required to be async-signal safe.}

To start recording, a tool needs to register a \emph{buffer request}
callback that will supply a device with a buffer to deposit events
and a \emph{buffer complete} callback that will be invoked by the
OpenMP runtime to empty a buffer containing event records. A device's
offloading runtime library is responsible for invoking these callbacks
on a thread that is not an OpenMP master or worker. 

\crossreferences
\begin{itemize}
\item \code{ompt\_buffer\_t} type, see
\specref{sec:ompt_buffer_t}.
\end{itemize}

\omptcallbacksignature{\code{ompt\_buffer\_complete\_callback\_t}}
\index{ompt\_buffer\_complete\_callback\_t@{\code{ompt\_buffer\_complete\_callback\_t}}}
\label{sec:ompt_buffer_complete_callback_t}
\summary
A device triggers a call to \code{ompt\_buffer\_complete\_callback\_t} when no further records will be recorded in an event buffer and all records written to the buffer are valid. 

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_buffer_complete_callback_t) (
  int \plc{device_id},
  const ompt_buffer_t *\plc{buf},
  size_t \plc{bytes},
  ompt_buffer_cursor_t \plc{begin},
  int \plc{buffer_owned}
);
\end{boxedcode}
\ccppspecificend
}
\descr ToDo
The callbacks with type signature \code{ompt\_buffer\_complete\_callback\_t},

\constraints

The argument \plc{device\_id} indicates the device whose events the
buffer contains. The argument \plc{buffer} is the address of a
buffer previously allocated by a \emph{buffer request} callback.
The argument \plc{bytes} indicates the full size of the buffer.
The argument \plc{begin} is an opaque cursor that indicates the
position at the beginning of the first record in the buffer. The
argument \plc{buffer\_owned} is 1 if the data
pointed to by buffer was allocated by a call to the buffer request
callback for that device and 0 otherwise. If multiple devices accumulate trace
events into a single buffer (as is the case for NVIDIA's CUPTI API),
this callback might be invoked with a pointer to one or more trace
records in a shared buffer with \plc{buffer\_owned} = 0. In this
case, the callback may not delete the buffer.

Under normal operating conditions, every event buffer provided to
a device by a \emph{buffer request} callback will receive a
\emph{buffer complete} callback before the OpenMP runtime shuts
down. If an exceptional condition terminates  execution of an OpenMP
program, the OpenMP runtime may choose not to provide a \emph{buffer
complete} callback for buffers provided to any device.


\crossreferences
\begin{itemize}
\item \code{ompt\_buffer\_t} type, see
\specref{sec:ompt_buffer_t}.
\item \code{ompt\_buffer\_cursor\_t} type, see
\specref{sec:ompt_buffer_cursor_t}.
\end{itemize}

\omptcallbacksignature{\code{ompt\_tcontrol\_callback\_t}}
\index{ompt\_tcontrol\_callback\_t@{\code{ompt\_tcontrol\_callback\_t}}}
\label{sec:ompt_tcontrol_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_tcontrol_callback_t) (
  long long int \plc{command},
  long long int \plc{modifier}
);
\end{boxedcode}
\ccppspecificend
}
\descr 
The callback with type signature \code{ompt\_tcontrol\_callback\_t},
includes parameters \plc{command} and \plc{modifier}. Standard values for
\plc{command} are defined by \code{omp\_tcontrol\_t}. 
defined in \specref{sec:tool_tcontrol}.
The callback also allows tool-specific values for \plc{command} and \plc{modifier}.
Tool-specific values for \plc{command} must be $\geq$ 64.
Tools must ignore \plc{command} values that they are not 
explicitly designed to handle.

\crossreferences
\begin{itemize}
\item \code{omp\_tcontrol\_t} enumeration type, see \specref{sec:tool_tcontrol}.
\end{itemize}

\omptcallbacksignature{\code{ompt\_cancell\_callback\_t}}
\index{ompt\_cancel\_callback\_t@{\code{ompt\_cancel\_callback\_t}}}
\label{sec:ompt_cancel_callback_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_cancel_callback_t) (
  ompt_data_t *\plc{task_data},
  int \plc{flags},
  const void *\plc{codeptr_ra}
  );
\end{boxedcode}
\ccppspecificend
}
\descr 
The callback with type signature \code{ompt\_cancel\_callback\_t},
includes \plc{flags} defined by the enumeration  \code{ompt\_cancel\_flag\_t}, which determines
whether the cancel is activated by the current task, or detected as being activated by another task. 
The construct being canceled is also described in the \plc{flags}.
When several constructs are detected as being concurrently canceled, each corresponding 
bit in the flags will be set. The \plc{task\_data} and \plc{codeptr\_ra} corresponds to 
the task encountering the cancel construct, 
the cancellation point construct, or the construct defined as having an implicit cancellation point construct.

\crossreferences
\begin{itemize}
\item \code{omp\_cancel\_flag\_t} enumeration type, see \specref{sec:ompt_cancel_flag_t}.
\end{itemize}


\omptcallbacksignature{\code{ompt\_device\_initialize\_callback\_t}}
\index{ompt\_flush\_callback\_t@{\code{ompt\_device\_initialize\_callback\_t}}}
\label{sec:ompt_device_initialize_callback_t}

\summary The tool callback with type signature
\code{ompt\_device\_initialize\_callback\_t} initializes a
tool's tracing interface for a device.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef void (*ompt_device_initialize_callback_t) (
  int \plc{device_id},
  const char *\plc{type},
  ompt_device_t *\plc{device},
  ompt_function_lookup_t *\plc{lookup},
  const char *\plc{documentation}
);
\end{boxedcode}
\ccppspecificend
}

\descr 

A tool that wants to asynchronously collect a trace of
activities on a device should register a callback with type signature
\code{ompt\_device\_initialize\_callback\_t} for the
\code{ompt\_event\_device\_initialize} OpenMP event. An OpenMP
implementation will invoke this callback for a device after OpenMP is
initialized for the device but before beginning execution of any
OpenMP construct on the device.

\argdesc

The first argument identifies the logical device being initialized.

The second argument is a character string indicating the type of the
device. A device type string is a semicolon separated character string
that includes at a minimum the vendor and model name of the
device. This may be followed by a semicolon-separated sequence of
properties that describe a device's hardware or software.  An example
type string in this format is the following: ``NVIDIA; Tesla M2050;
compute capability 2.0; CUDA 8.0''.

The third argument is a pointer to an opaque object that represents
the target device instance. The pointer to the device instance object
is used by functions in the device tracing interface to identify the
device being addressed.

The fourth argument is \plc{lookup}---a pointer to a runtime callback
that a tool must use to obtain pointers to entry points in the
device's OMPT tracing interface.

The last argument is a string that describes names and type signatures
of any additional device-specific entry points that can be obtained
using \plc{lookup}. Ideally, the documentation string should include
not only the type signature but also descriptive text for how to use
the device-specific API or pointers to external documentation about
it.

\effect

A tool's device initializer has several duties.  First, it should use
\plc{type} to determine whether the tool has any special knowledge
about a device's hardware and/or software.  Second, it should use
\plc{lookup} to look up pointers to entry points in the OMPT tracing
interface for the device.  Finally, using these entry points, it can
then set up tracing for a device.

\crossreferences
\begin{itemize}
\item device tracing, see
\specref{sec:tracing-device-activity}. 
\item \code{ompt\_function\_lookup\_t} type signature, see \specref{sec:ompt_function_lookup_t}
\end{itemize}

\section{Runtime Entry Points for Tools}

The OMPT interface supports two principal sets of entry points for tools. One
set of entry points enables a tool to register callbacks for OpenMP
events and to inspect the state of an OpenMP thread while
executing in a tool callback or a signal handler. The second set of entry points enables a
tool to trace activities on a device. When directed by the tracing
interface, an OpenMP implementation will trace activities on a device, collect
buffers full of trace records, and invoke callbacks on the host to
process these records. 
Runtime entry points for tools in an OpenMP implementation
should not be global symbols since tools cannot rely on the visibility
of such symbols in general.

In addition, the OMPT interface supports
entry points for two classes of lookup routines. The first
class of lookup routines contains a single member: a
routine that returns entry points in the OMPT callback interface. 
The second class of lookup routines includes 
a unique lookup routine for each kind of
device that can return entry points in a device's OMPT tracing interface.

\subsection{Entry Points in the OMPT Callback Interface}
\label{sec:ompt-callback-entry-points}

Entry points in the OMPT callback interface enable a tool to register
callbacks for OpenMP events and to inspect the state of an OpenMP thread while
executing in a tool callback or a signal handler. 
A tool obtains pointers to these entry points 
using the lookup function passed to the tool's initializer for the
callback interface.

{\em All entry points in the OMPT callback interface that 
  inspect an OpenMP thread's state must be async signal safe} so
that tools can call them from a signal handler.

\begin{comment}
OpenMP Runtime Library Routines are not guaranteed to be async
signal safe. That means that they might acquire and release 
a lock as part of their normal operation. For that reason,
is unsafe to call OpenMP Runtime Library Routines 
within an OMPT callback because doing
so may cause deadlock.
\end{comment}


\omptruntimeentrypoint{\code{ompt\_enumerate\_states\_t}}
\label{sec:ompt_enumerate_states_t}
\label{sec:ompt_enumerate_states}

\summary
An OpenMP implementation's 
tool entry point known as \code{ompt\_enumerate\_states} 
with type signature \code{ompt\_enumerate\_states\_t} 
enumerates the thread states supported by an OpenMP 
implementation.

\format

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_enumerate_states_t)(
  int \plc{current_state}, 
  int *\plc{next_state}, 
  const char **\plc{next_state_name}
);
\end{boxedcode}
\ccppspecificend
}

\descr
An OpenMP implementation may support only a subset of the states defined by 
the \code{omp\_states\_t} enumeration type. In addition, an
OpenMP implementation may support implementation-specific states.
The \code{ompt\_enumerate\_states} entry point enables a tool to 
enumerate the thread states supported by an OpenMP implementation.
 
When a thread state supported by an OpenMP implementation is passed
as the first argument to the entry point,
the entry point will assign the next thread state in the enumeration to
the variable passed by reference as the entry point's second argument
and assign the name associated with the next thread state
to the character pointer passed by reference as the third argument.
 
Whenever one or more states are left in the enumeration, 
the enumerate states entry point will return $1$.
When the last state in the enumeration is passed 
as the first argument, the entry point will return $0$ 
indicating that the enumeration is complete.

\begin{comment}
For instance, a particular OpenMP implementation may want to 
provide more detail about the nature of runtime overhead, 
e.g., to differentiate between overhead associated with setting up 
parallel regions
and overhead associated with setting up tasks. 
% A tool need not report all states defined herein, e.g., if state tracking for a particular state would be too expensive.
To enable a tool to identify all states that an OpenMP implementation
supports, the following interface for enumerating all states that may be reported by the runtime that is being used.
\end{comment}

\constraints

The first argument passed to the enumerate states entry point must be
a thread state supported by the OpenMP implementation.  
To begin enumerating the states that an OpenMP implementation supports,
a tool should pass \code{omp\_state\_undefined} as the
first argument to the enumerate states entry point.
Subsequent invocations of the entry point by the tool
should pass the value 
assigned to the variable passed by reference as the second argument to the previous call.

The second and third arguments to the entry point must be valid
references to variables of the specified types.

\vspace{2ex}

\needspace{6\baselineskip}\notestart
\noteheader -- The following example illustrates how a tool can 
enumerate all states supported by an OpenMP implementation.
The example assumes that a pointer to an OpenMP implementation's enumerate
states entry point has previously been assigned to a function pointer
\code{ompt\_enumerate\_states\_fn}.

\vbox{
\ccppspecificstart
\begin{boxedcode}
int state = omp_state_undefined;
const char *state_name;
while (ompt_enumerate_states_fn(state, &state, &state_name)) \{
  // note that the runtime supports a state value "state" 
  // associated with the name "state_name" 
\}
\end{boxedcode}
\ccppspecificend
\noteend
}

\crossreferences
\begin{itemize}
\item \code{omp\_state\_t}, see \specref{sec:thread-states}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_enumerate\_mutex\_impls\_t}}
\label{sec:ompt_enumerate_mutex_impls_t}
\label{sec:ompt_enumerate_mutex_impls}
\label{sec:ompt_mutex_impl_unknown}
 
\summary

An OpenMP implementation's tool entry point known as \code{ompt\_enumerate\_mutex\_impls} 
with type signature \code{ompt\_enumerate\_mutex\_impls\_t} 
enumerates the kinds of mutual exclusion implementations that
an OpenMP implementation employs.


\format

\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_enumerate_mutex_impls_t)(
  int \plc{current_impl}, 
  int *\plc{next_impl}, 
  const char **\plc{next_impl_name}
);

#define ompt_mutex_impl_unknown 0
\end{boxedcode}
\ccppspecificend
}

\descr
An OpenMP implementation may implement mutual exclusion for locks,
nest locks, critical sections, and atomic regions in several different
ways.  The \code{ompt\_enumerate\_mutex\_impls} entry point
enables a tool to enumerate the 
kinds of mutual exclusion implementations that an OpenMP implementation
employs.
The value \code{ompt\_mutex\_impl\_unknown} is reserved to indicate an invalid
implementation.

\begin{comment}
For that reason, a user program can provide hints
to help the runtime system to select appropriate implementations.
When a lock or nest lock is initialized, the \code{ompt\_event\_init\_lock}
callback receives the argument \code{kind}---a small integer that
indicates the lock implementation chosen by the OpenMP runtime.
Similarly, the \code{ompt\_event\_mutex\_acquire} callback receives
the argument \code{kind} to indicate the implementation of a lock,
critical section, atomic region, or ordered section. 
\end{comment}

When a mutex kind supported by an OpenMP implementation is passed
as the first argument to the entry point,
the entry point will assign the next mutex kind in the enumeration to
the variable passed by reference as the entry point's second argument
and assign the name associated with the next mutex kind 
to the character pointer passed by reference as the third argument.

Whenever one or more mutex kinds are left in the enumeration, 
the enumerate mutex kinds entry point will return $1$.
When the last mutex kind in the enumeration is passed 
as the first argument, the entry point will return $0$ 
indicating that the enumeration is complete.

\constraints
The first argument passed to the enumerate mutex kinds entry point must be
a mutex implementation kind supported
by an OpenMP implementation.  To begin enumerating the mutex
implementation kinds that an OpenMP implementation supports, a tool
should pass \code{ompt\_mutex\_impl\_unknown} as the first
argument of the enumerate mutex kinds entry point.  Subsequent invocations
of the entry point by the tool should pass the
value assigned to the variable passed by reference as the second
argument to the previous call.

The second and third arguments to the entry point must be valid
references to variables of the specified types.

\needspace{6\baselineskip}\notestart
\noteheader -- The following example illustrates how a tool can 
enumerate all types of mutex implementations supported by an OpenMP runtime.
The example assumes that a pointer to an OpenMP implementation's enumerate
mutex kinds callback has previously been assigned to a function pointer
\code{ompt\_enumerate\_mutex\_impls\_fn}.

\vspace{2ex}

\vbox{
\ccppspecificstart
\begin{boxedcode}
int kind = ompt_mutex_impl_unknown;
const char *impl_name;
while (ompt_enumerate_mutex_impls_fn(impl, &impl, &impl_name)) \{
  // note that the runtime supports a mutex value "impl" 
  // associated with the name "impl_name" 
\}
\end{boxedcode}
\ccppspecificend
\noteend
}


\omptruntimeentrypoint{\code{ompt\_set\_callback\_t}}
\label{sec:ompt_set_callback_t}
\label{sec:ompt_set_callback}

\summary

An OpenMP implementation's tool entry point known as \code{ompt\_set\_callback} 
with type signature \code{ompt\_set\_callback\_t} registers a
pointer to a tool callback that an OpenMP implementation will invoke when a host
OpenMP event occurs.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_set_callback_t)(
  ompt_event_t \plc{event},
  ompt_callback_t \plc{callback}
);
\end{boxedcode}
\ccppspecificend
}

\descr

OpenMP implementations can inform tools about events that occur during
the execution of an OpenMP program using callbacks.
To register a tool callback for an OpenMP event on the current device, 
a tool uses an OpenMP implementation's tool entry point 
known as \code{ompt\_set\_callback} 
with type signature \code{ompt\_set\_callback\_t}.

The return value of the \code{ompt\_set\_callback} entry point may indicate several possible
outcomes. Callback registration may fail if it is called outside the initializer for the
callback interface. Otherwise, the return value of set callback 
indicates whether or not the event may occur during execution and
whether or not the callback will always be invoked or not.

\constraints
When a tool registers a callback for an event, the type
signature for the callback must match the type signature appropriate for the
event. 
For an event with enumeration value name {\ttfamily\bfseries ompt\_event\_{\em xxx}}, 
the type signature for the event is {\ttfamily\bfseries ompt\_{\em xxx}\_callback\_t}. 
 
\begin{table}
\centering
\begin{tabular}{ll}
\hline
Return code & Meaning \\
\hline
0 & callback registration error\\
1 & event will never occur\\
2 & event may occur; no callback is possible\\
3 & event may occur; callback invoked when convenient\\
4 & event may occur; callback always invoked when event occurs\\
\hline
\end{tabular}
\vskip 1ex
\caption{Meaning of return codes for \code{ompt\_set\_callback}.}
\label{table:ToolsSupport_set_rc}
\end{table}

\crossreferences
\begin{itemize}
\item \code{ompt\_event\_t} enumeration type, see \specref{sec:ompt_event_t}.
\item \code{ompt\_callback\_t} type, see \specref{sec:ompt_callback_t}.
\item \code{ompt\_get\_callback\_t} host callback ftype signature,
see \specref{sec:ompt_get_callback_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_get\_callback\_t}}
\label{sec:ompt_get_callback_t}
\label{sec:ompt_get_callback}

\summary

An OpenMP implementation's tool entry point known as \code{ompt\_get\_callback} 
with type signature \code{ompt\_get\_callback\_t} retrieves a pointer
to a tool callback routine (if any) 
that an OpenMP implementation will invoke when an OpenMP event occurs.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_get_callback_t)(
  ompt_event_t \plc{event},
  ompt_callback_t *\plc{callback}
);
\end{boxedcode}
\ccppspecificend
}

\descr
A tool uses an OpenMP implementation's tool entry point known 
as \code{ompt\_get\_callback} 
with type signature \code{ompt\_get\_callback\_t} 
to obtain a pointer to the tool callback that 
an OpenMP implementation will invoke when a host OpenMP event occurs. 
If a non-\code{NULL} tool callback is registered for the specified event, 
the pointer to the tool callback will be assigned to the variable
passed by reference as the second argument and the entry
point will return 1; otherwise, it will return 0. If the entry point
returns 0, the value of the variable passed by reference as the second
argument is undefined.

\constraints
The second argument passed to the entry point must be a reference
to a variable of specified type.

\crossreferences
\begin{itemize}
\item \code{ompt\_event\_t} enumeration type, see \specref{sec:ompt_event_t}.
\item \code{ompt\_callback\_t} type, see \specref{sec:ompt_callback_t}.
\item \code{ompt\_set\_callback\_t} type signature, 
see \specref{sec:ompt_set_callback_t}. 
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_get\_thread\_data\_t}}
\label{sec:thread-inquiry}
\label{sec:ompt_get_thread_data_t}
\label{sec:ompt_get_thread_data}

\summary
An OpenMP implementation's tool entry point known as \code{ompt\_get\_thread\_data}
with type signature \code{ompt\_get\_thread\_data\_t} 
returns the address of the thread data object for the current thread.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef ompt_data_t *(*ompt_get_thread_data_t)(void);
\end{boxedcode}
\ccppspecificend}

\descr

Each OpenMP thread has an associated thread data object of type
\code{ompt\_data\_t}. 
A tool uses an OpenMP implementation's tool entry point known as
\code{ompt\_get\_thread\_data} 
with type signature \code{ompt\_get\_thread\_data\_t}
to obtain a pointer to the thread data object, if any, associated with the
current thread. If the current thread is unknown to the OpenMP
runtime, the entry point returns \code{NULL}.

A tool may use a pointer to an OpenMP thread's data object 
obtained from this entry point to 
inspect or modify the value of the data object.
When an OpenMP thread is created, its data object will be initialized
with value \code{ompt\_data\_none}.  

{\em This entry point is async signal safe.}

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see \specref{sec:ompt_data_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_get\_state\_t}}
\label{sec:ompt_get_state_t}
\label{sec:ompt_get_state}

\summary
An OpenMP implementation's tool entry point known as \code{ompt\_get\_state}
with type signature \code{ompt\_get\_state\_t} 
returns the state and the wait identifier of the 
current thread. 

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef omp_state_t (*ompt_get_state_t)(
  ompt_wait_id_t *\plc{wait_id}       
);
\end{boxedcode}
\ccppspecificend}

\descr

Each OpenMP thread has an associated state and a wait identifier.  If
a thread's state indicates that the thread is waiting for mutual
exclusion, the thread's wait identifier will contain an opaque handle
that indicates the data object upon which the thread is waiting.

To retrieve the state and wait identifier for the current thread,
a tool uses an OpenMP implementation's tool entry point known as
\code{ompt\_get\_state} with type signature \code{ompt\_get\_state\_t}.

If the returned state indicates that the thread is waiting for a
lock, nest lock, critical section, atomic region, or ordered region
and the pointer passed as the argument to the
entry point is not \code{NULL}, 
the entry point will assign the value of the thread's wait identifier to the
wait identifier passed by reference.
If the returned state is not one of the specified wait states,
the value of a wait identifier passed by reference to the entry
point is undefined following the call.

{\em This entry point is async signal safe.}

\constraints
The argument passed to the entry point must be a reference
to a variable of the specified type or \code{NULL}.

\crossreferences
\begin{itemize}
\item \code{ompt\_wait\_id\_t} type, see \specref{sec:ompt_wait_id_t}.
\end{itemize}


\omptruntimeentrypoint{\code{ompt\_get\_parallel\_info\_t}} 
\label{sec:ompt_get_parallel_info_t}
\label{sec:ompt_get_parallel_info}

\summary

An OpenMP implementation's tool entry point known as \code{ompt\_get\_parallel\_info} 
with type signature \code{ompt\_get\_parallel\_info\_t} 
returns information about
the parallel region, if any, at the specified ancestor level 
for the current execution context.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_get_parallel_info_t)(
  int \plc{ancestor_level},
  ompt_data_t **\plc{parallel_data},
  int *\plc{team_size}
);
\end{boxedcode}
\ccppspecificend}

\descr
During execution, an OpenMP program may employ nested parallel
regions. 
To obtain information about a parallel region, 
a tool uses an OpenMP implementation's tool entry point known as
\code{ompt\_get\_parallel\_info} 
with type signature \code{ompt\_get\_parallel\_info\_t}. 
This entry point
can be used to obtain information about the current parallel region,
if any, and any enclosing parallel regions
for the current execution context.

The first argument to the entry point specifies the parallel region of
interest to a tool by its ancestor level.
Ancestor level 0 refers to the innermost parallel region; information
about enclosing parallel regions may be obtained using larger
ancestor levels.  The \code{ompt\_get\_parallel\_info} entry point
returns 1 if there is a parallel region at the
specified ancestor level and 0 otherwise. 

If a parallel region exists at the specified ancestor
level, information will be returned in the variables passed by
reference as the second and third arguments to the entry point. 
Specifically, a reference to the parallel region's associated 
data object will be assigned to the pointer passed by reference 
as the second argument and the number of 
threads in the parallel region's team 
will be assigned to the variable passed as the third
argument.

If no enclosing parallel region exists at the specified ancestor
level, the values of variables passed by reference as the second
and third arguments to the entry point will be undefined when the
entry point returns.

A tool may use the pointer to a parallel region's data object that it
obtains from this entry point to inspect or modify the value of the
data object.
When a parallel region is created, its data object will be initialized
with the value \code{ompt\_data\_none}.  

{\em This entry point is async signal safe.}

\constraints
The second and third arguments to the entry point must be references
to variables of the specified types.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see \specref{sec:ompt_data_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_get\_task\_info\_t}}
\label{sec:ompt_get_task_info_t}
\label{sec:ompt_get_task_info}

\summary
An OpenMP implementation's tool entry point known as \code{ompt\_get\_task\_info} 
with type signature \code{ompt\_get\_task\_info\_t} provides information about the
task, if any, at the specified ancestor level in the current execution
context.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_get_task_info_t)(
  int \plc{ancestor_level},
  ompt_task_type_t *\plc{type},
  ompt_data_t **\plc{task_data},
  ompt_frame_t **\plc{task_frame},
  ompt_data_t **\plc{parallel_data},
  int *\plc{thread_num}
);
\end{boxedcode}
\ccppspecificend}

\descr
During execution, an OpenMP thread may be executing an OpenMP task.
Additionally, the thread's stack may contain
procedure frames associated with suspended OpenMP tasks or
OpenMP runtime system routines.
To obtain information about any task on the current thread's stack, 
a tool uses an OpenMP implementation's tool entry point known as
\code{ompt\_get\_task\_info} 
with type signature \code{ompt\_get\_task\_info\_t}. 

Ancestor level 0 refers to the active task; information about
ancestor tasks found in the current execution context may be queried at
higher ancestor levels.  The \code{ompt\_get\_task\_info} entry point
returns 1 if there is a task region at the
specified ancestor level and 0 otherwise. 

If a task exists at the specified ancestor level, information
will be returned in the variables passed by reference to the entry
point.  If no task region exists at the specified ancestor level, the
values of variables passed by reference to the entry point will be
undefined when the entry point returns.

Task types that a tool may observe on a thread's stack include 
initial, implicit, explicit, target, and degenerate tasks. 
In this context, 
a degenerate task indicates a sequence of one or more procedure frames 
from the OpenMP runtime system that appears on a thread's stack between
a pair of stack frames for user procedures that are both associated 
with the same task. 

If the task at the specified ancestor level is degenerate, the
pointer returned in \code{task\_data} will be NULL.  A degenerate
task will be associated with the enclosing parallel region.  

The pointer returned in \code{task\_frame} represents an
\code{ompt\_frame\_t} structure, which
a tool can use to distinguish between frames in the call stack 
associated with user code and those associated with
the OpenMP runtime system.\footnote{A frame 
on the call stack is said to be associated with 
the OpenMP runtime if it is a frame for a runtime system
routine or it belongs to a library function called by a runtime
system routine, directly or indirectly.} 
The \code{enter\_frame} field in this structure contains the
canonical frame pointer for the procedure that invoked 
user code for the task. 
For ancestor levels $>$ 0, the 
\code{exit\_frame} field of
the structure will contain the canonical frame pointer for the 
stack frame of the task procedure that invoked the runtime system to
create a new task. At ancestor level 0, the \code{exit\_frame} may or
may not be non-\code{NULL}. 
By inspecting the tasks on a thread's stack and their associated frame
structures,
a tool can map from an implementation-level view of the call stack
back to a source-level view.
Appendix~\ref{app:frame} discusses an example that
illustrates the use of \code{ompt\_frame\_t} structures with multiple
threads and nested parallelism.

If the thread invoking this function is outside any parallel region,
the pointer returned in \code{parallel\_data} will be NULL.  

The value returned in \code{thread\_num} indicates the number of the
OpenMP thread executing the task in the parallel region to which the
task belongs.

A tool may use a pointer to a data object for a task or parallel
region that it obtains from this entry point to inspect or modify the
value of the data object.  When either a parallel region or a task
region is created, its data object will be initialized with the value
\code{ompt\_data\_none}.

{\em This entry point is async signal safe.}

\constraints
With the exception of \code{ancestor\_level}, which is passed by
value, all other arguments to the entry point must be references
to variables of the specified types.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see \specref{sec:ompt_data_t}.
\item \code{ompt\_frame\_t} type, see \specref{sec:ompt_frame_t}.
\item \code{ompt\_task\_type\_t} type, see
  \specref{sec:ompt_task_type_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_get\_target\_info\_t}}
\label{sec:ompt_get_target_info_t}
\label{sec:ompt_get_target_info}

\summary
An OpenMP implementation's tool entry point known as \code{ompt\_get\_target\_info} 
with type signature \code{ompt\_get\_target\_info\_t} returns identifiers that specify a
thread's current target region and target operation id, if any.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_get_target_info_t)(
  int *\plc{device_id},
  ompt_id_t *\plc{target_id},
  ompt_id_t *\plc{host_op_id}
);
\end{boxedcode}
\ccppspecificend}

\descr
A tool can query whether an OpenMP thread is in a target region by
invoking the entry point known as \code{ompt\_get\_target\_info} 
with type signature \code{ompt\_get\_target\_info\_t}.
This entry point returns 1 if the invoking thread is
in a target region and 0 otherwise. If the entry point returns 0,
the values of the variables passed by reference as its arguments
are undefined.

If the invoking thread is in a target region, the device number for
the target device will be returned in the variable passed by reference
as the first argument and
the identifier for the target region instance will be returned in
the variable passed as the second argument. 
If the invoking thread
is in the process of initiating an operation on a target device
(e.g., copying data to or from an accelerator or launching a kernel)
the identifier for the operation being initiated will be returned in
the variable passed by reference as the third argument; 
otherwise, the third argument will be set to \code{ompt\_id\_none}.

{\em This entry point is async signal safe.}

\constraints

Arguments passed to the entry point must be valid
references to variables of the specified types.

\crossreferences
\begin{itemize}
\item \code{ompt\_id\_t} type, see \specref{sec:ompt_id_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_get\_num\_devices\_t}}
\label{sec:ompt_get_num_devices_t}
\label{sec:ompt_get_num_devices}

\summary
An OpenMP implementation's tool entry point known as \code{ompt\_get\_num\_devices} 
with type signature \code{ompt\_get\_num\_devices\_t} 
returns the number of available devices.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_get_num_devices_t)(void);
\end{boxedcode}
\ccppspecificend}

\descr

An OpenMP program may execute on one or more devices.
A tool may determine the number of devices available to an OpenMP
program by invoking an OpenMP implementation's tool entry point 
known as \code{ompt\_get\_num\_devices} 
with type signature \code{ompt\_get\_num\_devices\_t}.

{\em This entry point is async signal safe.}


\begin{comment}
\omptruntimeentrypoint{\code{ompt\_get\_device\_info\_t}}
\label{sec:ompt_get_device_info_t}
\label{sec:ompt_get_device_info}

\summary
An OpenMP implementation's tool entry point known as \code{ompt\_get\_device\_info} 
with type signature \code{ompt\_get\_device\_info\_t} r
returns information about a specified device.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_get_device_info_t)(
  int32_t \plc{device_id}, 
  const char **\plc{type}, 
  ompt_device_t **\plc{device},
  ompt_function_lookup_t *\plc{lookup},
  const char **\plc{documentation}
);
\end{boxedcode}
\ccppspecificend}

\descr
If \code{device\_id} refers to a valid device, the function will
return \code{true} indicating success; otherwise, it will return
\code{false} and the values of its return parameters are undefined.
The runtime will set \code{*type} to point to a character string
that identifies at a minimum the  type of the device. It might also
indicate the software stack it is running and perhaps even the
version number of one or more components in that stack. An example
string could be ``NVIDIA Tesla M2050, compute capability 2.0, CUDA
5.5.'' A tool can use such a type string to determine if it has any
special knowledge about hardware and software of the specific device.
The OpenMP runtime will set \code{*device} to point to an opaque
object that represents the target device instance. The device pointer
returned will need to be supplied as an argument to calls to
device-specific functions in the target interface to identify the
device being addressed.

The OpenMP runtime will set the value of \code{*lookup} to point
to a function that can be used to look up device-specific API
functions.  The \code{lookup} function for a device will enable a
tool to look up all functions marked \code{OMPT\_TARG\_API}.  If a
named function is not available in an OpenMP runtime's implementation
of OMPT, lookup will return NULL. Documentation for the names and
type signatures of any additional device-specific API functions
available through \code{lookup} should be provided in the form of
a single character string \code{*documentation}. Ideally, the
documentation string should include not only the type signature but
also necessary descriptive text for how to use the device-specific
API or pointers to external documentation.
\end{comment}

\begin{comment}
\omptruntimeentrypoint{\code{ompt\_get\_device\_id\_t}}
\label{sec:ompt_get_device_id_t}
\label{sec:ompt_get_device_id}

\summary
An OpenMP implementation's tool entry point known as \code{ompt\_get\_device\_id} 
with type signature \code{ompt\_get\_device\_id} returns the device
identifier for the active target device.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_get_device_id_t)(void);
\end{boxedcode}
\ccppspecificend}

\descr
This inquiry function is only supported on the host. If the inquiry
function is invoked by a thread not executing in the scope of a
\code{target}, \code{target data}, or \code{target update} construct,
then it will return a value of -1. 

{\em This entry point is async signal safe.}
\end{comment}

\subsection{Entry Points in the OMPT Device Tracing Interface}
\label{sec:ompt-tracing-entry-points}.

\omptruntimeentrypoint{\code{ompt\_get\_device\_time\_t}}
\label{sec:ompt_get_device_time_t}

\summary
An OpenMP implementation's tool entry point for a device known 
as \code{ompt\_get\_device\_time} 
with type signature \code{ompt\_get\_device\_time\_t} 
returns the current time on the specified device.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef ompt_device_time_t (*ompt_get_device_time_t)(
  ompt_device_t *\plc{device}
);
\end{boxedcode}
\ccppspecificend}

\descr
Host and target devices are typically distinct and run independently.
If host and target devices are different hardware components, they
may use different clock generators. For this reason,  there may be
no common time base for ordering host-side and device-side events.

An OpenMP implementation's tool entry point for a device known 
as \code{ompt\_get\_device\_time} with type signature 
\code{ompt\_get\_device\_time\_t} 
returns the current time on the specified device.
A tool can use this information 
to align time stamps from different devices.

\crossreferences
\begin{itemize}
\item \code{ompt\_device\_t},
see \specref{sec:ompt_device_t}.
\item \code{ompt\_device\_time\_t},
see \specref{sec:ompt_device_time_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_translate\_time\_t}}

\summary
An OpenMP implementation's tool entry point for a device known 
as \code{ompt\_translate\_time} 
with type signature \code{ompt\_translate\_time\_t} translates
a time value obtained from the specified device to a corresponding time
value on the host device. 

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef double (*ompt_translate_time_t)(
  ompt_device_t *\plc{device},
  ompt_device_time_t \plc{time}
);
\end{boxedcode}
\ccppspecificend}

\descr
An OpenMP implementation's tool entry point for a device known as \code{ompt\_translate\_time} 
with type signature \code{ompt\_translate\_time\_t} translates
a time value obtained from the specified device to a corresponding time
value on the host device. The returned value for the host time has
the same meaning as the value returned from \code{omp\_get\_wtime}.

\needspace{6\baselineskip}\notestart
\noteheader -- 
The accuracy of time translations may degrade if they are not
performed promptly after a device time value is received if either
the host or device vary their clock speeds. Prompt translation of
device times to host times is recommended.
\noteend

\crossreferences
\begin{itemize}
\item \code{ompt\_device\_t},
see \specref{sec:ompt_device_t}.
\item \code{ompt\_device\_time\_t},
see \specref{sec:ompt_device_time_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_set\_trace\_ompt\_t}}
\label{sec:ompt_set_trace_ompt_t}

\summary
An OpenMP implementation's tool entry point for a device known as \code{ompt\_set\_trace\_ompt} 
with type signature \code{ompt\_set\_trace\_ompt\_t} 
enables or disables the recording of trace records for one or more
types of OMPT events.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_set_trace_ompt_t)(
  ompt_device_t *\plc{device},
  unsigned int \plc{enable},
  unsigned int \plc{etype}
);
\end{boxedcode}
\ccppspecificend}

\constraints
The argument \code{device} identifies the device
whose tracing may be altered by invoking this function.

A positive value for
\code{enable} indicates that recording of one or more events specified 
by \code{etype}
should be enabled; a value of 0 for \code{enable} indicates that
recording of events should be disabled by this invocation.

An \code{etype} value 0 indicates that traces for all event types will be enabled or disabled.  
Passing a positive value for \code{etype} inidicates that recording
should be enabled or disabled for the event in \code{ompt\_event\_t}
that matches \code{etype}.

Table~\ref{table:record_set} shows the possible return
codes for \code{ompt\_set\_trace\_ompt}.  If a single invocation
of \code{ompt\_set\_trace\_ompt} is used to enable or disable
more than one event (i.e., \code{etype}=0), the return code will
be 3 if tracing is possible for one or more events but not for
others.

\begin{table}
\centering
\begin{tabular}{|l|l|}
\hline
return code & meaning \\\hline
0 & error\\\hline
1 & event will never occur\\\hline
2 & event may occur but no tracing is possible\\\hline
3 & event may occur and will be traced when convenient\\\hline
4 & event may occur and will always be traced if event occurs\\\hline
\end{tabular}
\vskip 1ex
\caption{Meaning of return codes for \code{ompt\_trace\_set\_ompt} and
  \code{ompt\_set\_trace\_native}.}
\label{table:record_set}
\end{table}


\crossreferences
\begin{itemize}
\item \code{ompt\_device\_t},
see \specref{sec:ompt_device_t}.
\item \code{ompt\_event\_t},
see \specref{sec:ompt_event_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_set\_trace\_native\_t}}
\label{sec:ompt_set_trace_native_t}

\summary
An OpenMP implementation's tool entry point for a device known as \code{ompt\_set\_trace\_native} 
with type signature \code{ompt\_set\_trace\_native\_t} 
enables or disables the recording of native trace records for a device.


\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_set_trace_native_t)(
  ompt_device_t *\plc{device},
  int \plc{enable},
  int  \plc{flags}
);
\end{boxedcode}
\ccppspecificend}

\descr
This interface is designed for use by a tool with no knowledge about
an attached device. If a tool knows how to program a particular
attached device, it may opt to invoke native control functions
directly using pointers obtained through the \code{lookup} function
associated with the device and described in the \code{documentation}
string that is returned by \code{ompt\_get\_device\_info}.

\constraints
The argument \code{device} is a handle to identify the target device
whose performance monitoring may be altered by invoking this function.
The boolean \code{enable} indicates whether recording of events
should be enabled or disabled by this invocation.  The kinds of
native device monitoring to enable or disable are specified by
\code{flags}. Each kind of monitoring is specified by a flag bit.
Flags can be composed by using logical {\ttfamily or}  to combine enumeration
values from type \code{ompt\_native\_mon\_flags\_t}.
Table~\ref{table:record_set} shows the possible return codes for
\code{ompt\_set\_trace\_native}.  If a single invocation of
\code{ompt\_set\_trace\_ompt} is used to enable/disable more
than one kind of monitoring, the return code will be 3 if tracing
is possible for one or more kinds of monitoring but not for others.


To start, pause, or stop tracing for a specific target device associated with the handle \code{device}, 
a tool calls the functions \code{ompt\_start\_trace}, \code{ompt\_pause\_trace}, or \code{ompt\_stop\_trace}.


\crossreferences
\begin{itemize}
\item \code{ompt\_device\_t},
see \specref{sec:ompt_device_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_start\_trace\_t}}
\label{sec:ompt_start_trace_t}

\summary
An OpenMP implementation's tool entry point for a device known as \code{ompt\_start\_trace} 
with type signature \code{ompt\_start\_trace\_t} 
starts tracing of activity on a specific device.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_start_trace_t)(
  ompt_device_t *\plc{device},
  ompt_buffer_request_callback_t \plc{request},
  ompt_buffer_complete_callback_t \plc{complete},
  ompt_get_target_info_callback_t \plc{get_info}
);
\end{boxedcode}
\ccppspecificend}

\crossreferences
\begin{itemize}
\item \code{ompt\_device\_t},
see \specref{sec:ompt_device_t}.
\item \code{ompt\_buffer\_request\_callback\_t},
see \specref{sec:ompt_buffer_request_callback_t}.
\item \code{ompt\_buffer\_complete\_callback\_t},
see \specref{sec:ompt_buffer_complete_callback_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_pause\_trace\_t}}
\label{sec:ompt_pause_trace_t}

\summary
An OpenMP implementation's tool entry point for a device known as \code{ompt\_pause\_trace} 
with type signature \code{ompt\_pause\_trace\_t} 
pauses or restarts activity tracing on a specific device.

\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_pause_trace_t)(
  ompt_device_t *\plc{device},
  int \plc{begin_pause}
);
\end{boxedcode}
\ccppspecificend}

\crossreferences
\begin{itemize}
\item \code{ompt\_device\_t},
see \specref{sec:ompt_device_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_stop\_trace\_t}}
\label{sec:ompt_stop_trace_t}

\summary
An OpenMP implementation's tool entry point for a device known as \code{ompt\_stop\_trace} 
with type signature \code{ompt\_stop\_trace\_t} 
stops tracing for a device.

\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_stop_trace_t)(
  ompt_device_t *\plc{device}
);
\end{boxedcode}
\ccppspecificend}

\descr
Each invocation returns 1 if the command succeeded and 0 otherwise.
A call to \code{ompt\_stop\_trace} also implicitly requests that the device flush any buffers that it owns.

%%? johnmc says: we should export one more function from a target device: ompt_target_scope(begin/end, host_id)
%% this function will be used by the OpenMP runtime when a target device is being monitored to signal the target device when 
%% (1) entering and leaving a target region
%% (2) before and after launching a kernel
%% (3) before and after performing a data operation: copy, allocation, release, ...
%% this function will enable the target device to associate device_activity_ids with some host_id that either represents a 
%% target region, target data operation, or target kernel submission

\crossreferences
\begin{itemize}
\item \code{ompt\_device\_t},
see \specref{sec:ompt_device_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_advance\_buffer\_cursor\_t}}
\label{sec:ompt_advance_buffer_cursor_t}

%There are several routines that need to be used together to process %target event records deposited in a buffer by a device. 

\summary
An OpenMP implementation's tool entry point for a device known as \code{ompt\_advance\_buffer\_cursor} 
with type signature \code{ompt\_advance\_buffer\_cursor\_t}
advances a trace buffer cursor to the next record.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef int (*ompt_advance_buffer_cursor_t)(
  ompt_buffer_t *\plc{buffer},
  size_t \plc{size}, 
  ompt_buffer_cursor_t \plc{current}, 
  ompt_buffer_cursor_t *\plc{next}
); 
\end{boxedcode}
\ccppspecificend}

\descr
It returns \code{true} if the advance is successful and the returned value \code{*next} is valid.

\crossreferences
\begin{itemize}
\item \code{ompt\_device\_t},
see \specref{sec:ompt_device_t}.
\item \code{ompt\_buffer\_cursor\_t},
see \specref{sec:ompt_buffer_cursor_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_buffer\_get\_record\_type\_t}}
\label{sec:ompt_buffer_get_record_type_t}

\summary
An OpenMP implementation's tool entry point for a device known as
\code{ompt\_buffer\_get\_record\_type} with type signature
\code{ompt\_buffer\_get\_record\_type\_t} inspects the type
of a trace record for a device.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef ompt_record_type_t (*ompt_buffer_get_record_type_t)(
  ompt_buffer_t *\plc{buffer}, 
  ompt_buffer_cursor_t \plc{current}
);
\end{boxedcode}
\ccppspecificend}

\descr

Trace records for a device may be in one of two forms: a
\emph{native} record format, which may be device-specific,
or an \emph{OMPT} record format, where each trace record 
corresponds to an OpenMP \emph{event} and fields in the record
structure are mostly the arguments that would be passed to the
OMPT callback for the event. 

An OpenMP implementation's tool entry point for a device known as
\code{ompt\_buffer\_get\_record\_type} with type signature
\code{ompt\_buffer\_get\_record\_type\_t} inspects the type
of a trace record and indicates whether the record at the current
position in the provided trace buffer is an OMPT record, 
a native record, or an invalid record. An invalid record type
is returned if the cursor is out of bounds.

\begin{comment}
\crossreferences
Appendix~\ref{appendix:ompt-records} defines the corresponding enumeration type for \code{ompt\_record\_kind\_t}. 
Section~\ref{sec:native-record-data} describes the interface to use for accessing native record types.
\end{comment}


\crossreferences
\begin{itemize}
\item \code{ompt\_buffer\_t},
see \specref{sec:ompt_buffer_t}.
\item \code{ompt\_buffer\_cursor\_t},
see \specref{sec:ompt_buffer_cursor_t}.
\item \code{ompt\_record\_type\_t},
see \specref{sec:ompt_record_type_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_buffer\_get\_record\_ompt\_t}}
\label{sec:ompt_buffer_get_record_ompt_t}
 
\summary
An OpenMP implementation's tool entry point for a device known as \code{ompt\_buffer\_get\_record\_ompt} 
with type signature \code{ompt\_buffer\_get\_record\_ompt\_t} 
obtains a pointer to an OMPT trace record from a trace buffer associated with a device.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef ompt_record_ompt_t *(*ompt_buffer_get_record_ompt_t)(
  ompt_buffer_t *\plc{buffer}, 
  ompt_buffer_cursor_t \plc{current}
);
\end{boxedcode}
\ccppspecificend}

\descr

This function returns a pointer that may point to a record in the trace
buffer, or it may point to a record in thread local storage where the information
extracted from a record was assembled. The information available
for an event depends upon its type. 

The return value of type \code{ompt\_record\_ompt\_t} 
defines a union type that can represent
information for any OMPT event record type.
Another call to the entry point may overwrite the
contents of the fields in a record returned by a prior invocation.

\crossreferences
\begin{itemize}
\item \code{ompt\_device\_t},
see \specref{sec:ompt_device_t}.
\item \code{ompt\_buffer\_cursor\_t},
see \specref{sec:ompt_buffer_cursor_t}.
\item \code{ompt\_record\_ompt\_t},
see \specref{sec:ompt_record_ompt_t}. 
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_buffer\_get\_record\_native\_t}}
\label{sec:ompt_buffer_get_record_native_t}

\summary

An OpenMP implementation's tool entry point for a device known as
\code{ompt\_buffer\_get\_record\_native} with type signature
\code{ompt\_buffer\_get\_record\_native\_t} 
obtains a pointer to a native trace record from a trace buffer associated with a device.

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef void *(ompt_buffer_get_record_native_t)(
  ompt_buffer_t *\plc{buffer}, 
  ompt_buffer_cursor_t \plc{current},
  ompt_id_t *\plc{host_op_id}
);
\end{boxedcode}
\ccppspecificend}

\descr

The pointer returned  may point into the specified trace buffer, or into
thread local storage where the information extracted from a trace
record was assembled. The information available for a native event
depends upon its type. If the function returns a non-NULL result,
it will also set \code{*host\_op\_id} to identify host-side identifier
for the operation associated with the record.  A subsequent call
to \code{ompt\_buffer\_get\_record\_native} may overwrite the
contents of the fields in a record returned by a prior invocation.


\crossreferences
\begin{itemize}
\item \code{ompt\_buffer\_t},
see \specref{sec:ompt_buffer_t}.
\item \code{ompt\_buffer\_cursor\_t},
see \specref{sec:ompt_buffer_cursor_t}.
\item \code{ompt\_id\_t},
see \specref{sec:ompt_id_t}.
\end{itemize}

\omptruntimeentrypoint{\code{ompt\_buffer\_get\_record\_native\_abstract\_t}}
\label{sec:ompt_buffer_get_record_native_abstract_t}

\summary
An OpenMP implementation's tool entry point for a device known as
\code{ompt\_buffer\_get\_record\_native\_abstract} 
with type signature
\code{ompt\_buffer\_get\_record\_native\_abstract\_t} 
summarizes the context of a native (device-specific) trace record.  

\format
\vbox{\ccppspecificstart
\begin{boxedcode}
typedef ompt_record_native_abstract_t *
(*ompt_buffer_get_record_native_abstract_t)(
  void *\plc{native_record} 
);
\end{boxedcode}
\ccppspecificend}

\descr
An OpenMP implementation may execute on a device that logs 
trace records in a native (device-specific) format unknown to a tool.
A tool can use an OpenMP implementation's tool entry point for the
device known as
\code{ompt\_buffer\_get\_record\_native\_abstract} 
with type signature
\code{ompt\_buffer\_get\_record\_native\_abstract\_t} 
to decode a native trace record that it
does not understand into a standard form that it can interpret. 

\crossreferences
\begin{itemize}
\item \code{ompt\_record\_native\_abstract\_t},
see \specref{sec:ompt_record_native_abstract_t}.
\end{itemize}

\subsection{Lookup Entry Point}

\omptruntimeentrypoint{\code{ompt\_function\_lookup\_t}}
\label{sec:ompt_function_lookup_t}
\label{sec:ompt_function_lookup}

\summary
A tool uses a lookup routine with type signature 
\code{ompt\_function\_lookup\_t}
to obtain pointers to entry points that are
part of an OpenMP implementation's OMPT interface.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef ompt_interface_fn_t (*\plc{ompt_function_lookup_t}) (
  const char *\plc{interface_function_name}
);
\end{boxedcode}
\ccppspecificend
}

\descr

An OpenMP implementation provides a pointer to a lookup routine as an
argument to tool callbacks used to initialize tool support for
monitoring an OpenMP device using either tracing or callbacks.

\begin{comment}
When an OpenMP runtime implementation is initialized for a device,
if a tool callback to initialize tracing for devices has been provided
to the OpenMP implementation by \verb|ompt_tool|, 
it will be invoked on the host. The OpenMP implementation will pass the
tool's device tracing initializer callback a lookup routine that the tool
can use to obtain pointers to runtime entry points that implement
tracing control routines appropriate for that device. 

If a tool callback to initialize monitoring using the OMPT callback
interface has been provided to the OpenMP implementation by
\verb|ompt_tool| and it is invoked on a device,
the initializer will be passed a lookup function to   
obtain pointers to runtime entry points that implement
routines used by the OpenMP implementation's callback interface.
\end{comment}

When an OpenMP implementation invokes a tool initializer to configure
the OMPT callback interface, the OpenMP implementation will pass the
initializer a lookup function that the tool can use to obtain 
pointers to entry points that implement routines that are part of 
the OpenMP implementation's callback interface.

When an OpenMP implementation invokes a tool initializer to configure
the OMPT tracing interface for a device, the Open implementation will
pass the device tracing initializer a lookup function that the tool
can use to obtain pointers to entry points that implement
tracing control routines appropriate for that device. 

\constraints
A lookup routine with type
signature \code{ompt\_function\_lookup\_t} takes a C string
that represents the name of an entry point in an interface
and returns a pointer to the corresponding entry point.

\crossreferences
\begin{itemize}
\item Tool initializer for the OMPT callback interface, \specref{sec:ompt_initialize_fn_t}
\item Entry points in the OMPT callback interface, see
  \tabref{table:ompt-callback-interface-functions} for a list and
  \specref{sec:ompt-callback-entry-points} for detailed definitions.
\item Tool initializer for a device's OMPT tracing interface, \specref{sec:ompt_event_device_initialize}.
\item Entry points in the OMPT tracing interface, see
  \tabref{table:ompt-tracing-interface-functions} for a list and
  \specref{sec:ompt-tracing-entry-points} for detailed definitions.
\end{itemize}

\begin{table}
{\small
\begin{tabular}{ll}\hline
Function name & Type signature\\\hline\hline
\code{ompt\_get\_device\_time} & \code{ompt\_get\_device\_time\_t}\\
\code{ompt\_translate\_time} & \code{ompt\_translate\_time\_t}\\
\code{ompt\_set\_trace\_ompt} & \code{ompt\_set\_trace\_ompt\_t}\\
\code{ompt\_set\_trace\_native} & \code{ompt\_set\_trace\_native\_t}\\
\code{ompt\_start\_trace} & \code{ompt\_start\_trace\_t}\\
\code{ompt\_pause\_trace} & \code{ompt\_pause\_trace\_t}\\
\code{ompt\_stop\_trace} & \code{ompt\_stop\_trace\_t}\\
\code{ompt\_advance\_buffer\_cursor} & \code{ompt\_advance\_buffer\_cursor\_t}\\
\code{ompt\_buffer\_get\_record\_type} & \code{ompt\_buffer\_get\_record\_type\_t}\\
\code{ompt\_buffer\_get\_record\_ompt} & \code{ompt\_buffer\_get\_record\_ompt\_t}\\
\code{ompt\_buffer\_get\_record\_native} & \code{ompt\_buffer\_get\_record\_native\_t}\\
\code{ompt\_buffer\_get\_record\_native\_abstract} & \code{ompt\_buffer\_get\_record\_native\_abstract\_t}\\\hline
\end{tabular}
}
\vskip 1ex
\caption{OMPT tracing interface entry point names and their type signatures.}
\label{table:ompt-tracing-interface-functions} 
\end{table}

% This is the end of ch4-toolsSupport.tex
