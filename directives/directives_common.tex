% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. There are environments that provide special formatting, e.g. language bars.
%       Please use them whereever appropriate.  Examples are:
%
%         \begin{fortranspecific}
%         This is text that appears enclosed in blue language bars for Fortran.
%         \end{fortranspecific}
%
%         \begin{note}
%         This is a note.  The "Note -- " header appears automatically.
%         \end{note}
%
%    6. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of 
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%


\section{Directive Format}
\label{sec:Directive Format}
\index{directive format}
\begin{ccppspecific}
OpenMP directives for C/C++ are specified with the \code{pragma} preprocessing directive. 
The syntax of an OpenMP directive is as follows:

\begin{boxedcode}
\#pragma\plc{ }omp\plc{ directive-name [clause[ [},\plc{] clause] ... ] new-line}
\end{boxedcode}

Each directive  starts with \code{\#pragma} \code{omp}. The remainder of the directive follows the 
conventions of the C and C++ standards for compiler directives. In particular, white 
space can be used before and after the \code{\#}, and sometimes white space must be used to 
separate the words in a directive. Preprocessing tokens following the \code{\#pragma} \code{omp}
are subject to macro replacement. 

Some OpenMP directives may be composed of consecutive \code{\#pragma} preprocessing 
directives if specified in their syntax.

Directives are case-sensitive. 

An OpenMP executable directive applies to at most one succeeding statement, which 
must be a structured block.
\end{ccppspecific}

\begin{fortranspecific}
OpenMP directives for Fortran are specified as follows:

\begin{boxedcode}
\plc{sentinel directive-name [clause[ [},\plc{] clause]...]}
\end{boxedcode}

All OpenMP compiler directives must begin with a directive \emph{sentinel}. The format of a 
sentinel differs between fixed and free-form source files, as described in 
\specref{subsec:Fixed Source Form Directives} and \specref{subsec:Free Source Form Directives}.

Directives are case insensitive. Directives cannot be embedded within continued 
statements, and statements cannot be embedded within directives.

In order to simplify the presentation, free form is used for the syntax of OpenMP 
directives for Fortran in the remainder of this document, except as noted.
\end{fortranspecific}

Only one \emph{directive-name} can be specified per directive (note that this includes combined 
directives, see \specref{sec:Combined Constructs}).  The order in which clauses appear on directives 
is not significant. Clauses on directives may be repeated as needed, subject to the 
restrictions listed in the description of each clause.

Some data-sharing attribute clauses (\specref{subsec:Data-Sharing Attribute Clauses}), 
data copying clauses (\specref{subsec:Data Copying Clauses}), the 
\code{threadprivate} directive (\specref{subsec:threadprivate Directive}), 
the \code{flush} directive (\specref{subsec:flush Construct}), and the 
\code{link} clause of the \code{declare}~\code{target} directive 
(\specref{subsec:declare target Directive}) accept a \emph{list}. The 
\code{to} clause of the \code{declare}~\code{target} directive 
(\specref{subsec:declare target Directive}) accepts an \plc{extended-list}. 
The \code{depend} clause (\specref{subsec:depend Clause}), when used to specify task dependences,
accepts a \plc{locator-list}.  A \plc{list} consists of a
comma-separated collection of one or more \plc{list items}. A
\plc{extended-list} consists of a comma-separated collection of one or more
\plc{extended list items}. A \plc{locator-list} consists of a comma-separated
collection of one or more \plc{locator list items}.

\begin{ccppspecific}
A \plc{list item} is a variable or array section. An \plc{extended list item} is a \plc{list
item} or a function name.  A \plc{locator list item} is any \plc{lvalue}
expression, including variables, or an array section.
\end{ccppspecific}

\begin{fortranspecific}
A \plc{list item} is a variable, array section or common block name 
(enclosed in slashes). An \plc{extended list item} is a \plc{list item} 
or a procedure name. A \plc{locator list item} is a \plc{list item}.

When a named common block appears in a \plc{list}, it has the same
meaning as if every explicit member of the common block appeared in
the list.  An explicit member of a common block is a variable that is
named in a \code{COMMON} statement that specifies the common block
name and is declared in the same scoping unit in which the clause
appears.

Although variables in common blocks can be accessed by use association
or host association, common block names cannot.  As a result, a common
block name specified in a data-sharing attribute, a data copying or
a data-mapping attribute clause must be declared to be a common block in
the same scoping unit in which the clause appears.
\end{fortranspecific}

For all base languages, a \plc{list item}  or an \plc{extended list item}
is subject to the restrictions specified in \specref{sec:Array Sections} 
and in each of the sections describing clauses and directives for which 
the \plc{list} or \plc{extended-list} appears.



\pagebreak
% Force the blue floater bar down, and force the subsection header up, to
% bring the blue bar closer to the header:
\vspace{2\baselineskip}
\begin{fortranspecific}
\vspace{-3\baselineskip}
\subsection{Fixed Source Form Directives}
\label{subsec:Fixed Source Form Directives}
\index{fixed source form directives}
The following sentinels are recognized in fixed form source files:

\begin{boxedcode}
!\$omp \textnormal{|} c\$omp \textnormal{|} *\$omp
\end{boxedcode}

Sentinels must start in column 1 and appear as a single word with no intervening 
characters. Fortran fixed form line length, white space, continuation, and column rules 
apply to the directive line. Initial directive lines must have a space or zero in column 6, 
and continuation directive lines must have a character other than a space or a zero in 
column 6.

Comments may appear on the same line as a directive. The exclamation point initiates a 
comment when it appears after column 6. The comment extends to the end of the source 
line and is ignored. If the first non-blank character after the directive sentinel of an 
initial or continuation directive line is an exclamation point, the line is ignored.

\begin{note}
in the following example, the three formats for specifying the directive are 
equivalent (the first line represents the position of the first 9 columns):

\begin{alltt}
\code{c23456789
!\$omp parallel do shared(a,b,c)

c\$omp parallel do
c\$omp+shared(a,b,c)

c\$omp paralleldoshared(a,b,c)}
\end{alltt}
\end{note}










\subsection{Free Source Form Directives}
\label{subsec:Free Source Form Directives}
\index{free source form directives}

The following sentinel is recognized in free form source files:

\begin{boxedcode}
!\$omp
\end{boxedcode}

The sentinel can appear in any column as long as it is preceded only by white space 
(spaces and tab characters). It must appear as a single word with no intervening 
character. Fortran free form line length, white space, and continuation rules apply to the 
directive line. Initial directive lines must have a space after the sentinel. Continued 
directive lines must have an ampersand (\code{\&}) as the last non-blank character on the line, 
prior to any comment placed inside the directive. Continuation directive lines can have 
an ampersand after the directive sentinel with optional white space before and after the 
ampersand.

Comments may appear on the same line as a directive. The exclamation point (\code{!}) 
initiates a comment. The comment extends to the end of the source line and is ignored. 
If the first non-blank character after the directive sentinel is an exclamation point, the 
line is ignored.

One or more blanks or horizontal tabs must be used to separate adjacent keywords in 
directives in free source form, except in the following cases, where white space is 
optional between the given set of keywords:

% blue line floater at top of this page for "Fortran, cont."
\begin{figure}[t!]
\linewitharrows{-1}{dashed}{Fortran (cont.)}{8em}
\end{figure}

\begin{indentedcodelist}
declare reduction
declare simd
declare target
distribute parallel do
distribute parallel do simd
distribute simd
do simd
end atomic
end critical
end distribute 
end distribute parallel do
end distribute parallel do simd
\end{indentedcodelist}
\pagebreak
% blue line floater at top of this page for "Fortran, cont."
\begin{figure}[t!]
\linewitharrows{-1}{dashed}{Fortran (cont.)}{8em}
\end{figure}
\begin{indentedcodelist}
end distribute simd
end do
end do simd
end master
end ordered
end parallel
end parallel do
end parallel do simd
end parallel sections
end parallel workshare
end sections
end simd
end single
end target
end target data
end target parallel
end target parallel do
end target parallel do simd
end target simd
end target teams
end target teams distribute
end target teams distribute parallel do
end target teams distribute parallel do simd
end target teams distribute simd
end task
end taskgroup
end taskloop
\end{indentedcodelist}
\pagebreak
% blue line floater at top of this page for "Fortran, cont."
\begin{figure}[t!]
\linewitharrows{-1}{dashed}{Fortran (cont.)}{8em}
\end{figure}
\begin{indentedcodelist}
end taskloop simd
end teams
end teams distribute
end teams distribute parallel do
end teams distribute parallel do simd
end teams distribute simd
end workshare
parallel do
parallel do simd
parallel sections
parallel workshare
target data
target enter data
target exit data
target parallel
target parallel do
target parallel do simd
target simd
target teams
target teams distribute
target teams distribute parallel do
target teams distribute parallel do simd
target teams distribute simd
target update
taskloop simd
teams distribute
teams distribute parallel do
teams distribute parallel do simd
teams distribute simd
\end{indentedcodelist}

\begin{note}
in the following example the three formats for specifying the directive are 
equivalent (the first line represents the position of the first 9 columns):

\begin{alltt}\code{!23456789
       !\$omp parallel do \&
                 !\$omp shared(a,b,c)

       !\$omp parallel \&
      !\$omp\&do shared(a,b,c)

!\$omp paralleldo shared(a,b,c)}
\end{alltt}
\end{note}
\bigskip
\end{fortranspecific}








\subsection{Stand-Alone Directives}
\label{subsec:Stand-Alone Directives}
\index{stand-alone directives}
\summary
Stand-alone directives are executable directives that have no associated user code.

\descr
Stand-alone directives do not have any associated executable user code. Instead, they 
represent executable statements that typically do not have succinct equivalent statements 
in the base languages. There are some restrictions on the placement of a stand-alone 
directive within a program. A stand-alone directive may be placed only at a point where 
a base language executable statement is allowed.

\restrictions
\begin{ccppspecific}
For C/C++, a stand-alone directive may not be used in place of the statement following 
an \code{if}, \code{while}, \code{do}, \code{switch}, or \code{label}. 
\end{ccppspecific}

\begin{fortranspecific}
For Fortran, a stand-alone directive may not be used as the action statement in an \code{if} 
statement or as the executable statement following a label if the label is referenced in 
the program.
\end{fortranspecific}









\section{Conditional Compilation}
\label{sec:Conditional Compilation}
\index{conditional compilation}
\index{_OPENMP@{\code{\_OPENMP} macro}}
In implementations that support a preprocessor, the \code{\_OPENMP} macro name is defined to 
have the decimal value \plc{yyyymm} where \plc{yyyy} and \plc{mm} are the year and month designations 
of the version of the OpenMP API that the implementation supports. 

If this macro is the subject of a \code{\#define} or a \code{\#undef} preprocessing directive, the 
behavior is unspecified.

\begin{fortranspecific}
The OpenMP API requires Fortran lines to be compiled conditionally, as described in 
the following sections.








\subsection{Fixed Source Form Conditional Compilation Sentinels}
\label{subsec:Fixed Source Form Conditional Compilation Sentinels}
\index{fixed source form conditional compilation sentinels}
\index{compilation sentinels}
The following conditional compilation sentinels are recognized in fixed form source 
files:

\begin{boxedcode}
!\$ \textnormal{|} *\$ \textnormal{|} c\$
\end{boxedcode}

To enable conditional compilation, a line with a conditional compilation sentinel must 
satisfy the following criteria: 

\begin{itemize}
\item The sentinel must start in column 1 and appear as a single word with no intervening 
white space. 

\item After the sentinel is replaced with two spaces, initial lines must have a space or zero 
in column 6 and only white space and numbers in columns 1 through 5.

\item After the sentinel is replaced with two spaces, continuation lines must have a 
character other than a space or zero in column 6 and only white space in columns 1 
through 5.
\end{itemize}

If these criteria are met, the sentinel is replaced by two spaces. If these criteria are not 
met, the line is left unchanged.

\begin{note}
in the following example, the two forms for specifying conditional compilation 
in fixed source form are equivalent (the first line represents the position of the first 9 
columns):

\begin{alltt}\code{c23456789
!\$ 10 iam = omp\_get\_thread\_num() +
!\$   \&          index

\#ifdef \_OPENMP
   10 iam = omp\_get\_thread\_num() +
     \&            index
\#endif}
\end{alltt}
\end{note}



% blue line floater at top of this page for "Fortran, cont."
\begin{figure}[t!]
\linewitharrows{-1}{dashed}{Fortran (cont.)}{8em}
\end{figure}





\subsection{Free Source Form Conditional Compilation Sentinel}
\label{subsec:Free Source Form Conditional Compilation Sentinel}
\index{free source form conditional compilation sentinel}
\index{compilation sentinels}
The following conditional compilation sentinel is recognized in free form source files:

\begin{boxedcode}
!\$
\end{boxedcode}

To enable conditional compilation, a line with a conditional compilation sentinel must 
satisfy the following criteria: 

\begin{itemize}
\item The sentinel can appear in any column but must be preceded only by white space.

\item The sentinel must appear as a single word with no intervening white space. 

\item Initial lines must have a space after the sentinel. 

\item Continued lines must have an ampersand as the last non-blank character on the line, 
prior to any comment appearing on the conditionally compiled line. Continuation lines 
can have an ampersand after the sentinel, with optional white space before and after 
the ampersand. 
\end{itemize}

If these criteria are met, the sentinel is replaced by two spaces. If these criteria are not 
met, the line is left unchanged. 

\begin{note}
in the following example, the two forms for specifying conditional compilation 
in free source form are equivalent (the first line represents the position of the first 9 
columns):

\begin{alltt}\code{c23456789
 !\$ iam = omp\_get\_thread\_num() +     \&
 !\$\&    index

\#ifdef \_OPENMP
    iam = omp\_get\_thread\_num() +     \&
        index
\#endif}
\end{alltt}
\end{note}
\bigskip
\end{fortranspecific}









\section{Internal Control Variables}
\label{sec:Internal Control Variables}
\index{internal control variables (ICVs)}
\index{ICVs (internal control variables)}
An OpenMP implementation must act as if there are internal control variables (ICVs) 
that control the behavior of an OpenMP program. These ICVs store information such as 
the number of threads to use for future \code{parallel} regions, the schedule to use for 
worksharing loops and whether nested parallelism is enabled or not. The ICVs are given 
values at various times (described below) during the execution of the program. They are 
initialized by the implementation itself and may be given values through OpenMP 
environment variables and through calls to OpenMP API routines. The program can 
retrieve the values of these ICVs only through OpenMP API routines.

For purposes of exposition, this document refers to the ICVs by certain names, but an 
implementation is not required to use these names or to offer any way to access the 
variables other than through the ways shown in 
\specref{subsec:ICV Initialization}.








\subsection{ICV Descriptions}
\label{subsec:ICV Descriptions}
The following ICVs store values that affect the operation of \code{parallel} regions.

\begin{itemize}
\item \plc{dyn-var} - controls whether dynamic adjustment of the number of threads is enabled 
for encountered \code{parallel} regions. There is one copy of this ICV per data 
environment. 

\item \plc{nest-var} - controls whether nested parallelism is enabled for encountered \code{parallel} 
regions. There is one copy of this ICV per data environment. 

\item \plc{nthreads-var} - controls the number of threads requested for encountered \code{parallel} 
regions. There is one copy of this ICV per data environment. 

\item \plc{thread-limit-var} - controls the maximum number of threads participating in the 
contention group. There is one copy of this ICV per data environment. 

\item \plc{max-active-levels-var} - controls the maximum number of nested active \code{parallel} 
regions. There is one copy of this ICV per device.

\item \plc{place-partition-var} â€“ controls the place partition available to the execution 
environment for encountered \code{parallel} regions. There is one copy of this ICV per 
implicit task.

\item \plc{active-levels-var} - the number of nested, active parallel regions enclosing the current 
task such that all of the \code{parallel} regions are enclosed by the outermost initial task 
region on the current device. There is one copy of this ICV per data environment.

\item \plc{levels-var} - the number of nested parallel regions enclosing the current task such that 
all of the \code{parallel} regions are enclosed by the outermost initial task region on the 
current device. There is one copy of this ICV per data environment. 

\item \plc{bind-var} - controls the binding of OpenMP threads to places. When binding is 
requested, the variable indicates that the execution environment is advised not to 
move threads between places. The variable can also provide default thread affinity 
policies. There is one copy of this ICV per data environment. 
\end{itemize}

The following ICVs store values that affect the operation of loop regions.

\begin{itemize}
\item \plc{run-sched-var} - controls the schedule that the \code{runtime} schedule clause uses for 
loop regions. There is one copy of this ICV per data environment.

\item \plc{def-sched-var} - controls the implementation defined default scheduling of loop 
regions. There is one copy of this ICV per device. 
\end{itemize}

The following ICVs store values that affect program execution.

\begin{itemize}
\item \plc{stacksize-var} - controls the stack size for threads that the OpenMP implementation 
creates. There is one copy of this ICV per device. 

\item \plc{wait-policy-var} - controls the desired behavior of waiting threads. There is one copy 
of this ICV per device. 

\item \plc{cancel-var} - controls the desired behavior of the \code{cancel} construct and cancellation 
points. There is one copy of this ICV for the whole program.

\item \plc{default-device-var} - controls the default target device. There is one copy of this ICV 
per data environment.

\item \plc{max-task-priority-var} - controls the maximum priority value that can be specified in the
\code{priority} clause of the \code{task} construct. There is one copy of this ICV for the whole program.

\end{itemize}

The following ICVs store values that affect the operation of the tool interface.

\begin{itemize}

\item \plc{tool-var} - determines whether an OpenMP implementation will 
try to register a tool.  There is one copy of this ICV for the whole program.

\item \plc{tool-libraries-var} - specifies a list of absolute paths to tool libraries for OpenMP devices.
There is one copy of this ICV for the whole program.

\end{itemize}






\subsection{ICV Initialization}
\label{subsec:ICV Initialization}
\index{modifying ICV's}
Table~\ref{tab:ICV Initial Values} shows the ICVs, associated 
environment variables, and initial values.

%% HACK ADDED TO KEEP TABLE HEADING WITH THE TABLE
\newpage

\nolinenumbers
\renewcommand{\arraystretch}{1.5}
\tablefirsthead{%
\hline
\textsf{\textbf{ICV}} & \textsf{\textbf{Environment Variable}} & \textsf{\textbf{Initial value}}\\
\hline\\[-3ex]
}
\tablehead{%
\multicolumn{2}{l}{\small\slshape table continued from previous page}\\
\hline
\textsf{\textbf{ICV}} & \textsf{\textbf{Environment Variable}} & \textsf{\textbf{Initial value}}\\
\hline\\[-3ex]
}
\tabletail{%
\hline\\[-4ex]
\multicolumn{2}{l}{\small\slshape table continued on next page}\\
}
\tablelasttail{\hline}
\tablecaption{ICV Initial Values\label{tab:ICV Initial Values}}
\begin{supertabular}{p{1.3in} p{1.7in} p{1.5in}}
\plc{dyn-var} & \code{OMP\_DYNAMIC} & See description below\\
\plc{nest-var} & \code{OMP\_NESTED} & \plc{false}\\
\plc{nthreads-var} & \code{OMP\_NUM\_THREADS} & Implementation defined\\
\plc{run-sched-var} & \code{OMP\_SCHEDULE} & Implementation defined\\
\plc{def-sched-var} & (none) & Implementation defined\\
\plc{bind-var} & \code{OMP\_PROC\_BIND} & Implementation defined\\
\plc{stacksize-var} & \code{OMP\_STACKSIZE} & Implementation defined\\
\plc{wait-policy-var} & \code{OMP\_WAIT\_POLICY} & Implementation defined\\
\plc{thread-limit-var} & \code{OMP\_THREAD\_LIMIT} & Implementation defined\\
\plc{max-active-levels-var} & \code{OMP\_MAX\_ACTIVE\_LEVELS} & See description below\\
\plc{active-levels-var} & (none) & \plc{zero}\\
\plc{levels-var} & (none) & \plc{zero}\\
\plc{place-partition-var} & \code{OMP\_PLACES} & Implementation defined\\
\plc{cancel-var} & \code{OMP\_CANCELLATION} & \plc{false}\\
\plc{default-device-var} & \code{OMP\_DEFAULT\_DEVICE} & Implementation defined\\
\plc{max-task-priority-var} & \code{OMP\_MAX\_TASK\_PRIORITY} & \plc{zero}\\
\plc{tool-var} & \code{OMP\_TOOL} & \plc{enabled}\\
\plc{tool-libraries-var} & \code{OMP\_TOOL\_LIBRARIES} & \plc{empty string}\\
\end{supertabular}
\linenumbers

\descr
\begin{itemize}
\item Each device has its own ICVs.

\item The value of the \plc{nthreads-var} ICV is a list. 

\item The value of the \plc{bind-var} ICV is a list. 

\item The initial value of \plc{dyn-var} is implementation defined if the implementation supports 
dynamic adjustment of the number of threads; otherwise, the initial value is \plc{false}. 

\item The initial value of \plc{max-active-levels-var} is the number of levels of parallelism that 
the implementation supports. See the definition of \emph{supporting n levels of parallelism}
in \specref{subsec:Implementation Terminology} for further details.
\end{itemize}

The host and target device ICVs are initialized before any OpenMP API construct or 
OpenMP API routine executes. After the initial values are assigned, the values of any 
OpenMP environment variables that were set by the user are read and the associated 
ICVs for the host device are modified accordingly. The method for initializing a target 
device's ICVs is implementation defined.

\crossreferences
\begin{itemize}
\item \code{OMP\_SCHEDULE} environment variable, see \specref{sec:OMP_SCHEDULE}.

\item \code{OMP\_NUM\_THREADS} environment variable, see \specref{sec:OMP_NUM_THREADS}.

\item \code{OMP\_DYNAMIC} environment variable, see \specref{sec:OMP_DYNAMIC}.

\item \code{OMP\_PROC\_BIND} environment variable, see \specref{sec:OMP_PROC_BIND}.

\item \code{OMP\_PLACES} environment variable, see \specref{sec:OMP_PLACES}.

\item \code{OMP\_NESTED} environment variable, see \specref{sec:OMP_NESTED}.

\item \code{OMP\_STACKSIZE} environment variable, see \specref{sec:OMP_STACKSIZE}. 

\item \code{OMP\_WAIT\_POLICY} environment variable, see \specref{sec:OMP_WAIT_POLICY}. 

\item \code{OMP\_MAX\_ACTIVE\_LEVELS} environment variable, see \specref{sec:OMP_MAX_ACTIVE_LEVELS}.

\item \code{OMP\_THREAD\_LIMIT} environment variable, see \specref{sec:OMP_THREAD_LIMIT}.

\item \code{OMP\_CANCELLATION} environment variable, see \specref{sec:OMP_CANCELLATION}.

\item \code{OMP\_DEFAULT\_DEVICE} environment variable, see \specref{sec:OMP_DEFAULT_DEVICE}.

\item \code{OMP\_MAX\_TASK\_PRIORITY} environment variable, see \specref{sec:OMP_MAX_TASK_PRIORITY}.

\item \code{OMP\_TOOL} environment variable, see \specref{sec:OMP_TOOL}.

\item \code{OMP\_TOOL\_LIBRARIES} environment variable, see \specref{sec:OMP_TOOL_LIBRARIES}.
\end{itemize}








\subsection{Modifying and Retrieving ICV Values}
\label{subsec:Modifying and Retrieving ICV Values}
\index{modifying and retrieving ICV values}
Table~\ref{tab:Ways to Modify and to Retrieve ICV Values} shows the method for modifying and retrieving the values of ICVs 
through OpenMP API routines.

\newpage %% HACK
{\small%
\nolinenumbers
\renewcommand{\arraystretch}{1.5}
\tablefirsthead{%
\hline
\textsf{\textbf{ICV}} & \textsf{\textbf{Ways to modify value}} & \textsf{\textbf{Ways to retrieve value}}\\
\hline\\[-3ex]
}
\tablehead{%
\multicolumn{2}{l}{\small\slshape table continued from previous page}\\
\hline
\textsf{\textbf{ICV}} & \textsf{\textbf{Ways to modify value}} & \textsf{\textbf{Ways to retrieve value}}\\
\hline\\[-3ex]
}
\tabletail{%
\hline\\[-4ex]
\multicolumn{2}{l}{\small\slshape table continued on next page}\\
}
\tablelasttail{\hline}
\tablecaption{Ways to Modify and to Retrieve ICV Values\label{tab:Ways to Modify and to Retrieve ICV Values}}
\begin{supertabular}{ p{1.2in} p{2.0in} p{1.5in}}
\plc{dyn-var} & \code{omp\_set\_dynamic()} & \code{omp\_get\_dynamic()}\\

\plc{nest-var} & \code{omp\_set\_nested()} & \code{omp\_get\_nested()}\\

\plc{nthreads-var} & \code{omp\_set\_num\_threads()} & \code{omp\_get\_max\_threads()}\\

\plc{run-sched-var} & \code{omp\_set\_schedule()} & \code{omp\_get\_schedule()}\\

\plc{def-sched-var} & (none) & (none)\\

\plc{bind-var} & (none) & \code{omp\_get\_proc\_bind()}\\

\plc{stacksize-var} & (none) & (none)\\

\plc{wait-policy-var} & (none) & (none)\\

\plc{thread-limit-var} & \code{thread\_limit} clause & \code{omp\_get\_thread\_limit()}\\

\plc{max-active-levels-var} & \code{omp\_set\_max\_active\_levels()} & \code{omp\_get\_max\_active\_levels()}\\

\plc{active-levels-var} & (none) & \code{omp\_get\_active\_level()}\\

\plc{levels-var} & (none) & \code{omp\_get\_level()}\\

\plc{place-partition-var} & (none) & See description below \\

\plc{cancel-var} & (none) & \code{omp\_get\_cancellation()}\\

\plc{default-device-var} & \code{omp\_set\_default\_device()} & \code{omp\_get\_default\_device()}\\

\plc{max-task-priority-var} & (none) & \code{omp\_get\_max\_task\_priority()}\\
\plc{tool-var} & (none) & (none)\\
\plc{tool-libraries-var} & (none) & (none)\\

\end{supertabular}
\linenumbers} % end of \small block

\descr
\begin{itemize}
\item The value of the \plc{nthreads-var} ICV is a list. The runtime call 
\code{omp\_set\_num\_threads()} sets the value of the first element of this list, and 
\code{omp\_get\_max\_threads()} retrieves the value of the first element of this list.

\item The value of the \plc{bind-var} ICV is a list. The runtime call \code{omp\_get\_proc\_bind()} 
retrieves the value of the first element of this list. 

\item 
Detailed values in the \plc{place-partition-var} ICV are retrieved using the runtime calls  
\code{omp\_get\_partition\_num\_places()}, \code{omp\_get\_partition\_place\_nums()}, 
\code{omp\_get\_place\_num\_procs()}, and \code{omp\_get\_place\_proc\_ids()}.
\end{itemize}

\crossreferences
\begin{itemize}
\item \code{thread\_limit} clause of the \code{teams} construct, see \specref{subsec:teams Construct}.

\item \code{omp\_set\_num\_threads} routine, see \specref{subsec:omp_set_num_threads}.

\item \code{omp\_get\_max\_threads} routine, see \specref{subsec:omp_get_max_threads}.

\item \code{omp\_set\_dynamic} routine, see \specref{subsec:omp_set_dynamic}.

\item \code{omp\_get\_dynamic} routine, see \specref{subsec:omp_get_dynamic}.

\item \code{omp\_get\_cancellation} routine, see \specref{subsec:omp_get_cancellation}.

\item \code{omp\_set\_nested} routine, see \specref{subsec:omp_set_nested}.

\item \code{omp\_get\_nested} routine, see \specref{subsec:omp_get_nested}.

\item \code{omp\_set\_schedule} routine, see \specref{subsec:omp_set_schedule}.

\item \code{omp\_get\_schedule} routine, see \specref{subsec:omp_get_schedule}.

\item \code{omp\_get\_thread\_limit} routine, see \specref{subsec:omp_get_thread_limit}.

\item \code{omp\_set\_max\_active\_levels} routine, see \specref{subsec:omp_set_max_active_levels}.

\item \code{omp\_get\_max\_active\_levels} routine, see \specref{subsec:omp_get_max_active_levels}.

\item \code{omp\_get\_level} routine, see \specref{subsec:omp_get_level}.

\item \code{omp\_get\_active\_level} routine, see \specref{subsec:omp_get_active_level}.

\item \code{omp\_get\_proc\_bind} routine, see \specref{subsec:omp_get_proc_bind}.

\item \code{omp\_get\_place\_num\_procs()} routine, see \specref{subsec:omp_get_place_num_procs}.

\item \code{omp\_get\_place\_proc\_ids()} routine, see \specref{subsec:omp_get_place_proc_ids}.

\item \code{omp\_get\_partition\_num\_places()} routine, see \specref{subsec:omp_get_partition_num_places}.

\item \code{omp\_get\_partition\_place\_nums()} routine, see \specref{subsec:omp_get_partition_place_nums}.

\item \code{omp\_set\_default\_device} routine, see \specref{subsec:omp_set_default_device}.

\item \code{omp\_get\_default\_device} routine, see \specref{subsec:omp_get_default_device}.

\item \code{omp\_get\_max\_task\_priority} routine, see \specref{subsec:omp_get_max_task_priority}.

\end{itemize}








\vspace{-1.0\baselineskip}
\subsection{How ICVs are Scoped}
\label{subsec:How ICVs are Scoped}
Table~\ref{tab:Scopes of ICVs} shows the ICVs and their scope.

\newpage %% HACK

\renewcommand{\arraystretch}{1.3}
\tablefirsthead{%
\hline
\textsf{\textbf{ICV}} & \textsf{\textbf{Scope}}\\
\hline \\[-3ex]
}
\tablehead{%
\multicolumn{2}{l}{\small\slshape table continued from previous page}\\
\hline
\textsf{\textbf{ICV}} & \textsf{\textbf{Scope}}\\
\hline \\[-3ex]
}
\tabletail{%
\hline\\[-4ex]
\multicolumn{2}{l}{\small\slshape table continued on next page}\\
}
\tablelasttail{\hline}
\tablecaption{Scopes of ICVs\label{tab:Scopes of ICVs}}
\begin{supertabular}{p{1.5in} p{2.5in}}
\plc{dyn-var} & data environment\\
\plc{nest-var} & data environment\\
\plc{nthreads-var} & data environment\\
\plc{run-sched-var} & data environment\\
\plc{def-sched-var} & device\\
\plc{bind-var} & data environment\\
\plc{stacksize-var} & device\\
\plc{wait-policy-var} & device\\
\plc{thread-limit-var} & data environment\\
\plc{max-active-levels-var} & device\\
\plc{active-levels-var} & data environment\\
\plc{levels-var} & data environment\\
\plc{place-partition-var} & implicit task\\
\plc{cancel-var} & global\\
\plc{default-device-var} & data environment\\
\plc{max-task-priority-var} & global\\
\plc{tool-var} & global\\
\plc{tool-libraries-var} & global\\
\end{supertabular}
\renewcommand{\arraystretch}{1.5} % restore the previous value

\descr
\begin{itemize}
\item There is one copy per device of each ICV with device scope

\item Each data environment has its own copies of ICVs with data environment scope

\item Each implicit task has its own copy of ICVs with implicit task scope 
\end{itemize}

Calls to OpenMP API routines retrieve or modify data environment scoped ICVs in the 
data environment of their binding tasks.










\subsubsection{How the Per-Data Environment ICVs Work}
\label{subsubsec:How the Per-Data Environment ICVs Work}
When a \code{task} construct or \code{parallel} construct is encountered, the generated task(s)
inherit the values of the data environment scoped ICVs from the generating task's ICV
values.

When a \code{task} construct is encountered, the generated task inherits the value of
\plc{nthreads-var} from the generating task's \plc{nthreads-var} value. When a \code{parallel}
construct is encountered, and the generating task's \plc{nthreads-var} list contains a single
element, the generated task(s) inherit that list as the value of \plc{nthreads-var}. When a
\code{parallel} construct is encountered, and the generating task's \plc{nthreads-var} list contains 
multiple elements, the generated task(s) inherit the value of \plc{nthreads-var} as the list 
obtained by deletion of the first element from the generating task's \plc{nthreads-var} value. 
The \plc{bind-var} ICV is handled in the same way as the \plc{nthreads-var} ICV.

When a \plc{target task} executes a \code{target} region, the generated initial task uses the values of the data environment scoped ICVs from the device data environment ICV values of the device that will execute the region. 

If a \code{teams} construct with a \code{thread\_limit} clause is encountered, 
the \plc{thread-limit-var} ICV of the construct's data environment is instead set to a value that is less than or equal to the value specified in the clause.  

When encountering a loop worksharing region with \code{schedule(runtime)}, all 
implicit task regions that constitute the binding parallel region must have the same value 
for \plc{run-sched-var} in their data environments. Otherwise, the behavior is unspecified.








\subsection{ICV Override Relationships}
\label{subsec:ICV Override Relationships}
Table~\ref{tab:ICV Override Relationships} shows the override relationships 
among construct clauses and ICVs.

\nolinenumbers
\renewcommand{\arraystretch}{1.5}
\tablefirsthead{%
\hline
\textsf{\textbf{ICV}} & \textsf{\textbf{construct clause, if used}}\\
\hline\\[-3ex]
}
\tablehead{%
\multicolumn{2}{l}{\small\slshape table continued from previous page}\\
\hline
\textsf{\textbf{ICV}} & \textsf{\textbf{construct clause, if used}}\\
\hline\\[-3ex]
}
\tabletail{%
\hline\\[-4ex]
\multicolumn{2}{l}{\small\slshape table continued on next page}\\
}
\tablelasttail{\hline}
\tablecaption{ICV Override Relationships\label{tab:ICV Override Relationships}}
\begin{supertabular}{ p{1.3in} p{2.0in}}
\plc{dyn-var} & (none)\\
\plc{nest-var} & (none)\\
\plc{nthreads-var} & \code{num\_threads}\\
\plc{run-sched-var} & \code{schedule}\\
\plc{def-sched-var} & \code{schedule}\\
\plc{bind-var} & \code{proc\_bind}\\
\plc{stacksize-var} & (none)\\
\plc{wait-policy-var} & (none)\\
\plc{thread-limit-var} & (none)\\
\plc{max-active-levels-var} & (none)\\
\plc{active-levels-var} & (none)\\
\plc{levels-var} & (none)\\
\plc{place-partition-var} & (none)\\
\plc{cancel-var} & (none)\\
\plc{default-device-var} & (none)\\
\plc{max-task-priority-var} & (none)\\
\plc{tool-var} & (none)\\
\plc{tool-libraries-var} & (none)\\
\end{supertabular}
\linenumbers

\descr
\begin{itemize}
\item The \code{num\_threads} clause overrides the value of the first element of the 
\plc{nthreads-var} ICV.

\item If \plc{bind-var} is not set to \plc{false} then the \code{proc\_bind} clause overrides the value of the 
first element of the \plc{bind-var} ICV; otherwise, the \code{proc\_bind} clause has no effect. 
\end{itemize}

\crossreferences
\begin{itemize}
\item \code{parallel} construct, see 
\specref{sec:parallel Construct}.

\item \code{proc\_bind} clause, 
\specref{sec:parallel Construct}.

\item \code{num\_threads} clause, see 
\specref{subsec:Determining the Number of Threads for a parallel Region}.

\item Loop construct, see 
\specref{subsec:Loop Construct}.

\item \code{schedule} clause, see 
\specref{subsubsec:Determining the Schedule of a Worksharing Loop}.
\end{itemize}










%% \filbreak
\section{Array Sections}
\label{sec:Array Sections}
\index{array sections}
An array section designates a subset of the elements in an array. An array section can
appear only in clauses where it is explicitly allowed.

\begin{ccppspecific}
To specify an array section in an OpenMP construct, array subscript expressions are 
extended with the following syntax:

\begin{quote}
\code{[\plc{ lower-bound }:\plc{ length }]} or

\code{[\plc{ lower-bound }:\plc{ }]} or

\code{[ :\plc{ length }]} or

\code{[\plc{ }:\plc{ }]}
\end{quote}

The array section must be a subset of the original array.

Array sections are allowed on multidimensional arrays. Base language array subscript 
expressions can be used to specify length-one dimensions of multidimensional array 
sections.

The \plc{lower-bound} and \plc{length} are integral type expressions. When evaluated they 
represent a set of integer values as follows:

\{ \plc{lower-bound}, \plc{lower-bound} + 1, \plc{lower-bound} + 2,... , \plc{lower-bound} + \plc{length} - 1 \}

The \plc{length} must evaluate to a non-negative integer.

When the size of the array dimension is not known, the \plc{length} must be specified 
explicitly.

When the \plc{length} is absent, it defaults to the size of the array dimension minus the 
\plc{lower-bound}.

When the \plc{lower-bound} is absent it defaults to 0.

\begin{note}
The following are examples of array sections:

\begin{indentedcodelist}
a[0:6]
a[:6]
a[1:10]
a[1:]
b[10][:][:0]
c[1:10][42][0:6]
\end{indentedcodelist}

The first two examples are equivalent. If \code{a} is declared to be an eleven element array, the 
third and fourth examples are equivalent. The fifth example is a zero-length array 
section. The last example is not contiguous.
\end{note}
\medskip
\end{ccppspecific}

Fortran has built-in support for array sections although some
restrictions apply to their use, as enumerated in the following section.

\restrictions
Restrictions to array sections are as follows:

\begin{itemize}
\item An array section can appear only in clauses where it is explicitly allowed.

\begin{ccppspecific}
\item An array section can only be specified for a base language identifier. 
\end{ccppspecific}

\begin{cspecific}
\item The type of the variable appearing in an array section must be array or pointer.
\end{cspecific}

\begin{cppspecific}
\item If the type of the variable appearing in an array section is a reference to a type \plc{T} then the type will be considered to be \plc{T} for all purposes of the array section.

\item An array section cannot be used in a C++ user-defined \code{[]}-operator.
\end{cppspecific}

\begin{fortranspecific}

\item A stride expression may not be specified.

\item The upper bound for the last dimension of an assumed-size dummy
  array must be specified.

\item If a list item is an array section with vector subscripts, the
  first array element must be the lowest in the array element order of
  the array section.

\end{fortranspecific}


\end{itemize}











