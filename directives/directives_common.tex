% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. There are environments that provide special formatting, e.g. language bars.
%       Please use them whereever appropriate.  Examples are:
%
%         \begin{fortranspecific}
%         This is text that appears enclosed in blue language bars for Fortran.
%         \end{fortranspecific}
%
%         \begin{note}
%         This is a note.  The "Note -- " header appears automatically.
%         \end{note}
%
%    6. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%


\section{Directive Format}
\label{sec:Directive Format}
\index{directive format}
\begin{ccppspecific}
OpenMP directives for C/C++ are specified with the \code{pragma} preprocessing directive.
The syntax of an OpenMP directive is as follows:

\begin{ompcPragma}
#pragma omp\plc{ directive-name [clause[ [},\plc{] clause] ... ] new-line}
\end{ompcPragma}

Each directive  starts with \pcode{\#pragma} \code{omp}. The remainder of the directive follows the
conventions of the C and C++ standards for compiler directives. In particular, white
space can be used before and after the \pcode{\#}, and sometimes white space must be used to
separate the words in a directive. Preprocessing tokens following the \pcode{\#pragma} \code{omp}
are subject to macro replacement.

Some OpenMP directives may be composed of consecutive \pcode{\#pragma} preprocessing
directives if specified in their syntax.

Directives are case-sensitive.

An OpenMP executable directive applies to at most one succeeding statement, which
must be a structured block.
\end{ccppspecific}

\begin{fortranspecific}
OpenMP directives for Fortran are specified as follows:

\begin{ompfPragma}
\plc{sentinel directive-name [clause[ [},\plc{] clause]...]}
\end{ompfPragma}

All OpenMP compiler directives must begin with a directive \emph{sentinel}. The format of a
sentinel differs between fixed and free-form source files, as described in
\specref{subsec:Fixed Source Form Directives} and \specref{subsec:Free Source Form Directives}.

Directives are case insensitive. Directives cannot be embedded within continued
statements, and statements cannot be embedded within directives.

In order to simplify the presentation, free form is used for the syntax of OpenMP
directives for Fortran in the remainder of this document, except as noted.
\end{fortranspecific}

Only one \emph{directive-name} can be specified per directive (note that this includes combined
directives, see \specref{sec:Combined Constructs}).  The order in which clauses appear on directives
is not significant. Clauses on directives may be repeated as needed, subject to the
restrictions listed in the description of each clause.

Some data-sharing attribute clauses (\specref{subsec:Data-Sharing Attribute Clauses}),
data copying clauses (\specref{subsec:Data Copying Clauses}), the
\code{threadprivate} directive (\specref{subsec:threadprivate Directive}),
the \code{flush} directive (\specref{subsec:flush Construct}), and the
\code{link} clause of the \code{declare}~\code{target} directive
(\specref{subsec:declare target Directive}) accept a \emph{list}. The
\code{to} clause of the \code{declare}~\code{target} directive
(\specref{subsec:declare target Directive}) accepts an \plc{extended-list}.
The \code{depend} clause (\specref{subsec:depend Clause}), when used to specify task dependences,
accepts a \plc{locator-list}.  A \plc{list} consists of a
comma-separated collection of one or more \plc{list items}. A
\plc{extended-list} consists of a comma-separated collection of one or more
\plc{extended list items}. A \plc{locator-list} consists of a comma-separated
collection of one or more \plc{locator list items}.

\begin{ccppspecific}
A \plc{list item} is a variable or array section. An \plc{extended list item} is a \plc{list item} or a function name.  A \plc{locator list item} is any \plc{lvalue}
expression, including variables, or an array section.
\end{ccppspecific}

\begin{fortranspecific}
A \plc{list item} is a variable, array section or common block name
(enclosed in slashes). An \plc{extended list item} is a \plc{list item}
or a procedure name. A \plc{locator list item} is a \plc{list item}.

When a named common block appears in a \plc{list}, it has the same
meaning as if every explicit member of the common block appeared in
the list.  An explicit member of a common block is a variable that is
named in a \code{COMMON} statement that specifies the common block
name and is declared in the same scoping unit in which the clause
appears.

Although variables in common blocks can be accessed by use association
or host association, common block names cannot.  As a result, a common
block name specified in a data-sharing attribute, a data copying or
a data-mapping attribute clause must be declared to be a common block in
the same scoping unit in which the clause appears.

If a list item that appears in a directive or clause is an optional
dummy argument that is not present, the directive or clause for that
list item is ignored.

If the variable referenced inside a construct is an optional dummy
argument that is not present, any explicitly determined, implicitly
determined, or predetermined data-sharing and data-mapping attribute
rules for that variable are ignored.  Otherwise, if the variable is an
optional dummy argument that is present, it is present inside the
construct.
\end{fortranspecific}

For all base languages, a \plc{list item}  or an \plc{extended list item}
is subject to the restrictions specified in \specref{sec:Array Sections}
and in each of the sections describing clauses and directives for which
the \plc{list} or \plc{extended-list} appears.



%\pagebreak
% Force the blue floater bar down, and force the subsection header up, to
% bring the blue bar closer to the header:
\vspace{2\baselineskip}
\begin{fortranspecific}
\vspace{-1\baselineskip}
\subsection{Fixed Source Form Directives}
\label{subsec:Fixed Source Form Directives}
\index{fixed source form directives}
The following sentinels are recognized in fixed form source files:

\begin{ompfPragma}
!$omp \textnormal{|} c$omp \textnormal{|} *$omp
\end{ompfPragma}

Sentinels must start in column 1 and appear as a single word with no intervening
characters. Fortran fixed form line length, white space, continuation, and column rules
apply to the directive line. Initial directive lines must have a space or zero in column 6,
and continuation directive lines must have a character other than a space or a zero in
column 6.

Comments may appear on the same line as a directive. The exclamation point initiates a
comment when it appears after column 6. The comment extends to the end of the source
line and is ignored. If the first non-blank character after the directive sentinel of an
initial or continuation directive line is an exclamation point, the line is ignored.

\begin{note}
in the following example, the three formats for specifying the directive are
equivalent (the first line represents the position of the first 9 columns):

\begin{ompfPragma}
c23456789
!$omp parallel do shared(a,b,c)

c$omp parallel do
c$omp+shared(a,b,c)

c$omp paralleldoshared(a,b,c)
\end{ompfPragma}
\end{note}










\subsection{Free Source Form Directives}
\label{subsec:Free Source Form Directives}
\index{free source form directives}

The following sentinel is recognized in free form source files:

\begin{ompfPragma}
!$omp
\end{ompfPragma}

The sentinel can appear in any column as long as it is preceded only by white space
(spaces and tab characters). It must appear as a single word with no intervening
character. Fortran free form line length, white space, and continuation rules apply to the
directive line. Initial directive lines must have a space after the sentinel. Continued
directive lines must have an ampersand (\code{&}) as the last non-blank character on the line,
prior to any comment placed inside the directive. Continuation directive lines can have
an ampersand after the directive sentinel with optional white space before and after the
ampersand.

Comments may appear on the same line as a directive. The exclamation point (\code{!})
initiates a comment. The comment extends to the end of the source line and is ignored.
If the first non-blank character after the directive sentinel is an exclamation point, the
line is ignored.

One or more blanks or horizontal tabs must be used to separate adjacent keywords in
directives in free source form, except in the following cases, where white space is
optional between the given set of keywords:

\begin{indentedcodelist}
declare reduction
declare simd
declare target
distribute parallel do
distribute parallel do simd
distribute loop
distribute simd
do simd
end atomic
end loop
end critical
end distribute
end distribute parallel do
end distribute parallel do simd
end distribute simd
end do
end do simd
end master
end ordered
end parallel
end parallel do
end parallel do simd
end parallel loop
end parallel sections
end parallel workshare
end sections
end simd
end single
end target
end target data
end target parallel
end target parallel do
end target parallel do simd
end target simd
end target teams
end target teams distribute
end target teams distribute parallel do
end target teams distribute parallel do simd
end target teams distribute simd
end task
end taskgroup
end taskloop
end taskloop simd
end teams
end teams distribute
end teams distribute parallel do
end teams distribute parallel do simd
end teams distribute loop
end teams distribute simd
end workshare
parallel do
parallel do simd
parallel loop
parallel sections
parallel workshare
target data
target enter data
target exit data
target parallel
target parallel do
target parallel do simd
target simd
target teams
target teams distribute
target teams distribute parallel do
target teams distribute parallel do simd
target teams distribute simd
target update
taskloop simd
teams distribute
teams distribute parallel do
teams distribute parallel do simd
teams distribute simd
\end{indentedcodelist}

\begin{note}
in the following example the three formats for specifying the directive are
equivalent (the first line represents the position of the first 9 columns):

\begin{ompfPragma}
!23456789
       !$omp parallel do &
                 !$omp shared(a,b,c)

       !$omp parallel &
      !$omp&do shared(a,b,c)

!$omp paralleldo shared(a,b,c)
\end{ompfPragma}
\end{note}
\bigskip
\end{fortranspecific}








\subsection{Stand-Alone Directives}
\label{subsec:Stand-Alone Directives}
\index{stand-alone directives}
\summary
Stand-alone directives are executable directives that have no associated user code.

\descr
Stand-alone directives do not have any associated executable user code. Instead, they
represent executable statements that typically do not have succinct equivalent statements
in the base languages. There are some restrictions on the placement of a stand-alone
directive within a program. A stand-alone directive may be placed only at a point where
a base language executable statement is allowed.

\restrictions
\begin{ccppspecific}
For C/C++, a stand-alone directive may not be used in place of the statement following
an \code{if}, \code{while}, \code{do}, \code{switch}, or \code{label}.
\end{ccppspecific}

\begin{fortranspecific}
For Fortran, a stand-alone directive may not be used as the action statement in an \code{if}
statement or as the executable statement following a label if the label is referenced in
the program.
\end{fortranspecific}









\section{Conditional Compilation}
\label{sec:Conditional Compilation}
\index{conditional compilation}
\index{_OPENMP@{\code{_OPENMP} macro}}
In implementations that support a preprocessor, the \code{_OPENMP} macro name is defined to
have the decimal value \plc{yyyymm} where \plc{yyyy} and \plc{mm} are the year and month designations
of the version of the OpenMP API that the implementation supports.

If this macro is the subject of a \pcode{\#define} or a \pcode{\#undef} preprocessing directive, the
behavior is unspecified.

\begin{fortranspecific}
The OpenMP API requires Fortran lines to be compiled conditionally, as described in
the following sections.




\subsection{Fixed Source Form Conditional Compilation Sentinels}
\label{subsec:Fixed Source Form Conditional Compilation Sentinels}
\index{fixed source form conditional compilation sentinels}
\index{compilation sentinels}
The following conditional compilation sentinels are recognized in fixed form source
files:

\begin{ompfPragma}
!$ \textnormal{|} *$ \textnormal{|} c$
\end{ompfPragma}

To enable conditional compilation, a line with a conditional compilation sentinel must
satisfy the following criteria:

\begin{itemize}
\item The sentinel must start in column 1 and appear as a single word with no intervening
white space.

\item After the sentinel is replaced with two spaces, initial lines must have a space or zero
in column 6 and only white space and numbers in columns 1 through 5.

\item After the sentinel is replaced with two spaces, continuation lines must have a
character other than a space or zero in column 6 and only white space in columns 1
through 5.
\end{itemize}

If these criteria are met, the sentinel is replaced by two spaces. If these criteria are not
met, the line is left unchanged.

\begin{note}
in the following example, the two forms for specifying conditional compilation
in fixed source form are equivalent (the first line represents the position of the first 9
columns):

\begin{ompfPragma}
c23456789
!$ 10 iam = omp_get_thread_num() +
!$   &          index

#ifdef _OPENMP
   10 iam = omp_get_thread_num() +
     &            index
#endif
\end{ompfPragma}
\end{note}





\subsection{Free Source Form Conditional Compilation Sentinel}
\label{subsec:Free Source Form Conditional Compilation Sentinel}
\index{free source form conditional compilation sentinel}
\index{compilation sentinels}
The following conditional compilation sentinel is recognized in free form source files:

\begin{ompfPragma}
!$
\end{ompfPragma}

To enable conditional compilation, a line with a conditional compilation sentinel must
satisfy the following criteria:

\begin{itemize}
\item The sentinel can appear in any column but must be preceded only by white space.

\item The sentinel must appear as a single word with no intervening white space.

\item Initial lines must have a space after the sentinel.

\item Continued lines must have an ampersand as the last non-blank character on the line,
prior to any comment appearing on the conditionally compiled line. Continuation lines
can have an ampersand after the sentinel, with optional white space before and after
the ampersand.
\end{itemize}

If these criteria are met, the sentinel is replaced by two spaces. If these criteria are not
met, the line is left unchanged.

\begin{note}
in the following example, the two forms for specifying conditional compilation
in free source form are equivalent (the first line represents the position of the first 9
columns):

\begin{ompfPragma}
c23456789
 !$ iam = omp_get_thread_num() +     &
 !$&    index

#ifdef _OPENMP
    iam = omp_get_thread_num() +     &
        index
#endif
\end{ompfPragma}
\end{note}
\bigskip
\end{fortranspecific}





\section{\hcode{requires} Directive}
\label{sec:requires Directive}
\index{requires@{\code{requires}}}
\index{directives!requires@{\code{requires}}}

\summary The \code{requires} directive specifies the features an implementation
must provide in order for the code to compile and to execute correctly.




\syntax
\begin{ccppspecific}
  The syntax of the \code{requires} directive is as follows:

\begin{ompcPragma}
  #pragma omp requires \plc{clause[ [ [},\plc{] clause] ... ] new-line}

\end{ompcPragma}

\end{ccppspecific}

\begin{fortranspecific}
  The syntax of the \code{requires} directive is as follows:

\begin{ompfPragma}
!$omp requires \plc{clause[ [ [},\plc{] clause] ... ]}

\end{ompfPragma}

\end{fortranspecific}

Where \plc{clause} is either one of the requirement clauses listed below or a
clause of the form {\scode{ext_}\plc{implementation-defined-requirement}} for an
implementation defined requirement clause.

\begin{indentedcodelist}
unified_address
unified_shared_memory
atomic_default_mem_order(seq_cst \textnormal{|} acq_rel \textnormal{|} relaxed)
dynamic_allocators
\end{indentedcodelist}

\descr

The \code{requires} directive specifies features an implementation must
support for correct execution. The behavior specified by a requirement clause
may override the normal behavior specified elsewhere in this document.

\begin{ccppspecific}
The \code{requires} directive specifies requirements for the execution of all
code in the current translation unit.
\end{ccppspecific}

\begin{fortranspecific}
The \code{requires} directive specifies requirements for the execution of all
code in the current program unit.
\end{fortranspecific}

\begin{note}
Use of this directive makes your code less portable. Users should be aware that not all
devices or implementations support all requirements.
\end{note}

When the \code{unified_address} clause appears on a \code{requires}
directive, the implementation guarantees that all devices accessible through
OpenMP API routines and directives use a unified address space. In this
address space, a pointer will always refer to the same location in memory
from all devices accessible through OpenMP.  The pointers returned by
\code{omp_target_alloc} and accessed through \code{use_device_ptr} are
guaranteed to be pointer values that can support pointer arithmetic while
still being native device pointers. The \code{is_device_ptr} clause is not
necessary for device pointers to be translated in \code{target} regions, and
pointers found not present are not set to null but keep their original value.
Memory local to a specific execution context may be exempt from this,
following the restrictions of locality to a given execution context, thread or
contention group.  Target devices may still have discrete memories and
dereferencing a device pointer on the host device remains unspecified
behavior.

The \code{unified_shared_memory} clause implies the \code{unified_address}
requirement, inheriting all of its behaviors.  Additionally memory in the
device data environment of any device visible to OpenMP, including but not
limited to the host, is considered part of the device data environment of all
devices accessible through OpenMP except as noted below.  Every device address
allocated through OpenMP device memory routines is a valid host pointer. Memory
local to an execution context as defined in \code{unified_address} above may remain
part of distinct device data environments as long as the execution context is
local to the device containing that environment.

The \code{unified_shared_memory} clause makes the \code{map} clause optional
on \code{target} constructs as well as the \code{declare}~\code{target}
directive on static lifetime variables accessed as part of
\code{declare}~\code{target} functions.  Scalar variables are still made
\code{firstprivate} by default for \code{target} regions.  Values stored into
memory by one device may not be visible to other devices until those two
devices synchronize with each other or both synchronize with the host.

The \code{atomic_default_mem_order} clause specifies the default memory ordering
behavior for \code{atomic} constructs that must be provided by an
implementation. If the default memory ordering is specified as \code{seq_cst}, all
\code{atomic} constructs on which \plc{memory-order-clause} is not specified
behave as if the \code{seq_cst} clause appears. If the default memory
ordering is specified as \code{relaxed}, all \code{atomic} constructs on which
\plc{memory-order-clause} is not specified behave as if the \code{relaxed}
clause appears.

If the default memory ordering is specified as \code{acq_rel}, \code{atomic}
constructs on which \plc{memory-order-clause} is not specified behave in the
following manner:

\begin{itemize}
    \item as if the \code{release} clause is present if the construct
        specifies an atomic write or atomic update operation;
    \item as if the \code{acquire} clause is present if the construct
        specifies an atomic read operation;
    \item as if the \code{acq_rel} clause is present if the construct
        specifies an atomic captured update operation.
\end{itemize}

The \code{dynamic_allocators} clause has the following effects:
\begin{itemize}
 \item makes the \code{uses_allocators} clause optional on \code{target} constructs for the purpose of using allocators in the corresponding \code{target} regions,
 \item allows the \code{omp_init_allocator} and \code{omp_destroy_allocator} API routines in \code{target} regions,
 \item allows default allocators to be used by \code{allocate} directives, \code{allocate} clauses and \code{omp_alloc} API routines in \code{target} regions.
\end{itemize}

Implementers are allowed to include additional implementation defined
requirement clauses.  Requirement names that do not start with \code{ext_} are
reserved. All implementation-defined requirements should begin with
\code{ext_}.

\restrictions

The restrictions for the \code{requires} directive are as follows:

\begin{itemize}

\begin{ccppspecific}
\item A \code{requires} directive with the \code{unified_address} clause must appear
       in all translation units of a program or none of them.
\item A \code{requires} directive with the \code{unified_shared_memory} clause must appear
       in all translation units of a program or none of them.
\end{ccppspecific}

\begin{fortranspecific}
\item A \code{requires} directive with the \code{unified_address} clause must appear
       in every program unit of a Fortran program, or in none of them.
\item A \code{requires} directive with the \code{unified_shared_memory} clause must appear
       in every program unit of a Fortran program, or in none of them.
\end{fortranspecific}

\end{itemize}


\section{Internal Control Variables}
\label{sec:Internal Control Variables}
\index{internal control variables (ICVs)}
\index{ICVs (internal control variables)}
An OpenMP implementation must act as if there are internal control variables (ICVs)
that control the behavior of an OpenMP program. These ICVs store information such as
the number of threads to use for future \code{parallel} regions, the schedule to use for
worksharing loops and whether nested parallelism is enabled or not. The ICVs are given
values at various times (described below) during the execution of the program. They are
initialized by the implementation itself and may be given values through OpenMP
environment variables and through calls to OpenMP API routines. The program can
retrieve the values of these ICVs only through OpenMP API routines.

For purposes of exposition, this document refers to the ICVs by certain names, but an
implementation is not required to use these names or to offer any way to access the
variables other than through the ways shown in
\specref{subsec:ICV Initialization}.








\subsection{ICV Descriptions}
\label{subsec:ICV Descriptions}
The following ICVs store values that affect the operation of \code{parallel} regions.

\begin{itemize}
\item \plc{dyn-var} - controls whether dynamic adjustment of the number of threads is enabled
for encountered \code{parallel} regions. There is one copy of this ICV per data
environment.

\item \plc{nest-var} - controls whether nested parallelism is enabled for encountered \code{parallel}
regions. There is one copy of this ICV per data environment. The \plc{nest-var} ICV has been deprecated.

\item \plc{nthreads-var} - controls the number of threads requested for encountered \code{parallel}
regions. There is one copy of this ICV per data environment.

\item \plc{thread-limit-var} - controls the maximum number of threads participating in the
contention group. There is one copy of this ICV per data environment.

\item \plc{max-active-levels-var} - controls the maximum number of nested active \code{parallel}
regions. There is one copy of this ICV per device.

\item \plc{place-partition-var} -- controls the place partition available to the execution
environment for encountered \code{parallel} regions. There is one copy of this ICV per
implicit task.

\item \plc{active-levels-var} - the number of nested, active parallel regions enclosing the current
task such that all of the \code{parallel} regions are enclosed by the outermost initial task
region on the current device. There is one copy of this ICV per data environment.

\item \plc{levels-var} - the number of nested parallel regions enclosing the current task such that
all of the \code{parallel} regions are enclosed by the outermost initial task region on the
current device. There is one copy of this ICV per data environment.

\item \plc{bind-var} - controls the binding of OpenMP threads to places. When binding is
requested, the variable indicates that the execution environment is advised not to
move threads between places. The variable can also provide default thread affinity
policies. There is one copy of this ICV per data environment.
\end{itemize}

The following ICVs store values that affect the operation of worksharing-loop regions.

\begin{itemize}
\item \plc{run-sched-var} - controls the schedule that the \code{runtime} schedule clause uses for
worksharing-loop regions. There is one copy of this ICV per data environment.

\item \plc{def-sched-var} - controls the implementation defined default scheduling of loop
regions. There is one copy of this ICV per device.
\end{itemize}

The following ICVs store values that affect program execution.

\begin{itemize}
\item \plc{stacksize-var} - controls the stack size for threads that the OpenMP implementation
creates. There is one copy of this ICV per device.

\item \plc{wait-policy-var} - controls the desired behavior of waiting threads. There is one copy
of this ICV per device.

\item \plc{display-affinity-var} - controls whether to display thread affinity. There is one copy of this ICV for the whole program.

\item \plc{affinity-format-var} - controls the thread affinity format when displaying thread affinity. There is one copy of this ICV per device.

\item \plc{cancel-var} - controls the desired behavior of the \code{cancel} construct and cancellation
points. There is one copy of this ICV for the whole program.

\item \plc{default-device-var} - controls the default target device. There is one copy of this ICV
per data environment.

\item \plc{target-offload-var} - controls the offloading behavior. There is one copy of this ICV
for the whole program.

\item \plc{max-task-priority-var} - controls the maximum priority value that can be specified in the
\code{priority} clause of the \code{task} construct. There is one copy of this ICV for the whole program.

\end{itemize}

The following ICVs store values that affect the operation of the
first-party tool interface.

\begin{itemize}

\item \plc{tool-var} - determines whether an OpenMP implementation will
try to register a tool.  There is one copy of this ICV for the whole program.

\item \plc{tool-libraries-var} - specifies a list of absolute paths to tool libraries for OpenMP devices.
There is one copy of this ICV for the whole program.

\end{itemize}

The following ICVs store values that relate to the operation of the
OMPD tool interface.

\begin{itemize}
\item
  \plc{debug-var} - determines whether an OpenMP implementation will collect
  information that an OMPD-plugin can access to satisfy requests from
  a tool.
  There is one copy of this ICV for the whole program.
\end{itemize}

The following ICVs store values that affect default memory allocation.

\begin{itemize}

\item \plc{def-allocator-var} - determines the memory allocator to be used by memory allocation routines, directives and clauses when a memory allocator is not specified by the user. There is one copy of this ICV per implicit task.

\end{itemize}




\subsection{ICV Initialization}
\label{subsec:ICV Initialization}
\index{modifying ICV's}
Table~\ref{tab:ICV Initial Values} shows the ICVs, associated
environment variables, and initial values.

\nolinenumbers
\renewcommand{\arraystretch}{1.5}
\tablefirsthead{%
\hline
\textsf{\textbf{ICV}} & \textsf{\textbf{Environment Variable}} & \textsf{\textbf{Initial value}}\\
\hline\\[-3ex]
}
\tablehead{%
\multicolumn{2}{l}{\small\slshape table continued from previous page}\\
\hline
\textsf{\textbf{ICV}} & \textsf{\textbf{Environment Variable}} & \textsf{\textbf{Initial value}}\\
\hline\\[-3ex]
}
\tabletail{%
\hline\\[-4ex]
\multicolumn{2}{l}{\small\slshape table continued on next page}\\
}
\tablelasttail{\hline}
\tablecaption{ICV Initial Values\label{tab:ICV Initial Values}}
\begin{supertabular}{p{1.4in} p{1.8in} p{1.5in}}
{\splc{dyn-var}} & {\scode{OMP_DYNAMIC}} & See description below\\
{\splc{nest-var}} & {\scode{OMP_NESTED}} & Implementation defined\\
{\splc{nthreads-var}} & {\scode{OMP_NUM_THREADS}} & Implementation defined\\
{\splc{run-sched-var}} & {\scode{OMP_SCHEDULE}} & Implementation defined\\
{\splc{def-sched-var}} & (none) & Implementation defined\\
{\splc{bind-var}} & {\scode{OMP_PROC_BIND}} & Implementation defined\\
{\splc{stacksize-var}} & {\scode{OMP_STACKSIZE}} & Implementation defined\\
{\splc{wait-policy-var}} & {\scode{OMP_WAIT_POLICY}} & Implementation defined\\
{\splc{thread-limit-var}} & {\scode{OMP_THREAD_LIMIT}} & Implementation defined\\
{\splc{max-active-levels-var}} & {\scode{OMP_MAX_ACTIVE_LEVELS}} & See description below\\
{\splc{active-levels-var}} & (none) & {\splc{zero}}\\
{\splc{levels-var}} & (none) & {\splc{zero}}\\
{\splc{place-partition-var}} & {\scode{OMP_PLACES}} & Implementation defined\\
{\splc{cancel-var}} & {\scode{OMP_CANCELLATION}} & {\splc{false}}\\
{\splc{display-affinity-var}} & {\scode{OMP_DISPLAY_AFFINITY}} & {\splc{false}}\\
{\splc{affinity-format-var}} & {\scode{OMP_AFFINITY_FORMAT}} & Implementation defined \\
{\splc{default-device-var}} & {\scode{OMP_DEFAULT_DEVICE}} & Implementation defined\\
{\splc{target-offload-var}} & {\scode{OMP_TARGET_OFFLOAD}} & {\scode{DEFAULT}} \\
{\splc{max-task-priority-var}} & {\scode{OMP_MAX_TASK_PRIORITY}} & {\splc{zero}}\\
{\splc{tool-var}} & {\scode{OMP_TOOL}} & {\splc{enabled}}\\
{\splc{tool-libraries-var}} & {\scode{OMP_TOOL_LIBRARIES}} & {\splc{empty string}}\\
{\splc{debug-var}} & {\scode{OMP_DEBUG}} & {\splc{disabled}} \\
{\splc{def-allocator-var}} & {\scode{OMP_ALLOCATOR}} & Implementation defined\\
\end{supertabular}

\linenumbers

\descr
\begin{itemize}
\item Each device has its own ICVs.

\item The value of the \plc{nthreads-var} ICV is a list.

\item The value of the \plc{bind-var} ICV is a list.

\item The initial value of \plc{dyn-var} is implementation defined if the implementation supports
dynamic adjustment of the number of threads; otherwise, the initial value is \plc{false}.

\item The initial value of \plc{max-active-levels-var} is the number of levels of parallelism that
the implementation supports. See the definition of \emph{supporting n levels of parallelism}
in \specref{subsec:Implementation Terminology} for further details.
\end{itemize}

The host and target device ICVs are initialized before any OpenMP API construct or
OpenMP API routine executes. After the initial values are assigned, the values of any
OpenMP environment variables that were set by the user are read and the associated
ICVs for the host device are modified accordingly. The method for initializing a target
device's ICVs is implementation defined.

\crossreferences
\begin{itemize}
\item \code{OMP_SCHEDULE} environment variable, see \specref{sec:OMP_SCHEDULE}.

\item \code{OMP_NUM_THREADS} environment variable, see \specref{sec:OMP_NUM_THREADS}.

\item \code{OMP_DYNAMIC} environment variable, see \specref{sec:OMP_DYNAMIC}.

\item \code{OMP_PROC_BIND} environment variable, see \specref{sec:OMP_PROC_BIND}.

\item \code{OMP_PLACES} environment variable, see \specref{sec:OMP_PLACES}.

\item \code{OMP_NESTED} environment variable, see \specref{sec:OMP_NESTED}.

\item \code{OMP_STACKSIZE} environment variable, see \specref{sec:OMP_STACKSIZE}.

\item \code{OMP_WAIT_POLICY} environment variable, see \specref{sec:OMP_WAIT_POLICY}.

\item \code{OMP_MAX_ACTIVE_LEVELS} environment variable, see \specref{sec:OMP_MAX_ACTIVE_LEVELS}.

\item \code{OMP_THREAD_LIMIT} environment variable, see \specref{sec:OMP_THREAD_LIMIT}.

\item \code{OMP_CANCELLATION} environment variable, see \specref{sec:OMP_CANCELLATION}.

\item \code{OMP_DISPLAY_AFFINITY} environment variable, see \specref{sec:OMP_DISPLAY_AFFINITY}.

\item \code{OMP_AFFINITY_FORMAT} environment variable, see \specref{sec:OMP_AFFINITY_FORMAT}.

\item \code{OMP_DEFAULT_DEVICE} environment variable, see \specref{sec:OMP_DEFAULT_DEVICE}.

\item \code{OMP_TARGET_OFFLOAD} environment variable, see \specref{sec:OMP_TARGET_OFFLOAD}.

\item \code{OMP_MAX_TASK_PRIORITY} environment variable, see \specref{sec:OMP_MAX_TASK_PRIORITY}.

\item \code{OMP_TOOL} environment variable, see \specref{sec:OMP_TOOL}.

\item \code{OMP_TOOL_LIBRARIES} environment variable, see \specref{sec:OMP_TOOL_LIBRARIES}.

\item \code{OMP_DEBUG} environment variable, see \specref{sec:OMP_DEBUG}.

\item \code{OMP_ALLOCATOR} environment variable, see \specref{sec:OMP_ALLOCATOR}.
\end{itemize}








\subsection{Modifying and Retrieving ICV Values}
\label{subsec:Modifying and Retrieving ICV Values}
\index{modifying and retrieving ICV values}
Table~\ref{tab:Ways to Modify and to Retrieve ICV Values} shows the method for modifying and retrieving the values of ICVs
through OpenMP API routines.

%\newpage %% HACK to force table title onto same page...
{\small%
\nolinenumbers
\renewcommand{\arraystretch}{1.5}
\tablefirsthead{%
\hline
\textsf{\textbf{ICV}} & \textsf{\textbf{Ways to modify value}} & \textsf{\textbf{Ways to retrieve value}}\\
\hline\\[-3ex]
}
\tablehead{%
\multicolumn{2}{l}{\small\slshape table continued from previous page}\\
\hline
\textsf{\textbf{ICV}} & \textsf{\textbf{Ways to modify value}} & \textsf{\textbf{Ways to retrieve value}}\\
\hline\\[-3ex]
}
\tabletail{%
\hline\\[-4ex]
\multicolumn{2}{l}{\small\slshape table continued on next page}\\
}
\tablelasttail{\hline}
\tablecaption{Ways to Modify and to Retrieve ICV Values\label{tab:Ways to Modify and to Retrieve ICV Values}}
\begin{supertabular}{ p{1.2in} p{2.0in} p{1.5in}}
{\splc{dyn-var}} & {\scode{omp_set_dynamic()}} & {\scode{omp_get_dynamic()}}\\

{\splc{nest-var}} & {\scode{omp_set_nested()}} & {\scode{omp_get_nested()}}\\

{\splc{nthreads-var}} & {\scode{omp_set_num_threads()}} & {\scode{omp_get_max_threads()}}\\

{\splc{run-sched-var}} & {\scode{omp_set_schedule()}} & {\scode{omp_get_schedule()}}\\

{\splc{def-sched-var}} & (none) & (none)\\

{\splc{bind-var}} & (none) & {\scode{omp_get_proc_bind()}}\\

{\splc{stacksize-var}} & (none) & (none)\\

{\splc{wait-policy-var}} & (none) & (none)\\

{\splc{thread-limit-var}} & {\scode{thread_limit}} clause & {\scode{omp_get_thread_limit()}}\\

{\splc{max-active-levels-var}} & {\scode{omp_set_max_active_levels()}} & {\scode{omp_get_max_active_levels()}}\\

{\splc{active-levels-var}} & (none) & {\scode{omp_get_active_level()}}\\

{\splc{levels-var}} & (none) & {\scode{omp_get_level()}}\\

{\splc{place-partition-var}} & (none) & See description below \\

{\splc{cancel-var}} & (none) & {\scode{omp_get_cancellation()}}\\

{\splc{display-affinity-var}} & (none) & (none)\\

{\splc{affinity-format-var}} & {\scode{omp_set_affinity_format()}} & {\scode{omp_get_affinity_format()}}\\

{\splc{default-device-var}} & {\scode{omp_set_default_device()}} & {\scode{omp_get_default_device()}}\\

{\splc{target-offload-var}} & (none) & (none)\\

{\splc{max-task-priority-var}} & (none) & {\scode{omp_get_max_task_priority()}}\\
{\splc{tool-var}} & (none) & (none)\\
{\splc{tool-libraries-var}} & (none) & (none)\\
{\splc{debug-var}} & (none) & (none) \\

{\splc{def-allocator-var}} & {\scode{omp_set_default_allocator()}} & {\scode{omp_get_default_allocator()}}\\

\end{supertabular}

\linenumbers} % end of \small block

\descr
\begin{itemize}
\item The value of the \plc{nthreads-var} ICV is a list. The runtime call
\code{omp_set_num_threads()} sets the value of the first element of this list, and
\code{omp_get_max_threads()} retrieves the value of the first element of this list.

\item The value of the \plc{bind-var} ICV is a list. The runtime call \code{omp_get_proc_bind()}
retrieves the value of the first element of this list.

\item
Detailed values in the \plc{place-partition-var} ICV are retrieved using the runtime calls
\code{omp_get_partition_num_places()}, \code{omp_get_partition_place_nums()},
\code{omp_get_place_num_procs()}, and \code{omp_get_place_proc_ids()}.
\end{itemize}

\crossreferences
\begin{itemize}
\item \code{thread_limit} clause of the \code{teams} construct, see \specref{subsec:teams Construct}.

\item \code{omp_set_num_threads} routine, see \specref{subsec:omp_set_num_threads}.

\item \code{omp_get_max_threads} routine, see \specref{subsec:omp_get_max_threads}.

\item \code{omp_set_dynamic} routine, see \specref{subsec:omp_set_dynamic}.

\item \code{omp_get_dynamic} routine, see \specref{subsec:omp_get_dynamic}.

\item \code{omp_get_cancellation} routine, see \specref{subsec:omp_get_cancellation}.

\item \code{omp_set_nested} routine, see \specref{subsec:omp_set_nested}.

\item \code{omp_get_nested} routine, see \specref{subsec:omp_get_nested}.

\item \code{omp_set_schedule} routine, see \specref{subsec:omp_set_schedule}.

\item \code{omp_get_schedule} routine, see \specref{subsec:omp_get_schedule}.

\item \code{omp_get_thread_limit} routine, see \specref{subsec:omp_get_thread_limit}.

\item \code{omp_set_max_active_levels} routine, see \specref{subsec:omp_set_max_active_levels}.

\item \code{omp_get_max_active_levels} routine, see \specref{subsec:omp_get_max_active_levels}.

\item \code{omp_get_level} routine, see \specref{subsec:omp_get_level}.

\item \code{omp_get_active_level} routine, see \specref{subsec:omp_get_active_level}.

\item \code{omp_get_proc_bind} routine, see \specref{subsec:omp_get_proc_bind}.

\item \code{omp_get_place_num_procs()} routine, see \specref{subsec:omp_get_place_num_procs}.

\item \code{omp_get_place_proc_ids()} routine, see \specref{subsec:omp_get_place_proc_ids}.

\item \code{omp_get_partition_num_places()} routine, see \specref{subsec:omp_get_partition_num_places}.

\item \code{omp_get_partition_place_nums()} routine, see \specref{subsec:omp_get_partition_place_nums}.

\item \code{omp_set_affinity_format} routine, see \specref{subsec:omp_set_affinity_format}.

\item \code{omp_get_affinity_format} routine, see \specref{subsec:omp_get_affinity_format}.

\item \code{omp_set_default_device} routine, see \specref{subsec:omp_set_default_device}.

\item \code{omp_get_default_device} routine, see \specref{subsec:omp_get_default_device}.

\item \code{omp_get_max_task_priority} routine, see \specref{subsec:omp_get_max_task_priority}.

\item \code{omp_set_default_allocator} routine, see \specref{subsec:omp_set_default_allocator}.

\item \code{omp_get_default_allocator} routine, see \specref{subsec:omp_get_default_allocator}.
\end{itemize}









\subsection{How ICVs are Scoped}
\label{subsec:How ICVs are Scoped}
Table~\ref{tab:Scopes of ICVs} shows the ICVs and their scope.

\nolinenumbers
\tablefirsthead{%
\hline
\textsf{\textbf{ICV}} & \textsf{\textbf{Scope}}\\
\hline \\[-3ex]
}
\tablehead{%
\multicolumn{2}{l}{\small\slshape table continued from previous page}\\
\hline
\textsf{\textbf{ICV}} & \textsf{\textbf{Scope}}\\
\hline \\[-3ex]
}
\tabletail{%
\hline\\[-4ex]
\multicolumn{2}{l}{\small\slshape table continued on next page}\\
}
\tablelasttail{\hline}
\tablecaption{Scopes of ICVs\label{tab:Scopes of ICVs}}
\begin{supertabular}{p{1.5in} p{2.5in}}
{\splc{dyn-var}} & data environment\\
{\splc{nest-var}} & data environment\\
{\splc{nthreads-var}} & data environment\\
{\splc{run-sched-var}} & data environment\\
{\splc{def-sched-var}} & device\\
{\splc{bind-var}} & data environment\\
{\splc{stacksize-var}} & device\\
{\splc{wait-policy-var}} & device\\
{\splc{thread-limit-var}} & data environment\\
{\splc{max-active-levels-var}} & device\\
{\splc{active-levels-var}} & data environment\\
{\splc{levels-var}} & data environment\\
{\splc{place-partition-var}} & implicit task\\
{\splc{cancel-var}} & global\\
{\splc{display-affinity-var}} & global \\
{\splc{affinity-format-var}} & device \\
{\splc{default-device-var}} & data environment\\
{\splc{target-offload-var}} & global\\
{\splc{max-task-priority-var}} & global\\
{\splc{tool-var}} & global\\
{\splc{tool-libraries-var}} & global\\
{\splc{debug-var}} & global \\
{\splc{third-party-tool-var}} & global \\
{\splc{def-allocator-var}} & implicit task\\
\end{supertabular}

\linenumbers

\descr
\begin{itemize}
\item There is one copy per device of each ICV with device scope

\item Each data environment has its own copies of ICVs with data environment scope

\item Each implicit task has its own copy of ICVs with implicit task scope
\end{itemize}

Calls to OpenMP API routines retrieve or modify data environment scoped ICVs in the
data environment of their binding tasks.










\subsubsection{How the Per-Data Environment ICVs Work}
\label{subsubsec:How the Per-Data Environment ICVs Work}
When a \code{task} construct or \code{parallel} construct is encountered, the generated task(s)
inherit the values of the data environment scoped ICVs from the generating task's ICV
values.

When a \code{parallel} construct is encountered, the value of each ICV witch implicit task scope is inherited, unless otherwise specified, from the implicit binding task of the generating task unless otherwise specified.

When a \code{task} construct is encountered, the generated task inherits the value of
\plc{nthreads-var} from the generating task's \plc{nthreads-var} value. When a \code{parallel}
construct is encountered, and the generating task's \plc{nthreads-var} list contains a single
element, the generated task(s) inherit that list as the value of \plc{nthreads-var}. When a
\code{parallel} construct is encountered, and the generating task's \plc{nthreads-var} list contains
multiple elements, the generated task(s) inherit the value of \plc{nthreads-var} as the list
obtained by deletion of the first element from the generating task's \plc{nthreads-var} value.
The \plc{bind-var} ICV is handled in the same way as the \plc{nthreads-var} ICV.

When a \plc{target task} executes a \code{target} region, the generated initial task uses the values of the data environment scoped ICVs from the device data environment ICV values of the device that will execute the region.

If a \code{teams} construct with a \code{thread_limit} clause is encountered,
the \plc{thread-limit-var} ICV of the construct's data environment is instead set to a value that is less than or equal to the value specified in the clause.

When encountering a loop worksharing region with \code{schedule(runtime)}, all
implicit task regions that constitute the binding parallel region must have the same value
for \plc{run-sched-var} in their data environments. Otherwise, the behavior is unspecified.








\subsection{ICV Override Relationships}
\label{subsec:ICV Override Relationships}
Table~\ref{tab:ICV Override Relationships} shows the override relationships
among construct clauses and ICVs.

\nolinenumbers
\renewcommand{\arraystretch}{1.5}
\tablefirsthead{%
\hline
\textsf{\textbf{ICV}} & \textsf{\textbf{construct clause, if used}}\\
\hline\\[-3ex]
}
\tablehead{%
\multicolumn{2}{l}{\small\slshape table continued from previous page}\\
\hline
\textsf{\textbf{ICV}} & \textsf{\textbf{construct clause, if used}}\\
\hline\\[-3ex]
}
\tabletail{%
\hline\\[-4ex]
\multicolumn{2}{l}{\small\slshape table continued on next page}\\
}
\tablelasttail{\hline}
\tablecaption{ICV Override Relationships\label{tab:ICV Override Relationships}}
\begin{supertabular}{ p{1.3in} p{2.0in}}
{\splc{dyn-var}} & (none)\\
{\splc{nest-var}} & (none)\\
{\splc{nthreads-var}} & {\scode{num_threads}}\\
{\splc{run-sched-var}} & {\scode{schedule}}\\
{\splc{def-sched-var}} & {\scode{schedule}}\\
{\splc{bind-var}} & {\scode{proc_bind}}\\
{\splc{stacksize-var}} & (none)\\
{\splc{wait-policy-var}} & (none)\\
{\splc{thread-limit-var}} & (none)\\
{\splc{max-active-levels-var}} & (none)\\
{\splc{active-levels-var}} & (none)\\
{\splc{levels-var}} & (none)\\
{\splc{place-partition-var}} & (none)\\
{\splc{cancel-var}} & (none)\\
{\splc{display-affinity-var}} & (none) \\
{\splc{affinity-format-var}} & (none) \\
{\splc{default-device-var}} & (none)\\
{\splc{target-offload-var}} & (none)\\
{\splc{max-task-priority-var}} & (none)\\
{\splc{tool-var}} & (none)\\
{\splc{tool-libraries-var}} & (none)\\
{\splc{debug-var}} & (none) \\
{\splc{def-allocator-var}} & {\scode{allocator}}\\
\end{supertabular}

\linenumbers

\descr
\begin{itemize}
\item The \code{num_threads} clause overrides the value of the first element of the
\plc{nthreads-var} ICV.

\item If \plc{bind-var} is not set to \plc{false} then the \code{proc_bind} clause overrides the value of the
first element of the \plc{bind-var} ICV; otherwise, the \code{proc_bind} clause has no effect.
\end{itemize}

\crossreferences
\begin{itemize}
\item \code{parallel} construct, see
\specref{sec:parallel Construct}.

\item \code{proc_bind} clause,
\specref{sec:parallel Construct}.

\item \code{num_threads} clause, see
\specref{subsec:Determining the Number of Threads for a parallel Region}.

\item Worksharing-Loop construct, see
\specref{subsec:Worksharing-Loop Construct}.

\item \code{schedule} clause, see
\specref{subsubsec:Determining the Schedule of a Worksharing Loop}.
\end{itemize}










%% \filbreak
\section{Array Sections}
\label{sec:Array Sections}
\index{array sections}
An array section designates a subset of the elements in an array. An array section can
appear only in clauses where it is explicitly allowed.

\begin{ccppspecific}
To specify an array section in an OpenMP construct, array subscript expressions are
extended with the following syntax:
\begin{indentedcodelist}
[\plc{ lower-bound }:\plc{ length }] \textnormal{or}

[\plc{ lower-bound }:\plc{ }] \textnormal{or}

[ :\plc{ length }] \textnormal{or}

[\plc{ }:\plc{ }]
\end{indentedcodelist}

% TODO: consider removing this in future ticket
The array section must be a subset of the original array.

% This is now in the glossary.
%The \emph{base expression} of an array section or an array element is an expression that specifies
%the address of the initial element of the original array.

Array sections are allowed on multidimensional arrays. Base language array subscript
expressions can be used to specify length-one dimensions of multidimensional array
sections.

The \plc{lower-bound} and \plc{length} are integral type expressions. When evaluated they
represent a set of integer values as follows:

\{ \plc{lower-bound}, \plc{lower-bound} + 1, \plc{lower-bound} + 2,... , \plc{lower-bound} + \plc{length} - 1 \}

The \plc{length} must evaluate to a non-negative integer.

When the size of the array dimension is not known, the \plc{length} must be specified
explicitly.

When the \plc{length} is absent, it defaults to the size of the array dimension minus the
\plc{lower-bound}.

When the \plc{lower-bound} is absent it defaults to 0.

% TODO: consider adding this in future ticket
%Each array element specified by an array section is determined according to
%the base expression of the array section and the array subscript expressions
%derived from its array section subscripts.

\begin{note}
The following are examples of array sections:

\begin{indentedcodelist}
a[0:6]
a[:6]
a[1:10]
a[1:]
b[10][:][:0]
c[1:10][42][0:6]
S.c[:100]
p->y[:10]
this->a[:N]
\end{indentedcodelist}

The first two examples are equivalent. If \code{a} is declared to be an eleven
element array, the third and fourth examples are equivalent. The fifth example
is a zero-length array section. The sixth example is not contiguous.  The
remaining examples show array sections that are formed from more general base
expressions.
\end{note}
\medskip
\end{ccppspecific}

Fortran has built-in support for array sections although some
restrictions apply to their use, as enumerated in the following section.

\restrictions
Restrictions to array sections are as follows:

\begin{itemize}
\item An array section can appear only in clauses where it is explicitly allowed.

\begin{ccppspecific}
%\item An array section can only be specified for a base expression.
\item An element of an array section with a non-zero size must have a complete type.

\item The type of the base expression appearing in an array section must be
    an array or pointer type.

\item If the type of the base expression of the array section is a pointer type, the
    base expression must be an lvalue expression.
\end{ccppspecific}

\begin{cppspecific}
\item If the type of the base expression of an array section is a reference to a type \plc{T} then the type will be considered to be \plc{T} for all purposes of the array section.

\item An array section cannot be used in a C++ user-defined \code{[]}-operator.
\end{cppspecific}

\begin{fortranspecific}

\item A stride expression may not be specified unless otherwise stated.

\item The upper bound for the last dimension of an assumed-size dummy
  array must be specified.

\item If a list item is an array section with vector subscripts, the
  first array element must be the lowest in the array element order of
  the array section.

\end{fortranspecific}


\end{itemize}

\section{Iterators}
\index{iterators}
\label{sec:iterators}

Iterators are identifiers that expand to multiple values in the clause on which they appear.

The syntax to define an iterator is the following:
\begin{ompSyntax}
\plc{iterators-definition}
\end{ompSyntax}
where \plc{iterators-definition} is either an \plc{iterator-specifier} or an \plc{iterator-specifier-list}.

The syntax of an \plc{iterator-specifier} is one of the following:
\begin{indentedcodelist}
[\plc{iterator-type }] \plc{identifier} = \plc{range-specification}
\end{indentedcodelist}

where:
\begin{itemize}
\item \plc{identifier} is a base language identifier.
\begin{ccppspecific}
\item \plc{iterator-type} is a type name.
\end{ccppspecific}
\begin{fortranspecific}
\item \plc{iterator-type} is a type specifier.
\end{fortranspecific}

\item \plc{range-specification} is of the form \plc{begin, end[, step]} where \plc{begin}, \plc{end} and \plc{step} are expressions for which their types can be converted to the \plc{iterator-type} type.
\end{itemize}

The syntax of an \plc{iterator-specifier-list} is as follows:
\begin{indentedcodelist}
( \plc{iterator-specifier} )[, \plc{iterator-specifier-list}]
\end{indentedcodelist}

%Each \plc{iterator-specifier} specifies an explicit iterator.

\begin{ccppspecific}
\begin{itemize}
\item The \plc{iterator-type} must be an integral or pointer type.
\item In an \plc{iterator-specifier}, if the \plc{iterator-type} is not specified then the type of that iterator is of \code{int} type.
\end{itemize}
\end{ccppspecific}

%\newpage %% HACK

\begin{fortranspecific}
\begin{itemize}
\item The \plc{iterator-type} must be an integer type.
\item In an \plc{iterator-specifier}, if the \plc{iterator-type} is not specified then the type of that iterator is default integer.
\end{itemize}
\end{fortranspecific}

In a \plc{range-specification}, if the \plc{step} is not specified its value is implicitly defined to be 1.

An iterator only exists in the context of the clause on which it appears. An iterator also hides all accessible symbols with the same name in the context of the clause.

The use of a variable in an expression that appears in the \plc{range-specification} causes an implicit reference to the variable in all enclosing constructs.

\begin{ccppspecific}
The values of the iterator are the set of values $i_{0}$...$i_{N-1}$ where $i_{0}=begin$,  $i_{j}=i_{j-1} + step$ and
\begin{itemize}
\item $i_{N-1} < end$ and $i_{N-1} + step >= end$ if $step > 0$.
\item $i_{N-1} > end$ and $i_{N-1} + step <= end$ if $step < 0$.
\end{itemize}
\end{ccppspecific}
\begin{fortranspecific}
The values of the iterator are the set of values $i_{1}$...$i_{N}$ where $i_{1}=begin$,  $i_{j}=i_{j-1} + step$ and
\begin{itemize}
\item $i_{N} <= end$ and $i_{N} + step > end$ if $step > 0$.
\item $i_{N} >= end$ and $i_{N} + step < end$ if $step < 0$.
\end{itemize}
\end{fortranspecific}

An expression containing an iterator identifier can only appear in clauses that
explicitly allow expressions containing iterators. For those clauses, the
effect is as if the list item is instantiated within the clause for each
value of the iterator in the set defined above, substituting each occurrence of
the iterator identifier in the expression with the iterator value.

\restrictions

\begin{itemize}
\item If the \plc{step} expression of a \plc{range-specification} equals zero the behavior is unspecified.
\item Each iterator identifier can only be defined once in an \plc{iterators-definition}.
\item Iterators cannot appear in the \plc{range-specification}.
\end{itemize}

