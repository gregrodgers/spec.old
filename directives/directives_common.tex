% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. There are environments that provide special formatting, e.g. language bars.
%       Please use them whereever appropriate.  Examples are:
%
%         \begin{fortranspecific}
%         This is text that appears enclosed in blue language bars for Fortran.
%         \end{fortranspecific}
%
%         \begin{note}
%         This is a note.  The "Note -- " header appears automatically.
%         \end{note}
%
%    6. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%


\section{Directive Format}
\label{sec:Directive Format}
\index{directive format}
\begin{ccppspecific}
OpenMP directives for C/C++ are specified with the \code{pragma} preprocessing directive.
The syntax of an OpenMP directive is as follows:

\begin{ompcPragma}
#pragma omp\plc{ directive-name [clause[ [},\plc{] clause] ... ] new-line}
\end{ompcPragma}

Each directive  starts with \pcode{\#pragma} \code{omp}. The remainder of the directive follows the
conventions of the C and C++ standards for compiler directives. In particular, white
space can be used before and after the \pcode{\#}, and sometimes white space must be used to
separate the words in a directive. Preprocessing tokens following the \pcode{\#pragma} \code{omp}
are subject to macro replacement.

Some OpenMP directives may be composed of consecutive \pcode{\#pragma} preprocessing
directives if specified in their syntax.

Directives are case-sensitive.

An OpenMP executable directive applies to at most one succeeding statement, which
must be a structured block.
\end{ccppspecific}

\begin{cppspecific}
Directives may not appear in constexpr functions or in constant expressions.
Variadic parameter packs cannot be expanded into a directive or its clauses
except as part of an expression argument to be evaluated by the base language,
such as into a function call inside an \code{if()} clause.
\end{cppspecific}

\begin{fortranspecific}
OpenMP directives for Fortran are specified as follows:

\begin{ompfPragma}
\plc{sentinel directive-name [clause[ [},\plc{] clause]...]}
\end{ompfPragma}

All OpenMP compiler directives must begin with a directive \emph{sentinel}. The format of a
sentinel differs between fixed and free-form source files, as described in
\specref{subsec:Fixed Source Form Directives} and \specref{subsec:Free Source Form Directives}.

Directives are case insensitive. Directives cannot be embedded within continued
statements, and statements cannot be embedded within directives.

In order to simplify the presentation, free form is used for the syntax of OpenMP
directives for Fortran in the remainder of this document, except as noted.
\end{fortranspecific}

Only one \emph{directive-name} can be specified per directive (note that this includes combined
directives, see \specref{sec:Combined Constructs}).  The order in which clauses appear on directives
is not significant. Clauses on directives may be repeated as needed, subject to the
restrictions listed in the description of each clause.

Some data-sharing attribute clauses (\specref{subsec:Data-Sharing Attribute Clauses}),
data copying clauses (\specref{subsec:Data Copying Clauses}), the
\code{threadprivate} directive (\specref{subsec:threadprivate Directive}),
the \code{flush} directive (\specref{subsec:flush Construct}), and the
\code{link} clause of the \code{declare}~\code{target} directive
(\specref{subsec:declare target Directive}) accept a \emph{list}. The
\code{to} clause of the \code{declare}~\code{target} directive
(\specref{subsec:declare target Directive}) accepts an \plc{extended-list}.
The \code{depend} clause (\specref{subsec:depend Clause}), when used to specify task dependences,
accepts a \plc{locator-list}.  A \plc{list} consists of a
comma-separated collection of one or more \plc{list items}. A
\plc{extended-list} consists of a comma-separated collection of one or more
\plc{extended list items}. A \plc{locator-list} consists of a comma-separated
collection of one or more \plc{locator list items}.

\begin{ccppspecific}
A \plc{list item} is a variable or array section. An \plc{extended list item} is a \plc{list item} or a function name.  A \plc{locator list item} is any \plc{lvalue}
expression, including variables, or an array section.
\end{ccppspecific}

\begin{fortranspecific}
A \plc{list item} is a variable, array section or common block name
(enclosed in slashes). An \plc{extended list item} is a \plc{list item}
or a procedure name. A \plc{locator list item} is a \plc{list item}.

When a named common block appears in a \plc{list}, it has the same
meaning as if every explicit member of the common block appeared in
the list.  An explicit member of a common block is a variable that is
named in a \code{COMMON} statement that specifies the common block
name and is declared in the same scoping unit in which the clause
appears.

Although variables in common blocks can be accessed by use association
or host association, common block names cannot.  As a result, a common
block name specified in a data-sharing attribute, a data copying or
a data-mapping attribute clause must be declared to be a common block in
the same scoping unit in which the clause appears.

If a list item that appears in a directive or clause is an optional
dummy argument that is not present, the directive or clause for that
list item is ignored.

If the variable referenced inside a construct is an optional dummy
argument that is not present, any explicitly determined, implicitly
determined, or predetermined data-sharing and data-mapping attribute
rules for that variable are ignored.  Otherwise, if the variable is an
optional dummy argument that is present, it is present inside the
construct.
\end{fortranspecific}

For all base languages, a \plc{list item}  or an \plc{extended list item}
is subject to the restrictions specified in \specref{sec:Array Sections}
and in each of the sections describing clauses and directives for which
the \plc{list} or \plc{extended-list} appears.



%\pagebreak
% Force the blue floater bar down, and force the subsection header up, to
% bring the blue bar closer to the header:
\vspace{2\baselineskip}
\begin{fortranspecific}
\vspace{-1\baselineskip}
\subsection{Fixed Source Form Directives}
\label{subsec:Fixed Source Form Directives}
\index{fixed source form directives}
The following sentinels are recognized in fixed form source files:

\begin{ompfPragma}
!$omp \textnormal{|} c$omp \textnormal{|} *$omp
\end{ompfPragma}

Sentinels must start in column 1 and appear as a single word with no intervening
characters. Fortran fixed form line length, white space, continuation, and column rules
apply to the directive line. Initial directive lines must have a space or zero in column 6,
and continuation directive lines must have a character other than a space or a zero in
column 6.

Comments may appear on the same line as a directive. The exclamation point initiates a
comment when it appears after column 6. The comment extends to the end of the source
line and is ignored. If the first non-blank character after the directive sentinel of an
initial or continuation directive line is an exclamation point, the line is ignored.

\begin{note}
in the following example, the three formats for specifying the directive are
equivalent (the first line represents the position of the first 9 columns):

\begin{ompfPragma}
c23456789
!$omp parallel do shared(a,b,c)

c$omp parallel do
c$omp+shared(a,b,c)

c$omp paralleldoshared(a,b,c)
\end{ompfPragma}
\end{note}










\subsection{Free Source Form Directives}
\label{subsec:Free Source Form Directives}
\index{free source form directives}

The following sentinel is recognized in free form source files:

\begin{ompfPragma}
!$omp
\end{ompfPragma}

The sentinel can appear in any column as long as it is preceded only by white space
(spaces and tab characters). It must appear as a single word with no intervening
character. Fortran free form line length, white space, and continuation rules apply to the
directive line. Initial directive lines must have a space after the sentinel. Continued
directive lines must have an ampersand (\code{&}) as the last non-blank character on the line,
prior to any comment placed inside the directive. Continuation directive lines can have
an ampersand after the directive sentinel with optional white space before and after the
ampersand.

Comments may appear on the same line as a directive. The exclamation point (\code{!})
initiates a comment. The comment extends to the end of the source line and is ignored.
If the first non-blank character after the directive sentinel is an exclamation point, the
line is ignored.

One or more blanks or horizontal tabs are optional to separate adjacent
keywords in \plc{directive-names} unless otherwise specified.

\begin{note}
in the following example the three formats for specifying the directive are
equivalent (the first line represents the position of the first 9 columns):

\begin{ompfPragma}
!23456789
       !$omp parallel do &
                 !$omp shared(a,b,c)

       !$omp parallel &
      !$omp&do shared(a,b,c)

!$omp paralleldo shared(a,b,c)
\end{ompfPragma}
\end{note}
\bigskip
\end{fortranspecific}








\subsection{Stand-Alone Directives}
\label{subsec:Stand-Alone Directives}
\index{stand-alone directives}
\summary
Stand-alone directives are executable directives that have no associated user code.

\descr
Stand-alone directives do not have any associated executable user code. Instead, they
represent executable statements that typically do not have succinct equivalent statements
in the base languages. There are some restrictions on the placement of a stand-alone
directive within a program. A stand-alone directive may be placed only at a point where
a base language executable statement is allowed.

\restrictions
\begin{ccppspecific}
For C/C++, a stand-alone directive may not be used in place of the statement following
an \code{if}, \code{while}, \code{do}, \code{switch}, or \code{label}.
\end{ccppspecific}

\begin{fortranspecific}
For Fortran, a stand-alone directive may not be used as the action statement in an \code{if}
statement or as the executable statement following a label if the label is referenced in
the program.
\end{fortranspecific}


\section{Conditional Compilation}
\label{sec:Conditional Compilation}
\index{conditional compilation}
\index{_OPENMP@{\code{_OPENMP} macro}}
In implementations that support a preprocessor, the \code{_OPENMP} macro name is defined to
have the decimal value \plc{yyyymm} where \plc{yyyy} and \plc{mm} are the year and month designations
of the version of the OpenMP API that the implementation supports.

If this macro is the subject of a \pcode{\#define} or a \pcode{\#undef} preprocessing directive, the
behavior is unspecified.

\begin{fortranspecific}
The OpenMP API requires Fortran lines to be compiled conditionally, as described in
the following sections.




\subsection{Fixed Source Form Conditional Compilation Sentinels}
\label{subsec:Fixed Source Form Conditional Compilation Sentinels}
\index{fixed source form conditional compilation sentinels}
\index{compilation sentinels}
The following conditional compilation sentinels are recognized in fixed form source
files:

\begin{ompfPragma}
!$ \textnormal{|} *$ \textnormal{|} c$
\end{ompfPragma}

To enable conditional compilation, a line with a conditional compilation sentinel must
satisfy the following criteria:

\begin{itemize}
\item The sentinel must start in column 1 and appear as a single word with no intervening
white space.

\item After the sentinel is replaced with two spaces, initial lines must have a space or zero
in column 6 and only white space and numbers in columns 1 through 5.

\item After the sentinel is replaced with two spaces, continuation lines must have a
character other than a space or zero in column 6 and only white space in columns 1
through 5.
\end{itemize}

If these criteria are met, the sentinel is replaced by two spaces. If these criteria are not
met, the line is left unchanged.

\begin{note}
in the following example, the two forms for specifying conditional compilation
in fixed source form are equivalent (the first line represents the position of the first 9
columns):

\begin{ompfPragma}
c23456789
!$ 10 iam = omp_get_thread_num() +
!$   &          index

#ifdef _OPENMP
   10 iam = omp_get_thread_num() +
     &            index
#endif
\end{ompfPragma}
\end{note}





\subsection{Free Source Form Conditional Compilation Sentinel}
\label{subsec:Free Source Form Conditional Compilation Sentinel}
\index{free source form conditional compilation sentinel}
\index{compilation sentinels}
The following conditional compilation sentinel is recognized in free form source files:

\begin{ompfPragma}
!$
\end{ompfPragma}

To enable conditional compilation, a line with a conditional compilation sentinel must
satisfy the following criteria:

\begin{itemize}
\item The sentinel can appear in any column but must be preceded only by white space.

\item The sentinel must appear as a single word with no intervening white space.

\item Initial lines must have a space after the sentinel.

\item Continued lines must have an ampersand as the last non-blank character on the line,
prior to any comment appearing on the conditionally compiled line. Continuation lines
can have an ampersand after the sentinel, with optional white space before and after
the ampersand.
\end{itemize}

If these criteria are met, the sentinel is replaced by two spaces. If these criteria are not
met, the line is left unchanged.

\begin{note}
in the following example, the two forms for specifying conditional compilation
in free source form are equivalent (the first line represents the position of the first 9
columns):

\begin{ompfPragma}
c23456789
 !$ iam = omp_get_thread_num() +     &
 !$&    index

#ifdef _OPENMP
    iam = omp_get_thread_num() +     &
        index
#endif
\end{ompfPragma}
\end{note}
\bigskip
\end{fortranspecific}





\section{\hcode{requires} Directive}
\label{sec:requires Directive}
\index{requires@{\code{requires}}}
\index{directives!requires@{\code{requires}}}

\summary The \code{requires} directive specifies the features an implementation
must provide in order for the code to compile and to execute correctly.
The \code{requires} directive is a declarative directive.




\syntax
\begin{ccppspecific}
  The syntax of the \code{requires} directive is as follows:

\begin{ompcPragma}
  #pragma omp requires \plc{clause[ [ [},\plc{] clause] ... ] new-line}

\end{ompcPragma}

\end{ccppspecific}

\begin{fortranspecific}
  The syntax of the \code{requires} directive is as follows:

\begin{ompfPragma}
!$omp requires \plc{clause[ [ [},\plc{] clause] ... ]}

\end{ompfPragma}

\end{fortranspecific}

Where \plc{clause} is either one of the requirement clauses listed below or a
clause of the form {\scode{ext_}\plc{implementation-defined-requirement}} for an
implementation defined requirement clause.

\begin{indentedcodelist}
unified_address
unified_shared_memory
atomic_default_mem_order(seq_cst \textnormal{|} acq_rel \textnormal{|} relaxed)
dynamic_allocators
\end{indentedcodelist}

\descr

The \code{requires} directive specifies features an implementation must
support for correct execution. The behavior specified by a requirement clause
may override the normal behavior specified elsewhere in this document.

\begin{ccppspecific}
The \code{requires} directive specifies requirements for the execution of all
code in the current translation unit.
\end{ccppspecific}

\begin{fortranspecific}
The \code{requires} directive specifies requirements for the execution of all
code in the current program unit.
\end{fortranspecific}

\begin{note}
Use of this directive makes your code less portable. Users should be aware that not all
devices or implementations support all requirements.
\end{note}

When the \code{unified_address} clause appears on a \code{requires}
directive, the implementation guarantees that all devices accessible through
OpenMP API routines and directives use a unified address space. In this
address space, a pointer will always refer to the same location in memory
from all devices accessible through OpenMP.  The pointers returned by
\code{omp_target_alloc} and accessed through \code{use_device_ptr} are
guaranteed to be pointer values that can support pointer arithmetic while
still being native device pointers. The \code{is_device_ptr} clause is not
necessary for device pointers to be translated in \code{target} regions, and
pointers found not present are not set to null but keep their original value.
Memory local to a specific execution context may be exempt from this,
following the restrictions of locality to a given execution context, thread or
contention group.  Target devices may still have discrete memories and
dereferencing a device pointer on the host device remains unspecified
behavior.

The \code{unified_shared_memory} clause implies the \code{unified_address}
requirement, inheriting all of its behaviors.  Additionally memory in the
device data environment of any device visible to OpenMP, including but not
limited to the host, is considered part of the device data environment of all
devices accessible through OpenMP except as noted below.  Every device address
allocated through OpenMP device memory routines is a valid host pointer. Memory
local to an execution context as defined in \code{unified_address} above may remain
part of distinct device data environments as long as the execution context is
local to the device containing that environment.

The \code{unified_shared_memory} clause makes the \code{map} clause optional
on \code{target} constructs as well as the \code{declare}~\code{target}
directive on static lifetime variables accessed as part of
\code{declare}~\code{target} functions.  Scalar variables are still made
\code{firstprivate} by default for \code{target} regions.  Values stored into
memory by one device may not be visible to other devices until those two
devices synchronize with each other or both synchronize with the host.

The \code{atomic_default_mem_order} clause specifies the default memory ordering
behavior for \code{atomic} constructs that must be provided by an
implementation. If the default memory ordering is specified as \code{seq_cst}, all
\code{atomic} constructs on which \plc{memory-order-clause} is not specified
behave as if the \code{seq_cst} clause appears. If the default memory
ordering is specified as \code{relaxed}, all \code{atomic} constructs on which
\plc{memory-order-clause} is not specified behave as if the \code{relaxed}
clause appears.

If the default memory ordering is specified as \code{acq_rel}, \code{atomic}
constructs on which \plc{memory-order-clause} is not specified behave in the
following manner:

\begin{itemize}
    \item as if the \code{release} clause is present if the construct
        specifies an atomic write or atomic update operation;
    \item as if the \code{acquire} clause is present if the construct
        specifies an atomic read operation;
    \item as if the \code{acq_rel} clause is present if the construct
        specifies an atomic captured update operation.
\end{itemize}

The \code{dynamic_allocators} clause has the following effects:
\begin{itemize}
 \item makes the \code{uses_allocators} clause optional on \code{target} constructs for the purpose of using allocators in the corresponding \code{target} regions,
 \item allows the \code{omp_init_allocator} and \code{omp_destroy_allocator} API routines in \code{target} regions,
 \item allows default allocators to be used by \code{allocate} directives, \code{allocate} clauses and \code{omp_alloc} API routines in \code{target} regions.
\end{itemize}

Implementers are allowed to include additional implementation defined
requirement clauses.  Requirement names that do not start with \code{ext_} are
reserved. All implementation-defined requirements should begin with
\code{ext_}.

\restrictions

The restrictions for the \code{requires} directive are as follows:

\begin{itemize}

\item Each of the clauses can appear at most once on the directive.

\item At most one \code{requires} directive with
\code{atomic_default_mem_order} clause can appear in a single compilation
unit.

\item A \code{requires} directive with a \code{unified_address},
  \code{unified_shared_memory} or \code{reverse_offload} clause shall appear
  lexically before any device constructs or device routines.

\item The \code{requires} directive with \code{atomic_default_mem_order}
clause may not appear lexically after any \code{atomic} construct on which
\plc{memory-order-clause} is not specified.

\end{itemize}


\section{Internal Control Variables}
\label{sec:Internal Control Variables}
\index{internal control variables (ICVs)}
\index{ICVs (internal control variables)}
An OpenMP implementation must act as if there are internal control variables (ICVs)
that control the behavior of an OpenMP program. These ICVs store information such as
the number of threads to use for future \code{parallel} regions, the schedule to use for
worksharing loops and whether nested parallelism is enabled or not. The ICVs are given
values at various times (described below) during the execution of the program. They are
initialized by the implementation itself and may be given values through OpenMP
environment variables and through calls to OpenMP API routines. The program can
retrieve the values of these ICVs only through OpenMP API routines.

For purposes of exposition, this document refers to the ICVs by certain names, but an
implementation is not required to use these names or to offer any way to access the
variables other than through the ways shown in
\specref{subsec:ICV Initialization}.








\subsection{ICV Descriptions}
\label{subsec:ICV Descriptions}
The following ICVs store values that affect the operation of \code{parallel} regions.

\begin{itemize}
\item \plc{dyn-var} - controls whether dynamic adjustment of the number of threads is enabled
for encountered \code{parallel} regions. There is one copy of this ICV per data
environment.

\item \plc{nest-var} - controls whether nested parallelism is enabled for encountered \code{parallel}
regions. There is one copy of this ICV per data environment. The \plc{nest-var} ICV has been deprecated.

\item \plc{nthreads-var} - controls the number of threads requested for encountered \code{parallel}
regions. There is one copy of this ICV per data environment.

\item \plc{thread-limit-var} - controls the maximum number of threads participating in the
contention group. There is one copy of this ICV per data environment.

\item \plc{max-active-levels-var} - controls the maximum number of nested active \code{parallel}
regions. There is one copy of this ICV per device.

\item \plc{place-partition-var} -- controls the place partition available to the execution
environment for encountered \code{parallel} regions. There is one copy of this ICV per
implicit task.

\item \plc{active-levels-var} - the number of nested, active parallel regions enclosing the current
task such that all of the \code{parallel} regions are enclosed by the outermost initial task
region on the current device. There is one copy of this ICV per data environment.

\item \plc{levels-var} - the number of nested parallel regions enclosing the current task such that
all of the \code{parallel} regions are enclosed by the outermost initial task region on the
current device. There is one copy of this ICV per data environment.

\item \plc{bind-var} - controls the binding of OpenMP threads to places. When binding is
requested, the variable indicates that the execution environment is advised not to
move threads between places. The variable can also provide default thread affinity
policies. There is one copy of this ICV per data environment.
\end{itemize}

The following ICVs store values that affect the operation of loop regions.

\begin{itemize}
\item \plc{run-sched-var} - controls the schedule that the \code{runtime} schedule clause uses for
loop regions. There is one copy of this ICV per data environment.

\item \plc{def-sched-var} - controls the implementation defined default scheduling of loop
regions. There is one copy of this ICV per device.
\end{itemize}

The following ICVs store values that affect program execution.

\begin{itemize}
\item \plc{stacksize-var} - controls the stack size for threads that the OpenMP implementation
creates. There is one copy of this ICV per device.

\item \plc{wait-policy-var} - controls the desired behavior of waiting threads. There is one copy
of this ICV per device.

\item \plc{display-affinity-var} - controls whether to display thread affinity. There is one copy of this ICV for the whole program.

\item \plc{affinity-format-var} - controls the thread affinity format when displaying thread affinity. There is one copy of this ICV per device.

\item \plc{cancel-var} - controls the desired behavior of the \code{cancel} construct and cancellation
points. There is one copy of this ICV for the whole program.

\item \plc{default-device-var} - controls the default target device. There is one copy of this ICV
per data environment.

\item \plc{target-offload-var} - controls the offloading behavior. There is one copy of this ICV
for the whole program.

\item \plc{max-task-priority-var} - controls the maximum priority value that can be specified in the
\code{priority} clause of the \code{task} construct. There is one copy of this ICV for the whole program.

\end{itemize}

The following ICVs store values that affect the operation of the
first-party tool interface.

\begin{itemize}

\item \plc{tool-var} - determines whether an OpenMP implementation will
try to register a tool.  There is one copy of this ICV for the whole program.

\item \plc{tool-libraries-var} - specifies a list of absolute paths to tool libraries for OpenMP devices.
There is one copy of this ICV for the whole program.

\end{itemize}

The following ICVs store values that relate to the operation of the
OMPD tool interface.

\begin{itemize}
\item
  \plc{debug-var} - determines whether an OpenMP implementation will collect
  information that an OMPD library can access to satisfy requests from
  a tool.
  There is one copy of this ICV for the whole program.
\end{itemize}

The following ICVs store values that affect default memory allocation.

\begin{itemize}

\item \plc{def-allocator-var} - determines the memory allocator to be used by memory allocation routines, directives and clauses when a memory allocator is not specified by the user. There is one copy of this ICV per implicit task.

\end{itemize}




\subsection{ICV Initialization}
\label{subsec:ICV Initialization}
\index{modifying ICV's}
Table~\ref{tab:ICV Initial Values} shows the ICVs, associated
environment variables, and initial values.

\nolinenumbers
\renewcommand{\arraystretch}{1.5}
\tablefirsthead{%
\hline
\textsf{\textbf{ICV}} & \textsf{\textbf{Environment Variable}} & \textsf{\textbf{Initial value}}\\
\hline\\[-3ex]
}
\tablehead{%
\multicolumn{2}{l}{\small\slshape table continued from previous page}\\
\hline
\textsf{\textbf{ICV}} & \textsf{\textbf{Environment Variable}} & \textsf{\textbf{Initial value}}\\
\hline\\[-3ex]
}
\tabletail{%
\hline\\[-4ex]
\multicolumn{2}{l}{\small\slshape table continued on next page}\\
}
\tablelasttail{\hline}
\tablecaption{ICV Initial Values\label{tab:ICV Initial Values}}
\begin{supertabular}{p{1.4in} p{1.8in} p{1.5in}}
{\splc{dyn-var}} & {\scode{OMP_DYNAMIC}} & See description below\\
{\splc{nest-var}} & {\scode{OMP_NESTED}} & Implementation defined\\
{\splc{nthreads-var}} & {\scode{OMP_NUM_THREADS}} & Implementation defined\\
{\splc{run-sched-var}} & {\scode{OMP_SCHEDULE}} & Implementation defined\\
{\splc{def-sched-var}} & (none) & Implementation defined\\
{\splc{bind-var}} & {\scode{OMP_PROC_BIND}} & Implementation defined\\
{\splc{stacksize-var}} & {\scode{OMP_STACKSIZE}} & Implementation defined\\
{\splc{wait-policy-var}} & {\scode{OMP_WAIT_POLICY}} & Implementation defined\\
{\splc{thread-limit-var}} & {\scode{OMP_THREAD_LIMIT}} & Implementation defined\\
{\splc{max-active-levels-var}} & {\scode{OMP_MAX_ACTIVE_LEVELS}} & See description below\\
{\splc{active-levels-var}} & (none) & {\splc{zero}}\\
{\splc{levels-var}} & (none) & {\splc{zero}}\\
{\splc{place-partition-var}} & {\scode{OMP_PLACES}} & Implementation defined\\
{\splc{cancel-var}} & {\scode{OMP_CANCELLATION}} & {\splc{false}}\\
{\splc{display-affinity-var}} & {\scode{OMP_DISPLAY_AFFINITY}} & {\splc{false}}\\
{\splc{affinity-format-var}} & {\scode{OMP_AFFINITY_FORMAT}} & Implementation defined \\
{\splc{default-device-var}} & {\scode{OMP_DEFAULT_DEVICE}} & Implementation defined\\
{\splc{target-offload-var}} & {\scode{OMP_TARGET_OFFLOAD}} & {\scode{DEFAULT}} \\
{\splc{max-task-priority-var}} & {\scode{OMP_MAX_TASK_PRIORITY}} & {\splc{zero}}\\
{\splc{tool-var}} & {\scode{OMP_TOOL}} & {\splc{enabled}}\\
{\splc{tool-libraries-var}} & {\scode{OMP_TOOL_LIBRARIES}} & {\splc{empty string}}\\
{\splc{debug-var}} & {\scode{OMP_DEBUG}} & {\splc{disabled}} \\
{\splc{def-allocator-var}} & {\scode{OMP_ALLOCATOR}} & Implementation defined\\
\end{supertabular}

\linenumbers

\descr
\begin{itemize}
\item Each device has its own ICVs.

\item The value of the \plc{nthreads-var} ICV is a list.

\item The value of the \plc{bind-var} ICV is a list.

\item The initial value of \plc{dyn-var} is implementation defined if the implementation supports
dynamic adjustment of the number of threads; otherwise, the initial value is \plc{false}.

\item The initial value of \plc{max-active-levels-var} is the number of levels of parallelism that
the implementation supports. See the definition of \emph{supporting n levels of parallelism}
in \specref{subsec:Implementation Terminology} for further details.
\end{itemize}

The host and target device ICVs are initialized before any OpenMP API construct or
OpenMP API routine executes. After the initial values are assigned, the values of any
OpenMP environment variables that were set by the user are read and the associated
ICVs for the host device are modified accordingly. The method for initializing a target
device's ICVs is implementation defined.

\crossreferences
\begin{itemize}
\item \code{OMP_SCHEDULE} environment variable, see \specref{sec:OMP_SCHEDULE}.

\item \code{OMP_NUM_THREADS} environment variable, see \specref{sec:OMP_NUM_THREADS}.

\item \code{OMP_DYNAMIC} environment variable, see \specref{sec:OMP_DYNAMIC}.

\item \code{OMP_PROC_BIND} environment variable, see \specref{sec:OMP_PROC_BIND}.

\item \code{OMP_PLACES} environment variable, see \specref{sec:OMP_PLACES}.

\item \code{OMP_NESTED} environment variable, see \specref{sec:OMP_NESTED}.

\item \code{OMP_STACKSIZE} environment variable, see \specref{sec:OMP_STACKSIZE}.

\item \code{OMP_WAIT_POLICY} environment variable, see \specref{sec:OMP_WAIT_POLICY}.

\item \code{OMP_MAX_ACTIVE_LEVELS} environment variable, see \specref{sec:OMP_MAX_ACTIVE_LEVELS}.

\item \code{OMP_THREAD_LIMIT} environment variable, see \specref{sec:OMP_THREAD_LIMIT}.

\item \code{OMP_CANCELLATION} environment variable, see \specref{sec:OMP_CANCELLATION}.

\item \code{OMP_DISPLAY_AFFINITY} environment variable, see \specref{sec:OMP_DISPLAY_AFFINITY}.

\item \code{OMP_AFFINITY_FORMAT} environment variable, see \specref{sec:OMP_AFFINITY_FORMAT}.

\item \code{OMP_DEFAULT_DEVICE} environment variable, see \specref{sec:OMP_DEFAULT_DEVICE}.

\item \code{OMP_TARGET_OFFLOAD} environment variable, see \specref{sec:OMP_TARGET_OFFLOAD}.

\item \code{OMP_MAX_TASK_PRIORITY} environment variable, see \specref{sec:OMP_MAX_TASK_PRIORITY}.

\item \code{OMP_TOOL} environment variable, see \specref{sec:OMP_TOOL}.

\item \code{OMP_TOOL_LIBRARIES} environment variable, see \specref{sec:OMP_TOOL_LIBRARIES}.

\item \code{OMP_DEBUG} environment variable, see \specref{sec:OMP_DEBUG}.

\item \code{OMP_ALLOCATOR} environment variable, see \specref{sec:OMP_ALLOCATOR}.
\end{itemize}








\subsection{Modifying and Retrieving ICV Values}
\label{subsec:Modifying and Retrieving ICV Values}
\index{modifying and retrieving ICV values}
Table~\ref{tab:Ways to Modify and to Retrieve ICV Values} shows the method for modifying and retrieving the values of ICVs
through OpenMP API routines.

%\newpage %% HACK to force table title onto same page...
{\small%
\nolinenumbers
\renewcommand{\arraystretch}{1.5}
\tablefirsthead{%
\hline
\textsf{\textbf{ICV}} & \textsf{\textbf{Ways to modify value}} & \textsf{\textbf{Ways to retrieve value}}\\
\hline\\[-3ex]
}
\tablehead{%
\multicolumn{2}{l}{\small\slshape table continued from previous page}\\
\hline
\textsf{\textbf{ICV}} & \textsf{\textbf{Ways to modify value}} & \textsf{\textbf{Ways to retrieve value}}\\
\hline\\[-3ex]
}
\tabletail{%
\hline\\[-4ex]
\multicolumn{2}{l}{\small\slshape table continued on next page}\\
}
\tablelasttail{\hline}
\tablecaption{Ways to Modify and to Retrieve ICV Values\label{tab:Ways to Modify and to Retrieve ICV Values}}
\begin{supertabular}{ p{1.2in} p{2.0in} p{1.5in}}
{\splc{dyn-var}} & {\scode{omp_set_dynamic()}} & {\scode{omp_get_dynamic()}}\\

{\splc{nest-var}} & {\scode{omp_set_nested()}} & {\scode{omp_get_nested()}}\\

{\splc{nthreads-var}} & {\scode{omp_set_num_threads()}} & {\scode{omp_get_max_threads()}}\\

{\splc{run-sched-var}} & {\scode{omp_set_schedule()}} & {\scode{omp_get_schedule()}}\\

{\splc{def-sched-var}} & (none) & (none)\\

{\splc{bind-var}} & (none) & {\scode{omp_get_proc_bind()}}\\

{\splc{stacksize-var}} & (none) & (none)\\

{\splc{wait-policy-var}} & (none) & (none)\\

{\splc{thread-limit-var}} & {\scode{thread_limit}} clause & {\scode{omp_get_thread_limit()}}\\

{\splc{max-active-levels-var}} & {\scode{omp_set_max_active_levels()}} & {\scode{omp_get_max_active_levels()}}\\

{\splc{active-levels-var}} & (none) & {\scode{omp_get_active_level()}}\\

{\splc{levels-var}} & (none) & {\scode{omp_get_level()}}\\

{\splc{place-partition-var}} & (none) & See description below \\

{\splc{cancel-var}} & (none) & {\scode{omp_get_cancellation()}}\\

{\splc{display-affinity-var}} & (none) & (none)\\

{\splc{affinity-format-var}} & {\scode{omp_set_affinity_format()}} & {\scode{omp_get_affinity_format()}}\\

{\splc{default-device-var}} & {\scode{omp_set_default_device()}} & {\scode{omp_get_default_device()}}\\

{\splc{target-offload-var}} & (none) & (none)\\

{\splc{max-task-priority-var}} & (none) & {\scode{omp_get_max_task_priority()}}\\
{\splc{tool-var}} & (none) & (none)\\
{\splc{tool-libraries-var}} & (none) & (none)\\
{\splc{debug-var}} & (none) & (none) \\

{\splc{def-allocator-var}} & {\scode{omp_set_default_allocator()}} & {\scode{omp_get_default_allocator()}}\\

\end{supertabular}

\linenumbers} % end of \small block

\descr
\begin{itemize}
\item The value of the \plc{nthreads-var} ICV is a list. The runtime call
\code{omp_set_num_threads} sets the value of the first element of this list, and
\code{omp_get_max_threads} retrieves the value of the first element of this list.

\item The value of the \plc{bind-var} ICV is a list. The runtime call \code{omp_get_proc_bind}
retrieves the value of the first element of this list.

\item
Detailed values in the \plc{place-partition-var} ICV are retrieved using the runtime calls
\code{omp_get_partition_num_places}, \code{omp_get_partition_place_nums},
\code{omp_get_place_num_procs}, and \code{omp_get_place_proc_ids}.
\end{itemize}

\crossreferences
\begin{itemize}
\item \code{thread_limit} clause of the \code{teams} construct, see \specref{subsec:teams Construct}.

\item \code{omp_set_num_threads} routine, see \specref{subsec:omp_set_num_threads}.

\item \code{omp_get_max_threads} routine, see \specref{subsec:omp_get_max_threads}.

\item \code{omp_set_dynamic} routine, see \specref{subsec:omp_set_dynamic}.

\item \code{omp_get_dynamic} routine, see \specref{subsec:omp_get_dynamic}.

\item \code{omp_get_cancellation} routine, see \specref{subsec:omp_get_cancellation}.

\item \code{omp_set_nested} routine, see \specref{subsec:omp_set_nested}.

\item \code{omp_get_nested} routine, see \specref{subsec:omp_get_nested}.

\item \code{omp_set_schedule} routine, see \specref{subsec:omp_set_schedule}.

\item \code{omp_get_schedule} routine, see \specref{subsec:omp_get_schedule}.

\item \code{omp_get_thread_limit} routine, see \specref{subsec:omp_get_thread_limit}.

\item \code{omp_set_max_active_levels} routine, see \specref{subsec:omp_set_max_active_levels}.

\item \code{omp_get_max_active_levels} routine, see \specref{subsec:omp_get_max_active_levels}.

\item \code{omp_get_level} routine, see \specref{subsec:omp_get_level}.

\item \code{omp_get_active_level} routine, see \specref{subsec:omp_get_active_level}.

\item \code{omp_get_proc_bind} routine, see \specref{subsec:omp_get_proc_bind}.

\item \code{omp_get_place_num_procs} routine, see \specref{subsec:omp_get_place_num_procs}.

\item \code{omp_get_place_proc_ids} routine, see \specref{subsec:omp_get_place_proc_ids}.

\item \code{omp_get_partition_num_places} routine, see \specref{subsec:omp_get_partition_num_places}.

\item \code{omp_get_partition_place_nums} routine, see \specref{subsec:omp_get_partition_place_nums}.

\item \code{omp_set_affinity_format} routine, see \specref{subsec:omp_set_affinity_format}.

\item \code{omp_get_affinity_format} routine, see \specref{subsec:omp_get_affinity_format}.

\item \code{omp_set_default_device} routine, see \specref{subsec:omp_set_default_device}.

\item \code{omp_get_default_device} routine, see \specref{subsec:omp_get_default_device}.

\item \code{omp_get_max_task_priority} routine, see \specref{subsec:omp_get_max_task_priority}.

\item \code{omp_set_default_allocator} routine, see \specref{subsec:omp_set_default_allocator}.

\item \code{omp_get_default_allocator} routine, see \specref{subsec:omp_get_default_allocator}.
\end{itemize}









\subsection{How ICVs are Scoped}
\label{subsec:How ICVs are Scoped}
Table~\ref{tab:Scopes of ICVs} shows the ICVs and their scope.

\nolinenumbers
\tablefirsthead{%
\hline
\textsf{\textbf{ICV}} & \textsf{\textbf{Scope}}\\
\hline \\[-3ex]
}
\tablehead{%
\multicolumn{2}{l}{\small\slshape table continued from previous page}\\
\hline
\textsf{\textbf{ICV}} & \textsf{\textbf{Scope}}\\
\hline \\[-3ex]
}
\tabletail{%
\hline\\[-4ex]
\multicolumn{2}{l}{\small\slshape table continued on next page}\\
}
\tablelasttail{\hline}
\tablecaption{Scopes of ICVs\label{tab:Scopes of ICVs}}
\begin{supertabular}{p{1.5in} p{2.5in}}
{\splc{dyn-var}} & data environment\\
{\splc{nest-var}} & data environment\\
{\splc{nthreads-var}} & data environment\\
{\splc{run-sched-var}} & data environment\\
{\splc{def-sched-var}} & device\\
{\splc{bind-var}} & data environment\\
{\splc{stacksize-var}} & device\\
{\splc{wait-policy-var}} & device\\
{\splc{thread-limit-var}} & data environment\\
{\splc{max-active-levels-var}} & device\\
{\splc{active-levels-var}} & data environment\\
{\splc{levels-var}} & data environment\\
{\splc{place-partition-var}} & implicit task\\
{\splc{cancel-var}} & global\\
{\splc{display-affinity-var}} & global \\
{\splc{affinity-format-var}} & device \\
{\splc{default-device-var}} & data environment\\
{\splc{target-offload-var}} & global\\
{\splc{max-task-priority-var}} & global\\
{\splc{tool-var}} & global\\
{\splc{tool-libraries-var}} & global\\
{\splc{debug-var}} & global \\
{\splc{third-party-tool-var}} & global \\
{\splc{def-allocator-var}} & implicit task\\
\end{supertabular}

\linenumbers

\descr
\begin{itemize}
\item There is one copy per device of each ICV with device scope

\item Each data environment has its own copies of ICVs with data environment scope

\item Each implicit task has its own copy of ICVs with implicit task scope
\end{itemize}

Calls to OpenMP API routines retrieve or modify data environment scoped ICVs in the
data environment of their binding tasks.










\subsubsection{How the Per-Data Environment ICVs Work}
\label{subsubsec:How the Per-Data Environment ICVs Work}
When a \code{task} construct or \code{parallel} construct is encountered, the generated task(s)
inherit the values of the data environment scoped ICVs from the generating task's ICV
values.

When a \code{parallel} construct is encountered, the value of each ICV witch implicit task scope is inherited, unless otherwise specified, from the implicit binding task of the generating task unless otherwise specified.

When a \code{task} construct is encountered, the generated task inherits the value of
\plc{nthreads-var} from the generating task's \plc{nthreads-var} value. When a \code{parallel}
construct is encountered, and the generating task's \plc{nthreads-var} list contains a single
element, the generated task(s) inherit that list as the value of \plc{nthreads-var}. When a
\code{parallel} construct is encountered, and the generating task's \plc{nthreads-var} list contains
multiple elements, the generated task(s) inherit the value of \plc{nthreads-var} as the list
obtained by deletion of the first element from the generating task's \plc{nthreads-var} value.
The \plc{bind-var} ICV is handled in the same way as the \plc{nthreads-var} ICV.

When a \plc{target task} executes a \code{target} region, the generated initial task uses the values of the data environment scoped ICVs from the device data environment ICV values of the device that will execute the region.

If a \code{teams} construct with a \code{thread_limit} clause is encountered,
the \plc{thread-limit-var} ICV of the construct's data environment is instead set to a value that is less than or equal to the value specified in the clause.

When encountering a loop worksharing region with \code{schedule(runtime)}, all
implicit task regions that constitute the binding parallel region must have the same value
for \plc{run-sched-var} in their data environments. Otherwise, the behavior is unspecified.








\subsection{ICV Override Relationships}
\label{subsec:ICV Override Relationships}
Table~\ref{tab:ICV Override Relationships} shows the override relationships
among construct clauses and ICVs.

\nolinenumbers
\renewcommand{\arraystretch}{1.5}
\tablefirsthead{%
\hline
\textsf{\textbf{ICV}} & \textsf{\textbf{construct clause, if used}}\\
\hline\\[-3ex]
}
\tablehead{%
\multicolumn{2}{l}{\small\slshape table continued from previous page}\\
\hline
\textsf{\textbf{ICV}} & \textsf{\textbf{construct clause, if used}}\\
\hline\\[-3ex]
}
\tabletail{%
\hline\\[-4ex]
\multicolumn{2}{l}{\small\slshape table continued on next page}\\
}
\tablelasttail{\hline}
\tablecaption{ICV Override Relationships\label{tab:ICV Override Relationships}}
\begin{supertabular}{ p{1.3in} p{2.0in}}
{\splc{dyn-var}} & (none)\\
{\splc{nest-var}} & (none)\\
{\splc{nthreads-var}} & {\scode{num_threads}}\\
{\splc{run-sched-var}} & {\scode{schedule}}\\
{\splc{def-sched-var}} & {\scode{schedule}}\\
{\splc{bind-var}} & {\scode{proc_bind}}\\
{\splc{stacksize-var}} & (none)\\
{\splc{wait-policy-var}} & (none)\\
{\splc{thread-limit-var}} & (none)\\
{\splc{max-active-levels-var}} & (none)\\
{\splc{active-levels-var}} & (none)\\
{\splc{levels-var}} & (none)\\
{\splc{place-partition-var}} & (none)\\
{\splc{cancel-var}} & (none)\\
{\splc{display-affinity-var}} & (none) \\
{\splc{affinity-format-var}} & (none) \\
{\splc{default-device-var}} & (none)\\
{\splc{target-offload-var}} & (none)\\
{\splc{max-task-priority-var}} & (none)\\
{\splc{tool-var}} & (none)\\
{\splc{tool-libraries-var}} & (none)\\
{\splc{debug-var}} & (none) \\
{\splc{def-allocator-var}} & {\scode{allocator}}\\
\end{supertabular}

\linenumbers

\descr
\begin{itemize}
\item The \code{num_threads} clause overrides the value of the first element of the
\plc{nthreads-var} ICV.

\item If \plc{bind-var} is not set to \plc{false} then the \code{proc_bind} clause overrides the value of the
first element of the \plc{bind-var} ICV; otherwise, the \code{proc_bind} clause has no effect.
\end{itemize}

\crossreferences
\begin{itemize}
\item \code{parallel} construct, see
\specref{sec:parallel Construct}.

\item \code{proc_bind} clause,
\specref{sec:parallel Construct}.

\item \code{num_threads} clause, see
\specref{subsec:Determining the Number of Threads for a parallel Region}.

\item Loop construct, see
\specref{subsec:Loop Construct}.

\item \code{schedule} clause, see
\specref{subsubsec:Determining the Schedule of a Worksharing Loop}.
\end{itemize}





%% \filbreak
\begin{ccppspecific}
\section{Array Shaping}
\label{sec:Array Shaping}
\index{array shaping}


If an expression has a pointer to \plc{T} type, then a shape-operator can be
used to specify the extent of that pointer. In other words, the
shape-operator is used to reinterpret, as an n-dimensional array, the region of
memory pointed by that expression.

Formally, the syntax of the shape-operator is as follows:
\begin{indentedcodelist}
\plc{ shaped-expression } := ([\plc{s}@\textsubscript{\plc{1}}@\plc{}][\plc{s}@\textsubscript{\plc{2}}@]...[\plc{s}@\textsubscript{\plc{n}}@])\plc{expression}
\end{indentedcodelist}

The result of applying the shape-operator to an expression is an lvalue
expression with an n-dimensional array type with dimensions
\plc{s}\textsubscript{\plc{1}} $\times$ \plc{s}\textsubscript{\plc{2}} ...
$\times$ \plc{s}\textsubscript{\plc{n}} and element type \plc{T}.

The precedence of the shape operator is the same as a type cast.

Each $\plc{s}_\plc{i}$ is an integral type expression that must evaluate to a positive integer.

\restrictions
Restrictions on the shape-operator are as follows:

\begin{itemize}
\item The \plc{T} type must be a complete type.

\item The shape-operator can appear only in clauses where it is explicitly allowed.

\item The type of the expression upon which a shape-operator is applied must be a pointer type.

\begin{cppspecific}
\item If the \plc{T} type is a reference to a type \plc{T'} then the type will be considered to be \plc{T'}
for all purposes of the designated array.
\end{cppspecific}

\end{itemize}
\end{ccppspecific}





%% \filbreak
\section{Array Sections}
\label{sec:Array Sections}
\index{array sections}
An array section designates a subset of the elements in an array.

\begin{ccppspecific}
To specify an array section in an OpenMP construct, array subscript expressions are
extended with the following syntax:
\begin{indentedcodelist}
[\plc{ lower-bound }:\plc{ length }:\plc{ stride}] \textnormal{or}

[\plc{ lower-bound }:\plc{ length }:\plc{ }] \textnormal{or}

[\plc{ lower-bound }:\plc{ length }] \textnormal{or}

[\plc{ lower-bound }:\plc{ }:\plc{ stride}] \textnormal{or}

[\plc{ lower-bound }:\plc{ }:\plc{ }] \textnormal{or}

[\plc{ lower-bound }:\plc{ }] \textnormal{or}

[ :\plc{ length }:\plc{ stride}] \textnormal{or}

[ :\plc{ length }:\plc{ }] \textnormal{or}

[ :\plc{ length }] \textnormal{or}

[\plc{ }:\plc{ }:\plc{ stride}]

[\plc{ }:\plc{ }:\plc{ }]

[\plc{ }:\plc{ }]
\end{indentedcodelist}

% TODO: consider removing this in future ticket
The array section must be a subset of the original array.

% This is now in the glossary.
%The \emph{base expression} of an array section or an array element is an expression that specifies
%the address of the initial element of the original array.

Array sections are allowed on multidimensional arrays. Base language array subscript
expressions can be used to specify length-one dimensions of multidimensional array
sections.

The \plc{lower-bound}, \plc{length} and \plc{stride} are integral type 
expressions. When evaluated they represent a set of integer values as follows:

\{ \plc{lower-bound}, \plc{lower-bound} + \plc{stride}, \plc{lower-bound} + 2 * \plc{stride},... , \plc{lower-bound} + ((\plc{length} - 1) * \plc{stride}) \}

The \plc{length} must evaluate to a non-negative integer.

The \plc{stride} must to a positive integer.

When the size of the array dimension is not known, the \plc{length} must 
be specified explicitly.

When the \plc{stride} is absent it defaults to 1.

When the \plc{length} is absent, it defaults to 
$(\plc{size} - \plc{lower-bound})/\plc{stride}$ where \plc{size} is
the size of the array dimension 

When the \plc{lower-bound} is absent it defaults to 0.

The precedence of an array section is the same as the subscript operator.

% TODO: consider adding this in future ticket
%Each array element specified by an array section is determined according to
%the base expression of the array section and the array subscript expressions
%derived from its array section subscripts.

\begin{note}
The following are examples of array sections:

\begin{indentedcodelist}
a[0:6]
a[:6]
a[1:10]
a[1:]
b[10][:][:0]
c[1:10][42][0:6]
S.c[:100]
p->y[:10]
this->a[:N]
\end{indentedcodelist}

The first two examples are equivalent. If \code{a} is declared to be an eleven
element array, the third and fourth examples are equivalent. The fifth example
is a zero-length array section. The sixth example is not contiguous.  The
remaining examples show array sections that are formed from more general base
expressions.
\end{note}
\medskip
\end{ccppspecific}

\begin{fortranspecific}
Fortran has built-in support for array sections although some
restrictions apply to their use, as enumerated in the following section.
\end{fortranspecific}

\restrictions
Restrictions to array sections are as follows:

\begin{itemize}
\item An array section can appear only in clauses where it is explicitly allowed.

\item A \plc{stride} expression may not be specified unless otherwise stated.

\begin{ccppspecific}

%\item An array section can only be specified for a base expression.
\item An element of an array section with a non-zero size must have a complete type.

\item The type of the base expression appearing in an array section must be
    an array or pointer type.

\end{ccppspecific}

\begin{cppspecific}
\item If the type of the base expression of an array section is a reference to a type \plc{T} then the type will be considered to be \plc{T} for all purposes of the array section.

\item An array section cannot be used in a C++ user-defined \code{[]}-operator.
\end{cppspecific}

\begin{fortranspecific}

\item If a stride expression is specified, it must be positive.

\item The upper bound for the last dimension of an assumed-size dummy
  array must be specified.

\item If a list item is an array section with vector subscripts, the
  first array element must be the lowest in the array element order of
  the array section.


\end{fortranspecific}


\end{itemize}




\section{Iterators}
\index{iterators}
\label{sec:iterators}

Iterators are identifiers that expand to multiple values in the clause on which they appear.

The syntax of an \plc{iterators-definition} is the following:
\begin{ompSyntax}
\plc{iterator-specifier [}, \plc{iterators-definition ]}
\end{ompSyntax}

The syntax of an \plc{iterator-specifier} is one of the following:
\begin{indentedcodelist}
\plc{[ iterator-type ] } \plc{identifier} = \plc{range-specification}
\end{indentedcodelist}

where:
\begin{itemize}
\item \plc{identifier} is a base language identifier.
\begin{ccppspecific}
\item \plc{iterator-type} is a type name.
\end{ccppspecific}
\begin{fortranspecific}
\item \plc{iterator-type} is a type specifier.
\end{fortranspecific}

\item \plc{range-specification} is of the form \plc{begin}\code{:}\plc{end[}\code{:}\plc{step]} where \plc{begin}, \plc{end} and \plc{step} are expressions for which their types can be converted to the \plc{iterator-type} type.

\begin{ccppspecific}
\item In an \plc{iterator-specifier}, if the \plc{iterator-type} is not specified then the type of that iterator is of \code{int} type.
\end{ccppspecific}

%\newpage %% HACK

\begin{fortranspecific}
\item In an \plc{iterator-specifier}, if the \plc{iterator-type} is not specified then the type of that iterator is default integer.
\end{fortranspecific}
\end{itemize}

In a \plc{range-specification}, if the \plc{step} is not specified its value is implicitly defined to be 1.

An iterator only exists in the context of the clause on which it appears. An iterator also hides all accessible symbols with the same name in the context of the clause.

The use of a variable in an expression that appears in the \plc{range-specification} causes an implicit reference to the variable in all enclosing constructs.

\begin{ccppspecific}
The values of the iterator are the set of values $i_{0}$...$i_{N-1}$ where $i_{0}=begin$,  $i_{j}=i_{j-1} + step$ and
\begin{itemize}
\item $i_{0} < end$ and $i_{N-1} < end$ and $i_{N-1} + step >= end$ if $step > 0$.
\item $i_{0} > end$ and $i_{N-1} > end$ and $i_{N-1} + step <= end$ if $step < 0$.
\end{itemize}
\end{ccppspecific}
\begin{fortranspecific}
The values of the iterator are the set of values $i_{1}$...$i_{N}$ where $i_{1}=begin$,  $i_{j}=i_{j-1} + step$ and
\begin{itemize}
\item $i_{1} <= end$ and $i_{N} <= end$ and $i_{N} + step > end$ if $step > 0$.
\item $i_{1} >= end$ and $i_{N} >= end$ and $i_{N} + step < end$ if $step < 0$.
\end{itemize}
\end{fortranspecific}
The set of of values will be empty if no possible value complies with the conditions above.

 For those clauses that contain expressions containing iterator identifiers, the
effect is as if the list item is instantiated within the clause for each
value of the iterator in the set defined above, substituting each occurrence of
the iterator identifier in the expression with the iterator value. If the set of values of the iterator is empty then the effect is as if the clause was not specified.

\restrictions

\begin{itemize}
\item An expression containing an iterator identifier can only appear in clauses that explicitly allow expressions containing iterators.
\begin{ccppspecific}
\item The \plc{iterator-type} must be an integral or pointer type.
\end{ccppspecific}
\begin{fortranspecific}
\item The \plc{iterator-type} must be an integer type.
\end{fortranspecific}
\item If the \plc{step} expression of a \plc{range-specification} equals zero the behavior is unspecified.
\item Each iterator identifier can only be defined once in an \plc{iterators-definition}.
\item Iterators cannot appear in the \plc{range-specification}.
\end{itemize}


\section{Variant Directives}
\label{sec:Variant Directives}
\index{variant directives}
\index{directives!variant directives}

\subsection{OpenMP Context}
\label{subsec:OpenMP Context}

At any point in a program, an OpenMP context exists that defines traits describing the active OpenMP constructs, the execution devices, and functionallity supported by the implementation. The traits are grouped in trait sets. The following trait sets exist: \plc{construct}, \plc{device} and \plc{implementation}.

The \plc{construct} set is composed of the directive names, each being a trait, of all enclosing executable directives at that point in the program up to a \code{target} directive. Combined and composite constructs will be added to the set as independent constructs in the same nesting order specified by the original construct. The set is ordered by their nesting level in increasing order. In addition, if the point in the program is not enclosed by a \code{target} directive, the following rules will be applied in order:
\begin{enumerate} 
 \item for functions with a \code{declare simd} directive, the \plc{simd} trait will be added at the beginning of the set for the generated SIMD versions.  
 \item for functions with a \code{declare variant} directive, the selectors of the \code{construct} selector set will be added in the same order at the beginning of the set.
 \item for functions within a \code{declare target} block, the \plc{target} trait will be added at the beginning of the set for the versions of the function being generated for \code{target} regions.
\end{enumerate}

The \plc{simd} trait can be further defined with properties that match the clauses accepted by the \code{declare}~\code{simd} directive with the same name and semantics. The \plc{simd} trait will define at least the \plc{simdlen} property and one of  the \plc{inbrach} or \plc{notinbranch} properties.

The \plc{device} set includes traits that define the characteristics of the device being targeted by the compiler at that point in the program. At least the following traits must be defined:
\begin{itemize}
 \item The \plc{kind(kind-name-list)} trait specifies the general kind of the device. The following \plc{kind-name} values are defined:
 \begin{itemize}
  \item \plc{host} specifies that the device is the host device.
  \item \plc{nohost} specifies that the devices is not the host device. 
  \item Values defined in the ``OpenMP Context Definitions'' document which is available on \url{http://www.openmp.org/}. 
 \end{itemize}
 \item The \plc{isa(isa-name-list)} trait specifies the Instruction Set Architectures supported by the device. The accepted \plc{isa-name} values are implementation defined.
 \item The \plc{arch(arch-name-list)} trait specifies the architectures supported by the device. The accepted \plc{arch-name} values are implementation defined.
\end{itemize}

The \plc{implementation} set includes traits that describe the functionallity supported by the OpenMP implementation at that point in the program. At least the following traits can be defined:
\begin{itemize}
 \item The \plc{vendor(vendor-name)} trait specifies the name of the vendor of the implementation. OpenMP defined values for \plc{vendor-name} are defined in the ``OpenMP Context Definitions'' document which is available on \url{http://www.openmp.org/}. 
 \item The \plc{extension(extension-name-list)} trait specifies vendor specific extensions to the OpenMP specification. The accepted \plc{extension-name} values are implementation defined.
 \item A trait with the same name corresponding to each clause that can be supplied to the \code{requires} directive.
\end{itemize}

Implementations can define further traits in the \plc{device} and \plc{implementation} sets. All implementation defined traits must follow the following syntax:
\begin{ompSyntax}
\plc{identifier[}(\plc{context-element[}, \plc{context-element[}, \plc{...]]})\plc{]}

\plc{context-element}:
  \plc{identifier[}(\plc{context-element[}, \plc{context-element[}, \plc{...]]})\plc{]}
  or
  \plc{context-value}

\plc{context-value}:
  \plc{string}
  or
  \plc{integer expression}
\end{ompSyntax}

where \plc{identifier} is a base language identifier.

\subsection{Context Selectors}
\label{subsec:Context Selectors} 

Context selectors allow to define the properties of an OpenMP context that a directive or clause wants to match. OpenMP defines different sets of selectors, each containing different selectors.

The syntax to define a \plc{context-selector-specification} is the following:

\begin{ompSyntax}
\plc{trait-set-selector[},\plc{trait-set-selector[},\plc{...]]}

\plc{trait-set-selector}:
   \plc{trait-set-selector-name}={\plc{trait-selector[}, \plc{trait-selector[}, \plc{...]]}}

\plc{trait-selector}:
   \plc{trait-selector-name[}(\plc{trait-property[}, \plc{trait-property[}, \plc{...]]})\plc{]}
\end{ompSyntax}

The \code{construct} selector set defines which \plc{construct} traits should be active in the OpenMP context. The following selectors can be defined in the \code{construct} set: \code{target}, \code{teams}, \code{parallel}, \code{for} (in C/C++), \code{do} (in Fortran), and \code{simd}. The properties of each selector are the same defined for the corresponding trait. The \code{construct} selector is an ordered list.

The \code{device} and \code{implementation} selector sets define which traits should be active in the corresponding trait set of the OpenMP context. The same traits defined in the corresponding traits sets can be used as selectors with the same properties. The \code{kind} selector of the \code{device} selector set can also be set to the value \code{any} which is as if no \code{kind} selector was specified. 

The \code{user} selector set defines the \code{condition} selector that provides additional user-defined conditions. 
\begin{cspecific}
The \code{condition(}\plc{boolean-expr}\code{)} selector defines a \plc{constant expression} that must evaluate to true for the selector to be true. 
\end{cspecific}
\begin{cppspecific}
The \code{condition(}\plc{boolean-expr}\code{)} selector defines a \plc{constexpr} expression that must evaluate to true for the selector to be true.  
\end{cppspecific}
\begin{fortranspecific}
The \code{condition(}\plc{logical-expr}\code{)} selector defines a \plc{constant expression} that must evaluate to true for the selector to be true. 
\end{fortranspecific}

Implementations can allow further selectors to be specified. Implementations can ignore specified selectors that are not those described in this section.

\restrictions
\begin{itemize}
 \item Each \plc{trait-set-selector-name} can only be specified once.
 \item Each \plc{trait-selector-name} can only be specified once.
\end{itemize}

\subsection{Matching and Scoring Context Selectors}
\label{subsec:Matching and Scoring Context Selectors}

A given context selector is compatible with a given OpenMP context if:
\begin{itemize}
 \item All selectors in the \code{user} set of the context selector are true,
 \item All selectors in the \code{construct}, \code{device} and \code{implementation} sets of the context selector appear in the corresponding trait set of the OpenMP context,
 \item For each selector in the context selector, its properties are a subset of the properties of the corresponding trait of the OpenMP context,
 \item Selectors in the \code{construct} set of the context selector appear in the same relative order as their correspending traits in the \plc{construct} trait set of the OpenMP context.
\end{itemize}

Some properties of the \code{simd} selector have special rules to match the properties of the \plc{simd} trait:
\begin{itemize}
 \item The \code{simdlen(}\plc{N}\code{)} property of the selector matches the \plc{simdlen(M)} trait of the OpenMP context $M \% N$ equals zero.
 \item The \code{aligned(}\plc{list:N}\code{)} property of the selector matches the \plc{aligned(list:M)} trait of the OpenMP context if $N \% M$ equals zero.
\end{itemize}

Among compatible context selectors a score will be computed using the following algorithm:
\begin{enumerate}
 \item Each trait appearing in the \plc{construct} trait set in the OpenMP context gets assigned the value $2^{p-1}$ where $p$ is the position of trait in the set.
 \item The \code{kind}, \code{arch} and \code{isa} selectors will have the value $2^{l}$, $2^{l+1}$ and $2^{l+2}$ respectively where $l$ is the number of traits in the \plc{construct} set.
 \item Additional implementation allowed selector values are implementation defined.
 \item Other selectors have a value of zero.
 \item Context selectors which are a strict subset of another context selector have a score of zero. For other context selectors, the final score is the addition of the values of all the specified selectors plus $1$. If the traits corrpesding to the \code{construct} selectors appear multiple times in the OpenMP context, the highest valued subset of traits that contains all the selectors in the same order will be used.
\end{enumerate}

\subsection{\hcode{declare variant} Directive}
\index{declare variant@{\code{declare variant}}}
\index{directives!declare variant@{\code{declare variant}}}
\label{subsec:declare variant Directive}
\summary
The \code{declare variant} declares a function to be a specialized variant of another function and in which context it should be used.

\syntax
\begin{ccppspecific}
\begin{samepage}
The syntax of the \code{declare variant} directive is as follows:

\begin{ompcPragma}
#pragma omp declare variant(\plc{base-func-name}) \plc{[clause[ [},\plc{] clause] ... ] new-line}
   \plc{function definition or declaration}
\end{ompcPragma}
\end{samepage}

\begin{samepage}
where \plc{clause} is one of the following{}:

\begin{indentedcodelist}
match(\plc{context-selector-specification})
\end{indentedcodelist}
\end{samepage}
\end{ccppspecific}

\begin{fortranspecific}
The syntax of the \code{declare variant} directive is as follows:

\begin{ompfPragma}
!$omp declare variant(\plc{[proc-name}:\plc{]base-proc-name}) \plc{[clause[ [},\plc{] clause] ... ]}
\end{ompfPragma}

where \plc{clause} is one of the following{}:

\begin{indentedcodelist}
match(\plc{context-selector-specification})
\end{indentedcodelist}
\end{fortranspecific}

\descr

The use of a \code{declare}~\code{variant} directive declares the function to be a function variant of the \plc{base-func-name} or \plc{base-proc-name} function. If no \code{match} clause is specified then the context selector for the variant is empty. If a \code{match} clause is specified then the context selector in the clause will be associated to the variant.

At any point, after the declaration of variant for a given base function, where there is a direct call to that base function the compiler will check if there is any variant that is compatible with OpenMP context at that point. Among the compatible variants, the variant with the highest score according to the algorithm described in Section \ref{subsec:Matching and Scoring Context Selectors} will be selected. If multiple variants have the highest score, it is unspecified which one will be selected. If a compatible variant exists, the original call to the base function will be replaced with a call to the selected variant function. 

The prototype of the variant function shall, in general, match that of the base function. It is implementation defined if for some specific OpenMP context the prototype of the variant should differ, and how, from that of the base function.

\restrictions
Restrictions to the \code{declare variant} directive are as follows:

\begin{itemize}
\item At most one \code{match} clause can appear in a \code{declare variant} directive.
\item If the function definition has a \code{declare}~\code{variant} directive or if a declaration of the function in the same compilation unit has a \code{declare}~\code{variant}, then, calling the variant function directly in an OpenMP context that is different than the one specified by the \code{construct} set of the context selector is non-conforming.

\begin{ccppspecific}
\item If the function has any declarations, then the \code{declare}~\code{variant} directive for any
declaration that has one must be equivalent. If the function definition has a \code{declare}~\code{variant} it must also be equivalent.
Otherwise, the result is unspecified.
\end{ccppspecific}

\begin{cppspecific}
\item \plc{base-func-name} should not designate an overloaded function name. Otherwise, \plc{base-func-name} must be a function declaration without the return type.
\item The \plc{base-func-name} of a \code{declare variant} directive cannot be a template function.
\item The \plc{base-func-name} of a \code{declare variant} directive cannot be a virtual function.
\end{cppspecific}

\begin{fortranspecific}
\item \plc{proc-name} must not be a generic name, procedure pointer or entry name
\item If \plc{proc-name} is omitted, the \code{declare variant} directive must appear in the specification part of a subroutine subprogram or a function subprogram.
\item Any \code{declare variant} directive must appear in the specification part of a subroutine, subprogram, function subprogram or interface body to which it applies.
\item If a \code{declare variant} directive is specified in an interface block for a procedure, it must match a \code{declare variant} directive in the definition of the procedure.
\item If a procedure is declared via a procedure declaration statement, the procedure \plc{proc-name} should appear in the same specification.
\item If a \code{declare variant} diretive is specified for a procedure name with explicit interface and a \code{declare variant} directive is also specified for the definition of the procedure the two \code{declare variant} directives must match. Otherwise the result is unspecified.
\end{fortranspecific}
\end{itemize}

\crossreferences
\begin{itemize}
\item OpenMP Context Specification, see \specref{subsec:OpenMP Context}.
\item Context Selectors, see \specref{subsec:Context Selectors}.
\end{itemize}


\subsection{Metadirective Meta-Directive}
\label{sec:directive variants}
\summary
The metadirective meta-directive can specify multiple directive variants
of which one may be conditionally selected to replace the meta-directive based
on the enclosing context.

\syntax
\begin{ccppspecific}
The syntax of the metadirective meta-directive takes one of the
following forms:
\begin{ompcPragma}
#pragma omp metadirective \plc{[clause[ [},\plc{] clause] ... ] new-line}
\end{ompcPragma}
or
\begin{ompcPragma}
#pragma omp begin metadirective \plc{[clause[ [},\plc{] clause] ... ] new-line}
    \plc{stmt(s)}
#pragma omp end metadirective 
\end{ompcPragma}


\begin{samepage}
where \plc{clause} is:
\begin{indentedcodelist}
    when(\plc{context-selector-specification}: \plc{[directive-variant]})
    default(\plc{directive-variant})
\end{indentedcodelist}
\end{samepage}

\end{ccppspecific}

\begin{fortranspecific}
The syntax of the metadirective meta-directive takes one of the following
forms:

\begin{ompfPragma}
!$omp metadirective \plc{[clause[ [},\plc{] clause] ... ]}
\end{ompfPragma}

or 

\begin{ompfPragma}
!$omp begin metadirective \plc{[clause[ [},\plc{] clause] ... ]}
    \plc{stmt(s)}
!$omp end metadirective 
\end{ompfPragma}

\begin{samepage}
where \plc{clause} is:

\begin{indentedcodelist}
    when(\plc{context-selector-specification}: \plc{[directive-variant]})
    default(\plc{directive-variant})
\end{indentedcodelist}
\end{samepage}

\end{fortranspecific}

In the \code{when} clause, \plc{context-selector-specification} specifies a context
selector (see Section~\ref{subsec:Context Selectors}).

In the \code{when} and \code{default} clauses, \plc{directive-variant}
has the following form and specifies a directive variant that is an OpenMP
directive that has the same directive name and clauses.

\begin{indentedcodelist}
\plc{ directive-name [clause[ [},\plc{] clause] ... ]}
\end{indentedcodelist}

\descr

The metadirective directive is a meta-directive that
behaves as if it is either ignored or replaced by the directive variant
specified in one of the \code{when} or \code{default} clauses that appears on
the directive.

The OpenMP context for a given meta-directive is defined according to Section
\ref{subsec:OpenMP Context}.  For each \code{when} clause that appears on the
meta-directive, the specified directive variant, if present, is a candidate to
replace the meta-directive if the corresponding context selector is compatible
with the OpenMP context according to the matching rules defined in
Section~\ref{subsec:Matching and Scoring Context Selectors}.  If only one
compatible context selector specified by a \code{when} clause has the highest
score and it specifies a directive variant, the directive variant will replace
the meta-directive. If more than one \code{when} clause specifies a compatible
context selector that has the highest computed score and at least one
specifies a directive variant, the first directive variant specified in the
lexical order of those \code{when} clauses will replace the meta-directive.

If no context selector from any \code{when} clause is compatible with the
OpenMP context and a \code{default} clause is present, the directive variant
specified in the \code{default} clause will replace the meta-directive.

If a directive variant is not selected to replace the meta-directive according
to the above rules, the meta-directive has no effect on the execution of program. 

The \code{begin}~\code{metadirective} directive behaves
identically to the \code{metadirective} directive, except that the
directive syntax for the specified directive variants must accept a paired
\code{end}~\plc{directive}.  For any directive variant that is selected to
replace the \code{begin}~\code{metadirective} meta-directive, the
\code{end}~\code{metadirective} directive will be implicitly
replaced by its paired \code{end}~\plc{directive} to demarcate the statements
that are affected by or are associated with the directive variant. If no
directive variant is selected to replace the meta-directive, its paired
\code{end}~\code{metadirective} directive is ignored.

\restrictions
Restrictions for the metadirective directive are as follows:

\begin{itemize}
    \item The directive variant appearing in a \code{when} or \code{default}
        clause must not specify a \code{metadirective},
        \code{begin}~\code{metadirective}, or \code{end}~\code{metadirective}
        directive.

    \item The context selector that appears in a \code{when} clause must not
        specify any properties for the \code{simd} selector.

    \item Any replacement that occurs for a metadirective meta-directive must
        not result in a non-conforming OpenMP program.

    \item Any directive variant that is specified by a \code{when} or \code{default}
        clause on a \code{begin}~\code{metadirective}
        meta-directive must be an OpenMP directive that has a paired \code{end}~\plc{directive}, and
        the \code{begin}~\code{metadirective} directive must have a paired
        \code{end}~\code{metadirective} directive.

    \item The \code{default} clause may appear at most once on the directive.
\end{itemize}
