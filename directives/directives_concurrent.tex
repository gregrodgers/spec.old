% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. There are environments that provide special formatting, e.g. language bars.
%       Please use them whereever appropriate.  Examples are:
%
%         \begin{fortranspecific}
%         This is text that appears enclosed in blue language bars for Fortran.
%         \end{fortranspecific}
%
%         \begin{note}
%         This is a note.  The "Note -- " header appears automatically.
%         \end{note}
%
%    6. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of 
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%

\section{\code{concurrent} Construct}
\index{concurrent@{\code{concurrent}}}
\index{constructs!concurrent@{\code{concurrent}}}
\label{sec:concurrent Construct}
\summary
  A \code{concurrent} construct asserts to the compiler that all iterations of
  the associated loops are free of data dependencies and can be safely run
  concurrently in any order.

\syntax
\begin{ccppspecific}
The syntax of the \code{concurrent} construct is as follows:
\begin{boxedcode}
\#pragma omp concurrent \plc{[clause[ [},\plc{] clause] ... ] new-line}
    \plc{for-loops}
\end{boxedcode}

where \plc{clause} is one of the following:

\begin{indentedcodelist}
private(\plc{list})
firstprivate(\plc{list})
reduction(\plc{reduction-identifier }:\plc{ list})
levels(\plc{n})

\end{indentedcodelist}
The \code{concurrent} directive places restrictions on the structure of all associated \plc{for-loops}. 
Specifically, all associated \plc{for-loops} must have \emph{canonical loop form} (see 
\specref{sec:Canonical Loop Form}).
\end{ccppspecific}

\begin{fortranspecific}
The syntax of the \code{concurrent} construct is as follows:

\begin{boxedcode}
!\$omp concurrent \plc{[clause[ [},\plc{] clause] ... ]}
   \plc{do-loops}
[!\$omp end concurrent]
\end{boxedcode}

\begin{samepage}
where \plc{clause} is one of the following:

\begin{indentedcodelist}
private(\plc{list})
firstprivate(\plc{list})
reduction(\plc{reduction-identifier }:\plc{ list})
levels(\plc{n})
\end{indentedcodelist}
\end{samepage}

If an \code{end}~\code{concurrent} directive is not specified, an
  \code{end}~\code{concurrent} directive is assumed at the end of the 
\plc{do-loops}.

Any associated \plc{do-loop} must be a \plc{do-construct} or an
\plc{inner-shared-do-construct} as defined by the Fortran standard. If
an \code{end}~\code{concurrent} directive follows a \plc{do-construct} in
which several loop statements share a \code{DO} termination statement,
then the directive can only be specified for the outermost of these
\code{DO} statements.

If any of the loop iteration variables would otherwise be shared, they are implicitly 
  made private on the \code{concurrent} construct.
\end{fortranspecific}

% Loop induction variables for the associated loop(s) are private by default.

If a \code{private} or \code{firstprivate} clause appears on the
\code{concurrent} construct then if the iterations of the associated loops are
executed concurrently, then the variables listed in the \code{private} or
\code{firstprivate} clause must behave as if they were made private to each
loop iteration.

If a reduction clause appears on the \code{concurrent} construct and an
implementation chooses to execute the iterations of the associated loops
concurrently, it must perform a parallel reduction with respect to the parallel
execution units (teams, threads, or SIMD lanes) used to execute the loop
iterations. The result of the reduction operation must be usable immediately
following the end of the associated loops.

\binding
If the \code{concurrent} construct is closely nested inside a \code{teams} construct,
the binding thread set of the region is the set of master threads that executes
the \code{teams} region and the region's binding region is the \code{teams} region. If the
\code{concurrent} construct is closely nested inside a \code{parallel} construct, the
binding thread set of the region is the current thread team and the region's
binding region is the \code{parallel} region. Otherwise, the binding thread set for a
\code{concurrent} region is the encountering thread and the binding region is the
current task region.

\descr
The \code{concurrent} construct is associated with a loop nest consisting of one more
more loops that follow the directive. The construct asserts that all iterations
of the associated loop nest are independent with respect to each other, given
that privatization and reduction clauses are honored, and may be executed
concurrently in any order. 

If more than one thread encounters an \code{concurrent} construct the
implementation  will ensure that each logical iteration of the corresponding
loops is executed exactly once.

% An implementation may choose to treat an \code{concurrent} construct as a
% \code{distribute}, Loop, and/or SIMD construct if it would be conforming for a
% programmer to have explicitly specified the selected construct. If the
% implementation chooses to treat an \code{concurrent} construct as one of these
% constructs then the default data sharing and binding will be as-if the
% programmer had specified the implicitly-added construct. A conforming
% implementation may also choose to execute the iterations of the associated loop
% concurrently in ways not represented by these constructs.

The \code{levels} clause may be used to specify how many loops are associated
with the \code{concurrent} construct. The parameter of the \code{levels}
clause must be a constant positive integer expression. If a \code{levels}
clause is present then for the next N nested loops all iterations of the loops
may be executed concurrently with any other iteration in the combined
iteration space of the associated loops in any order. If no \code{levels}
clause appears on the construct, the \code{concurrent} directive applies to
only the loop that immediately follows the directive.

% A \code{concurrent} construct may be nested within other OpenMP regions, but does
% not increase the nesting level, as defined in [add crossref]. \feedback{[Should we
% restrict the nesting to only particular constructs for the first
% implementation?]}

\restrictions
Restrictions to the \code{concurrent} construct are as follows:

\begin{itemize}
  \item An implementation may not generate a new league of thread teams
    as the result of a \code{concurrent} construct.

  \item Only one \code{levels} clause can appear on a \code{concurrent} directive.
  
%JLARKIN Moved to directives_nesting.tex
%    \item Only the following directives may be nested within an
%    \code{concurrent}
%    region: \code{parallel}, \code{distribute}, loop, \code{simd},
%    \code{concurrent}, and \code{single}. 
%    %JLARKIN we'd like to add back atomic eventually. Is there really a reason
%    %to restrict MASTER?

  \item A \code{concurrent} region may not contain calls to functions containing
    OpenMP directives. %JLARKIN Would like to relax this later.
    
%JLARKIN Moved to directives_nesting.tex
%  \item A \code{concurrent} construct must be closely nested within a
%    \code{teams}, \code{parallel}, Loop, SIMD, or \code{concurrent} construct.
%    %JLARKIN in other words, cannot appear by itself in a
%    % function call because it would be hard for a compiler to know how
%    % it can parallelize the loop.

  \item A \code{concurrent} region may not contain calls to the OpenMP Runtime
    API.

\end{itemize}

\begin{ccppspecific}
\begin{itemize}
    
  \item The associated for-loops must be structured blocks.

  \item No statement can branch to any associated \code{concurrent} statement.

\end{itemize}

\end{ccppspecific}

\begin{fortranspecific}
\begin{itemize}
    
  \item The associated do-loops must be structured blocks.
    
  \item No statement in the associated loops other than the DO statements can cause
    a branch out of the loops.


\end{itemize}
\end{fortranspecific}

\crossreferences
\begin{itemize}
  \item The Loop construct, see \specref{subsec:Loop Construct}.

  \item \code{distribute} constrict, see \specref{subsec:distribute Construct}.

  \item SIMD constructs, see \specref{sec:SIMD Constructs}.

  \item The \code{single} construct, see \specref{subsec:single Construct}.

\end{itemize}
%% \pagebreak
