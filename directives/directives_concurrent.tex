% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. There are environments that provide special formatting, e.g. language bars.
%       Please use them whereever appropriate.  Examples are:
%
%         \begin{fortranspecific}
%         This is text that appears enclosed in blue language bars for Fortran.
%         \end{fortranspecific}
%
%         \begin{note}
%         This is a note.  The "Note -- " header appears automatically.
%         \end{note}
%
%    6. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%

\section{\hcode{loop} Construct}
\index{loop@{\code{loop}}}
\index{constructs!loop@{\code{loop}}}
\label{sec:loop Construct}
\summary
  A \code{loop} construct specifies whether the iterations of the associated
  loops may execute concurrently and permits the encountering thread(s) to
  execute the loop accordingly.

\syntax
\begin{ccppspecific}
The syntax of the \code{loop} construct is as follows:
\begin{ompcPragma}
#pragma omp loop \plc{[clause[ [},\plc{] clause] ... ] new-line}
    \plc{for-loops}
\end{ompcPragma}

where \plc{clause} is one of the following:

\begin{indentedcodelist}
nodep
seq
private(\plc{list})
firstprivate(\plc{list})
reduction(\plc{reduction-identifier }:\plc{ list})
collapse(\plc{n})
bind(\plc{binding-region})
\end{indentedcodelist}
The \code{loop} directive places restrictions on the structure of all associated \plc{for-loops}.
Specifically, all associated \plc{for-loops} must have \emph{canonical loop form} (see
\specref{sec:Canonical Loop Form}).
\end{ccppspecific}

\begin{fortranspecific}
The syntax of the \code{loop} construct is as follows:

\begin{ompfPragma}
!$omp loop \plc{[clause[ [},\plc{] clause] ... ]}
   \plc{do-loops}
[!$omp end loop]
\end{ompfPragma}

\begin{samepage}
where \plc{clause} is one of the following:

\begin{indentedcodelist}
nodep
seq
private(\plc{list})
firstprivate(\plc{list})
reduction(\plc{reduction-identifier }:\plc{ list})
collapse(\plc{n})
bind(\plc{binding-region})
\end{indentedcodelist}
\end{samepage}

If an \code{end}~\code{loop} directive is not specified, an
  \code{end}~\code{loop} directive is assumed at the end of the
\plc{do-loops}.

Any associated \plc{do-loop} must be a \plc{do-construct} or an
\plc{inner-shared-do-construct} as defined by the Fortran standard. If
an \code{end}~\code{loop} directive follows a \plc{do-construct} in
which several loop statements share a \code{DO} termination statement,
then the directive can only be specified for the outermost of these
\code{DO} statements.

If any of the loop iteration variables would otherwise be shared, they are implicitly
  made private on the \code{loop} construct.
\end{fortranspecific}

% Loop induction variables for the associated loop(s) are private by default.

%If a \code{private} or \code{firstprivate} clause appears on the
%\code{concurrent} construct and the iterations of the associated loops are
%executed concurrently, then a private copy of the listed variables must be
%created for each thread team, thread, or SIMD lane that executes the
%iterations.
%
%If a \code{reduction} clause appears on the \code{concurrent} construct and an
%implementation executes the iterations of the associated loops concurrently,
%then it must perform a parallel reduction with respect to the parallel
%execution units (teams, threads, or SIMD lanes) used to execute the loop
%iterations. The result of the reduction operation must be available immediately
%following the end of the associated loops.

\binding

If the \code{bind} clause is present on the construct, the binding region is
determined by \plc{binding-region}. If the \code{loop} construct is closely
nested inside a \code{teams} or \code{parallel} construct, the binding region
is the corresponding \code{teams} or \code{parallel} region. If the
\code{loop} construct with the \code{nodep} clause present is closely nested
inside another \code{loop} construct with the \code{nodep} clause present, the
binding region is the \code{loop} region corresponding to that construct.
Otherwise, the \code{loop} region does not have a binding region.

If the binding region is a \code{teams} region, then the binding thread set is
the set of master threads executing that region. If the binding region is a
\code{parallel} region, then the binding thread set is the team of threads
executing that region. If the binding region is a \code{loop} region, then the
binding thread set is the same as the binding thread set for that region. If
the \code{loop} region does not have a binding region, then the binding thread
set is the encountering thread.


% If the \code{concurrent} construct is closely nested inside a \code{teams} construct,
% the binding thread set of the region is the set of master threads that executes
% the \code{teams} region and the region's binding region is the \code{teams} region. If the
% \code{concurrent} construct is closely nested inside a \code{parallel} construct, the
% binding thread set of the region is the current thread team and the region's
% binding region is the \code{parallel} region. Otherwise, the binding thread set for a
% \code{concurrent} region is the encountering thread and the binding region is the
% current task region.

\descr

The \code{loop} construct is associated with a loop nest consisting of
one or more loops that follow the directive. 

The \code{collapse} clause may be used to specify how many loops are
associated with the \code{loop} construct. The parameter of the \code{collapse}
clause must be a constant positive integer expression. If a \code{collapse}
clause is specified with a parameter value greater than 1, then the
iterations of the associated loops to which the clause applies are collapsed
into one larger iteration space. If no \code{collapse} clause is present or its
parameter is 1, the only loop that is associated with the \code{loop} construct
is the one that immediately follows the \code{loop} directive.

If more than one loop is associated with the \code{loop} construct then the
number of times that any intervening code between any two associated
loops will be executed is unspecified but will be at least once per
iteration of the loop enclosing the intervening code and at most once
per iteration of the innermost loop associated with the construct. If the
iteration count of any loop that is associated with the \code{loop} construct and does not
enclose the intervening code is zero then the behavior is unspecified.

The iteration space of the associated loops correspond to logical
iterations numbered 0,1,...,N-1 where N is the number of loop iterations, and
the logical numbering denotes the sequence in which the iterations would be
executed if a set of associated loop(s) were executed sequentially.  At the
beginning of each logical iteration, the loop iteration variable of each
associated loop has the value that it would have if the set of the associated
loop(s) were executed sequentially. 


%The \code{levels} clause may be used to specify how many loops are associated
%with the \code{concurrent} construct. The parameter of the \code{levels}
%clause must be a constant positive integer expression. If a \code{levels}
%clause is present then for the next N nested loops all iterations of the loops
%may be executed concurrently with any other iteration in the combined
%iteration space of the associated loops in any order. If no \code{levels}
%clause appears on the construct, the \code{concurrent} directive applies to
%only the loop that immediately follows the directive.

If the \code{bind} clause is present then \plc{binding-region} may be one of
the following: \code{teams}, \code{parallel}, or \code{none}. If
\plc{binding-region} is \code{teams}, then the innermost enclosing
\code{teams} region is the binding region.  If \plc{binding-region} is
\code{parallel}, then the innermost enclosing \code{parallel} region is the
binding region. If \plc{binding-region} is \code{none}, then the binding
region is not defined for the \code{loop} region.

If the binding region is a \code{teams} or \code{parallel} region, each
logical iteration is executed once per instance of the \code{loop} region that
is encountered by the binding thread set. Otherwise, each logical iteration is
executed once per instance of the \code{loop} region that is encountered by a
thread.

If neither the \code{nodep} clause or the \code{seq} clause is present, the
behavior is as if the \code{nodep} clause appeared on the construct.  If the
\code{nodep} clause appears on the \code{loop} construct, the implementation 
may assume that dependences do not exist between logical iterations, so that
the iterations may execute in any order, including concurrently. If the
\code{seq} clause is present, the iterations must execute as if in their
logical iteration order.

The set of threads that may execute the iterations of the \code{loop} region
is its \emph{executing thread set}. The executing thread set includes all
threads in the binding thread set. Additionally, if the \code{nodep} clause
appears on the corresponding construct, any thread in the executing
thread set may create a thread team, as if from a \code{parallel} construct,
where each thread in the team is included in the executing thread set.

\begin{note}
If the \code{nodep} clause appears on the \code{loop} construct, the number of
threads or levels of parallelism that are used to execute iterations in the
loop is unspecified. Additionally, the directive guarantees that it is safe
for an implementation use SIMD instructions to facilitate concurrent execution
of the associated loops. Additional iteration reordering optimizations may
also be employed by the implementation to take advantage of the assertion of
independence provided by the directive.  
\end{note}

If the \code{loop} region binds to a \code{teams} region, the threads in the
binding thread set may continue execution after the \code{loop} region without
waiting for all iterations of the associated loop(s) to complete. The
iterations are guaranteed to complete before the end of the \code{teams}
region. 

If the \code{loop} region does not bind to a \code{teams} region, all
iterations of the associated loop(s) must complete before the encountering
thread(s) continue execution after the \code{loop} region.


% An implementation may choose to treat an \code{concurrent} construct as a
% \code{distribute}, Loop, and/or SIMD construct if it would be conforming for a
% programmer to have explicitly specified the selected construct. If the
% implementation chooses to treat an \code{concurrent} construct as one of these
% constructs then the default data sharing and binding will be as-if the
% programmer had specified the implicitly-added construct. A conforming
% implementation may also choose to execute the iterations of the associated loop
% concurrently in ways not represented by these constructs.


% A \code{concurrent} construct may be nested within other OpenMP regions, but does
% not increase the nesting level, as defined in [add crossref]. \feedback{[Should we
% restrict the nesting to only particular constructs for the first
% implementation?]}

\restrictions
Restrictions to the \code{loop} construct are as follows:

\begin{itemize}
%  \item An implementation may not generate a new league of thread teams
%    as the result of a \code{loop} construct.

  \item The \code{seq} and \code{nodep} clauses may not both appear on the
      construct.

  \item Only one \code{collapse} clause can appear on a \code{loop} directive.

  \item If a \code{loop} construct is not nested inside another OpenMP
      construct and it appears in a procedure called from the program, the
      \code{bind} clause must be present.

  \item If a \code{loop} region binds to a \code{teams} or \code{parallel}
      region, it must be encountered by all threads in the binding thread set
      or by none of them.

  \item The only construct that may be nested inside a \code{loop} construct
      with the \code{nodep} clause present is the \code{loop} construct.

%JLARKIN Moved to directives_nesting.tex
%    \item Only the following directives may be nested within an
%    \code{concurrent}
%    region: \code{parallel}, \code{distribute}, loop, \code{simd},
%    \code{concurrent}, and \code{single}.
%    %JLARKIN we'd like to add back atomic eventually. Is there really a reason
%    %to restrict MASTER?

  \item A \code{loop} region corresponding to a \code{loop} construct with the
      \code{nodep} clause present may not contain calls to procedures that contain
    OpenMP directives. %JLARKIN Would like to relax this later.

%JLARKIN Moved to directives_nesting.tex
%  \item A \code{concurrent} construct must be closely nested within a
%    \code{teams}, \code{parallel}, Loop, SIMD, or \code{concurrent} construct.
%    %JLARKIN in other words, cannot appear by itself in a
%    % function call because it would be hard for a compiler to know how
%    % it can parallelize the loop.

\item A \code{loop} region corresponding to a \code{loop} construct with the
    \code{nodep} clause present may not contain calls to the OpenMP Runtime
    API.

\end{itemize}

\begin{ccppspecific}
\begin{itemize}

  \item The associated for-loops must be structured blocks.

  \item No statement can branch to any associated \code{for} statement.

\end{itemize}

\end{ccppspecific}

\begin{fortranspecific}
\begin{itemize}

  \item The associated do-loops must be structured blocks.

  \item No statement in the associated loops other than the DO statements can cause
    a branch out of the loops.


\end{itemize}
\end{fortranspecific}

\crossreferences
\begin{itemize}
  \item The Worksharing-Loop construct, see \specref{subsec:Worksharing-Loop Construct}.

  \item \code{distribute} constrict, see \specref{subsec:distribute Construct}.

  \item SIMD constructs, see \specref{sec:SIMD Constructs}.

  \item The \code{single} construct, see \specref{subsec:single Construct}.

\end{itemize}
%% \pagebreak
