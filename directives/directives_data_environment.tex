% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. There are environments that provide special formatting, e.g. language bars.
%       Please use them whereever appropriate.  Examples are:
%
%         \begin{fortranspecific}
%         This is text that appears enclosed in blue language bars for Fortran.
%         \end{fortranspecific}
%
%         \begin{note}
%         This is a note.  The "Note -- " header appears automatically.
%         \end{note}
%
%    6. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%


\section{Data Environment}
\label{sec:Data Environment}
\index{data environment}
This section presents directives and clauses for controlling data environments.

\subsection{Data-Sharing Attribute Rules}
\label{subsec:Data-sharing Attribute Rules}
\index{data-sharing attribute rules}
\index{attributes, data-sharing}
This section describes how the data-sharing attributes of variables referenced in
data environments are determined. The following two cases are described separately:

\begin{itemize}
\item \specref{subsubsec:Variables Referenced in a Construct} describes the 
      data-sharing attribute rules for variables referenced in a construct.
\item \specref{subsubsec:Variables Referenced in a Region but not in a Construct} 
      describes the data-sharing attribute rules for variables referenced in a 
      region, but outside any construct.
\end{itemize}



\subsubsection{Variables Referenced in a Construct}
\label{subsubsec:Variables Referenced in a Construct}
The data-sharing attributes of variables that are referenced in a construct can be
\emph{predetermined}, \emph{explicitly determined}, or \emph{implicitly determined}, 
according to the rules outlined in this section.

Specifying a variable in a data-sharing attribute clause, except for the 
\code{private} clause, or \code{copyprivate} clause of an enclosed construct 
causes an implicit reference to the variable in the enclosing construct. 
Specifying a variable in a \code{map} clause of an enclosed construct may 
cause an implicit reference to the variable in the enclosing construct.
Such implicit references are also subject to the data-sharing attribute 
rules outlined in this section.

Certain variables and objects have \emph{predetermined} data-sharing 
attributes as follows:

\begin{ccppspecific}
\begin{itemize}
\item Variables that appear in \code{threadprivate} directives are threadprivate.
\item Variables with automatic storage duration that are declared in a scope 
      inside the construct are private.
\item Objects with dynamic storage duration are shared.
\item Static data members are shared.
\item The loop iteration variable(s) in the associated \plc{for-loop(s)} of a
      \code{for}, \code{parallel}~\code{for}, \code{taskloop}, or 
      \code{distribute} construct is (are) private.
\item The loop iteration variable in the associated \plc{for-loop} of a
      \code{simd} construct with just one associated \plc{for-loop} is 
      linear with a \plc{linear-step} that is the increment 
      of the associated \plc{for-loop}.
\item The loop iteration variables in the associated \plc{for-loops} of a
      \code{simd} construct with multiple associated \plc{for-loops} are lastprivate.
\item The loop iteration variable(s) in the associated \plc{for-loop(s)} of a
      \code{loop} construct is (are) lastprivate.
\item Variables with static storage duration that are declared in a scope 
      inside the construct are shared.
\item If a list item in a \code{map} clause on the \code{target} construct 
      has a base pointer, and the base pointer is a scalar variable that 
      does not appear in a \code{map} clause on the construct, the base 
      pointer is firstprivate.
\item If a list item in a \code{reduction} or \code{in_reduction} clause on a
      construct has a base pointer then the base pointer is private.
\end{itemize}
\end{ccppspecific}

\begin{fortranspecific}
\begin{itemize}
\item Variables and common blocks that appear in \code{threadprivate} directives
      are threadprivate.
\item The loop iteration variable(s) in the associated \plc{do-loop(s)} of a
      \code{do}, \code{parallel}~\code{do}, \code{taskloop}, or \code{distribute} 
      construct is (are) private.
\item The loop iteration variable in the associated \plc{do-loop} of a
      \code{simd} construct with just one associated \plc{do-loop} is 
      linear with a \plc{linear-step} that is the increment of the 
      associated \plc{do-loop}.
\item The loop iteration variables in the associated \plc{do-loops} of a
      \code{simd} construct with multiple associated \plc{do-loops} are lastprivate.
\item The loop iteration variable(s) in the associated \plc{do-loop(s)} of a
      \code{loop} construct is (are) lastprivate.
\item A loop iteration variable for a sequential loop in a \code{parallel} 
      or task generating construct is private in the innermost such construct 
      that encloses the loop.
\item Implied-do indices and \code{forall} indices are private.
\item Cray pointees have the same data-sharing attribute as the storage 
      with which their Cray pointers are associated.
\item Assumed-size arrays are shared.
\item An associate name preserves the association with the selector established 
      at the \code{ASSOCIATE} or \code{SELECT}~\code{TYPE} statement.
\end{itemize}
\end{fortranspecific}

Variables with predetermined data-sharing attributes may not be listed in 
data-sharing attribute clauses, except for the cases listed below. For these 
exceptions only, listing a predetermined variable in a data-sharing attribute 
clause is allowed and overrides the variable's predetermined data-sharing attributes.

\begin{ccppspecific}
\begin{itemize}
\item The loop iteration variable(s) in the associated \plc{for-loop(s)} of
      a \code{for}, \code{parallel}~\code{for}, \code{taskloop}, \code{distribute},
      or \code{loop} construct may be listed in a \code{private} or 
      \code{lastprivate} clause.
\item The loop iteration variable in the associated \plc{for-loop} of a 
      \code{simd} construct with just one associated \plc{for-loop} may be 
      listed in a \code{private}, \code{lastprivate}, or \code{linear} clause 
      with a \plc{linear-step} that is the increment of the associated \plc{for-loop}.
\item The loop iteration variables in the associated \plc{for-loops} of a 
      \code{simd} construct with multiple associated \plc{for-loops} may be 
      listed in a \code{private} or \code{lastprivate} clause.
\item Variables with \code{const}-qualified type with no mutable members may 
      be listed in a \code{firstprivate} clause, even if they are static data members.
\end{itemize}
\end{ccppspecific}

\begin{fortranspecific}
\begin{itemize}
\item The loop iteration variable(s) in the associated \plc{do-loop(s)} of a 
      \code{do}, \code{parallel}~\code{do}, \code{taskloop}, \code{distribute},
      or \code{loop} construct may be listed in a \code{private} or 
      \code{lastprivate} clause.
\item The loop iteration variable in the associated \plc{do-loop} of a \code{simd} 
      construct with just one associated \plc{do-loop} may be listed in a 
      \code{private}, \code{lastprivate}, or \code{linear} clause with a 
      \plc{linear-step} that is the increment of the associated loop.
\item The loop iteration variables in the associated \plc{do-loops} of a 
      \code{simd} construct with multiple associated \plc{do-loops} may be 
      listed in a \code{private} or \code{lastprivate} clause.
\item Variables used as loop iteration variables in sequential loops in a 
      \code{parallel} or task generating construct may be listed in 
      data-sharing attribute clauses on the construct itself, and on
      enclosed constructs, subject to other restrictions.
\item Assumed-size arrays may be listed in a \code{shared} clause.
\end{itemize}
\end{fortranspecific}

Additional restrictions on the variables that may appear in individual clauses are
described with each clause in \specref{subsec:Data-Sharing Attribute Clauses}.

Variables with \emph{explicitly determined} data-sharing attributes are those that 
are referenced in a given construct and are listed in a data-sharing attribute clause 
on the construct.

Variables with \emph{implicitly determined} data-sharing attributes are those that 
are referenced in a given construct, do not have predetermined data-sharing 
attributes, and are not listed in a data-sharing attribute clause on the construct.

Rules for variables with \emph{implicitly determined} data-sharing attributes 
are as follows:

\begin{itemize}
\item In a \code{parallel}, \code{teams}, or task generating construct, the 
      data-sharing attributes of these variables are determined by the 
      \code{default} clause, if present (see \specref{subsubsec:default clause}).
\item In a \code{parallel} construct, if no \code{default} clause is present, 
      these variables are shared.
\item For constructs other than task generating constructs, if no \code{default} 
      clause is present, these variables reference the variables with the same 
      names that exist in the enclosing context.
\item In a \code{target} construct, variables that are not mapped after applying 
      data-mapping attribute rules (see 
      \specref{subsec:Data-Mapping Attribute Rules, Clauses, and Directives}) 
      are firstprivate.
\end{itemize}

\begin{cppspecific}
\begin{itemize}
\item In an orphaned task generating construct, if no \code{default} clause is 
      present, formal arguments passed by reference are firstprivate.
\end{itemize}
\end{cppspecific}

\begin{fortranspecific}
\begin{itemize}
\item In an orphaned task generating construct, if no \code{default} clause is 
      present, dummy arguments are firstprivate.
\end{itemize}
\end{fortranspecific}

\begin{itemize}
\item In a task generating construct, if no \code{default} clause is present, a 
      variable for which the data-sharing attribute is not determined by the rules 
      above and that in the enclosing context is determined to be shared by all 
      implicit tasks bound to the current team is shared.
\item In a task generating construct, if no \code{default} clause is present, a 
      variable for which the data-sharing attribute is not determined by the rules 
      above is firstprivate.
\end{itemize}

Additional restrictions on the variables for which data-sharing attributes cannot be
implicitly determined in a task generating construct are described in
\specref{subsubsec:firstprivate clause}.



\subsubsection{Variables Referenced in a Region but not in a Construct}
\label{subsubsec:Variables Referenced in a Region but not in a Construct}
The data-sharing attributes of variables that are referenced in a region, but not 
in a construct, are determined as follows:

\begin{ccppspecific}
\begin{itemize}
\item Variables with static storage duration that are declared in called routines 
      in the region are shared.
\item File-scope or namespace-scope variables referenced in called routines in the 
      region are shared unless they appear in a \code{threadprivate} directive.
\item Objects with dynamic storage duration are shared.
\item Static data members are shared unless they appear in a \code{threadprivate} 
      directive.
\item In C++, formal arguments of called routines in the region that are passed
      by reference have the same data-sharing attributes as the associated actual 
      arguments.
\item Other variables declared in called routines in the region are private.
\end{itemize}
\end{ccppspecific}

\begin{fortranspecific}
\begin{itemize}
\item Local variables declared in called routines in the region and that have the 
      \code{save} attribute, or that are data initialized, are shared unless they 
      appear in a \code{threadprivate} directive.
\item Variables belonging to common blocks, or accessed by host or use association, 
      and referenced in called routines in the region are shared unless they appear 
      in a \code{threadprivate} directive.
\item Dummy arguments of called routines in the region that have the
      \code{VALUE} attribute are private.
\item Dummy arguments of called routines in the region that do not have the
      \code{VALUE} attribute are private if the associated actual argument is not 
      shared.
\item Dummy arguments of called routines in the region that do not have the
      \code{VALUE} attribute are shared if the actual argument is shared and 
      it is a scalar variable, structure, an array that is not a pointer or
      assumed-shape array, or a simply contiguous array section.  Otherwise, the
      data-sharing attribute of the dummy argument is implementation-defined if
      the associated actual argument is shared.
\item Cray pointees have the same data-sharing attribute as the storage with 
      which their Cray pointers are associated.
\item Implied-do indices, \code{forall} indices, and other local variables 
      declared in called routines in the region are private.
\end{itemize}
\end{fortranspecific}



\subsection{\hcode{threadprivate} Directive}
\index{threadprivate@{\code{threadprivate}}}
\index{directives!threadprivate@{\code{threadprivate}}}
\label{subsec:threadprivate Directive}
\summary
The \code{threadprivate} directive specifies that variables are replicated, with 
each thread having its own copy. The \code{threadprivate} directive is a declarative 
directive.

\syntax
\begin{ccppspecific}
The syntax of the \code{threadprivate} directive is as follows:

\begin{ompcPragma}
#pragma omp threadprivate(\plc{list}) \plc{new-line}
\end{ompcPragma}

where \plc{list} is a comma-separated list of file-scope, namespace-scope, or static
block-scope variables that do not have incomplete types.
\end{ccppspecific}

\begin{fortranspecific}
The syntax of the \code{threadprivate} directive is as follows:

\begin{ompfPragma}
!$omp threadprivate(\plc{list})
\end{ompfPragma} %$ Close off misinterpreted dollar sign/math symbol

where \plc{list} is a comma-separated list of named variables and named common blocks.
Common block names must appear between slashes.
\end{fortranspecific}

\descr
Each copy of a threadprivate variable is initialized once, in the manner specified 
by the program, but at an unspecified point in the program prior to the first 
reference to that copy. The storage of all copies of a threadprivate variable is 
freed according to how static variables are handled in the base language, but at 
an unspecified point in the program.

A program in which a thread references another thread's copy of a threadprivate 
variable is non-conforming.

The content of a threadprivate variable can change across a task scheduling point 
if the executing thread switches to another task that modifies the variable. For 
more details on task scheduling, see \specref{sec:Execution Model} and
\specref{sec:Tasking Constructs}.

In \code{parallel} regions, references by the master thread will be to the copy of the
variable in the thread that encountered the \code{parallel} region.

During a sequential part references will be to the initial thread's copy of the 
variable. The values of data in the initial thread's copy of a threadprivate 
variable are guaranteed to persist between any two consecutive references to 
the variable in the program provided that no \code{teams} construct that is not 
nested inside of a \code{target} construct is encountered between the references 
and that the initial thread is not nested inside of a \code{teams} region.
For initial threads nested inside of a \code{teams} region, the values of data
in the copies of a threadprivate variable of those initial threads are guaranteed
to persist between any two consecutive references to the variable inside of that
\code{teams} region.

The values of data in the threadprivate variables of threads that are not
initial threads are guaranteed to persist between two consecutive active
\code{parallel} regions only if all of the following conditions hold:

\begin{itemize} 
\item Neither \code{parallel} region is nested inside another explicit 
      \code{parallel} region;
\item The number of threads used to execute both \code{parallel} regions is the same;
\item The thread affinity policies used to execute both \code{parallel} 
      regions are the same;
\item The value of the \plc{dyn-var} internal control variable in the enclosing 
      task region is \plc{false} at entry to both \code{parallel} regions; and
\item No \code{teams} construct that is not nested inside of a \code{target}
      construct is encountered between both \code{parallel} regions.
\item Neither the \code{omp_pause_resource} nor \code{omp_pause_resource_all} 
      routine is called.
\end{itemize}

If these conditions all hold, and if a threadprivate variable is referenced in 
both regions, then threads with the same thread number in their respective 
regions will reference the same copy of that variable.

\begin{ccppspecific}
If the above conditions hold, the storage duration, lifetime, and value of a 
thread's copy of a threadprivate variable that does not appear in any 
\code{copyin} clause on the second region will be retained. Otherwise, the 
storage duration, lifetime, and value of a thread's copy of the variable in 
the second region is unspecified.
\end{ccppspecific}

\begin{fortranspecific}
If the above conditions hold, the definition, association, or allocation 
status of a thread's copy of a threadprivate variable or a variable in a 
threadprivate common block that is not affected by any \code{copyin} clause 
that appears on the second region (a variable is affected by a \code{copyin} 
clause if the variable appears in the \code{copyin} clause or it is in a 
common block that appears in the \code{copyin} clause) will be retained.
Otherwise, the definition and association status of a thread's copy of the 
variable in the second region are undefined, and the allocation status of 
an allocatable variable will be implementation defined.

If a threadprivate variable or a variable in a threadprivate common block is
not affected by any \code{copyin} clause that appears on the first \code{parallel} 
region in which it is referenced, the thread's copy of the variable inherits the
declared type parameter and the default parameter values from the original variable.  
The variable or any subobject of the variable is initially defined or
undefined according to the following rules:

\begin{itemize}
\item If it has the \code{ALLOCATABLE} attribute, each copy created will have 
      an initial allocation status of unallocated;
\item If it has the \code{POINTER} attribute:

\begin{itemize}
\item If it has an initial association status of disassociated, either through 
      explicit initialization or default initialization, each copy created will 
      have an association status of disassociated;
\item Otherwise, each copy created will have an association status of undefined.
\end{itemize}

\item If it does not have either the \code{POINTER} or the \code{ALLOCATABLE} 
      attribute:

\begin{samepage}
\begin{itemize}
\item If it is initially defined, either through explicit initialization or default
      initialization, each copy created is so defined;
\item Otherwise, each copy created is undefined.
\end{itemize}
\end{samepage}
\end{itemize}
\end{fortranspecific}

\begin{ccppspecific}
The address of a threadprivate variable is not an address constant.
\end{ccppspecific}

\begin{cppspecific}
The order in which any constructors for different threadprivate variables 
of class type are called is unspecified. The order in which any destructors 
for different threadprivate variables of class type are called is unspecified.
\end{cppspecific}

\restrictions
The restrictions to the \code{threadprivate} directive are as follows:

\begin{itemize}
\item A threadprivate variable must not appear in any clause except the 
      \code{copyin}, \code{copyprivate}, \code{schedule}, \code{num_threads}, 
      \code{thread_limit}, and \code{if} clauses.
\item A program in which an untied task accesses threadprivate storage is 
      non-conforming.

\begin{ccppspecific}
\item If the value of a variable referenced in an explicit initializer of a 
      threadprivate variable is modified prior to the first reference to any 
      instance of the threadprivate variable, then the behavior is unspecified.
\item A variable that is part of another variable (as an array or structure 
      element) cannot appear in a \code{threadprivate} clause unless it is a 
      static data member of a C++ class.
\item A \code{threadprivate} directive for file-scope variables must appear 
      outside any definition or declaration, and must lexically precede all 
      references to any of the variables in its list.
\item A \code{threadprivate} directive for namespace-scope variables must 
      appear outside any definition or declaration other than the namespace 
      definition itself, and must lexically precede all references to any of 
      the variables in its list.
\item Each variable in the list of a \code{threadprivate} directive at file, 
      namespace, or class scope must refer to a variable declaration at file, 
      namespace, or class scope that lexically precedes the directive.
\item A \code{threadprivate} directive for static block-scope variables must 
      appear in the scope of the variable and not in a nested scope. The 
      directive must lexically precede all references to any of the variables 
      in its list.
\item Each variable in the list of a \code{threadprivate} directive in block 
      scope must refer to a variable declaration in the same scope that lexically 
      precedes the directive. The variable declaration must use the static 
      storage-class specifier.
\item If a variable is specified in a \code{threadprivate} directive in one 
      translation unit, it must be specified in a \code{threadprivate} directive 
      in every translation unit in which it is declared.
\end{ccppspecific}

\begin{cppspecific}
\item A \code{threadprivate} directive for static class member variables must 
      appear in the class definition, in the same scope in which the member 
      variables are declared, and must lexically precede all references to 
      any of the variables in its list.
\item A threadprivate variable must not have an incomplete type or a reference type.
\item A threadprivate variable with class type must have:

\begin{itemize}
\item An accessible, unambiguous default constructor in the case of default 
      initialization without a given initializer;
\item An accessible, unambiguous constructor that accepts the given argument
      in the case of direct initialization; and
\item An accessible, unambiguous copy constructor in the case of copy initialization 
      with an explicit initializer.
\end{itemize}
\end{cppspecific}
\end{itemize}

\begin{fortranspecific}
\begin{itemize}
\item A variable that is part of another variable (as an array, structure element 
      or type parameter inquiry) cannot appear in a \code{threadprivate} clause.
\item A coarray cannot appear in a \code{threadprivate} directive.
\item The \code{threadprivate} directive must appear in the declaration section 
      of a scoping unit in which the common block or variable is declared.
\item If a \code{threadprivate} directive that specifies a common block name appears 
      in one program unit, then such a directive must also appear in every other 
      program unit that contains a \code{COMMON} statement that specifies the same 
      name. It must appear after the last such \code{COMMON} statement in the 
      program unit.
\item If a threadprivate variable or a threadprivate common block is declared
      with the \code{BIND} attribute, the corresponding C entities must also be 
      specified in a \code{threadprivate} directive in the C program.
\item A blank common block cannot appear in a \code{threadprivate} directive.
\item A variable can only appear in a \code{threadprivate} directive in the 
      scope in which it is declared. It must not be an element of a common block 
      or appear in an \code{EQUIVALENCE} statement.
\item A variable that appears in a \code{threadprivate} directive must be declared 
      in the scope of a module or have the \code{SAVE} attribute, either explicitly 
      or implicitly.
\end{itemize}
\end{fortranspecific}

\begin{crossrefs}
\item \plc{dyn-var} ICV, see
\specref{sec:Internal Control Variables}.

\item Number of threads used to execute a \code{parallel} region, see
\specref{subsec:Determining the Number of Threads for a parallel Region}.

\item \code{copyin} clause, see
\specref{subsubsec:copyin clause}.
\end{crossrefs}



\subsection{List Item Privatization}
\label{subsec:List Item Privatization}
\index{list item privatization}

For any construct, a list item that appears in a data-sharing attribute
clause, including a reduction clause, may be privatized. Each task that
references a privatized list item in any statement in the construct receives
at least one new list item if the construct has one or more associated loops,
and otherwise each such task receives one new list item.  Each SIMD lane used
in a \code{simd} construct that references a privatized list item in any
statement in the construct receives at least one new list item.
Language-specific attributes for new list items are derived from the
corresponding original list item. Inside the construct, all references to the
original list item are replaced by references to a new list item received by
the task or SIMD lane.  

If the construct has one or more associated loops, within the same logical
iteration of the loop(s) the same new list item replaces all references to the
original list item. For any two logical iterations, if the references to the
original list item are replaced by the same list item then the logical
iterations must execute in some sequential order.

In the rest of the region, it is unspecified whether references are
to a new list item or the original list item. Therefore, if an attempt is made
to reference the original item, its value after the region is also
unspecified. If a task or a SIMD lane does not reference a privatized list
item, it is unspecified whether the task or SIMD lane receives a new list
item.

The value and/or allocation status of the original list item will change only:

\begin{itemize}
\item If accessed and modified via pointer;
\item If possibly accessed in the region but outside of the construct;
\item As a side effect of directives or clauses; or

\begin{fortranspecific}
\item If accessed and modified via construct association.
\end{fortranspecific}
\end{itemize}

\begin{cppspecific}
If the construct is contained in a member function, it is unspecified
anywhere in the region if accesses through the implicit \code{this}
pointer refer to the new list item or the original list item.
\end{cppspecific}

\begin{ccppspecific}
A new list item of the same type, with automatic storage duration, is allocated 
for the construct. The storage and thus lifetime of these list items last until 
the block in which they are created exits. The size and alignment of the new list 
item are determined by the type of the variable. This allocation occurs once for 
each task generated by the construct and once for each SIMD lane used by the construct.

The new list item is initialized, or has an undefined initial value, as if it 
had been locally declared without an initializer.
\end{ccppspecific}

\begin{cppspecific}
If the type of a list item is a reference to a type \plc{T} then the type will 
be considered to be \plc{T} for all purposes of this clause.

The order in which any default constructors for different private variables of 
class type are called is unspecified. The order in which any destructors for 
different private variables of class type are called is unspecified.
\end{cppspecific}

\begin{fortranspecific}
If any statement of the construct references a list item, a new list
item of the same type and type parameters is allocated. This
allocation occurs once for each task generated by the construct and
once for each SIMD lane used by the construct. The initial value of
the new list item is undefined. The initial status of a private
pointer is undefined.

For a list item or the subobject of a list item with the \code{ALLOCATABLE} attribute:

\begin{itemize}
\item If the allocation status is unallocated, the new list item or the subobject
      of the new list item will have an initial allocation status of unallocated;
\item If the allocation status is allocated, the new list item or the subobject of
      the new list item will have an initial allocation status of allocated; and
\item If the new list item or the subobject of the new list item is an array, its 
      bounds will be the same as those of the original list item or the subobject 
      of the original list item.
\end{itemize}

A privatized list item may be storage-associated with other variables when the 
data-sharing attribute clause is encountered. Storage association may exist
because of constructs such as \code{EQUIVALENCE} or \code{COMMON}. If \plc{A}
is a variable that is privatized by a construct and \plc{B} is a variable that 
is storage-associated with \plc{A}, then:

\begin{itemize}
\item The contents, allocation, and association status of \plc{B} are undefined 
      on entry to the region;
\item Any definition of \plc{A}, or of its allocation or association status, 
      causes the contents, allocation, and association status of \plc{B} to 
      become undefined; and
\item Any definition of \plc{B}, or of its allocation or association status, 
      causes the contents, allocation, and association status of \plc{A} to 
      become undefined.
\end{itemize}

A privatized list item clause may be a selector of an \code{ASSOCIATE} or
\code{SELECT TYPE} construct. If the construct association is established
prior to a \code{parallel} region, the association between the associate name
and the original list item will be retained in the region.

Finalization of a list item of a finalizable type or subobjects of a
list item of a finalizable type occurs at the end of the region. The
order in which any final subroutines for different variables of a
finalizable type are called is unspecified.
\end{fortranspecific}

If a list item appears in both \code{firstprivate} and \code{lastprivate} 
clauses, the update required for the \code{lastprivate} clause occurs after 
all initializations for the \code{firstprivate} clause.

\restrictions
The following restrictions apply to any list item that is privatized unless
otherwise stated for a given data-sharing attribute clause:

\begin{itemize}
\begin{cspecific}
\item A variable that is part of another variable (as an array or structure
      element) cannot be privatized.
\end{cspecific}

\begin{cppspecific}
\item A variable that is part of another variable (as an array or structure 
      element) cannot be privatized except if the data-sharing attribute clause 
      is associated with a construct within a class non-static member function 
      and the variable is an accessible data member of the object for which the 
      non-static member function is invoked.
\item A variable of class type (or array thereof) that is privatized requires
      an accessible, unambiguous default constructor for the class type.
\end{cppspecific}

\begin{ccppspecific}
\item A variable that is privatized must not have a \code{const}-qualified type
      unless it is of class type with a \code{mutable} member. This restriction 
      does not apply to the \code{firstprivate} clause.
\item A variable that is privatized must not have an incomplete type or be a 
      reference to an incomplete type. 
\end{ccppspecific}

\begin{fortranspecific}
\item A variable that is part of another variable (as an array or structure 
      element) cannot be privatized.
\item A variable that is privatized must either be definable, or an allocatable 
      variable. This restriction does not apply to the \code{firstprivate} clause.
\item Variables that appear in namelist statements, in variable format expressions, 
      and in expressions for statement function definitions, may not be privatized.
\item Pointers with the \code{INTENT(IN)} attribute may not be privatized. 
      This restriction does not apply to the \code{firstprivate} clause.
\item A private variable must not be coindexed or appear as an actual
      argument to a procedure where the corresponding dummy argument is a
      coarray.
\item Assumed-size arrays may not be privatized in a \code{target},
      \code{teams}, or \code{distribute} construct.
\end{fortranspecific}
\end{itemize}



\subsection{Data-Sharing Attribute Clauses}
\label{subsec:Data-Sharing Attribute Clauses}
\index{data-sharing attribute clauses}
\index{attribute clauses}
\index{clauses!data-sharing}
\index{clauses!attribute data-sharing}
Several constructs accept clauses that allow a user to control the data-sharing
attributes of variables referenced in the construct.  Not all of the clauses
listed in this section are valid on all directives. The set of clauses that is
valid on a particular directive is described with the directive.

Most of the clauses accept a comma-separated list of list items (see
\specref{sec:Directive Format}). All list items that appear in a clause must be 
visible, according to the scoping rules of the base language. With the exception 
of the \code{default} clause, clauses may be repeated as needed. A list item may 
not appear in more than one clause on the same directive, except that it may be 
specified in both \code{firstprivate} and \code{lastprivate} clauses.

The reduction data-sharing attribute clauses are explained in 
\specref{subsec:Reduction Clauses and Directives}.

\begin{cppspecific}
If a variable referenced in a data-sharing attribute clause has a type derived from a
template, and the program does not otherwise reference that variable then any
behavior related to that variable is unspecified.
\end{cppspecific}

\begin{fortranspecific}
When a named common block appears in a \code{private}, \code{firstprivate},
\code{lastprivate}, or \code{shared} clause of a directive, none of its members 
may be declared in another data-sharing attribute clause in that directive. When 
individual members of a common block appear in a \code{private}, \code{firstprivate},
\code{lastprivate}, \code{reduction}, or \code{linear} clause of a directive, the 
storage of the specified variables is no longer Fortran associated with the storage 
of the common block itself. 
\end{fortranspecific}



\subsubsection{\hcode{default} Clause}
\label{subsubsec:default clause}
\index{default@{\code{default}}}
\index{clauses!default@{\code{default}}}
\summary
The \code{default} clause explicitly determines the data-sharing attributes 
of variables that are referenced in a \code{parallel}, \code{teams}, or task 
generating construct and would otherwise be implicitly determined (see
\specref{subsubsec:Variables Referenced in a Construct}).

\syntax
\begin{ccppspecific}
The syntax of the \code{default} clause is as follows:

\begin{ompSyntax}
default(shared \textnormal{|} none)
\end{ompSyntax}
\end{ccppspecific}

\begin{fortranspecific}
The syntax of the \code{default} clause is as follows:

\begin{ompSyntax}
default(private \textnormal{|} firstprivate \textnormal{|} shared \textnormal{|} none)
\end{ompSyntax}
\end{fortranspecific}

\descr
The \code{default(shared)} clause causes all variables referenced in the construct 
that have implicitly determined data-sharing attributes to be shared.

\begin{fortranspecific}
The \code{default(firstprivate)} clause causes all variables in the construct that 
have implicitly determined data-sharing attributes to be firstprivate.

The \code{default(private)} clause causes all variables referenced in the construct 
that have implicitly determined data-sharing attributes to be private.
\end{fortranspecific}

The \code{default(none)} clause requires that each variable that is referenced 
in the construct, and that does not have a predetermined data-sharing attribute, 
must have its data-sharing attribute explicitly determined by being listed in a 
data-sharing attribute clause.

\restrictions
The restrictions to the \code{default} clause are as follows:

\begin{itemize}
\item Only a single \code{default} clause may be specified on a
      \code{parallel}, \code{task}, \code{taskloop} or \code{teams} directive.
\end{itemize}



\subsubsection{\hcode{shared} Clause}
\label{subsubsec:shared clause}
\index{shared@{\code{shared}}}
\index{clauses!shared@{\code{shared}}}
\summary
The \code{shared} clause declares one or more list items to be shared by 
tasks generated by a \code{parallel}, \code{teams}, or task generating construct.

\syntax
The syntax of the \code{shared} clause is as follows:

\begin{ompSyntax}
shared(\plc{list})
\end{ompSyntax}

\descr
All references to a list item within a task refer to the storage area of the 
original variable at the point the directive was encountered.

The programmer must ensure, by adding proper synchronization, that storage 
shared by an explicit task region does not reach the end of its lifetime before
the explicit task region completes its execution.


\begin{fortranspecific}
The association status of a shared pointer becomes undefined upon entry to and 
exit from the \code{parallel}, \code{teams}, or task generating construct if 
it is associated with a target or a subobject of a target that appears
as a privatized list item in a data-sharing attribute clause on the construct.


\begin{note}
Passing a shared variable to a procedure may result in the use of temporary 
storage in place of the actual argument when the corresponding dummy argument 
does not have the \code{VALUE} or \code{CONTIGUOUS} attribute and its 
data-sharing attribute is implementation-defined as per the rules in
\specref{subsubsec:Variables Referenced in a Region but not in a Construct}.
These conditions effectively result in references to, and definitions of, the
temporary storage during the procedure reference.  Furthermore, the value of
the shared variable is copied into the intervening temporary storage before 
the procedure reference when the dummy argument does not have the \code{INTENT(OUT)}
attribute, and is copied out of the temporary storage into the shared variable when
the dummy argument does not have the \code{INTENT(IN)} attribute.  Any
references to (or definitions of) the shared storage that is associated with
the dummy argument by any other task must be synchronized with
the procedure reference to avoid possible data races.
\end{note}
\end{fortranspecific}

\restrictions
The restrictions for the \code{shared} clause are as follows:

\begin{itemize}
\begin{cspecific}
\item A variable that is part of another variable (as an array or structure 
      element) cannot appear in a \code{shared} clause.
\end{cspecific}

\begin{cppspecific}
\item A variable that is part of another variable (as an array or structure
      element) cannot appear in a \code{shared} clause except if the \code{shared}
      clause is associated with a construct within a class non-static member
      function and the variable is an accessible data member of the object for
      which the non-static member function is invoked.
\end{cppspecific}

\begin{fortranspecific}
\item A variable that is part of another variable (as an array, structure element 
      or type parameter inquiry) cannot appear in a \code{shared} clause.
\end{fortranspecific}

\end{itemize}



\subsubsection{\hcode{private} Clause}
\index{private@{\code{private}}}
\index{clauses!private@{\code{private}}}
\label{subsubsec:private clause}
\summary
The \code{private} clause declares one or more list items to be private to a task 
or to a SIMD lane.

\syntax
The syntax of the \code{private} clause is as follows:

\begin{ompSyntax}
private(\plc{list})
\end{ompSyntax}

\descr

The \code{private} clause specifies that its list items are to be
privatized according to \specref{subsec:List Item Privatization}. Each task
or SIMD lane that references a list item in the construct receives only one
new list item, unless the construct has one or more associated loops and the
\code{order(concurrent)} clause is also present.

List items that appear in a \code{private}, \code{firstprivate}, or
\code{reduction} clause in a \code{parallel} construct may also appear
in a \code{private} clause in an enclosed \code{parallel}, worksharing, 
\code{loop}, \code{task}, \code{taskloop}, \code{simd}, or \code{target} construct.

List items that appear in a \code{private} or \code{firstprivate} clause 
in a \code{task} or \code{taskloop} construct may also appear in a \code{private}
clause in an enclosed \code{parallel}, \code{loop}, \code{task}, \code{taskloop}, 
\code{simd}, or \code{target} construct.

List items that appear in a \code{private}, \code{firstprivate},
\code{lastprivate}, or \code{reduction} clause in a worksharing
construct may also appear in a \code{private} clause in an enclosed
\code{parallel}, \code{loop}, \code{task}, \code{simd}, or \code{target} construct.

List items that appear in a \code{private} clause on a \code{loop} construct
may also appear in a \code{private} clause in an enclosed \code{loop}, 
\code{parallel}, or \code{simd} construct.

\restrictions
The restrictions to the \code{private} clause are as specified in
Section~\ref{subsec:List Item Privatization}.

\begin{crossrefs}
\item List Item Privatization, see \specref{subsec:List Item Privatization}.
\end{crossrefs}



\subsubsection{\hcode{firstprivate} Clause}
\label{subsubsec:firstprivate clause}
\index{firstprivate@{\code{firstprivate}}}
\index{clauses!firstprivate@{\code{firstprivate}}}
\summary
The \code{firstprivate} clause declares one or more list items to be private 
to a task, and initializes each of them with the value that the corresponding 
original item has when the construct is encountered.

\syntax
The syntax of the \code{firstprivate} clause is as follows:

\begin{ompSyntax}
firstprivate(\plc{list})
\end{ompSyntax}

\descr
The \code{firstprivate} clause provides a superset of the functionality provided 
by the \code{private} clause.

A list item that appears in a \code{firstprivate} clause is subject to the 
\code{private} clause semantics described in \specref{subsubsec:private clause},
except as noted. In addition, the new list item is initialized from the original 
list item existing before the construct. The initialization of the new list item 
is done once for each task that references the list item in any statement in the 
construct. The initialization is done prior to the execution of the construct.

For a \code{firstprivate} clause on a \code{parallel}, \code{task},
\code{taskloop}, \code{target}, or \code{teams} construct, the initial
value of the new list item is the value of the original list item that
exists immediately prior to the construct in the task region where the
construct is encountered unless otherwise specified. For a
\code{firstprivate} clause on a worksharing construct, the initial
value of the new list item for each implicit task of the threads that
execute the worksharing construct is the value of the original list
item that exists in the implicit task immediately prior to the point
in time that the worksharing construct is encountered unless otherwise
specified.

To avoid data races, concurrent updates of the original list item must be
synchronized with the read of the original list item that occurs as a result of the
\code{firstprivate} clause.

\begin{ccppspecific}
For variables of non-array type, the initialization occurs by copy assignment. 
For an array of elements of non-array type, each element is initialized as if 
by assignment from an element of the original array to the corresponding element 
of the new array. 
\end{ccppspecific}

\begin{cppspecific}
For each variable of class type:

\begin{itemize}
\item If the \code{firstprivate} clause is not on a \code{target} construct then 
      a copy constructor is invoked to perform the initialization; and
\item If the \code{firstprivate} clause is on a \code{target} construct then it 
      is unspecified how many copy constructors, if any, are invoked.
\end{itemize}

If copy constructors are called, the order in which copy constructors for different 
variables of class type are called is unspecified.
\end{cppspecific}

\begin{fortranspecific}
If the original list item does not have the \code{POINTER} attribute,
initialization of the new list items occurs as if by intrinsic
assignment unless the list item has a type bound procedure as a
defined assignment.  If the original list item that does not have the
\code{POINTER} attribute has the allocation status of unallocated, the
new list items will have the same status.

If the original list item has the \code{POINTER} attribute, the new list 
items receive the same association status of the original list item as if 
by pointer assignment.
\end{fortranspecific}

\restrictions
The restrictions to the \code{firstprivate} clause are as follows:

\begin{itemize}
\item A list item that is private within a \code{parallel} region must
      not appear in a \code{firstprivate} clause on a worksharing construct
      if any of the worksharing regions arising from the worksharing construct 
      ever bind to any of the \code{parallel} regions arising from the 
      \code{parallel} construct.
\item A list item that is private within a \code{teams} region must not 
      appear in a \code{firstprivate} clause on a \code{distribute} construct 
      if any of the \code{distribute} regions arising from the \code{distribute} 
      construct ever bind to any of the \code{teams} regions arising from the 
      \code{teams} construct.
\item A list item that appears in a \code{reduction} clause of a \code{parallel}
      construct must not appear in a \code{firstprivate} clause on a worksharing, 
      \code{task}, or \code{taskloop} construct if any of the worksharing or 
      \code{task} regions arising from the worksharing, \code{task}, or 
      \code{taskloop} construct ever bind to any of the \code{parallel} 
      regions arising from the \code{parallel} construct.
\item A list item that appears in a \code{reduction} clause of a \code{teams} 
      construct must not appear in a \code{firstprivate} clause on a 
      \code{distribute} construct if any of the \code{distribute} regions arising 
      from the \code{distribute} construct ever bind to any of
      the \code{teams} regions arising from the \code{teams} construct.
\item A list item that appears in a \code{reduction} clause of a worksharing 
      construct must not appear in a \code{firstprivate} clause in a \code{task} 
      construct encountered during execution of any of the worksharing regions 
      arising from the worksharing construct.

\begin{cppspecific}
\item A variable of class type (or array thereof) that appears in a 
      \code{firstprivate} clause requires an accessible, unambiguous copy 
      constructor for the class type.
\end{cppspecific}

\begin{ccppspecific}
\item If a list item in a \code{firstprivate} clause on a worksharing construct 
      has a reference type then it must bind to the same object for all threads 
      of the team.
\end{ccppspecific}

\begin{fortranspecific}
\item If the list item is a polymorphic variable with the \code{ALLOCATABLE} 
      attribute, the behavior is unspecified.
\end{fortranspecific}
\end{itemize}



\subsubsection{\hcode{lastprivate} Clause}
\index{lastprivate@{\code{lastprivate}}}
\index{clauses!lastprivate@{\code{lastprivate}}}
\label{subsubsec:lastprivate clause}
\summary
The \code{lastprivate} clause declares one or more list items to be private to 
an implicit task or to a SIMD lane, and causes the corresponding original list 
item to be updated after the end of the region.

\syntax
The syntax of the \code{lastprivate} clause is as follows:

\begin{ompSyntax}
lastprivate(\plc{[ lastprivate-modifier}:\plc{] list})
\end{ompSyntax}

where \plc{lastprivate-modifier} is:
\begin{indentedcodelist}
conditional
\end{indentedcodelist}

\descr
The \code{lastprivate} clause provides a superset of the functionality provided 
by the \code{private} clause.

A list item that appears in a \code{lastprivate} clause is subject to the 
\code{private} clause semantics described in \specref{subsubsec:private clause}.
In addition, when a \code{lastprivate} clause without the \code{conditional} 
modifier appears on a directive, the value of each new list item from the 
sequentially last iteration of the associated loops, or the lexically last 
\code{section} construct, is assigned to the original list item. When the 
\code{conditional} modifier appears on the clause, if an assignment to a list 
item is encountered in the construct then the original list item is assigned 
the value that is assigned to the new list item in the sequentially last 
iteration or lexically last section in which such an assignment is encountered.

\begin{ccppspecific}
For an array of elements of non-array type, each element is assigned to the
corresponding element of the original array.
\end{ccppspecific}

\begin{fortranspecific}
If the original list item does not have the \code{POINTER} attribute,
its update occurs as if by intrinsic assignment unless it has a type
bound procedure as a defined assignment.

If the original list item has the \code{POINTER} attribute, its update 
occurs as if by pointer assignment.
\end{fortranspecific}

When the \code{conditional} modifier does not appear on the \code{lastprivate} 
clause, list items that are not assigned a value by the sequentially last 
iteration of the loops, or by the lexically last \code{section} construct, 
have unspecified values after the construct. Unassigned subcomponents also 
have unspecified values after the construct.

If the \code{lastprivate} clause is used on a construct to which neither
the \code{nowait} nor the \code{nogroup} clauses are applied, the original list item
becomes defined at the end of the construct.  To avoid data races,
concurrent reads or updates of the original list item must be synchronized with
the update of the original list item that occurs as a result of the
\code{lastprivate} clause.

Otherwise, If the \code{lastprivate} clause is used on a construct to which
the \code{nowait} or the \code{nogroup} clauses are applied, accesses to the original
list item may create a data race.  To avoid this data race, if an assignment to the
original list item occurs then synchronization must be inserted to ensure that
the assignment completes and the original list item is flushed to memory.

If a list item that appears in a \code{lastprivate} clause with the
\code{conditional} modifier is modified in the region by an assignment
outside the construct or not to the list item then the value assigned to
the original list item is unspecified.

\restrictions
The restrictions to the \code{lastprivate} clause are as follows:

\begin{itemize}
\item A list item that is private within a \code{parallel} region, or
      that appears in the \code{reduction} clause of a \code{parallel}
      construct, must not appear in a \code{lastprivate} clause on a
      worksharing construct if any of the corresponding worksharing 
      regions ever binds to any of the corresponding \code{parallel} regions.
\item A list item that appears in a \code{lastprivate} clause with the
      \code{conditional} modifier must be a scalar variable.

\begin{cppspecific}
\item A variable of class type (or array thereof) that appears in a 
      \code{lastprivate} clause requires an accessible, unambiguous 
      default constructor for the class type, unless the list item is 
      also specified in a \code{firstprivate} clause.
\item A variable of class type (or array thereof) that appears in a 
      \code{lastprivate} clause requires an accessible, unambiguous 
      copy assignment operator for the class type. The order in which 
      copy assignment operators for different variables of class type 
      are called is unspecified.
\end{cppspecific}

\begin{ccppspecific}
\item If a list item in a \code{lastprivate} clause on a worksharing
      construct has a reference type then it must bind to the same 
      object for all threads of the team.
\end{ccppspecific}

\begin{fortranspecific}
\item A variable that appears in a \code{lastprivate} clause must be definable.
\item If the original list item has the \code{ALLOCATABLE} attribute, the
      corresponding list item whose value is assigned to the original list 
      item must have an allocation status of allocated upon exit from
      the sequentially last iteration or lexically last \code{section} construct.
\item If the list item is a polymorphic variable with the \code{ALLOCATABLE} 
      attribute, the behavior is unspecified.
\end{fortranspecific}
\end{itemize}



\subsubsection{\hcode{linear} Clause}
\index{linear@{\code{linear}}}
\index{clauses!linear@{\code{linear}}}
\label{subsubsec:linear clause}
\summary
The \code{linear} clause declares one or more list items to be private and to have 
a linear relationship with respect to the iteration space of a loop associated 
with the construct on which the clause appears.

\syntax


\begin{cspecific}
The syntax of the \code{linear} clause is as follows:
\begin{ompSyntax}
linear(\plc{linear-list[ }:\plc{ linear-step]})
\end{ompSyntax}
where \plc{linear-list} is one of the following
 
\begin{indentedcodelist}
\plc{list}
\plc{modifier}(\plc{list})
\end{indentedcodelist}
where  \plc{modifier} is one of the following:
 
\begin{indentedcodelist}
val
\end{indentedcodelist}
\end{cspecific}

\begin{cppspecific}
The syntax of the \code{linear} clause is as follows:
\begin{ompSyntax}
linear(\plc{linear-list[ }:\plc{ linear-step]})
\end{ompSyntax}
where \plc{linear-list} is one of the following
 
\begin{indentedcodelist}
\plc{list}
\plc{modifier}(\plc{list})
\end{indentedcodelist}
where  \plc{modifier} is one of the following:
 
\begin{indentedcodelist}
ref
val
uval
\end{indentedcodelist}
\end{cppspecific}

\begin{fortranspecific}
The syntax of the \code{linear} clause is as follows:
\begin{ompSyntax}
linear(\plc{linear-list[ }:\plc{ linear-step]})
\end{ompSyntax}
where \plc{linear-list} is one of the following
 
\begin{indentedcodelist}
\plc{list}
\plc{modifier}(\plc{list})
\end{indentedcodelist}
where  \plc{modifier} is one of the following:
 
\begin{indentedcodelist}
ref
val
uval
\end{indentedcodelist}
\end{fortranspecific}

\descr
The \code{linear} clause provides a superset of the functionality provided by 
the \code{private} clause. A list item that appears in a \code{linear} clause 
is subject to the \code{private} clause semantics described in 
\specref{subsubsec:private clause} except as noted. If \plc{linear-step} is 
not specified, it is assumed to be 1.

When a \code{linear} clause is specified on a construct, the value of the new 
list item on each iteration of the associated loop(s) corresponds to the value 
of the original list item before entering the construct plus the logical number 
of the iteration times \plc{linear-step}. The value corresponding to the 
sequentially last iteration of the associated loop(s) is assigned to the 
original list item.

When a \code{linear} clause is specified on a declarative directive, all list 
items must be formal parameters (or, in Fortran, dummy arguments) of a function 
that will be invoked concurrently on each SIMD lane. If no \plc{modifier} is 
specified or the \code{val} or \code{uval} modifier is specified, the value of 
each list item on each lane corresponds to the value of the list item upon entry 
to the function plus the logical number of the lane times \plc{linear-step}.
If the \code{uval} modifier is specified, each invocation uses the same storage 
location for each SIMD lane; this storage location is updated with the final 
value of the logically last lane. If the \code{ref} modifier is specified, the 
storage location of each list item on each lane corresponds to an array at the 
storage location upon entry to the function indexed by the logical number of 
the lane times \plc{linear-step}.

\restrictions
\begin{itemize}
\item The \plc{linear-step} expression must be invariant during the execution 
      of the region that corresponds to the construct. Otherwise, the execution 
      results in unspecified behavior.
\item Only a loop iteration variable of a loop that is associated with the
      construct may appear as a \plc{list-item} in a \code{linear} clause if a
      \code{reduction} clause with the \code{inscan} modifier also appears on
      the construct.

\begin{cspecific}
\item A \plc{list-item} that appears in a \code{linear} clause must be of 
      integral or pointer type.
\end{cspecific}

\begin{cppspecific}
\item A \plc{list-item} that appears in a \code{linear} clause without the 
      \code{ref} modifier must be of integral or pointer type, or must be a 
      reference to an integral or pointer type.
\item The \code{ref} or \code{uval} modifier can only be used if the 
      \plc{list-item} is of a reference type.
\item If a list item in a \code{linear} clause on a worksharing construct has a
      reference type then it must bind to the same object for all threads of the team.
\item If the list item is of a reference type and the \code{ref} modifier is 
      not specified and if any write to the list item occurs before any read 
      of the list item then the result is unspecified.
\end{cppspecific}

\begin{fortranspecific}
\item A \plc{list-item} that appears in a \code{linear} clause without the 
      \code{ref} modifier must be of type \code{integer}.
\item The \code{ref} or \code{uval} modifier can only be used if the 
      \plc{list-item} is a dummy argument without the \code{VALUE} attribute.
\item Variables that have the \code{POINTER} attribute and Cray pointers may 
      not appear in a \code{linear} clause.
\item If the list item has the \code{ALLOCATABLE} attribute and the \code{ref} 
      modifier is not specified, the allocation status of the list item in the 
      sequentially last iteration must be allocated upon exit from that iteration.
\item If the \code{ref} modifier is specified, variables with the 
      \code{ALLOCATABLE} attribute, assumed-shape arrays and polymorphic 
      variables may not appear in the \code{linear} clause.
\item If the list item is a dummy argument without the \code{VALUE} attribute 
      and the \code{ref} modifier is not specified and if any write to the list 
      item occurs before any read of the list item then the result is unspecified.
\item A common block name cannot appear in a \code{linear} clause.
\end{fortranspecific}
\end{itemize}



\subsection{Reduction Clauses and Directives}
\index{reduction clauses}
\label{subsec:Reduction Clauses and Directives}
The reduction clauses are data-sharing attribute clauses that can be used to 
perform some forms of recurrence calculations in parallel. Reduction clauses 
include reduction scoping clauses and reduction participating clauses. Reduction 
scoping clauses define the region in which a reduction is computed. Reduction 
participating clauses define the participants in the reduction. Reduction clauses 
specify a \plc{reduction-identifier} and one or more list items.



\subsubsection{Properties Common To All Reduction Clauses}
\label{subsubsec:Properties Common To All Reduction Clauses}

\syntax
The syntax of a \plc{reduction-identifier} is defined as follows:

\begin{cspecific}
A \plc{reduction-identifier} is either an \plc{identifier} or one 
of the following operators: \code{+}, \code{-}, \code{*}, \code{&},
\code{|}, \code{^}, \code{&&} and \code{||}.
\end{cspecific} 

\begin{cppspecific}
A \plc{reduction-identifier} is either an \plc{id-expression} or one 
of the following operators: \code{+}, \code{-}, \code{*}, \code{&},
\code{|}, \code{^}, \code{&&} and \code{||}.
\end{cppspecific}

\begin{fortranspecific}
A \plc{reduction-identifier} is either a base language identifier, or 
a user-defined operator, or one of the following operators: \code{+},
\code{-}, \code{*}, \code{.and.}, \code{.or.}, \code{.eqv.}, \code{.neqv.},
or one of the following intrinsic procedure names: \code{max}, \code{min},
\code{iand}, \code{ior}, \code{ieor}.
\end{fortranspecific}

\begin{ccppspecific}
Table~\ref{tab:Implicitly Declared C/C++ Reduction Identifiers} lists each
\plc{reduction-identifier} that is implicitly declared at every scope for
arithmetic types and its semantic initializer value. The actual initializer
value is that value as expressed in the data type of the reduction list item.

\nolinenumbers
\needspace{\sbns}
\renewcommand{\arraystretch}{1.5}
\tablecaption{Implicitly Declared C/C++ \plc{reduction-identifiers}\label{tab:Implicitly Declared C/C++ Reduction Identifiers}}
\tablefirsthead{
\hline
\textsf{\textbf{Identifier}} & \textsf{\textbf{Initializer}} & \textsf{\textbf{Combiner}}\\
\hline \\[-3ex]
}
\tablehead{%
\multicolumn{2}{l}{\small\slshape table continued from previous page}\\
\hline
\textsf{\textbf{Identifier}} & \textsf{\textbf{Initializer}} & \textsf{\textbf{Combiner}}\\
\hline \\[-3ex]
}
\tabletail{%
\hline\\[-4ex]
\multicolumn{2}{l}{\small\slshape table continued on next page}\\
}
\tablelasttail{\hline}
\begin{supertabular}{ p{0.1\textwidth} p{0.3\textwidth} p{0.5\textwidth}}
{\scode{+}} & {\scode{omp_priv = 0}} & {\scode{omp_out += omp_in}}\\
{\scode{-}} & {\scode{omp_priv = 0}} & {\scode{omp_out += omp_in}}\\
{\scode{*}} & {\scode{omp_priv = 1}} & {\scode{omp_out *= omp_in}}\\
{\scode{&}} & {\scode{omp_priv =  ~ 0}} & {\scode{omp_out &= omp_in}}\\
{\scode{|}} & {\scode{omp_priv = 0}} & {\scode{omp_out |= omp_in}}\\
{\scode{^}} & {\scode{omp_priv = 0}} & {\scode{omp_out ^}}{\scode{= omp_in}}\\
{\scode{&&}} & {\scode{omp_priv = 1}} & {\scode{omp_out = omp_in && omp_out}}\\
{\scode{||}} & {\scode{omp_priv = 0}} & {\scode{omp_out = omp_in || omp_out}}\\
{\scode{max}} & {\scode{omp_priv = }\splc{Least representable number in the reduction list item type}} & {\scode{omp_out = omp_in > omp_out ? omp_in : omp_out}}\\
{\scode{min}} & {\scode{omp_priv = }\splc{Largest representable number in the reduction list item type}} & {\scode{omp_out = omp_in < omp_out ? omp_in : omp_out}}\\
\end{supertabular}
\bigskip
\end{ccppspecific}
\linenumbers

\begin{fortranspecific}
Table~\ref{tab:Implicitly Declared Fortran Reduction Identifiers} lists each
\plc{reduction-identifier} that is implicitly declared for numeric and logical
types and its semantic initializer value. The actual initializer value is that
value as expressed in the data type of the reduction list item.

\nolinenumbers
\renewcommand{\arraystretch}{1.5}
\tablefirsthead{
\hline
\textsf{\textbf{Identifier}} & \textsf{\textbf{Initializer}} & \textsf{\textbf{Combiner}}\\
\hline \\[-3ex]
}
\tablehead{
\multicolumn{2}{l}{\small\slshape table continued from previous page}\\
\hline
\textsf{\textbf{Identifier}} & \textsf{\textbf{Initializer}} & \textsf{\textbf{Combiner}}\\
\hline \\[-3ex]
}
\tabletail{
\hline\\[-4ex]
\multicolumn{2}{l}{\small\slshape table continued on next page}\\
}
\tablelasttail{\hline}
\tablecaption{Implicitly Declared Fortran \plc{reduction-identifiers}\label{tab:Implicitly Declared Fortran Reduction Identifiers}}
\begin{supertabular}{ p{0.1\textwidth} p{0.30\textwidth} p{0.5\textwidth}}
{\scode{+}} & {\scode{omp_priv = 0}} & {\scode{omp_out = omp_in + omp_out}}\\
{\scode{-}} & {\scode{omp_priv = 0}} & {\scode{omp_out = omp_in + omp_out}}\\
{\scode{*}} & {\scode{omp_priv = 1}} & {\scode{omp_out = omp_in * omp_out}}\\
{\scode{.and.}} & {\scode{omp_priv = .true.}} & {\scode{omp_out = omp_in .and. omp_out}}\\
{\scode{.or.}} & {\scode{omp_priv = .false.}} & {\scode{omp_out = omp_in .or. omp_out}}\\
{\scode{.eqv.}} & {\scode{omp_priv = .true.}} & {\scode{omp_out = omp_in .eqv. omp_out}}\\
{\scode{.neqv.}} & {\scode{omp_priv = .false.}} & {\scode{omp_out = omp_in .neqv. omp_out}}\\
{\scode{max}} & {\scode{omp_priv = }\splc{Least representable number in the reduction list item type}} & {\scode{omp_out = max(omp_in, omp_out)}}\\
{\scode{min}} & {\scode{omp_priv = }\splc{Largest representable number in the reduction list item type}} & {\scode{omp_out = min(omp_in, omp_out)}}\\
{\scode{iand}} & {\scode{omp_priv = }\splc{All bits on}} & {\scode{omp_out = iand(omp_in, omp_out)}}\\
{\scode{ior}} & {\scode{omp_priv = 0}} & {\scode{omp_out = ior(omp_in, omp_out)}}\\
{\scode{ieor}} & {\scode{omp_priv = 0}} & {\scode{omp_out = ieor(omp_in, omp_out)}}\\
\end{supertabular}
\end{fortranspecific}
\linenumbers

In the above tables, \code{omp_in} and \code{omp_out} correspond to two
identifiers that refer to storage of the type of the list item. \code{omp_out}
holds the final value of the combiner operation.

Any \plc{reduction-identifier} that is defined with the \code{declare}~\code{reduction}
directive is also valid. In that case, the initializer and combiner of the
\plc{reduction-identifier} are specified by the \plc{initializer-clause} and
the \plc{combiner} in the \code{declare}~\code{reduction} directive.

\descr
A reduction clause specifies a \plc{reduction-identifier} and one or more list
items.

The \plc{reduction-identifier} specified in a reduction clause must match a
previously declared \plc{reduction-identifier} of the same name and type for
each of the list items. This match is done by means of a name lookup in the
base language.

The list items that appear in a reduction clause may include array sections.

\begin{cppspecific}
If the type is a derived class, then any \plc{reduction-identifier} that matches 
its base classes is also a match, if there is no specific match for the type.

If the \plc{reduction-identifier} is not an \plc{id-expression}, then it is
implicitly converted to one by prepending the keyword operator (for example,
\code{+} becomes {\plc{operator}\code{+}}).

If the \plc{reduction-identifier} is qualified then a qualified name lookup is
used to find the declaration.

If the \plc{reduction-identifier} is unqualified then an 
\emph{argument-dependent name lookup} must be performed using the 
type of each list item.
\end{cppspecific}

If the list item is an array or array section, it will be treated as
if a reduction clause would be applied to each separate element
of the array section.

If the list item is an array section, the elements of any copy of the 
array section will be allocated contiguously.

\begin{samepage}
\begin{fortranspecific}
If the original list item has the \code{POINTER} attribute, any copies of
the list item are associated with private targets.
\end{fortranspecific}
\end{samepage}

Any copies associated with the reduction are initialized with the initializer
value of the \plc{reduction-identifier}.

Any copies are combined using the combiner associated with the
\plc{reduction-identifier}.

\events

The \plc{reduction-begin} event occurs before a task begins to perform 
loads and stores that belong to the implementation of a reduction and 
the \plc{reduction-end} event occurs after the task has completed loads 
and stores associated with the reduction. If a task participates in 
multiple reductions, each reduction may be bracketed by its own pair of 
\plc{reduction-begin}/\plc{reduction-end} events or multiple reductions 
may be bracketed by a single pair of events. The interval defined by a 
pair of \plc{reduction-begin}/\plc{reduction-end} events may not contain 
a task scheduling point.

\tools

A thread dispatches a registered \code{ompt_callback_reduction} with
\code{ompt_sync_region_reduction} in its \plc{kind} argument and
\code{ompt_scope_begin} as its \plc{endpoint} argument for each 
occurrence of a \plc{reduction-begin} event in that thread. Similarly,
a thread dispatches a registered \code{ompt_callback_reduction} with
\code{ompt_sync_region_reduction} in its \plc{kind} argument and
\code{ompt_scope_end} as its \plc{endpoint} argument for each 
occurrence of a \plc{reduction-end} event in that thread. These 
callbacks occur in the context of the task that performs the reduction
and has the type signature \code{ompt_callback_sync_region_t}.

\restrictions
The restrictions common to reduction clauses are as follows:

\begin{itemize}
\item Any number of reduction clauses can be specified on the directive,
      but a list item (or any array element in an array section) can appear
      only once in reduction clauses for that directive.
\item For a \plc{reduction-identifier} declared with the 
      \code{declare}~\code{reduction} construct, the directive must appear 
      before its use in a reduction clause.
\item If a list item is an array section or an array element, its base 
      expression must be a base language identifier.
\item If a list item is an array section, it must specify contiguous storage
      and it cannot be a zero-length array section.
\item If a list item is an array section or an array element, accesses to the
      elements of the array outside the specified array section or array
      element result in unspecified behavior.

\begin{cspecific}
\item A variable that is part of another variable, with the exception of array
      elements, cannot appear in a reduction clause.
\end{cspecific}

\begin{cppspecific}
\item A variable that is part of another variable, with the exception of array
      elements, cannot appear in a reduction clause except if the reduction clause
      is associated with a construct within a class non-static member function and
      the variable is an accessible data member of the object for which the
      non-static member function is invoked.
\end{cppspecific}

\begin{ccppspecific}
\item The type of a list item that appears in a reduction clause must be 
      valid for the \plc{reduction-identifier}. For a \code{max} or 
      \code{min} reduction in C, the type of the list item must be an 
      allowed arithmetic data type: \code{char}, \code{int}, \code{float}, 
      \code{double}, or \code{_Bool}, possibly modified with \code{long}, 
      \code{short}, \code{signed}, or \code{unsigned}. For a \code{max} or 
      \code{min} reduction in C++, the type of the list item must be an 
      allowed arithmetic data type: \code{char}, \code{wchar_t}, \code{int}, 
      \code{float}, \code{double}, or \code{bool}, possibly modified with 
      \code{long}, \code{short}, \code{signed}, or \code{unsigned}.
\item A list item that appears in a reduction clause must not be 
      \code{const}-qualified.
\item The \plc{reduction-identifier} for any list item must be unambiguous 
      and accessible.
\end{ccppspecific}

\begin{fortranspecific}
\item A variable that is part of another variable, with the exception of array
      elements, cannot appear in a reduction clause.
\item A type parameter inquiry cannot appear in a reduction clause.
\item The type, type parameters and rank of a list item that appears in a 
      reduction clause must be valid for the \plc{combiner} and \plc{initializer}.
\item A list item that appears in a reduction clause must be definable.
\item A procedure pointer may not appear in a reduction clause.
\item A pointer with the \code{INTENT(IN)} attribute may not appear in the
      reduction clause.
\item An original list item with the \code{POINTER} attribute or any pointer
      component of an original list item that is referenced in the \plc{combiner}
      must be associated at entry to the construct that contains the reduction
      clause. Additionally, the list item or the pointer component of the list item
      must not be deallocated, allocated, or pointer assigned within the region.
\item An original list item with the \code{ALLOCATABLE} attribute or any
      allocatable component of an original list item that corresponds to the special
      variable identifier in the \plc{combiner} or the \plc{initializer} must be
      in the allocated state at entry to the construct that contains the reduction
      clause. Additionally, the list item or the allocatable component of the list
      item must be neither deallocated nor allocated, explicitly or implicitly,
      within the region.
\item If the \plc{reduction-identifier} is defined in a \code{declare}~\code{reduction}
      directive, the \code{declare}~\code{reduction} directive must be in the same
      subprogram, or accessible by host or use association.
\item If the \plc{reduction-identifier} is a user-defined operator, the same
      explicit interface for that operator must be accessible as at the
      \code{declare}~\code{reduction} directive.
\item If the \plc{reduction-identifier} is defined in a \code{declare}~\code{reduction}
      directive, any subroutine or function referenced in the initializer clause or
      combiner expression must be an intrinsic function, or must have an explicit
      interface where the same explicit interface is accessible as at the
      \code{declare}~\code{reduction} directive.
\end{fortranspecific}
\end{itemize}

\begin{crossrefs}
\item \code{ompt_scope_begin} and \code{ompt_scope_end}, see
\specref{sec:ompt_scope_endpoint_t}.

\item \code{ompt_sync_region_reduction}, see
\specref{sec:ompt_sync_region_t}.

\item \code{ompt_callback_sync_region_t}, see
\specref{sec:ompt_callback_sync_region_t}.

\end{crossrefs}



\subsubsection{Reduction Scoping Clauses}
\label{subsubsec:Reduction Scoping Clauses}
Reduction scoping clauses define the region in which a reduction is computed by
tasks or SIMD lanes. All properties common to all reduction clauses, which are 
defined in \specref{subsubsec:Properties Common To All Reduction Clauses}, apply 
to reduction scoping clauses.

The number of copies created for each list item and the time at which those
copies are initialized are determined by the particular reduction scoping clause
that appears on the construct.

The time at which the original list item contains the result of the reduction
is determined by the particular reduction scoping clause.

The location in the OpenMP program at which values are combined and the
order in which values are combined are unspecified. Therefore, when
comparing sequential and parallel runs, or when comparing one parallel run to
another (even if the number of threads used is the same), there is no guarantee
that bitwise-identical results will be obtained or that side effects (such as
floating-point exceptions) will be identical or take place at the same location
in the OpenMP program.

To avoid data races, concurrent reads or updates of the original list item
must be synchronized with the update of the original list item that occurs as a
result of the reduction computation.



\subsubsection{Reduction Participating Clauses}
\label{subsubsec:Reduction Participating Clauses}
A reduction participating clause specifies a task or a SIMD lane as a
participant in a reduction defined by a reduction scoping clause. All 
properties common to all reduction clauses, which are defined in 
\specref{subsubsec:Properties Common To All Reduction Clauses}, apply to
reduction participating clauses.

Accesses to the original list item may be replaced by accesses to copies of the
original list item created by a region that corresponds to a construct with a
reduction scoping clause.

In any case, the final value of the reduction must be determined as if all tasks
or SIMD lanes that participate in the reduction are executed sequentially in
some arbitrary order.



\subsubsection{\hcode{reduction} Clause}
\index{reduction@{\code{reduction}}}
\index{clauses!reduction@{\code{reduction}}}
\label{subsubsec:reduction clause}
\summary
The \code{reduction} clause specifies a \plc{reduction-identifier} and one or
more list items. For each list item, a private copy is created in each implicit
task or SIMD lane and is initialized with the initializer value of the
\plc{reduction-identifier}. After the end of the region, the original list item
is updated with the values of the private copies using the combiner associated
with the \plc{reduction-identifier}.

\syntax
\begin{ompSyntax}
reduction(\plc{[ reduction-modifier},\plc{]reduction-identifier }:\plc{ list})
\end{ompSyntax}

Where \plc{reduction-identifier} is defined in 
\specref{subsubsec:Properties Common To All Reduction Clauses}, and
\plc{reduction-modifier} is one of the following:
\begin{indentedcodelist}
inscan
task
default
\end{indentedcodelist}

\descr
The \code{reduction} clause is a reduction scoping clause and a reduction
participating clause, as described in \specref{subsubsec:Reduction Scoping Clauses} 
and \specref{subsubsec:Reduction Participating Clauses}. 

If \plc{reduction-modifier} is not present or the \code{default}
\plc{reduction-modifier} is present, the behavior is
as follows. For \code{parallel} and worksharing constructs, one or more
private copies of each list item are created for each implicit task, as if the
\code{private} clause had been used. For the \code{simd} construct, one or
more private copies of each list item are created for each SIMD lane, as if the
\code{private} clause had been used.  For the \code{taskloop} construct,
private copies are created according to the rules of the reduction scoping
clauses.  For the \code{teams} construct, one or more private copies of each
list item are created for the initial task of each team in the league, as if
the \code{private} clause had been used. For the \code{loop} construct,
private copies are created and used in the construct according to the 
description and restrictions in \specref{subsec:List Item Privatization}. At 
the end of a region that corresponds to a construct for which the \code{reduction} 
clause was specified, the original list item is updated by combining its original 
value with the final value of each of the private copies, using the combiner of the
specified \plc{reduction-identifier}. 

If the \code{inscan} \plc{reduction-modifier} is present, a scan computation is
performed over updates to the list item performed in each logical iteration of
the loop associated with the worksharing-loop, worksharing-loop SIMD, or
\code{simd} construct (see \specref{subsec:scan Directive}). The list
items are privatized in the construct according to the description and 
restrictions in \specref{subsec:List Item Privatization}. At the end of the region, 
each original list item is assigned the value of the private copy from the last 
logical iteration of the loops associated with the construct.

If the \code{task} \plc{reduction-modifier} is present for a \code{parallel}
or worksharing construct, then each list item is privatized according to the
description and restrictions in \specref{subsec:List Item Privatization}, and 
an unspecified number of additional private copies are created to support task 
reductions.  Any copies associated with the reduction are initialized before they 
are accessed by the tasks that participate in the reduction, which include all 
implicit tasks in the corresponding region and all participating explicit tasks 
that specify an \code{in_reduction} clause (see 
\specref{subsubsec:in_reduction clause}). After the end of the region, the original 
list item contains the result of the reduction.

If \code{nowait} is not specified for the construct, the reduction computation 
will be complete at the end of the construct; however, if the \code{reduction} 
clause is used on a construct to which \code{nowait} is also applied, accesses 
to the original list item will create a race and, thus, have unspecified effect 
unless synchronization ensures that they occur after all threads have executed 
all of their iterations or \code{section} constructs, and the reduction computation
has completed and stored the computed value of that list item. This can most 
simply be ensured through a barrier synchronization.

\restrictions
The restrictions to the \code{reduction} clause are as follows:

\begin{itemize}
\item All restrictions common to all reduction clauses, which are listed in
      \specref{subsubsec:Properties Common To All Reduction Clauses}, apply to
      this clause.
\item A list item that appears in a \code{reduction} clause of a worksharing
      construct must be shared in the \code{parallel} region to which a corresponding
      worksharing region binds.
\item If a list item that appears in a \code{reduction} clause of a worksharing
      construct or \code{loop} construct for which the corresponding region binds to a
      parallel region is an array section or an array element, all threads
      that participate in the reduction must specify the same storage location.
\item A list item that appears in a \code{reduction} clause with the \code{inscan} 
      \plc{reduction-modifier} must appear as a list item in an \code{inclusive} or
      \code{exclusive} clause on a \code{scan} directive enclosed by the construct.
\item A \code{reduction} clause without the \code{inscan} \plc{reduction-modifier} 
      may not appear on a construct on which a \code{reduction} clause with the
      \code{inscan} \plc{reduction-modifier} appears.
\item A \code{reduction} clause with the \code{task} \plc{reduction-modifier}
      may only appear on a \code{parallel} construct, a worksharing construct
      or a combined or composite construct for which any of the aforementioned 
      constructs is a constituent construct and \code{simd} or \code{loop} are 
      not constituent constructs.
\item A \code{reduction} clause with the \code{inscan} \plc{reduction-modifier}
      may only appear on a worksharing-loop construct, a worksharing-loop SIMD
      construct, a \code{simd} construct, a parallel worksharing-loop construct or
      a parallel worksharing-loop SIMD construct.
\item A list item that appears in a \code{reduction} clause of the innermost
      enclosing worksharing or \code{parallel} construct may not be accessed in an
      explicit task generated by a construct for which an \code{in_reduction} clause
      over the same list item does not appear.
\item The \code{task} \plc{reduction-modifier} may not appear in a \code{reduction} 
      clause if the \code{nowait} clause is specified on the same construct.

\begin{ccppspecific}
\item If a list item in a \code{reduction} clause on a worksharing construct
      or \code{loop} construct for which the corresponding region binds to a
      parallel region has a reference type then it must bind to the same object
      for all threads of the team.
\item If a list item in a \code{reduction} clause on a worksharing construct
      or \code{loop} construct for which the corresponding region binds to a
      parallel region is an array section or an array element then the base
      pointer must point to the same variable for all threads of the team.
\item A variable of class type (or array thereof) that appears in a \code{reduction} 
      clause with the \code{inscan} \plc{reduction-modifier} requires an accessible, 
      unambiguous default constructor for the class type. The number of calls to the 
      default constructor while performing the scan computation is unspecified.
\item A variable of class type (or array thereof) that appears in a \code{reduction} 
      clause with the \code{inscan} \plc{reduction-modifier} requires an accessible, 
      unambiguous copy assignment operator for the class type. The number of calls 
      to the copy assignment operator while performing the scan computation is 
      unspecified.
\end{ccppspecific}
\end{itemize}

\begin{crossrefs}
\item \code{scan} directive, see \specref{subsec:scan Directive}.

\item List Item Privatization, see \specref{subsec:List Item Privatization}.

\item \code{private} clause, see \specref{subsubsec:private clause}.
\end{crossrefs}



\subsubsection{\hcode{task_reduction} Clause}
\index{task_reduction@{\code{task_reduction}}}
\index{clauses!task_reduction@{\code{task_reduction}}}
\label{subsubsec:task_reduction clause}
\summary
The \code{task_reduction} clause specifies a reduction among tasks.

\syntax
\begin{ompSyntax}
task_reduction(\plc{reduction-identifier }:\plc{ list})
\end{ompSyntax}
Where \plc{reduction-identifier} is defined in Section
\ref{subsubsec:Properties Common To All Reduction Clauses}.

\descr
The \code{task_reduction} clause is a reduction scoping clause, as described in
\ref{subsubsec:Reduction Scoping Clauses}.

For each list item, the number of copies is unspecified. Any copies associated
with the reduction are initialized before they are accessed by the tasks
participating in the reduction. After the end of the region, the original list
item contains the result of the reduction.

\restrictions
The restrictions to the \code{task_reduction} clause are as follows:

\begin{itemize}
\item All restrictions common to all reduction clauses, which are listed in
      \specref{subsubsec:Properties Common To All Reduction Clauses}, apply to
      this clause.
\end{itemize}



\subsubsection{\hcode{in_reduction} Clause}
\index{in_reduction@{\code{in_reduction}}}
\index{clauses!in_reduction@{\code{in_reduction}}}
\label{subsubsec:in_reduction clause}
\summary
The \code{in_reduction} clause specifies that a task participates in a reduction.

\syntax
\begin{ompSyntax}
in_reduction(\plc{reduction-identifier }:\plc{ list})
\end{ompSyntax}

where \plc{reduction-identifier} is defined in 
\specref{subsubsec:Properties Common To All Reduction Clauses}.

\descr
The \code{in_reduction} clause is a reduction participating clause, as
described in \specref{subsubsec:Reduction Participating Clauses}. For a
given a list item, the \code{in_reduction} clause defines a task to be a
participant in a task reduction that is defined by an enclosing region for a
matching list item that appears in a \code{task_reduction} clause or a
\code{reduction} clause with the \code{task} modifier, where either:

\begin{enumerate}
\item The matching list item has the same storage location as the list
      item in the \code{in_reduction} clause; or
\item A private copy, derived from the matching list item, that is used to
      perform the task reduction has the same storage location as the list item
      in the \code{in_reduction} clause.
\end{enumerate}

For the \code{task} construct, the generated task becomes the participating
task. For each list item, a private copy may be created as if the \code{private}
clause had been used.

For the \code{target} construct, the target task becomes the participating
task. For each list item, a private copy will be created in the data
environment of the target task as if the \code{private} clause had been used,
and this private copy will be implicitly mapped into the device data
environment of the target device.

At the end of the task region, if a private copy was created its value is
combined with a copy created by a reduction scoping clause or with the original
list item.

\restrictions
The restrictions to the \code{in_reduction} clause are as follows:

\begin{itemize}
\item All restrictions common to all reduction clauses, which are listed in
      \specref{subsubsec:Properties Common To All Reduction Clauses}, apply to
      this clause.
\item A list item that appears in a \code{task_reduction} clause or a 
      \code{reduction} clause with the \code{task} modifier that is specified on 
      a construct that corresponds to a region in which the region of the 
      participating task is closely nested must match each list item. The 
      construct that corresponds to the innermost enclosing region that meets
      this condition must specify the same \plc{reduction-identifier} for the
      matching list item as the \code{in_reduction} clause.
\end{itemize}



\subsubsection{\hcode{declare}~\hcode{reduction} Directive}
\index{declare reduction@{\code{declare}~\code{reduction}}}
\index{directives!declare reduction@{\code{declare}~\code{reduction}}}
\label{subsubsec:declare reduction Directive}
\summary
The following section describes the directive for declaring user-defined 
reductions. The \code{declare}~\code{reduction} directive declares a 
\plc{reduction-identifier} that can be used in a \code{reduction} clause. 
The \code{declare}~\code{reduction} directive is a declarative directive.

\syntax
\begin{cspecific}
\begin{ompcPragma}
#pragma omp declare reduction(\plc{reduction-identifier }:\plc{ typename-list }:
\plc{combiner })\plc{[initializer-clause] new-line}
\end{ompcPragma}

where:

\begin{itemize}
\item \plc{reduction-identifier} is either a base language identifier or one of 
      the following operators: \code{+}, \code{-}, \code{*}, \code{&}, \code{|},
      \code{^}, \code{&&} and \code{||}
\item \plc{typename-list} is a list of type names
\item \plc{combiner} is an expression
\item \plc{initializer-clause} is \code{initializer(}\plc{initializer-expr}\code{)}
      where \plc{initializer-expr} is\linebreak
      \code{omp_priv = }\plc{initializer} or \plc{function-name}\code{(}\plc{argument-list}\code{)}
\end{itemize}
\end{cspecific}

\begin{cppspecific}
\begin{ompcPragma}
#pragma omp declare reduction(\plc{reduction-identifier }:\plc{ typename-list }:
\plc{combiner})\plc{ [initializer-clause] new-line}
\end{ompcPragma}

where:

\begin{itemize}
\item \plc{reduction-identifier} is either an \plc{id-expression} or one of 
      the following operators: \code{+}, \code{-}, \code{*}, \code{&}, \code{|},
      \code{^}, \code{&&} or \code{||}
\item \plc{typename-list} is a list of type names
\item \plc{combiner} is an expression

% An equal sign is intentionally missing for C++, so that
% initializer (omp_priv (4)) syntax is also valid in addition to
% initializer (omp_priv = 4).
\item \plc{initializer-clause} is \code{initializer(}\plc{initializer-expr}\code{)}
      where \plc{initializer-expr} is\linebreak 
      \code{omp_priv} \plc{initializer} or \plc{function-name}\code{(}\plc{argument-list}\code{)}
\end{itemize}
\end{cppspecific}


\begin{fortranspecific}
\begin{ompfPragma}
!$omp declare reduction(\plc{reduction-identifier }:\plc{ type-list }:\plc{ combiner})
\plc{[initializer-clause]}
\end{ompfPragma} %$ Close off misinterpreted dollar sign/math symbol

where:

\begin{itemize}
\item \plc{reduction-identifier} is either a base language identifier, or a 
      user-defined operator, or one of the following operators: \code{+}, \code{-},
      \code{*}, \code{.and.}, \code{.or.}, \code{.eqv.}, \code{.neqv.}, or one of 
      the following intrinsic procedure names: \code{max}, \code{min}, \code{iand},
      \code{ior}, \code{ieor}.
\item \plc{type-list} is a list of type specifiers that must not be \code{CLASS(*)} 
      and abstract type
\item \plc{combiner} is either an assignment statement or a subroutine name followed 
      by an argument list
\item \plc{initializer-clause} is \code{initializer(}\plc{initializer-expr}\code{)},
      where \plc{initializer-expr} is\linebreak
      \code{omp_priv = }\plc{expression} or \plc{subroutine-name}\code{(}\plc{argument-list}\code{)}
\end{itemize}
\end{fortranspecific}

\descr
Custom reductions can be defined using the \code{declare}~\code{reduction} 
directive; the \plc{reduction-identifier} and the type identify the 
\code{declare}~\code{reduction} directive. The \plc{reduction-identifier} can 
later be used in a \code{reduction} clause that uses variables of the type or types 
specified in the \code{declare}~\code{reduction} directive. If the directive 
applies to several types then it is considered as if there were multiple 
\code{declare}~\code{reduction} directives, one for each type.

\begin{fortranspecific}
If a type with deferred or assumed length type parameter is specified in a 
\code{declare}~\code{reduction} directive, the \plc{reduction-identifier} 
of that directive can be used in a reduction clause with any variable of 
the same type and the same kind parameter, regardless of the length type 
Fortran parameters with which the variable is declared.
\end{fortranspecific}

The visibility and accessibility of this declaration are the same as those 
of a variable declared at the same point in the program. The enclosing context 
of the \plc{combiner} and of the \plc{initializer-expr} is that of the 
\code{declare}~\code{reduction} directive. The \plc{combiner} and the 
\plc{initializer-expr} must be correct in the base language as if they were 
the body of a function defined at the same point in the program.

\begin{fortranspecific}
If the \plc{reduction-identifier} is the same as the name of a user-defined 
operator or an extended operator, or the same as a generic name that is one 
of the allowed intrinsic procedures, and if the operator or procedure name 
appears in an accessibility statement in the same module, the accessibility 
of the corresponding \code{declare}~\code{reduction} directive is determined 
by the accessibility attribute of the statement.

If the \plc{reduction-identifier} is the same as a generic name that is one 
of the allowed intrinsic procedures and is accessible, and if it has the same 
name as a derived type in the same module, the accessibility of the corresponding 
\code{declare}~\code{reduction} directive is determined by the accessibility 
of the generic name according to the base language.
\end{fortranspecific}

\begin{cppspecific}
The \code{declare}~\code{reduction} directive can also appear at points in the 
program at which a static data member could be declared. In this case, the 
visibility and accessibility of the declaration are the same as those of a 
static data member declared at the same point in the program.
\end{cppspecific}

The \plc{combiner} specifies how partial results can be combined into a single 
value. The \plc{combiner} can use the special variable identifiers \code{omp_in} 
and \code{omp_out} that are of the type of the variables that this 
\plc{reduction-identifier} reduces. Each of them will denote one of the values to 
be combined before executing the \plc{combiner}. The special \code{omp_out} 
identifier refers to the storage that holds the resulting combined value after 
executing the \plc{combiner}.

The number of times that the \plc{combiner} is executed, and the order of these 
executions, for any reduction clause is unspecified.

\begin{fortranspecific}
If the \plc{combiner} is a subroutine name with an argument list, the 
\plc{combiner} is evaluated by calling the subroutine with the specified argument list.

If the \plc{combiner} is an assignment statement, the \plc{combiner} is 
evaluated by executing the assignment statement.
\end{fortranspecific}

As the \plc{initializer-expr} value of a user-defined reduction is not known 
\emph{a priori} the \plc{initializer-clause} can be used to specify one. Then 
the contents of the \plc{initializer-clause} will be used as the initializer 
for private copies of reduction list items where the \code{omp_priv} identifier 
will refer to the storage to be initialized. The special identifier 
\code{omp_orig} can also appear in the \plc{initializer-clause} and it will 
refer to the storage of the  original variable to be reduced.

The number of times that the \plc{initializer-expr} is evaluated, and the order 
of these evaluations, is unspecified.

\begin{ccppspecific}
If the \plc{initializer-expr} is a function name with an argument list, the 
\plc{initializer-expr} is evaluated by calling the function with the specified 
argument list. Otherwise, the \plc{initializer-expr} specifies how \code{omp_priv} 
is declared and initialized.
\end{ccppspecific}

\begin{cspecific}
If no \plc{initializer-clause} is specified, the private variables will be initialized
following the rules for initialization of objects with static storage duration.
\end{cspecific}

\begin{cppspecific}
If no \plc{initializer-expr} is specified, the private variables will be 
initialized following the rules for \plc{default-initialization}.
\end{cppspecific}

\begin{fortranspecific}
If the \plc{initializer-expr} is a subroutine name with an argument list, 
the \plc{initializer-expr} is evaluated by calling the subroutine with the  
specified argument list.

If the \plc{initializer-expr} is an assignment statement, the 
\plc{initializer-expr} is evaluated by executing the assignment statement.

If no \plc{initializer-clause} is specified, the private variables will be 
initialized as follows:

\begin{itemize}
\item For \code{complex}, \code{real}, or \code{integer} types, the value 0 
      will be used.
\item For \code{logical} types, the value \code{.false.} will be used.
\item For derived types for which default initialization is specified, default 
      initialization will be used.
\item Otherwise, not specifying an \plc{initializer-clause} results in unspecified 
      behavior.
\end{itemize}
\end{fortranspecific}

\begin{ccppspecific}
If \plc{reduction-identifier} is used in a \code{target} region then a 
\code{declare}~\code{target} construct must be specified for any function 
that can be accessed through the \plc{combiner} and
\plc{initializer-expr}.
\end{ccppspecific}

\begin{fortranspecific}
If \plc{reduction-identifier} is used in a \code{target} region then a 
\code{declare}~\code{target} construct must be specified for any function 
or subroutine that can be accessed through the \plc{combiner} 
and \plc{initializer-expr}.
\end{fortranspecific}

\restrictions
\begin{itemize}
\item The only variables allowed in the \plc{combiner} are 
      \code{omp_in} and \code{omp_out}.
\item The only variables allowed in the \plc{initializer-clause} are
      \code{omp_priv} and \code{omp_orig}.
\item If the variable \code{omp_orig} is modified in the \plc{initializer-clause}, 
      the behavior is unspecified.
\item If execution of the \plc{combiner} or the \plc{initializer-expr} results 
      in the execution of an OpenMP construct or an OpenMP API call, then the 
      behavior is unspecified.
\item A \plc{reduction-identifier} may not be re-declared in the current scope 
      for the same type or for a type that is compatible according to the base 
      language rules.
\item At most one \plc{initializer-clause} can be specified.
\item The \plc{typename-list} must not declare new types.

\begin{ccppspecific}
\item A type name in a \code{declare}~\code{reduction} directive cannot be a 
      function type, an array type, a reference type, or a type qualified with 
      \code{const}, \code{volatile} or \code{restrict}.
\end{ccppspecific}
\bigskip

\begin{cspecific}
\item If the \plc{initializer-expr} is a function name with an argument list, 
      then one of the arguments must be the address of \code{omp_priv}.
\end{cspecific}

\begin{cppspecific}
\item If the \plc{initializer-expr} is a function name with an argument list, then 
      one of the arguments must be \code{omp_priv} or the address of \code{omp_priv}.
\end{cppspecific}

\begin{fortranspecific}
\item If the \plc{initializer-expr} is a subroutine name with an argument list, 
      then one of the arguments must be \code{omp_priv}.
\item If the \code{declare}~\code{reduction} directive appears in the specification 
      part of a module and the corresponding reduction clause does not appear in 
      the same module, the \plc{reduction-identifier} must be the same as the name 
      of a user-defined operator, one of the allowed operators that is extended or 
      a generic name that is the same as the name of one of the allowed intrinsic 
      procedures.
\item If the \code{declare}~\code{reduction} directive appears in the specification 
      of a module, if the corresponding \code{reduction} clause does not appear in 
      the same module, and if the \plc{reduction-identifier} is the same as the name 
      of a user-defined operator or an extended operator, or the same as a generic 
      name that is the same as one of the allowed intrinsic procedures then the 
      interface for that operator or the generic name must be defined in the 
      specification of the same module, or must be accessible by use association.
\item Any subroutine or function used in the \code{initializer} clause or 
      \plc{combiner} expression must be an intrinsic function, or must have 
      an accessible interface.
\item Any user-defined operator, defined assignment or extended operator used 
      in the \code{initializer} clause or \plc{combiner} expression must have 
      an accessible interface.
\item If any subroutine, function, user-defined operator, defined assignment or 
      extended operator is used in the \code{initializer} clause or \plc{combiner} 
      expression, it must be accessible to the subprogram in which the 
      corresponding \code{reduction} clause is specified.
\item If the length type parameter is specified for a type, it must be a 
      constant, a colon or an~\code{*}.
\item If a type with deferred or assumed length parameter is specified in a 
      \code{declare}~\code{reduction} directive, no other 
      \code{declare}~\code{reduction} directive with the same type, the same 
      kind parameters and the same \plc{reduction-identifier} is allowed in 
      the same scope.
\item Any subroutine used in the \code{initializer} clause or \plc{combiner} 
      expression must not have any alternate returns appear in the argument list.
\end{fortranspecific}
\end{itemize}

\begin{crossrefs}
\item Properties Common To All Reduction Clauses, see
\specref{subsubsec:Properties Common To All Reduction Clauses}.
\end{crossrefs}



\subsection{Data Copying Clauses}
\label{subsec:Data Copying Clauses}
\index{data copying clauses}
\index{clauses!data copying}
This section describes the \code{copyin} clause (allowed on the \code{parallel} 
construct and combined parallel worksharing constructs) and the \code{copyprivate} 
clause (allowed on the \code{single} construct).

These clauses support the copying of data values from private or threadprivate 
variables on one implicit task or thread to the corresponding variables on other 
implicit tasks or threads in the team.

The clauses accept a comma-separated list of list items (see 
\specref{sec:Directive Format}). All list items appearing in a clause must be 
visible, according to the scoping rules of the base language. Clauses may be 
repeated as needed, but a list item that specifies a given variable may not 
appear in more than one clause on the same directive.

\begin{fortranspecific}
An associate name preserves the association with the selector established at 
the \code{ASSOCIATE} statement. A list item that appears in a data copying 
clause may be a selector of an \code{ASSOCIATE} construct. If the construct 
association is established prior to a parallel region, the association between 
the associate name and the original list item will be retained in the region.
\end{fortranspecific}



\subsubsection{\hcode{copyin} Clause}
\index{copyin@{\code{copyin}}}
\index{clauses!copyin@{\code{copyin}}}
\label{subsubsec:copyin clause}
\summary
The \code{copyin} clause provides a mechanism to copy the value of a threadprivate 
variable of the master thread to the threadprivate variable of each other member of 
the team that is executing the \code{parallel} region.

\syntax
The syntax of the \code{copyin} clause is as follows:

\begin{ompSyntax}
copyin(\plc{list})
\end{ompSyntax}

\descr
\begin{ccppspecific}
The copy is done after the team is formed and prior to the start of execution of the
associated structured block. For variables of non-array type, the copy occurs by copy
assignment. For an array of elements of non-array type, each element is copied as if by
assignment from an element of the array of the master thread to the corresponding 
element of the array of the other thread.
\end{ccppspecific}

\begin{cppspecific}
For class types, the copy assignment operator is invoked. The order in which copy
assignment operators for different variables of class type are called is unspecified.
\end{cppspecific}

\begin{fortranspecific}
The copy is done, as if by assignment, after the team is formed and prior to 
the start of execution of the associated structured block.

On entry to any \code{parallel} region, each thread's copy of a variable that 
is affected by a \code{copyin} clause for the \code{parallel} region will acquire 
the type parameters, allocation, association, and definition status of the copy
of the master thread, according to the following rules:

\begin{itemize}
\item If the original list item has the \code{POINTER} attribute, each copy 
      receives the same association status as that of the copy of the master 
      thread as if by pointer assignment.
\item If the original list item does not have the \code{POINTER}
      attribute, each copy becomes defined with the value of the copy of
      the master thread as if by intrinsic assignment unless the list item has
      a type bound procedure as a defined assignment.  If the original
      list item that does not have the \code{POINTER} attribute has the
      allocation status of unallocated, each copy will have the same status.
\item If the original list item is unallocated or unassociated, the copy of
      the other thread inherits the declared type parameters and the default 
      type parameter values from the original list item.
\end{itemize}
\end{fortranspecific}

\restrictions
The restrictions to the \code{copyin} clause are as follows:

\begin{ccppspecific}
\begin{itemize}
\item A list item that appears in a \code{copyin} clause must be threadprivate.
\item A variable of class type (or array thereof) that appears in a \code{copyin} 
      clause requires an accessible, unambiguous copy assignment operator for the 
      class type.
\end{itemize}
\end{ccppspecific}

\begin{fortranspecific}
\begin{itemize}
\item A list item that appears in a \code{copyin} clause must be threadprivate. 
      Named variables that appear in a threadprivate common block may be specified: 
      it is not necessary to specify the whole common block.
\item A common block name that appears in a \code{copyin} clause must be declared 
      to be a common block in the same scoping unit in which the \code{copyin} 
      clause appears.
\item If the list item is a polymorphic variable with the \code{ALLOCATABLE} 
      attribute, the behavior is unspecified.
\end{itemize}
\end{fortranspecific}

\begin{crossrefs}
\item \code{parallel} construct, see
\specref{sec:parallel Construct}.

\item \code{threadprivate} directive, see
\specref{subsec:threadprivate Directive}.
\end{crossrefs}



\subsubsection{\hcode{copyprivate} Clause}
\index{copyprivate@{\code{copyprivate}}}
\index{clauses!copyprivate@{\code{copyprivate}}}
\label{subsubsec:copyprivate clause}
\summary
The \code{copyprivate} clause provides a mechanism to use a private variable 
to broadcast a value from the data environment of one implicit task to the data 
environments of the other implicit tasks that belong to the \code{parallel} region.

To avoid data races, concurrent reads or updates of the list item must be
synchronized with the update of the list item that occurs as a result of the
\code{copyprivate} clause.

\syntax
The syntax of the \code{copyprivate} clause is as follows:

\begin{ompSyntax}
copyprivate(\plc{list})
\end{ompSyntax}

\descr
The effect of the \code{copyprivate} clause on the specified list items occurs 
after the execution of the structured block associated with the \code{single} 
construct (see \specref{subsec:single Construct}), and before any of the threads 
in the team have left the barrier at the end of the construct.

\begin{ccppspecific}
In all other implicit tasks that belong to the \code{parallel} region, each 
specified list item becomes defined with the value of the corresponding list 
item in the implicit task associated with the thread that executed the 
structured block. For variables of non-array type, the definition occurs by 
copy assignment. For an array of elements of non-array type, each element is
copied by copy assignment from an element of the array in the data environment of the
implicit task that is associated with the thread that executed the structured 
block to the corresponding element of the array in the data environment of the 
other implicit tasks
\end{ccppspecific}

\begin{cppspecific}
For class types, a copy assignment operator is invoked. The order in which copy
assignment operators for different variables of class type are called is unspecified.
\end{cppspecific}

\begin{fortranspecific}
If a list item does not have the \code{POINTER} attribute, then in all other 
implicit tasks that belong to the \code{parallel} region, the list item becomes 
defined as if by intrinsic assignment with the value of the corresponding list 
item in the implicit task that is associated with the thread that executed the 
structured block.  If the list item has a type bound procedure as a defined 
assignment, the assignment is performed by the defined assignment.

If the list item has the \code{POINTER} attribute, then, in all other implicit 
tasks that belong to the \code{parallel} region, the list item receives, as if by 
pointer assignment, the same association status of the corresponding list item in the 
implicit task that is associated with the thread that executed the structured block.

The order in which any final subroutines for different variables of a finalizable 
type are called is unspecified.
\end{fortranspecific}

\begin{note}
The \code{copyprivate} clause is an alternative to using a shared variable for the
value when providing such a shared variable would be difficult (for example, in a
recursion requiring a different variable at each level).
\end{note}

\restrictions
The restrictions to the \code{copyprivate} clause are as follows:

\begin{itemize}
\item All list items that appear in the \code{copyprivate} clause must be 
      either threadprivate or private in the enclosing context.
\item A list item that appears in a \code{copyprivate} clause may not appear 
      in a \code{private} or \code{firstprivate} clause on the \code{single} construct.

\begin{cppspecific}
\item A variable of class type (or array thereof) that appears in a 
      \code{copyprivate} clause requires an accessible unambiguous copy 
      assignment operator for the class type.
\end{cppspecific}

\begin{fortranspecific}
\item A common block that appears in a \code{copyprivate} clause must be threadprivate.
\item Pointers with the \code{INTENT(IN)} attribute may not appear in the 
      \code{copyprivate} clause.
\item The list item with the \code{ALLOCATABLE} attribute must have the 
      allocation status of allocated when the intrinsic assignment is performed.
\item If the list item is a polymorphic variable with the \code{ALLOCATABLE} 
      attribute, the behavior is unspecified.
\end{fortranspecific}
\end{itemize}

\begin{crossrefs}
\item \code{parallel} construct, see
\specref{sec:parallel Construct}.

\item \code{threadprivate} directive, see
\specref{subsec:threadprivate Directive}.

\item \code{private} clause, see
\specref{subsubsec:private clause}.
\end{crossrefs}



\subsection{Data-Mapping Attribute Rules, Clauses, and Directives}
\label{subsec:Data-Mapping Attribute Rules, Clauses, and Directives}
\index{data-mapping rules and clauses}
\index{attributes, data-mapping}
This section describes how the data-mapping and data-sharing attributes of
any variable referenced in a \code{target} region are determined. When specified,
explicit data-sharing attributes, \code{map} or \code{is_device_ptr} clauses on
\code{target} directives determine these attributes.  Otherwise, the first matching 
rule from the following implicit data-mapping rules applies for variables referenced
in a \code{target} construct that are not declared in the construct and do not appear 
in data-sharing attribute, \code{map} or \code{is_device_ptr} clauses.

\begin{itemize}
\item If a variable appears in a \code{to} or \code{link} clause on a
      \code{declare}~\code{target} directive then it is treated as if it had
      appeared in a \code{map} clause with a \plc{map-type} of \code{tofrom}.
\item If a list item appears in a \code{reduction}, \code{lastprivate} or
      \code{linear} clause on a combined \code{target} construct then it is 
      treated as if it also appears in a \code{map} clause with a 
      \plc{map-type} of \code{tofrom}.
\item If a list item appears in an \code{in_reduction} clause on a
      \code{target} construct then it is treated as if it also appears in a
      \code{map} clause with a \plc{map-type} of \code{tofrom} and a
      \plc{map-type-modifier} of \code{always}.
\item If a \code{defaultmap} clause is present for the category of the
      variable and specifies an implicit behavior other than \code{default},
      the data-mapping attribute is determined by that clause.

\begin{cppspecific}
\item If the \code{target} construct is within a class non-static member
      function, and a variable is an accessible data member of the object for
      which the non-static data member function is invoked, the variable is
      treated as if the \code{this[:1]} expression had appeared in a \code{map}
      clause with a \plc{map-type} of \code{tofrom}.  Additionally, if the
      variable is of a type pointer or reference to pointer, it is also
      treated as if it has appeared in a \code{map} clause as a zero-length
      array section.
\item If the \code{this} keyword is referenced inside a \code{target}
      construct within a class non-static member function, it is treated as
      if the \code{this[:1]} expression had appeared in a \code{map} clause
      with a \plc{map-type} of \code{tofrom}.
\end{cppspecific}

\begin{ccppspecific}
\item A variable that is of type pointer is treated as if it is the base
      pointer of a zero-length array section that appeared as a list item in a
      \code{map} clause.  
\end{ccppspecific}

\begin{cppspecific}
\item A variable that is of type reference to pointer is treated as if it
      had appeared in a \code{map} clause as a zero-length array section.
\end{cppspecific}

\item If a variable is not a scalar then it is treated as if it had appeared 
      in a \code{map} clause with a \plc{map-type} of \code{tofrom}.

\begin{fortranspecific}
\item If a scalar variable has the \code{TARGET}, \code{ALLOCATABLE}
      or \code{POINTER} attribute then it is treated as if it has appeared 
      in a \code{map} clause with a \plc{map-type} of \code{tofrom}.
\end{fortranspecific}

\item If none of the above rules applies then a scalar variable is not
      mapped, but instead has an implicit data-sharing attribute of
      mapped, but instead has an implicit data-sharing attribute of
      firstprivate (see \specref{subsubsec:Variables Referenced in a Construct}).
\end{itemize}



\subsubsection{\hcode{map} Clause}
\label{subsec:map Clause}
\index{map@{\code{map}}}
\index{clauses!map@{\code{map}}}
\summary
The \code{map} clause specifies how an original list item is mapped from the 
current task's data environment to a corresponding list item in the device 
data environment of the device identified by the construct.

\syntax
The syntax of the map clause is as follows:

\begin{ompSyntax}
map(\plc{[ [map-type-modifier[},\plc{] [map-type-modifier[},\plc{] ...] map-type} : \plc{] locator-list})
\end{ompSyntax}

where \plc{map-type} is one of the following:

\begin{indentedcodelist}
to
from
tofrom
alloc
release
delete
\end{indentedcodelist}

and \plc{map-type-modifier} is one of the following:

\begin{indentedcodelist}
always
close
mapper(\plc{mapper-identifier})
require_present
\end{indentedcodelist}

\descr
The list items that appear in a \code{map} clause may include array sections 
and structure elements.

The \plc{map-type} and \plc{map-type-modifier} specify the effect of the 
\code{map} clause, as described below.

For a given construct, the effect of a \code{map} clause with the \code{to},
\code{from}, or \code{tofrom} \plc{map-type} is ordered before the effect of a
\code{map} clause with the \code{alloc}, \code{release}, or \code{delete}
\plc{map-type}. If a mapper is specified for the type being mapped, or
explicitly specified with the \code{mapper} \plc{map-type-modifier}, then the
effective \code{map-type} of a list item will be determined according to the
rules of map-type decay.  If a \code{map} clause with a \code{require_present}
\plc{map-type-modifier} is present in a \code{map} clause, then
the effect of the clause is ordered before all other \code{map} clauses that do not have
the \code{required_present} modifier.  If a \code{mapper} \plc{map-type-modifier}
is present along with a \code{require_present} \plc{map-type-modifier} then all
elements of the object are treated as if they had a \code{require_present} modifier.

If a mapper is specified for the type being mapped, or explicitly specified with
the \code{mapper} \plc{map-type-modifier}, then all map clauses that appear on the
\code{declare mapper} directive are treated as though they appeared on the
construct with the \code{map} clause.  Array sections of a mapper type are
mapped as normal, then each element in the array section is mapped according to
the rules of the mapper.

\begin{ccppspecific}
If a list item in a \code{map} clause is a variable of structure type then it
is treated as if each structure element contained in the variable is a list
item in the clause.
\end{ccppspecific}

\begin{fortranspecific}
If a list item in a \code{map} clause is a derived type variable then
it is treated as if each component is a list item in the clause.

Each pointer component that is a list item that results from a mapped
derived type variable is treated as if its association status is
undefined, unless the pointer component appears as another list item
or as the base pointer of another list item in a \code{map} clause on
the same construct.
\end{fortranspecific}

If a list item in a \code{map} clause is a structure element then all other
structure elements of the containing structure variable form a \plc{structure 
sibling list}.  The \code{map} clause and the structure sibling list are
associated with the same construct.  If a corresponding list item of the
structure sibling list item is present in the device data environment when the
construct is encountered then:

\begin{itemize}
\item If the structure sibling list item does not appear in a \code{map}
      clause on the construct then:

\begin{itemize}
\item If the construct is a \code{target}, \code{target}~\code{data},
      or \code{target}~\code{enter}~\code{data} construct then the structure
      sibling list item is treated as if it is a list item in a \code{map}
      clause on the construct with a \plc{map-type} of \code{alloc}.
\item If the construct is \code{target}~\code{exit}~\code{data}
      construct, then the structure sibling list item is treated as if it is
      a list item in a \code{map} clause on the construct with a
      \plc{map-type} of \code{release}.

\begin{fortranspecific}
\item If the structure sibling list item is a pointer then it
      is treated as if its association status is undefined, unless
      it appears as the base pointer of another list item in a
      \code{map} clause on the same construct.
\end{fortranspecific}
\end{itemize}

\item If the \code{map} clause in which the structure element appears as a
      list item has a \plc{map-type} of \code{delete} and the structure sibling
      list item does not appear as a list item in a \code{map} clause on the
      construct with a \plc{map-type} of \code{delete} then the structure sibling
      list item is treated as if it is a list item in a \code{map} clause on the
      construct with a \plc{map-type} of \code{delete}.
\end{itemize}

If \plc{item}\textsubscript{1} is a list item in a \code{map} clause, and
\plc{item}\textsubscript{2} is another list item in a \code{map} clause on the
same construct that has a base pointer that is, or is part of,
\plc{item}\textsubscript{1}, then:

\begin{itemize}
\item If the \code{map} clause(s) appear on a \code{target},
      \code{target}~\code{data}, or \code{target}~\code{enter}~\code{data} 
      construct, then on entry to the corresponding region the effect of 
      the \code{map} clause on \plc{item}\textsubscript{1} is ordered to 
      occur before the effect of the \code{map} clause on 
      \plc{item}\textsubscript{2}.
\item If the \code{map} clause(s) appear on a \code{target},
      \code{target}~\code{data}, or \code{target}~\code{exit}~\code{data} 
      construct then on exit from the corresponding region the effect of 
      the \code{map} clause on \plc{item}\textsubscript{2} is ordered to 
      occur before the effect of the \code{map} clause on 
      \plc{item}\textsubscript{1}.
\end{itemize}

\begin{fortranspecific}
If a list item in a \code{map} clause is an associated pointer and the
pointer is not the base pointer of another list item in a \code{map}
clause on the same construct, then it is treated as if its pointer
target is implicitly mapped in the same clause. For the purposes of
the \code{map} clause, the mapped pointer target is treated as if its
base pointer is the associated pointer.
\end{fortranspecific}

If a list item in a \code{map} clause has a base pointer, and a pointer
variable is present in the device data environment that corresponds to the
base pointer when the effect of the \code{map} clause occurs, then if
the corresponding pointer or the corresponding
list item is created in the device data environment on entry to the
construct, then:

\begin{enumerate}

\begin{ccppspecific}
\item The corresponding pointer variable is assigned an address such that the
      corresponding list item can be accessed through the pointer in a
      \code{target} region.
\end{ccppspecific}

\begin{fortranspecific}
\item[1.] The corresponding pointer variable is associated with a pointer
      target that has the same rank and bounds as the pointer target of
      the original pointer, such that the corresponding list item can be
      accessed through the pointer in a \code{target} region.
\end{fortranspecific}

\item The corresponding pointer variable becomes an attached pointer
      for the corresponding list item.
\item If the original base pointer and the corresponding attached pointer
      share storage, then the original list item and the corresponding list item 
      must share storage. 
\end{enumerate}

\begin{cppspecific}
If a \plc{lambda} is mapped explicitly or implicitly, variables
that are captured by the \plc{lambda} behave as follows:

\begin{itemize}
\item the variables that are of pointer type are treated as if they had
      appeared in a \code{map} clause as zero-length array sections; and 
\item the variables that are of reference type are treated as if they
      had appeared in a \code{map} clause.
\end{itemize}

If a member variable is captured by a \plc{lambda} in class scope, and
the \plc{lambda} is later mapped explicitly or implicitly with its
full static type, the \code{this} pointer is treated as if it had
appeared on a \code{map} clause.
\end{cppspecific}

The original and corresponding list items may share storage such that writes to 
either item by one task followed by a read or write of the other item by another 
task without intervening synchronization can result in data races.

If the \code{map} clause appears on a \code{target}, \code{target}~\code{data},
\code{target}~\code{enter}~\code{data} or  \code{target}~\code{exit}~\code{data}
construct with a \code{require_present} \plc{map-type-modifier} then on entry to
the region if the corresponding list item does not appear in the device data
envirionment an error occurs and the program terminates.

If the \code{map} clause appears on a \code{target}, \code{target}~\code{data}, 
or \code{target}~\code{enter}~\code{data} construct then on entry to the region 
the following sequence of steps occurs as if performed as a single atomic operation:

\begin{enumerate}
\item If a corresponding list item of the original list item is not present 
      in the device data environment, then:

\begin{enumerate}
\item A new list item with language-specific attributes is derived from the 
      original list item and created in the device data environment;
\item The new list item becomes the corresponding list item of the original 
      list item in the device data environment;
\item The corresponding list item has a reference count that is initialized 
      to zero; and
\item The value of the corresponding list item is undefined;
\end{enumerate}

\item If the corresponding list item's reference count was not already incremented 
      because of the effect of a \code{map} clause on the construct then:
\begin{enumerate}
\item The corresponding list item's reference count is incremented by one;
\end{enumerate}

\item If the corresponding list item's reference count is one or the
      \code{always} \plc{map-type-modifier} is present, and if the
      \plc{map-type} is \code{to} or \code{tofrom}, then:

\begin{enumerate}
\begin{ccppspecific}
\item For each part of the list item that is an attached pointer,
      that part of the corresponding list item will have the value that it
      had immediately prior to the effect of the \code{map} clause; and
\end{ccppspecific}

\begin{fortranspecific}
\item[a)] For each part of the list item that is an attached pointer,
      that part of the corresponding list item, if associated, will be
      associated with the same pointer target that it was associated
      with immediately prior to the effect of the \code{map} clause.
\end{fortranspecific}

\item For each part of the list item that is not an attached pointer, 
      the value of that part of the original list item is assigned to 
      that part of the corresponding list item.
\end{enumerate}
\end{enumerate}

\begin{note}
If the effect of the \code{map} clauses on a construct would assign the
value of an original list item to a corresponding list item more than once,
then an implementation is allowed to ignore additional assignments of
the same value to the corresponding list item.
\end{note}

In all cases on entry to the region, concurrent reads or updates of any part 
of the corresponding list item must be synchronized with any update of the 
corresponding list item that occurs as a result of the \code{map} clause to
avoid data races.

If the \code{map} clause appears on a \code{target}, \code{target}~\code{data}, 
or \code{target}~\code{exit}~\code{data} construct and a corresponding list item 
of the original list item is not present in the device data environment on exit 
from the region then the list item is ignored. Alternatively, if the \code{map} 
clause appears on a \code{target}, \code{target}~\code{data}, or 
\code{target}~\code{exit}~\code{data} construct and a corresponding list item of 
the original list item is present in the device data environment on exit from the 
region, then the following sequence of steps occurs as if performed as a single 
atomic operation:

\begin{enumerate}
\item If the \plc{map-type} is not \code{delete} and the corresponding list 
      item's reference count is finite and was not already decremented because 
      of the effect of a \code{map} clause on the construct then:

\begin{enumerate}
\item The corresponding list item's reference count is decremented by one;
\end{enumerate}

\item If the \plc{map-type} is \code{delete} and the corresponding list item's 
      reference count is finite then:

\begin{enumerate}
\item The corresponding list item's reference count is set to zero;
\end{enumerate}

\item If the \plc{map-type} is \code{from} or \code{tofrom} and if the 
      corresponding list item's reference count is zero or the \code{always} 
      \plc{map-type-modifier} is present then:

\begin{enumerate}
\begin{ccppspecific}
\item For each part of the list item that is an attached pointer, that part 
      of the original list item will have the value that it had immediately
      prior to the effect of the \code{map} clause;
\end{ccppspecific}

\begin{fortranspecific}
\item[a)] For each part of the list item that is an attached pointer, that
      part of the corresponding list item, if associated, will be
      associated with the same pointer target with which it was associated
      immediately prior to the effect of the \code{map} clause; and
\end{fortranspecific}

\item For each part of the list item that is not an attached pointer, the value
      of that part of the corresponding list item is assigned to that part of 
      the original list item; and
\end{enumerate}

\item If the corresponding list item's reference count is zero then the 
      corresponding list item is removed from the device data environment.
\end{enumerate}

\begin{note}
If the effect of the \code{map} clauses on a construct would assign the
value of a corresponding list item to an original list item more than once,
then an implementation is allowed to ignore additional assignments of
the same value to the original list item.
\end{note}

In all cases on exit from the region, concurrent reads or updates of any part of 
the original list item must be synchronized with any update of the original list 
item that occurs as a result of the \code{map} clause to avoid data races.

If a single contiguous part of the original storage of a list item with an
implicit data-mapping attribute has corresponding storage in the device data
environment prior to a task encountering the construct that is associated with the
\code{map} clause, only that part of the original storage will have corresponding 
storage in the device data environment as a result of the \code{map} clause.

If a list item with an implicit data-mapping attribute does not have
any corresponding storage in the device data environment prior to a
task encountering the construct associated with the \code{map} clause,
and one or more contiguous parts of the original storage are either
list items or base pointers to list items that are explicitly mapped
on the construct, only those parts of the original storage will have
corresponding storage in the device data environment as a result of
the \code{map} clauses on the construct.

\begin{ccppspecific}
If a new list item is created then a new list item of the same type, with 
automatic storage duration, is allocated for the construct. The size and alignment 
of the new list item are determined by the static type of the variable. This 
allocation occurs if the region references the list item in any statement.
Initialization and assignment of the new list item are through bitwise copy.
\end{ccppspecific}

\begin{fortranspecific}
If a new list item is created then a new list item of the same type, type 
parameter, and rank is allocated.  The new list item inherits all default 
values for the type parameters from the original list item.
The value of the new list item becomes that of the original list item
in the map initialization and assignment.

If the allocation status of the original list item with the
\code{ALLOCATABLE} attribute is changed in the host device data
environment and the corresponding list item is already present in the
device data environment, the allocation status of the corresponding
list item is unspecified until a mapping operation is performed with a
\code{map} clause on entry to a \code{target}, \code{target}~\code{data}, or
\code{target}~\code{enter}~\code{data} region.
\end{fortranspecific}

The \plc{map-type} determines how the new list item is initialized.

If a \plc{map-type} is not specified, the \plc{map-type} defaults to \code{tofrom}.

The \code{close} \plc{map-type-modifier} is a hint to the runtime to 
allocate memory close to the target device.

\events
The \plc{target-map} event occurs when a thread maps data to or from a target device.

The \plc{target-data-op} event occurs when a thread initiates a data operation 
on a target device.

\tools

A thread dispatches a registered \code{ompt_callback_target_map}
callback for each occurrence of a \plc{target-map} event in that thread.
The callback occurs in the context of the target task and has type signature 
\code{ompt_callback_target_map_t}.

A thread dispatches a registered \code{ompt_callback_target_data_op}
callback for each occurrence of a \plc{target-data-op} event in that thread.
The callback occurs in the context of the target task and has type signature 
\code{ompt_callback_target_data_op_t}.

\restrictions
The restrictions to the \code{map} clause are as follows:

\begin{itemize}
\item A list item cannot appear in both a \code{map} clause and a data-sharing
      attribute clause on the same construct unless the construct is a
      combined construct.
\item Each of the \plc{map-type-modifier} modifiers can appear at most once on the
      \code{map} clause.

\begin{ccppspecific}
\item List items of the \code{map} clauses on the same construct must not share
      original storage unless they are the same lvalue expression or array section.
\end{ccppspecific}

\item If a list item is an array section, it must specify contiguous storage.
\item If multiple list items are explicitly mapped on the same construct and 
      have the same containing array or have base pointers that share original 
      storage, and if any of the list items do not have corresponding list
      items that are present in the device data environment prior to a task
      encountering the construct, then the list items must refer to the same 
      array elements of either the containing array or the implicit array of 
      the base pointers.
\item If any part of the original storage of a list item with an explicit 
      data-mapping attribute has corresponding storage in the device data
      environment prior to a task encountering the construct associated with the
      \code{map} clause, all of the original storage must have corresponding storage
      in the device data environment prior to the task encountering the construct.
\item If a list item is an element of a structure, and a different element
      of the structure has a corresponding list item in the device data 
      environment prior to a task encountering the construct associated 
      with the \code{map} clause, then the list item must also have a 
      corresponding list item in the device data environment prior to 
      the task encountering the construct.
\item A list item must have a mappable type.
\item \code{threadprivate} variables cannot appear in a \code{map} clause.
\item If a \code{mapper} map-type-modifier is specified, its type must match 
      the type of the list-items passed to that map clause.
\item Memory spaces and memory allocators cannot appear as a list item in 
      a \code{map} clause.

\begin{cppspecific}
\item If the type of a list item is a reference to a type \plc{T} then the
      reference in the device data environment is initialized to refer to 
      the object in the device data environment that corresponds to the 
      object referenced by the list item.  If mapping occurs, it occurs 
      as though the object were mapped through a pointer with an array 
      section of type \plc{T} and length one.
\item No type mapped through a reference can contain a reference to its own
      type, or any references to types that could produce a cycle of references.
\item If the list item is a \plc{lambda}, any pointers and references captured by
      the \plc{lambda} must have the corresponding list item in the device
      data environment prior to the task encountering the construct.
\end{cppspecific}

\begin{ccppspecific}
\item A list item cannot be a variable that is a member of a structure 
      with a union type.
\item A bit-field cannot appear in a \code{map} clause.
\item A pointer that has a corresponding attached pointer must not be modified
      for the duration of the lifetime of the list item to which the
      corresponding pointer is attached in the device data environment.
\end{ccppspecific}
\end{itemize}

\begin{fortranspecific}
\begin{itemize}
\item List items of the \code{map} clauses on the same construct must not share
      original storage unless they are the same variable or array section.
\item A pointer that has a corresponding attached pointer and is associated
    with a given pointer target must not become associated with a different
    pointer target for the duration of the lifetime of the list item to which
    the corresponding pointer is attached in the device data environment.
\item If the allocation status of a list item or any subobject of the
      list item with the \code{ALLOCATABLE} attribute is unallocated upon
      entry to a \code{target} region, the list item or any subobject of
      the corresponding list item must be unallocated upon exit from the region.
\item If the allocation status of a list item or any subobject of the
      list item with the \code{ALLOCATABLE} attribute is allocated upon
      entry to a \code{target} region, the allocation status of the
      corresponding list item or any subobject of the corresponding list
     item must not be changed and must not be reshaped in the region.
\item If an array section is mapped and the size of the section is
      smaller than that of the whole array, the behavior of referencing
      the whole array in the \code{target} region is unspecified.
\item A list item must not be a whole array of an assumed-size array.
\item If the association status of a list item with the \code{POINTER}
      attribute is associated upon entry to a \code{target} region, the
      list item must be associated with the same pointer target upon exit
      from the region.
\item If the association status of a list item with the \code{POINTER}
      attribute is disassociated upon entry to a \code{target} region, the
      list item must be disassociated upon exit from the region.
\item If the association status of a list item with the \code{POINTER}
      attribute is undefined upon entry to a \code{target} region, the
      list item must be undefined upon exit from the region.
\item If the association status of a list item with the \code{POINTER}
      attribute is disassociated or undefined on entry and if the list
      item is associated with a pointer target inside a \code{target}
      region, then the pointer association status must become
      disassociated before the end of the region.
\end{itemize}
\end{fortranspecific}

\begin{crossrefs}
\item \code{ompt_callback_target_data_op_t}, see
\specref{sec:ompt_callback_target_data_op_t}.

\item \code{ompt_callback_target_map_t}, see
\specref{sec:ompt_callback_target_map_t}.
\end{crossrefs}

\begin{ccppspecific}
\subsubsection{Pointer Initialization for Device Data Environments}
\label{subsec:pointer initialization}

This section describes how a pointer may be assigned an initial value to point
to an object that exists in a device data environment and corresponds to a
\emph{matching mapped list item}.

All previously mapped list items that have corresponding storage in a given
device data environment constitute the set of currently mapped list items.  If
a currently mapped list item has a base pointer, the \emph{base address} of
the currently mapped list item is the value of its base pointer. Otherwise,
the base address is determined by the following steps:

\begin{enumerate}
\item Let \plc{X} refer to the currently mapped list item.

\item If \plc{X} refers to an array section or array element, let \plc{X}
    refer to its base array.

\item If \plc{X} refers to a structure element, let \plc{X} refer to its
    containing structure and return to step 2.

\item The base address for the currently mapped list item is the address of \plc{X}.
\end{enumerate}

Additionally, each currently mapped list item has a \emph{starting address}
and an \emph{ending address}. The starting address is the address of the
first storage location associated with the list item, and the \emph{ending
address} is the address of the storage location that immediately follows
the last storage location associated with the list item.

The \emph{mapped address range} of the currently mapped list item is the range
of addresses that starts from the starting address and ends with the ending
address. The \emph{extended address range} of the currently mapped list item
is the range of addresses that starts from the minimum of the starting address
and the base address and that ends with the maximum of the ending address and
the base address.

If the value of a given pointer is in the mapped address range of a currently
mapped list item then that currently mapped list item is a matching mapped
list item.  Otherwise, if the value of the pointer is in the extended address
range of a currently mapped list item then that currently mapped list item is
a matching mapped list item.

If multiple matching mapped list items are found and they all appear as part
of the same containing structure, the one that has the lowest starting address
is treated as the sole matching mapped list item. Otherwise, if multiple
matching mapped list items are found then the behavior is unspecified.

If a matching mapped list item is found, the initial value that is assigned to
the pointer is a device address such that the corresponding list item in the
device data environment can be accessed through the pointer in a
\code{target} region.

If a matching mapped list item is not found, the assigned initial value of the
pointer is NULL.
\end{ccppspecific}


\subsubsection{\hcode{defaultmap} Clause}
\label{subsubsec:defaultmap clause}
\index{defaultmap@{\code{defaultmap}}}
\index{clauses!defaultmap@{\code{defaultmap}}}

\summary

The \code{defaultmap} clause explicitly determines the data-mapping attributes 
of variables that are referenced in a \code{target} construct for which the
data-mapping attributes  would otherwise be implicitly determined  (see 
\specref{subsec:Data-Mapping Attribute Rules, Clauses, and Directives}).

\syntax
The syntax of the \code{defaultmap} clause is as follows:

\begin{ompSyntax}
  defaultmap(\plc{implicit-behavior[:variable-category]})
\end{ompSyntax}

Where \plc{implicit-behavior} is one of:
\begin{indentedcodelist}
  alloc
  to
  from
  tofrom
  firstprivate
  none
  default
\end{indentedcodelist}

\begin{ccppspecific}
and \plc{variable-category} is one of:
\begin{indentedcodelist}
  scalar
  aggregate
  pointer
\end{indentedcodelist}
\end{ccppspecific}

\begin{fortranspecific}
and \plc{variable-category} is one of:
\begin{indentedcodelist}
  scalar
  aggregate
  allocatable
  pointer
\end{indentedcodelist}
\end{fortranspecific}

\descr
The \code{defaultmap} clause sets the implicit data-mapping attribute for 
all variables referenced in the construct. If \plc{variable-category} is 
specified, the effect of the \code{defaultmap} clause is as follows:

\begin{itemize}
\item If \plc{variable-category} is \code{scalar}, all scalar variables of
      non-pointer type or all non-pointer non-allocatable scalar variables that
      have an implicitly determined data-mapping or data-sharing attribute will
      have a data-mapping or data-sharing attribute specified by
      \plc{implicit-behavior}.
\item If \plc{variable-category} is \code{aggregate} or \code{allocatable},
      all aggregate or allocatable variables that have an implicitly determined
      data-mapping or data-sharing attribute will have a data-mapping or
      data-sharing attribute specified by \plc{implicit-behavior}.
\item If \plc{variable-category} is \code{pointer}, all variables of pointer
      type or with the POINTER attribute that have implicitly determined
      data-mapping or data-sharing attributes will have a data-mapping or
      data-sharing attribute specified by \plc{implicit-behavior}.  The
      zero-length array section and attachment that are otherwise applied to
      an implicitly mapped pointer are only provided for the \code{default} behavior.
\end{itemize}

If no \plc{variable-category} is specified in the clause then
\plc{implicit-behavior} specifies the implicitly determined data-mapping or
data-sharing attribute for all variables referenced in the construct.  If
\plc{implicit-behavior} is \code{none}, each variable referenced in the
construct that does not have a predetermined data-sharing attribute and does
not appear in a \code{to} or \code{link} clause on a \code{declare}~\code{target}
directive must be listed in a data-mapping attribute clause, a data-sharing
attribute clause (including a data-sharing attribute clause on a combined
construct where \code{target} is one of the constituent constructs), or
an \code{is_device_ptr} clause. If \plc{implicit-behavior} is \code{default},
then the clause has no effect for the variables in the category specified by
\plc{variable-category}.



\subsubsection{\hcode{declare}~\hcode{mapper} Directive}
\index{declare mapper@{\code{declare}~\code{mapper}}}
\index{directives!declare mapper@{\code{declare}~\code{mapper}}}
\index{constructs!declare mapper@{\code{declare}~\code{mapper}}}
\index{device constructs!declare mapper@{\code{declare}~\code{mapper}}}
\label{subsubsec:declare mapper Directive}

\summary

The \code{declare mapper} directive declares a user-defined mapper for a given
type, and may define a \plc{mapper-identifier} that can be used in a \code{map}
clause. The \code{declare mapper} directive is a declarative directive.

\syntax
\begin{ccppspecific}
The syntax of the \code{declare mapper} directive is as follows:

\begin{ompcPragma}
#pragma omp declare mapper(\plc{[mapper-identifier}:\plc{]type var}) \
            \plc{[clause[ [},\plc{] clause] ... ] new-line}
\end{ompcPragma}

\end{ccppspecific}

\begin{fortranspecific}
The syntax of the \code{declare mapper} directive is as follows:

\begin{ompfPragma}
!$omp declare mapper(\plc{[mapper-identifier}:\plc{] type :: var}) &
      \plc{[clause[ [},\plc{] clause] ... ]}
\end{ompfPragma}
%$
\end{fortranspecific}

where:

\begin{itemize}
\item \plc{mapper-identifier} is a base-language identifier or \pcode{default}
\item \plc{type} is a valid type in scope
\item \plc{var} is a valid base-language identifier
\item \plc{clause} is \pcode{map(}\plc{[[map-type-modifier[}\pcode{,}\plc{] [map-type-modifier[}\pcode{,}\plc{] ...]] map-type}\pcode{:}\plc{ ] list}\pcode{)}
, where \plc{map-type} is one of the following:

\begin{itemize}
\item \code{alloc}
\item \code{to}
\item \code{from}
\item \code{tofrom}
\end{itemize}

and where \plc{map-type-modifier} is one of the following:

\begin{itemize}
\item \code{always}
\item \code{close}
\end{itemize}
\end{itemize}

\descr
User-defined mappers can be defined using the \code{declare mapper} directive.
The type and the \plc{mapper-identifier} uniquely identify the mapper for use in
a \code{map} clause later in the program.  If the \plc{mapper-identifier} is not
specified, then \code{default} is used.  The visibility and accessibility of
this declaration are the same as those of a variable declared at the same point
in the program.

The variable declared by \plc{var} is available for use in all \code{map}
clauses on the directive, and no part of the variable to be mapped is mapped by
default.

The default mapper for all types \plc{T}, designated by the pre-defined
\plc{mapper-identifier} \code{default}, is as follows unless a user-defined 
mapper is specified for that type.

\begin{ompSyntax}
declare mapper(\plc{T} v) map(tofrom: v)
\end{ompSyntax}

Using the \code{default} \plc{mapper-identifier} overrides the pre-defined
default mapper for the given type, making it the default for all
variables of \plc{type}. All \code{map} clauses with this construct in scope
that map a list item of \plc{type} will use this mapper unless another is
explicitly specified.

All \code{map} clauses on the directive are expanded into corresponding
\code{map} clauses wherever this mapper is invoked, either by matching type or
by being explicitly named in a \code{map} clause. A \code{map} clause with list item
\plc{var} maps \plc{var} as though no mapper were specified.

\begin{cppspecific}
The \code{declare mapper} directive can also appear at points in the program at
which a static data member could be declared. In this case, the visibility and
accessibility of the declaration are the same as those of a static data member
declared at the same point in the program.
\end{cppspecific}

\restrictions
The restrictions to the \code{declare}~\code{mapper} directive are as follows:

\begin{itemize}
\item No instance of \plc{type} can be mapped as part of the mapper, either
      directly or indirectly through another type, except the instance passed as the
      list item. If a set of \code{declare}~\code{mapper} directives results in a
      cyclic definition then the behavior is unspecified.
\item The \plc{type} must be of struct, union or class type in C and C++ or a
      non-intrinsic type in Fortran.
\item The \plc{type} must not declare a new type.
\item At least one \code{map} clause that maps \plc{var} or at least one element
      of \plc{var} is required.
\item List-items in \code{map} clauses on this construct may only refer to the
      declared variable \plc{var} and entities that could be referenced by a
      procedure defined at the same location.
\item Each \plc{map-type-modifier} can appear at most once on the
      \code{map} clause.
\item A \plc{mapper-identifier} may not be redeclared in the current scope for the 
      same type or for a type that is compatible according to the base language rules.

\begin{fortranspecific}
\item \plc{type} must not be an abstract type.
\end{fortranspecific}
\end{itemize}
