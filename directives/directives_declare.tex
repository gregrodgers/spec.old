% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. There are environments that provide special formatting, e.g. language bars.
%       Please use them whereever appropriate.  Examples are:
%
%         \begin{fortranspecific}
%         This is text that appears enclosed in blue language bars for Fortran.
%         \end{fortranspecific}
%
%         \begin{note}
%         This is a note.  The "Note -- " header appears automatically.
%         \end{note}
%
%    6. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%

\section{Declare Directives}
\index{declare@{\code{declare}}}
\index{directives!declare}
\index{sec:Declare Directives}

\subsection{\hcode{declare}~\hcode{simd} Directive}
\index{declare simd@{\code{declare}~\code{simd}}}
\index{directives!declare simd@{\code{declare}~\code{simd}}}
\label{subsec:declare simd Directive}
\summary
The \code{declare}~\code{simd} directive can be applied to a function (C, C++ and Fortran) or a
subroutine (Fortran) to enable the creation of one or more versions that can process
multiple arguments using SIMD instructions from a single invocation in a SIMD
loop. The \code{declare}~\code{simd} directive is a declarative directive. There may be multiple
\code{declare}~\code{simd} directives for a function (C, C++, Fortran) or subroutine (Fortran).

\syntax
The syntax of the \code{declare}~\code{simd} directive is as follows:

\begin{ccppspecific}
\begin{ompcPragma}
#pragma omp declare simd \plc{[clause[ [},\plc{] clause] ... ] new-line}
\plc{[}#pragma omp declare simd \plc{[clause[ [},\plc{] clause] ... ] new-line]}
\plc{[ ... ]}
   \plc{function definition or declaration}
\end{ompcPragma}

where \plc{clause} is one of the following:

\begin{indentedcodelist}
simdlen(\plc{length})
linear(\plc{linear-list[ }:\plc{ linear-step]})
aligned(\plc{argument-list[ }:\plc{ alignment]})
uniform(\plc{argument-list})
inbranch
notinbranch
\end{indentedcodelist}
\end{ccppspecific}


\begin{fortranspecific}
\begin{ompfPragma}
!$omp declare simd \plc{[}(\plc{proc-name})\plc{] [clause[ [},\plc{] clause] ... ]}
\end{ompfPragma}

where \plc{clause} is one of the following:
\begin{indentedcodelist}
simdlen(\plc{length})
linear(\plc{linear-list[ }:\plc{ linear-step]})
aligned(\plc{argument-list[ }:\plc{ alignment]})
uniform(\plc{argument-list})
inbranch
notinbranch
\end{indentedcodelist}
\end{fortranspecific}


\descr
\begin{ccppspecific}
The use of one or more \code{declare}~\code{simd} directives immediately prior
to a function declaration or definition enables the
creation of corresponding SIMD
versions of the associated function that can be used to process multiple arguments from
a single invocation in a SIMD loop concurrently.

The expressions appearing in the clauses of each directive are evaluated in the scope of
the arguments of the function declaration or definition.
\end{ccppspecific}

\begin{samepage}
\begin{fortranspecific}
The use of one or more \code{declare}~\code{simd} directives for a specified
subroutine or function enables the creation of corresponding SIMD versions of the
subroutine or function that can be used to process multiple arguments from a
single invocation in a SIMD loop concurrently.
\end{fortranspecific}
\end{samepage}

If a SIMD version is created, the number of concurrent arguments for the function is
determined by the \code{simdlen} clause. If the \code{simdlen} clause is used its value
corresponds to the number of concurrent arguments of the function. The parameter of
the \code{simdlen} clause must be a constant positive integer expression. Otherwise, the
number of concurrent arguments for the function is implementation defined.

\begin{cppspecific}
The special \plc{this} pointer can be used as if was one of the arguments to the function in any of the \code{linear}, \code{aligned}, or \code{uniform} clauses.
\end{cppspecific}

The \code{uniform} clause declares one or more arguments to have an invariant value for all
concurrent invocations of the function in the execution of a single SIMD loop.

\begin{samepage}
\begin{ccppspecific}
The \code{aligned} clause declares that the object to which each list item points is aligned to
the number of bytes expressed in the optional parameter of the \code{aligned} clause.
\end{ccppspecific}
\end{samepage}

\needspace{15\baselineskip}\begin{samepage}
\begin{fortranspecific}
The \code{aligned} clause declares that the target of each list item is aligned to the number
of bytes expressed in the optional parameter of the \code{aligned} clause.
\end{fortranspecific}
\end{samepage}

The optional parameter of the \code{aligned} clause, \plc{alignment}, must be a constant positive
integer expression. If no optional parameter is specified, implementation-defined default
alignments for SIMD instructions on the target platforms are assumed.

The \code{inbranch} clause specifies that the SIMD version of the function will always be called from inside a
conditional statement of a SIMD loop. The \code{notinbranch} clause specifies that the
SIMD version of the function will never be called from inside a conditional statement of a SIMD loop. If
neither clause is specified, then the SIMD version of the function may or may not be called from inside a
conditional statement of a SIMD loop.

\restrictions
\begin{itemize}
\item Each argument can appear in at most one \code{uniform} or \code{linear} clause.

\item At most one \code{simdlen} clause can appear in a \code{declare}~\code{simd} directive.

\item Either \code{inbranch} or \code{notinbranch} may be specified, but not both.

\item When a \plc{linear-step} expression is specified in a \code{linear} clause it must be
either a constant integer expression or an integer-typed parameter that is specified in
a \code{uniform} clause on the directive.

\item The function or subroutine body must be a structured block.

\item The execution of the function or subroutine, when called from a SIMD loop, cannot result in the execution of an OpenMP construct except for an \code{ordered} construct with the \code{simd} clause or an \code{atomic} construct.

\item The execution of the function or subroutine cannot have any side effects that would
alter its execution for concurrent iterations of a SIMD chunk.

\item A program that branches into or out of the function is non-conforming.

\begin{ccppspecific}
\item If the function has any declarations, then the \code{declare}~\code{simd} construct for any
declaration that has one must be equivalent to the one specified for the definition.
Otherwise, the result is unspecified.

\item The function cannot contain calls to the \code{longjmp} or \code{setjmp} functions.
\end{ccppspecific}

\begin{cspecific}
\item The type of list items appearing in the \code{aligned} clause must be array or pointer.
\end{cspecific}

\begin{cppspecific}
\item The function cannot contain any calls to \code{throw}.

\item The type of list items appearing in the \code{aligned} clause must be array, pointer,
reference to array, or reference to pointer.
\end{cppspecific}

\begin{fortranspecific}
\item \plc{proc-name} must not be a generic name, procedure pointer or entry name.

\item If \plc{proc-name} is omitted, the \code{declare}~\code{simd}
  directive must appear in the specification part of a subroutine
  subprogram or a function subprogram for which creation of the SIMD
  versions is enabled.

\item Any \code{declare}~\code{simd} directive must appear in the specification part of a subroutine
subprogram, function subprogram or interface body to which it applies.

\item If a \code{declare}~\code{simd} directive is specified in an interface block for a procedure, it
must match a \code{declare}~\code{simd} directive in the definition of the procedure.

\item If a procedure is declared via a procedure declaration statement, the procedure
\plc{proc-name} should appear in the same specification.

\item If a \code{declare}~\code{simd} directive is specified for a procedure name with explicit
interface and a \code{declare}~\code{simd} directive is also specified for the definition of the
procedure then the two \code{declare}~\code{simd} directives must match. Otherwise the result
is unspecified.

\item Procedure pointers may not be used to access versions created by the \code{declare}~\code{simd} directive.

\item The type of list items appearing in the \code{aligned} clause must be \code{C_PTR} or Cray
pointer, or the list item must have the \code{POINTER} or \code{ALLOCATABLE} attribute.
\end{fortranspecific}
\end{itemize}

\crossreferences
\begin{itemize}
\item \code{reduction} clause, see
\specref{subsubsec:reduction clause}.

\item \code{linear} clause, see
\specref{subsubsec:linear clause}.
\end{itemize}



\subsection{\hcode{declare}~\hcode{reduction} Directive}
\index{declare reduction@{\code{declare}~\code{reduction}}}
\index{directives!declare reduction@{\code{declare}~\code{reduction}}}
\label{subsec:declare reduction Directive}
\summary
The following section describes the directive for declaring user-defined reductions. The
\code{declare}~\code{reduction} directive declares a \plc{reduction-identifier} that can be used in a
\code{reduction} clause. The \code{declare}~\code{reduction} directive is a declarative directive.

\syntax
\begin{cspecific}
\begin{ompcPragma}
#pragma omp declare reduction(\plc{reduction-identifier }:\plc{ typename-list }:
\plc{combiner })\plc{[initializer-clause] new-line}
\end{ompcPragma}

where:

\begin{itemize}

\item \plc{reduction-identifier} is either a base language identifier or one of the following
operators:
\code{+},
\code{-},
\code{*},
\code{&},
\code{|},
\code{^},
\code{&&} and
\code{||}

\item \plc{typename-list} is a list of type names

\item \plc{combiner} is an expression

\item \plc{initializer-clause} is \code{initializer(}\plc{initializer-expr}\code{)}
where \plc{initializer-expr} is\linebreak
\code{omp_priv = }\plc{initializer} or \plc{function-name}\code{(}\plc{argument-list}\code{)}
\end{itemize}
\end{cspecific}


\begin{cppspecific}
\begin{ompcPragma}
#pragma omp declare reduction(\plc{reduction-identifier }:\plc{ typename-list }:
\plc{combiner})\plc{ [initializer-clause] new-line}
\end{ompcPragma}

where:

\begin{itemize}
\item \plc{reduction-identifier} is either an \plc{id-expression} or one of the following
operators:
\code{+},
\code{-},
\code{*},
\code{&},
\code{|},
\code{^},
\code{&&} and
\code{||}

\item \plc{typename-list} is a list of type names

\item \plc{combiner} is an expression

% An equal sign is intentionally missing for C++, so that
% initializer (omp_priv (4)) syntax is also valid in addition to
% initializer (omp_priv = 4).
\item \plc{initializer-clause} is \code{initializer(}\plc{initializer-expr}\code{)}
where \plc{initializer-expr} is\linebreak
\code{omp_priv} \plc{initializer} or \plc{function-name}\code{(}\plc{argument-list}\code{)}
\end{itemize}
\end{cppspecific}


\begin{fortranspecific}
\begin{ompfPragma}
!$omp declare reduction(\plc{reduction-identifier }:\plc{ type-list }:\plc{ combiner})
\plc{[initializer-clause]}
\end{ompfPragma}

where:

\begin{itemize}
\item \plc{reduction-identifier} is either a base language identifier, or a user-defined operator, or
one of the following operators:
\code{+},
\code{-},
\code{*},
\code{.and.},
\code{.or.},
\code{.eqv.},
\code{.neqv.}, or one of the following intrinsic procedure names:
\code{max},
\code{min},
\code{iand},
\code{ior},
\code{ieor}.

\item \plc{type-list} is a list of type specifiers that must not be \code{CLASS(*)}

\item \plc{combiner} is either an assignment statement or a subroutine name followed by an
argument list

\item \plc{initializer-clause} is \code{initializer(}\plc{initializer-expr}\code{)},
where \plc{initializer-expr} is\linebreak
\code{omp_priv = }\plc{expression} or \plc{subroutine-name}\code{(}\plc{argument-list}\code{)}
\end{itemize}
\end{fortranspecific}

\descr
Custom reductions can be defined using the \code{declare}~\code{reduction} directive; the
\plc{reduction-identifier} and the type identify the \code{declare}~\code{reduction} directive. The
\plc{reduction-identifier} can later be used in a \code{reduction} clause using variables of the
type or types specified in the \code{declare}~\code{reduction} directive. If the directive applies
to several types then it is considered as if there were multiple \code{declare}~\code{reduction}
directives, one for each type.

\begin{fortranspecific}
If a type with deferred or assumed length type parameter is specified in a \code{declare}~\code{reduction} directive, the \plc{reduction-identifier} of that directive can be used in a \code{reduction} clause with any variable of the same type and the same kind parameter, regardless of the length type Fortran parameters with which the variable is declared.
\end{fortranspecific}

The visibility and accessibility of this declaration are the same as those of a variable
declared at the same point in the program. The enclosing context of the \plc{combiner} and of
the \plc{initializer-expr} will be that of the \code{declare}~\code{reduction} directive. The \plc{combiner}
and the \plc{initializer-expr} must be correct in the base language as if they were the body of
a function defined at the same point in the program.

\begin{fortranspecific}
If the \plc{reduction-identifier} is the same as the name of a user-defined operator or an extended operator, or the same as a generic name that is one of the allowed intrinsic procedures, and if the operator or procedure name appears in an accessibility statement in the same module, the accessibility of the corresponding \code{declare}~\code{reduction} directive is determined by the accessibility attribute of the statement.

If the \plc{reduction-identifier} is the same as a generic name that is one of the allowed intrinsic procedures and is accessible, and if it has the same name as a derived type in the same module, the accessibility of the corresponding \code{declare}~\code{reduction} directive is determined by the accessibility of the generic name according to the base language.
\end{fortranspecific}

\begin{cppspecific}
The \code{declare}~\code{reduction} directive can also appear at points in the program at which
a static data member could be declared. In this case, the visibility and accessibility of
the declaration are the same as those of a static data member declared at the same point
in the program.
\end{cppspecific}

The \plc{combiner} specifies how partial results can be combined into a single value. The
\plc{combiner} can use the special variable identifiers \code{omp_in} and \code{omp_out} that are of the
type of the variables being reduced with this \plc{reduction-identifier}. Each of them will
denote one of the values to be combined before executing the \plc{combiner}. It is assumed
that the special \code{omp_out} identifier will refer to the storage that holds the resulting
combined value after executing the \plc{combiner}.

The number of times the \plc{combiner} is executed, and the order of these executions, for
any \code{reduction} clause is unspecified.

\begin{fortranspecific}
If the \plc{combiner} is a subroutine name with an argument list, the \plc{combiner} is evaluated by
calling the subroutine with the specified argument list.

If the \plc{combiner} is an assignment statement, the \plc{combiner} is evaluated by executing the
assignment statement.
\end{fortranspecific}

As the \plc{initializer-expr} value of a user-defined reduction is not known \emph{a priori} the
\plc{initializer-clause} can be used to specify one. Then the contents of the \plc{initializer-clause}
will be used as the initializer for private copies of reduction list items where the
\code{omp_priv} identifier will refer to the storage to be initialized. The special identifier
\code{omp_orig} can also appear in the \plc{initializer-clause} and it will refer to the storage of the
original variable to be reduced.

The number of times that the \plc{initializer-expr} is evaluated, and the order of these
evaluations, is unspecified.

\begin{ccppspecific}
If the \plc{initializer-expr} is a function name with an argument list, the \plc{initializer-expr} is
evaluated by calling the function with the specified argument list. Otherwise, the
\plc{initializer-expr} specifies how \code{omp_priv} is declared and initialized.
\end{ccppspecific}
%\bigskip

\begin{cspecific}
If no \plc{initializer-clause} is specified, the private variables will be initialized following the
rules for initialization of objects with static storage duration.
\end{cspecific}

\begin{cppspecific}
If no \plc{initializer-expr} is specified, the private variables will be initialized following the
rules for \plc{default-initialization}.
\end{cppspecific}
%\bigskip

\begin{fortranspecific}
If the \plc{initializer-expr} is a subroutine name with an argument list, the \plc{initializer-expr} is
evaluated by calling the subroutine with the specified argument list.

If the \plc{initializer-expr} is an assignment statement, the \plc{initializer-expr} is evaluated by
executing the assignment statement.

If no \plc{initializer-clause} is specified, the private variables will be initialized as follows:
\begin{itemize}
\item For \code{complex}, \code{real}, or \code{integer} types, the value 0 will be used.
\item For \code{logical} types, the value \code{.false.} will be used.
\item For derived types for which default initialization is specified, default initialization
will be used.
\item Otherwise, not specifying an \plc{initializer-clause} results in unspecified behavior.
\end{itemize}
\end{fortranspecific}
%\bigskip

\begin{ccppspecific}
If \plc{reduction-identifier} is used in a \code{target} region then a \code{declare}~\code{target} construct
must be specified for any function that can be accessed through the \plc{combiner} and
\plc{initializer-expr}.
\end{ccppspecific}
%\bigskip

\begin{fortranspecific}
If \plc{reduction-identifier} is used in a \code{target} region then a \code{declare}~\code{target} construct
must be specified for any function or subroutine that can be accessed through the \plc{combiner}
and \plc{initializer-expr}.
\end{fortranspecific}

\restrictions
\begin{itemize}

\item The only variables allowed in the \plc{combiner} are
  \code{omp_in} and \code{omp_out}.

\item The only variables allowed in the \plc{initializer-clause} are
  \code{omp_priv} and \code{omp_orig}.

\item If the variable \code{omp_orig} is modified in the \plc{initializer-clause}, the behavior is
unspecified.

\item If execution of the \plc{combiner} or the \plc{initializer-expr} results in the execution of an
OpenMP construct or an OpenMP API call, then the behavior is unspecified.

\item A \plc{reduction-identifier} may not be re-declared in the current scope for the same type
or for a type that is compatible according to the base language rules.

\item At most one \plc{initializer-clause} can be specified.

\begin{ccppspecific}
\item A type name in a \code{declare}~\code{reduction} directive cannot be a function type, an
array type, a reference type, or a type qualified with \code{const}, \code{volatile} or
\code{restrict}.
\end{ccppspecific}
\bigskip

\begin{cspecific}
\item If the \plc{initializer-expr} is a function name with an argument list, then one of the
arguments must be the address of \code{omp_priv}.
\end{cspecific}
% \bigskip

\begin{cppspecific}
\item If the \plc{initializer-expr} is a function name with an argument list, then one of the
arguments must be \code{omp_priv} or the address of \code{omp_priv}.
\end{cppspecific}
% \bigskip

\begin{fortranspecific}
\item If the \plc{initializer-expr} is a subroutine name with an argument list, then one of the
arguments must be \code{omp_priv}.

\item If the \code{declare}~\code{reduction} directive appears in the specification part of a module and the corresponding reduction clause does not appear in the same module, the \plc{reduction-identifier} must be the same as the name of a user-defined operator, one of the allowed operators that is extended or a generic name that is the same as the name of one of the allowed intrinsic procedures.

\item If the \code{declare}~\code{reduction} directive appears in the specification of a module, if the corresponding \code{reduction} clause does not appear in the same module, and if the \plc{reduction-identifier} is the same as the name of a user-defined operator or an extended operator, or the same as a generic name that is the same as one of the allowed intrinsic procedures then the interface for that operator or the generic name must be defined in the specification of the same module, or must be accessible by use association.

\item Any subroutine or function used in the \code{initializer} clause or \plc{combiner} expression must be an intrinsic function, or must have an accessible interface.

\item Any user-defined operator or extended operator used in the \code{initializer} clause or \plc{combiner} expression must have an accessible interface.

\item If any subroutine, function, user-defined operator, or extended operator is used in the \code{initializer} clause or \plc{combiner} expression, it must be accessible to the subprogram in which the corresponding \code{reduction} clause is specified.

\item If the length type parameter is specified for a character type, it must be a constant, a colon or an~\code{*}.

\item If a character type with deferred or assumed length parameter is specified in a \code{declare}~\code{reduction} directive, no other \code{declare}~\code{reduction} directive with Fortran character type of the same kind parameter and the same \plc{reduction-identifier} is allowed in the same scope.

\item Any subroutine used in the \code{initializer} clause or \plc{combiner} expression must not have any alternate returns appear in the argument list.
\end{fortranspecific}
\end{itemize}

\crossreferences
\begin{itemize}
\item \code{reduction} clause,
\specref{subsubsec:reduction clause}.
\end{itemize}










