% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. There are environments that provide special formatting, e.g. language bars.
%       Please use them whereever appropriate.  Examples are:
%
%         \begin{fortranspecific}
%         This is text that appears enclosed in blue language bars for Fortran.
%         \end{fortranspecific}
%
%         \begin{note}
%         This is a note.  The "Note -- " header appears automatically.
%         \end{note}
%
%    6. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%

\section{Loop Constructs}
\label{sec:LoopConstructs}

\subsection{Canonical Loop Form}
\label{subsec:Canonical Loop Form}
\index{canonical loop form}
\begin{cppspecific}
A range-based for loop with random access iterator has a \emph{canonical loop form}.
\end{cppspecific}
\begin{ccppspecific}
A loop has \emph{canonical loop form} if it conforms to the following:

\medskip
\nolinenumbers
\renewcommand{\arraystretch}{1.0}
\tablefirsthead{%
    \hline\\[-2ex]
    \multicolumn{2}{l}{\hspace*{-5pt}%
        {\scode{for (}\splc{init-expr}\scode{; }\splc{test-expr}\scode{; }\splc{incr-expr}\scode{) }\splc{structured-block}}}\\[2pt]
    \hline\\[-2ex]
}
\tablehead{%
    \multicolumn{2}{l}{\small\slshape continued from previous page}\\
    \hline\\[-2ex]
}
\tabletail{%
    \hline\\[-2ex]
    \multicolumn{2}{l}{\small\slshape continued on next page}\\
}
\tablelasttail{\hline}
\begin{supertabular}{ p{0.8in} p{4.5in}}
    {\splc{init-expr}} & One of the following:\\
    & {\splc{var}} = {\splc{lb}}\\
    & {\splc{integer-type}} {\splc{var}} = {\splc{lb}}\\
    & {\splc{random-access-iterator-type}} {\splc{var}} = {\splc{lb}}\\
    & {\splc{pointer-type}} {\splc{var}} = {\splc{lb}}\\
    & \\
    {\splc{test-expr}} & One of the following:\\
    & {\splc{var}} {\splc{relational-op}} {\splc{b}}\\
    & {\splc{b}} {\splc{relational-op}} {\splc{var}}\\
    & \\
    {\splc{incr-expr}} & One of the following:\\
    & ++{\splc{var}}\\
    & {\splc{var}}++\\
    & {-} {-} {\splc{var}}\\
    & {\splc{var}} {-} {-}\\
    & {\splc{var}} += {\splc{incr}}\\
    & {\splc{var}} {-} = {\splc{incr}}\\
    & {\splc{var}} = {\splc{var}} + {\splc{incr}}\\
    & {\splc{var}} = {\splc{incr}} + {\splc{var}}\\
    & {\splc{var}} = {\splc{var}} - {\splc{incr}}\\
    & \\
    {\splc{var}} & One of the following:\\
    & \hspace{1.5em}A variable of a signed or unsigned integer type.\\
    & \hspace{1.5em}For C++, a variable of a random access iterator type.\\
    & \hspace{1.5em}For C, a variable of a pointer type.\\
    & If this variable would otherwise be shared, it is implicitly made private in the loop
    construct. This variable must not be modified during the execution of the {\splc{for-loop}}
    other than in {\splc{incr-expr}}. Unless the variable is specified {\scode{lastprivate}}
    or {\scode{linear}} on the loop construct, its value after the loop is unspecified.\\
    {\splc{relational-op}} & One of the following:\\
    & {\scode{<}}\\
    & {\scode{<=}}\\
    & {\scode{>}}\\
    & {\scode{>=}}\\
    & {\scode{!=}}\\
    & \\
    {\splc{lb}} and {\splc{b}} & Loop invariant expressions of a type compatible with the type of {\splc{var}}.\\
    & \\
    {\splc{incr}} & A loop invariant integer expression.\\
\end{supertabular}
\medskip

\linenumbers

The canonical form allows the iteration count of all associated loops to be computed
before executing the outermost loop. The computation is performed for each loop in an
integer type. This type is derived from the type of \plc{var} as follows:

\begin{itemize}
    \item If \plc{var} is of an integer type, then the type is the type of \plc{var}.

    \item For C++, if \plc{var} is of a random access iterator type, then the type is the type that
    would be used by \plc{std::distance} applied to variables of the type of \plc{var}.

    \item For C, if \plc{var} is of a pointer type, then the type is \code{ptrdiff_t}.
\end{itemize}

The behavior is unspecified if any intermediate result required to compute the iteration
count cannot be represented in the type determined above.

There is no implied synchronization during the evaluation of the \plc{lb}, \plc{b}, or \plc{incr}
expressions. It is unspecified whether, in what order, or how many times any side effects
within the \plc{lb}, \plc{b}, or \plc{incr} expressions occur.

\begin{note}
Random access iterators are required to support random access to elements in
constant time. Other iterators are precluded by the restrictions since they can take linear
time or offer limited functionality. It is therefore advisable to use tasks to parallelize
those cases.

% The word "Restrictions" seems out of place; was it meant to be a header outside of the Note?

%Restrictions
\end{note}

\restrictions
The following restrictions also apply:

\begin{itemize}
    \item If \plc{test-expr} is of the form \plc{var} \plc{relational-op}
    \plc{b} and \plc{relational-op} is < or <= then \plc{incr-expr} must cause \plc{var} to increase on each
    iteration of the loop. If \plc{test-expr} is of
    the form \plc{var} \plc{relational-op} \plc{b} and \plc{relational-op}
    is > or >= then \plc{incr-expr} must cause \plc{var} to decrease on each iteration of the loop.

    \item If \plc{test-expr} is of the form \plc{b} \plc{relational-op}
    \plc{var} and \plc{relational-op} is < or <= then
    \plc{incr-expr} must cause \plc{var} to decrease on each iteration of the loop. If \plc{test-expr} is of
    the form \plc{b} \plc{relational-op} \plc{var} and \plc{relational-op}
    is > or >= then \plc{incr-expr} must cause \plc{var} to increase on each iteration of the loop.

    \item If \plc{test-expr} is of the form \plc{b} != \plc{var} or
    \plc{var} != \plc{b} then \plc{incr-expr} must cause \plc{var}
    either to increase on each iteration of the loop or to decrease on
    each iteration of the loop.

    \item For C++, in the \code{simd} construct the only random access iterator types that are
    allowed for \plc{var} are pointer types.

    \item The \plc{b}, \plc{lb} and \plc{incr} expressions may not reference
    \plc{var} of any of the associated loops.

    \item If \plc{relational-op} is != and \plc{incr-expr} is of the
    form that has \plc{incr} then \plc{incr} must be a constant expression and
    evaluate to -1 or 1.
\end{itemize}
\end{ccppspecific}


\subsection{Worksharing Loop Construct}
\label{subsec:Worksharing Loop Construct}
\index{loop@{\code{loop}}}
\index{constructs!loop@{\emph{loop}}}
\index{constructs!do@{\code{do} \emph{Fortran}}}
\index{do@{\code{do}, \emph{Fortran}}}
\index{for@{\code{for}, \emph{C/C++}}}
\index{constructs!for@{\code{for}, \emph{C/C++}}}
\summary
The loop construct specifies that the iterations of one or more associated loops will be
executed in parallel by threads in the team in the context of their implicit tasks. The
iterations are distributed across threads that already exist in the team executing the
\code{parallel} region to which the loop region binds.

\syntax
\begin{ccppspecific}
The syntax of the loop construct is as follows:

\begin{ompcPragma}
#pragma omp for \plc{[clause[ [},\plc{] clause] ... ] new-line}
    \plc{for-loops}
\end{ompcPragma}

where clause is one of the following:
\index{clauses!collapse@{\code{collapse}}}

\begin{indentedcodelist}
private(\plc{list})
firstprivate(\plc{list})
lastprivate(\plc{[ lastprivate-modifier}:\plc{] list})
linear(\plc{list[ }:\plc{ linear-step]})
reduction(\plc{reduction-identifier }:\plc{ list})
schedule(\plc{[modifier [}, \plc{modifier]}:\plc{]kind[},\plc{ chunk_size]})
collapse(\plc{n})
ordered\plc{[}(\plc{n})\plc{]}
nowait
allocate(\plc{[allocator: ]}\plc{list})
\end{indentedcodelist}

The \code{for} directive places restrictions on the structure of all associated \plc{for-loops}.
Specifically, all associated \plc{for-loops} must have \emph{canonical loop form} (see
\specref{subsec:Canonical Loop Form}).
\end{ccppspecific}

\begin{fortranspecific}
The syntax of the loop construct is as follows:

\begin{ompfPragma}
!$omp do \plc{[clause[ [},\plc{] clause] ... ]}
   \plc{do-loops}
\textsl{[}!$omp end do \textsl{[}nowait\textsl{]]}
\end{ompfPragma}

where \plc{clause} is one of the following:

\begin{indentedcodelist}
private(\plc{list})
firstprivate(\plc{list})
lastprivate(\plc{[ lastprivate-modifier}:\plc{] list})
linear(\plc{list[ }:\plc{ linear-step]})
reduction(\plc{reduction-identifier }:\plc{ list})
schedule(\plc{[modifier [}, \plc{modifier]}:\plc{]kind[},\plc{ chunk_size]})
collapse(\plc{n})
ordered\plc{[}(\plc{n})\plc{]}
allocate(\plc{[allocator: ]}\plc{list})
\end{indentedcodelist}

If an \code{end}~\code{do} directive is not specified, an \code{end}~\code{do} directive is assumed at the end of the
\plc{do-loops}.

Any associated \plc{do-loop} must be a \plc{do-construct} or an
\plc{inner-shared-do-construct} as defined by the Fortran standard. If
an \code{end}~\code{do} directive follows a \plc{do-construct} in
which several loop statements share a \code{DO} termination statement,
then the directive can only be specified for the outermost of these
\code{DO} statements.

If any of the loop iteration variables would otherwise be shared, they are implicitly
made private on the loop construct.
\end{fortranspecific}


\binding
The binding thread set for a loop region is the current team. A loop region binds to the
innermost enclosing \code{parallel} region. Only the threads of the team executing the
binding \code{parallel} region participate in the execution of the loop iterations and the
implied barrier of the loop region if the barrier is not eliminated by a \code{nowait} clause.

\descr
The loop construct is associated with a loop nest consisting of one or more loops that
follow the directive.

There is an implicit barrier at the end of a loop construct unless a \code{nowait} clause is
specified.

\index{clauses!collapse@{\code{collapse}}}
The \code{collapse} clause may be used to specify how many loops are
associated with the loop construct. The parameter of the \code{collapse}
clause must be a constant positive integer expression. If a \code{collapse}
clause is specified with a parameter value greater than 1, then the
iterations of the associated loops to which the clause applies are collapsed
into one larger iteration space that is then divided according
to the \code{schedule} clause. The sequential execution of the iterations
in these associated loops determines the order of the iterations in the
collapsed iteration space. If no \code{collapse} clause is present or its
parameter is 1, the only loop that is associated with the loop construct
for the purposes of determining how the iteration space is divided according
to the \code{schedule} clause is the one that immediately follows the
loop directive.

If more than one loop is associated with the loop construct then the
number of times that any intervening code between any two associated
loops will be executed is unspecified but will be at least once per
iteration of the loop enclosing the intervening code and at most once
per iteration of the innermost loop associated with the construct. If the
iteration count of any loop that is associated with the loop construct and does not
enclose the intervening code is zero then the behavior is unspecified.

The iteration count for each associated loop is computed before entry to the
outermost loop. If execution of any associated loop changes any of the values
used to compute any of the iteration counts, then the behavior is unspecified.

The integer type (or kind, for Fortran) used to compute the iteration count
for the collapsed loop is implementation defined.

\index{clauses!schedule@{\code{schedule}}} A worksharing loop has
logical iterations numbered 0,1,...,N-1 where N is the number of loop
iterations, and the logical numbering denotes the sequence in which
the iterations would be executed if a set of associated loop(s) were
executed sequentially.  At the beginning of each logical iteration,
the loop iteration variable of each associated loop has the value that
it would have if the set of the associated loop(s) were executed
sequentially.  The \code{schedule} clause specifies how iterations of
these associated loops are divided into contiguous non-empty subsets,
called chunks, and how these chunks are distributed among threads of
the team. Each thread executes its assigned chunk(s) in the context of
its implicit task.  The iterations of a given chunk are executed in
sequential order by the assigned thread.  The \plc{chunk_size}
expression is evaluated using the original list items of any variables
that are made private in the loop construct. It is unspecified
whether, in what order, or how many times, any side effects of the
evaluation of this expression occur. The use of a variable in a
\code{schedule} clause expression of a loop construct causes an
implicit reference to the variable in all enclosing constructs.

Different loop regions with the same schedule and iteration count, even if
they occur in the same parallel region, can distribute iterations among
threads differently. The only exception is for the \code{static} schedule
as specified in Table~\ref{tab:Schedule-Values}. Programs that depend
on which thread executes a particular iteration under any other circumstances
are non-conforming.

See \specref{subsubsec:Determining the Schedule of a Worksharing Loop}
for details of how the schedule for a worksharing loop is
determined.

The schedule \plc{kind} can be one of those specified in
Table~\ref{tab:Schedule-Values}.

The schedule \plc{modifier} can be one of those specified in
Table~\ref{tab:Schedule Clause Modifier Values}. If the
\code{static} schedule kind is specified or if the \code{ordered}
clause is specified, and if the \code{nonmonotonic} modifier is
not specified, the effect is as if the \code{monotonic} modifier
is specified. Otherwise, unless the \code{monotonic} modifier is
specified, the effect is as if the \code{nonmonotonic} modifier
is specified.

The \code{ordered} clause with the parameter may also be used to specify
how many loops are associated with the loop construct. The parameter of
the \code{ordered} clause must be a constant positive integer expression
if specified. The parameter of the \code{ordered} clause does not
affect how the logical iteration space is then divided. If an \code{ordered}
clause with the parameter is specified for the loop construct, then those
associated loops form a \emph{doacross loop nest}.

If the value of the parameter in the \code{collapse} or \code{ordered}
clause is larger than the number of nested loops following the construct,
the behavior is unspecified.

\nolinenumbers
\vspace{1ex}\renewcommand{\arraystretch}{1.5}
\tablefirsthead{%
\hline\\[-3ex]
}
\tablehead{%
\multicolumn{2}{l}{\small\slshape table continued from previous page}\\
\hline\\[-3ex]
}
\tabletail{%
\hline\\[-4ex]
\multicolumn{2}{l}{\small\slshape table continued on next page}\\
}
\tablelasttail{\hline}
\tablecaption{\code{schedule} Clause \plc{kind} Values\label{tab:Schedule-Values}}
\begin{supertabular}{ p{0.8in} p{4.3in} }
{\scode{static}} & When {\scode{schedule(static,}\splc{ chunk_size}\scode{)}} is specified, iterations are divided
into chunks of size {\splc{chunk_size}}, and the chunks are assigned to the threads in
the team in a round-robin fashion in the order of the thread number.
Each chunk contains {\splc{chunk_size}} iterations, except for the 
chunk that contains the sequentially last iteration, which 
may have fewer iterations.\\

 & When no {\splc{chunk_size}} is specified, the iteration space is divided into chunks that
are approximately equal in size, and at most one chunk is distributed to each
thread. The size of the chunks is unspecified in this case.\\

 & A compliant implementation of the {\scode{static}} schedule must ensure that the
same assignment of logical iteration numbers to threads will be used in two
loop regions if the following conditions are satisfied: 1) both loop regions have
the same number of loop iterations, 2) both loop regions have the same value
of {\splc{chunk_size}} specified, or both loop regions have no {\splc{chunk_size}} specified, 3)
both loop regions bind to the same parallel region, and 4) neither loop is
associated with a SIMD construct. A data dependence between the same
logical iterations in two such loops is guaranteed to be satisfied allowing safe
use of the {\scode{nowait}} clause.\\

\index{dynamic@{{\scode{dynamic}}}}
{\scode{dynamic}} & When {\scode{schedule(dynamic,}\splc{ chunk_size}\scode{)}} is specified, the iterations are
distributed to threads in the team in chunks. Each
thread executes a chunk of iterations, then requests another chunk, until no
chunks remain to be distributed. \\

 & Each chunk contains {\splc{chunk_size}} iterations, except for the
chunk that contains the sequentially last iteration, which may have fewer iterations.\\

 & When no {\splc{chunk_size}} is specified, it defaults to 1.\\

\index{guided@{{\scode{guided}}}}
{\scode{guided}} & When {\scode{schedule(guided,}\splc{ chunk_size}\scode{)}} is specified, the iterations are
assigned to threads in the team in chunks. Each thread executes a
chunk of iterations, then requests another chunk, until no chunks remain to be assigned.\\

 & For a {\splc{chunk_size}} of 1, the size of each chunk is proportional to the
number of unassigned iterations divided by the number of threads in the team,
decreasing to 1. For a {\splc{chunk_size}} with value $k$ (greater than 1), the
size of each chunk is determined in the same way, with the restriction
that the chunks do not contain fewer than $k$ iterations (except for the
chunk that contains the sequentially last iteration, which may have fewer
than $k$ iterations).
\\

 & When no {\splc{chunk_size}} is specified, it defaults to 1.\\

{\scode{auto}} & When {\scode{schedule(auto)}} is specified, the decision regarding scheduling is
\index{auto@{{\scode{auto}}}}
delegated to the compiler and/or runtime system. The programmer gives the
implementation the freedom to choose any possible mapping of iterations to
threads in the team.\\

{\scode{runtime}} & When {\scode{schedule(runtime)}} is specified, the decision regarding scheduling
is deferred until run time, and the schedule and chunk size are taken from the
{\splc{run-sched-var}} ICV. If the ICV is set to {\scode{auto}}, the schedule is implementation
defined.\\
\end{supertabular}

\linenumbers
\bigskip\bigskip


\begin{note}
For a team of $p$ threads and a loop of $n$ iterations, let $\blceil n/p \brceil$ be the integer $q$
that satisfies $n = p*q - r$, with $0 <= r < p$. One compliant implementation of the \code{static}
schedule (with no specified \plc{chunk_size}) would behave as though \plc{chunk_size} had been
specified with value $q$. Another compliant implementation would assign $q$ iterations to
the first $p-r$ threads, and $q-1$ iterations to the remaining $r$ threads. This illustrates why a
conforming program must not rely on the details of a particular implementation.

A compliant implementation of the \code{guided} schedule with a \plc{chunk_size} value of $k$
would assign $q = \blceil n/p \brceil$ iterations to the first available thread and set $n$ to the larger of
$n-q$ and $p*k$. It would then repeat this process until $q$ is greater than or equal to the
number of remaining iterations, at which time the remaining iterations form the final
chunk. Another compliant implementation could use the same method, except with
$q = \blceil n/(2p) \brceil$, and set $n$ to the larger of $n-q$ and $2*p*k$.
\end{note}

\nolinenumbers
\vspace{1ex}\renewcommand{\arraystretch}{1.5}
\tablefirsthead{%
\hline\\[-3ex]
}
\tablehead{%
\multicolumn{2}{l}{\small\slshape table continued from previous page}\\
\hline\\[-3ex]
}
\tabletail{%
\hline\\[-4ex]
\multicolumn{2}{l}{\small\slshape table continued on next page}\\
}
\tablelasttail{\hline}
\tablecaption{\code{schedule} Clause \plc{modifier} Values\label{tab:Schedule Clause Modifier Values}}
%% \vspace{1ex}
\begin{supertabular}{ p{1in} p{4.1in} }
{\scode{monotonic}} & When the {\scode{monotonic}} modifier is specified then each thread executes the chunks
that it is assigned in increasing logical iteration order.\\
{\scode{nonmonotonic}} & When the {\scode{nonmonotonic}} modifier is specified then chunks are assigned to threads
in any order and the behavior of an application that depends on any execution order of the chunks is unspecified.\\
{\scode{simd}} & When the {\scode{simd}} modifier is specified and the loop is associated with a SIMD construct, the {\splc{chunk_size}} for all chunks except the first and last chunks  is  $new\_chunk\_size = \blceil chunk\_size / simd\_width \brceil * simd\_width $ where {\splc{simd_width}} is an implementation-defined value. The first chunk will have at least {\splc{new_chunk_size}} iterations except if it is also the last chunk. The last chunk may have fewer iterations than {\splc{new_chunk_size}}. If the {\scode{simd}} modifier is specified and the loop is not associated  with a SIMD construct, the modifier is ignored.\\
\end{supertabular}
\linenumbers
\medskip

\omptWorksharing{loop}{ompt_work_loop}

\restrictions
Restrictions to the loop construct are as follows:

\begin{itemize}
\item There must be no OpenMP directive in the region between any
associated loops.

\item If a \code{collapse} clause is specified, exactly one loop must
occur in the region at each nesting level up to the number of loops
specified by the parameter of the \code{collapse} clause.

\item If the \code{ordered} clause is present, all loops associated
with the construct must be perfectly nested; that is there must be
no intervening code between any two loops.

\item The values of the loop control expressions of the loops associated with the loop
construct must be the same for all threads in the team.

\item Only one \code{schedule} clause can appear on a loop directive.

\item Only one \code{collapse} clause can appear on a loop directive.

\item \plc{chunk_size} must be a loop invariant integer expression with a positive value.

\item The value of the \plc{chunk_size} expression must be the same for all threads in the team.

\item The value of the \plc{run-sched-var} ICV must be the same for all threads in the team.

\item When \code{schedule(runtime)} or \code{schedule(auto)} is specified, \plc{chunk_size} must
not be specified.

\item A \plc{modifier} may not be specified on a \code{linear} clause.

\item Only one \code{ordered} clause can appear on a loop directive.

\item The \code{ordered} clause must be present on the loop construct if any \code{ordered} region
ever binds to a loop region arising from the loop construct.

\item The \code{nonmonotonic} modifier cannot be specified if an \code{ordered} clause is specified.

\item Either the \code{monotonic} modifier or the \code{nonmonotonic} modifier can be specified but not both.

\item The loop iteration variable may not appear in a \code{threadprivate} directive.

\item If both the \code{collapse} and \code{ordered} clause with a parameter are specified,
the parameter of the \code{ordered} clause must be greater than or equal to the parameter of the
\code{collapse} clause.

\item A \code{linear} clause or an \code{ordered} clause with a parameter can be specified on a loop directive but not both.
\end{itemize}

\begin{ccppspecific}
\begin{itemize}
\item The associated \plc{for-loops} must be structured blocks.

\item Only an iteration of the innermost associated loop may be curtailed by a \code{continue}
statement.

\item No statement can branch to any associated \code{for} statement.

\item Only one \code{nowait} clause can appear on a \code{for} directive.

\item A throw executed inside a loop region must cause execution to resume within the
same iteration of the loop region, and the same thread that threw the exception must
catch it.
\end{itemize}
\end{ccppspecific}

\begin{fortranspecific}
\begin{itemize}
\item The associated \plc{do-loops} must be structured blocks.

\item Only an iteration of the innermost associated loop may be curtailed by a \code{CYCLE}
statement.

\item No statement in the associated loops other than the \code{DO} statements can cause a branch
out of the loops.

\item The \plc{do-loop} iteration variable must be of type integer.

\item The \plc{do-loop} cannot be a \code{DO WHILE} or a \code{DO} loop without loop control.
\end{itemize}
\end{fortranspecific}

\crossreferences
\begin{itemize}
\item \code{private}, \code{firstprivate}, \code{lastprivate}, \code{linear}, and \code{reduction} clauses, see
\specref{subsec:Data-Sharing Attribute Clauses}.

\item \code{OMP_SCHEDULE} environment variable, see
\specref{sec:OMP_SCHEDULE}.

\item \code{ordered} construct, see
\specref{subsec:ordered Construct}.

\item \code{depend} clause, see
\specref{subsec:depend Clause}.

\item \code{ompt_scope_begin} and \code{ompt_scope_end}, see
  \specref{sec:ompt_scope_endpoint_t}.
\item \code{ompt_work_loop}, see \specref{sec:ompt_work_t}.

\item \code{ompt_callback_work_t}, see
\specref{sec:ompt_callback_work_t}.

\end{itemize}

\subsubsection{Determining the Schedule of a Worksharing Loop}
\label{subsubsec:Determining the Schedule of a Worksharing Loop}
\index{worksharing!scheduling}
When execution encounters a loop directive, the \code{schedule} clause (if any) on the
directive, and the \plc{run-sched-var} and \plc{def-sched-var} ICVs are used to determine how loop
iterations are assigned to threads. See
\specref{sec:Internal Control Variables}
for details of how the
values of the ICVs are determined. If the loop directive does not have a \code{schedule}
clause then the current value of the \mbox{\plc{def-sched-var}} ICV determines the schedule. If the
loop directive has a \code{schedule} clause that specifies the \code{runtime} schedule kind then
the current value of the \plc{run-sched-var} ICV determines the schedule. Otherwise, the
value of the \code{schedule} clause determines the schedule. Figure~\ref{fig:schedule loop}
describes how the schedule for a worksharing loop is determined.

% Figure 2-1: The process for editing a .dia diagram is:
%    1. Use dia to edit the .dia file
%    2. Export to a .tex file
%    3. Edit the .tex file and manually add the \code{} and \plc{} markup.

\begin{figure}[h]
\begin{quote} % to indent the diagram
\input{directives/worksharing-schedule-loop}
\end{quote}
\caption{Determining the \code{schedule} for a Worksharing Loop\label{fig:schedule loop}}
\end{figure}

\crossreferences
\begin{itemize}
\item ICVs, see
\specref{sec:Internal Control Variables}
\end{itemize}



\subsection{\hcode{distribute} Loop Constructs}
\label{sec:distribute Loop Constructs}

\subsubsection{\hcode{distribute} Construct}
\index{distribute@{\code{distribute}}}
\index{constructs!distribute@{\code{distribute}}}
\index{device constructs!distribute@{\code{distribute}}}
\label{subsec:distribute Construct}
\summary
The \code{distribute} construct specifies that the iterations of one or more loops will be
executed by the initial teams in the context of their implicit tasks. The iterations are
distributed across the initial threads of all initial teams that execute the \code{teams} region to
which the \code{distribute} region binds.

\syntax
\begin{ccppspecific}
The syntax of the \code{distribute} construct is as follows:

\begin{ompcPragma}
#pragma omp distribute \plc{[clause[ [},\plc{] clause] ... ] new-line}
   \plc{for-loops}
\end{ompcPragma}

Where \plc{clause} is one of the following:

\begin{indentedcodelist}
private(\plc{list})
firstprivate(\plc{list})
lastprivate(\plc{list})
collapse(\plc{n})
dist_schedule(\plc{kind[},\plc{ chunk_size]})
allocate(\plc{[allocator: ]}\plc{list})
\end{indentedcodelist}

All associated \plc{for-loops} must have the canonical form described in
\specref{subsec:Canonical Loop Form}.
\end{ccppspecific}
\bigskip

\begin{fortranspecific}
The syntax of the \code{distribute} construct is as follows:

\begin{ompfPragma}
!$omp distribute \plc{[clause[ [},\plc{] clause] ... ]}
   \plc{do-loops}
\plc{[}!$omp end distribute\plc{]}
\end{ompfPragma}

Where \plc{clause} is one of the following:

\begin{indentedcodelist}
private(\plc{list})
firstprivate(\plc{list})
lastprivate(\plc{list})
collapse(\plc{n})
dist_schedule(\plc{kind[},\plc{ chunk_size]})
allocate(\plc{[allocator: ]}\plc{list})
\end{indentedcodelist}

If an \code{end}~\code{distribute} directive is not specified, an \code{end}~\code{distribute} directive
is assumed at the end of the \plc{do-loops}.

Any associated \plc{do-loop} must be a \plc{do-construct} or an
\plc{inner-shared-do-construct} as defined by the Fortran standard. If an
\code{end}~\code{distribute} directive follows a \plc{do-construct} in which several loop statements share a \code{DO}
termination statement, then the directive can only be specified for the outermost of these
\code{DO} statements.
\end{fortranspecific}

\begin{samepage}

\binding
The binding thread set for a \code{distribute} region is the set of initial
threads executing an enclosing \code{teams} region. A \code{distribute} region
binds to this \code{teams} region.
%Only the threads executing the binding \code{teams} region participate in the execution of the loop iterations.

\descr
The \code{distribute} construct is associated with a loop nest consisting of one or more
loops that follow the directive.

There is no implicit barrier at the end of a \code{distribute} construct.
To avoid data races the original
list items modified due to \code{lastprivate} or \code{linear} clauses
should not be accessed between the end of the \code{distribute} construct and the end
of the \code{teams} region to which the \code{distribute} binds.

\end{samepage}

The \code{collapse} clause may be used to specify how many loops are
associated with the \code{distribute} construct.  The parameter of the
\code{collapse} clause must be a constant positive integer expression.
If no \code{collapse} clause is present or its paraemter is 1, the
only loop that is associated with the \code{distribute} construct is
the one that immediately follows the \code{distribute} construct.  If
a \code{collapse} clause is specified with a parameter value greater
than 1 and more than one loop is associated with the \code{distribute}
construct, then the iteration of all associated loops are collapsed
into one larger iteration space.  The sequential execution of the
iterations in all associated loops determines the order of the
iterations in the collapsed iteration space.

A distribute loop has logical iterations numbered 0,1,...,N-1 where N
is the number of loop iterations, and the logical numbering denotes
the sequence in which the iterations would be executed if the set of
associated loop(s) were executed sequentially.  At the beginning of
each logical iteration, the loop iteration variable of each associated
loop has the value that it would have if the set of the associated
loop(s) were executed sequentially.

If more than one loop is associated with the \code{distribute}
construct then the number of times that any intervening code between
any two associated loops will be executed is unspecified but will be
at least once per iteration of the loop enclosing the intervening code
and at most once per iteration of the innermost loop associated with
the construct.  If the iteration count of any loop that is associated with the
\code{distribute} construct and does not enclose the intervening code is zero
then the behavior is unspecified.


The iteration count for each associated loop is computed before entry to the outermost loop. If execution of any associated loop changes any of the values used to compute any of the iteration counts, then the behavior is unspecified.

The integer type (or kind, for Fortran) used to compute the iteration count for the collapsed loop is implementation defined.

If \code{dist_schedule} is specified, \plc{kind} must be \code{static}. If specified, iterations are
divided into chunks of size \plc{chunk_size}, chunks are assigned to the
initial teams of the league in
a round-robin fashion in the order of the initial team number. When no \plc{chunk_size} is specified,
the iteration space is divided into chunks that are approximately equal in size, and at
most one chunk is distributed to each initial team of the league. The size of the
chunks is unspecified in this case.

When no \code{dist_schedule} clause is specified, the schedule is implementation defined.

%\tools
\omptWorksharing{distribute}{ompt_work_distribute}

\restrictions
Restrictions to the \code{distribute} construct are as follows:

\begin{itemize}
\item The \code{distribute} construct inherits the restrictions of the loop construct.

\item Each \code{distribute} region must be encountered by the initial
threads of all initial teams in a league or by none at all.

\item The sequence of the \code{distribute} regions encountered must
be the same for every initial thread of every initial team in a league.

\item The region corresponding to the \code{distribute} construct must be
strictly nested inside a \code{teams} region.

\item A list item may appear in a \code{firstprivate} or \code{lastprivate} clause but not both.
\end{itemize}

\crossreferences
\begin{itemize}
\item loop construct, see
\specref{subsec:Worksharing Loop Construct}.

\item \code{teams} construct, see
\specref{sec:teams Construct}

\item \code{ompt_work_distribute}, see \specref{sec:ompt_work_t}.
\item \code{ompt_callback_work_t}, see
\specref{sec:ompt_callback_work_t}.
\end{itemize}





\subsubsection{\hcode{distribute}~\hcode{simd} Construct}
\index{distribute simd@{\code{distribute}~\code{simd}}}
\index{constructs!distribute simd@{\code{distribute}~\code{simd}}}
\index{device constructs!distribute simd@{\code{distribute}~\code{simd}}}
\label{subsec:distribute simd Construct}
\summary
The \code{distribute}~\code{simd} construct specifies a loop that will be distributed across the
master threads of the \code{teams} region and executed concurrently using SIMD instructions. The \code{distribute}~\code{simd} construct is a composite construct.

\syntax
The syntax of the \code{distribute}~\code{simd} construct is as follows:

\begin{ccppspecific}
\begin{ompcPragma}
#pragma omp distribute simd \plc{[clause[ [},\plc{] clause] ... ] newline}
   \plc{for-loops}
\end{ompcPragma}

where \plc{clause} can be any of the clauses accepted by the \code{distribute} or \code{simd}
directives with identical meanings and restrictions.
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfPragma}
!$omp distribute simd \plc{[clause[ [},\plc{] clause] ... ]}
   \plc{do-loops}
\plc{[}!$omp end distribute simd\plc{]}
\end{ompfPragma}

where \plc{clause} can be any of the clauses accepted by the \code{distribute} or \code{simd}
directives with identical meanings and restrictions.

If an \code{end}~\code{distribute}~\code{simd} directive is not specified, an \code{end}~\code{distribute}~\code{simd}
directive is assumed at the end of the \plc{do-loops}.
\end{fortranspecific}

\descr
The \code{distribute}~\code{simd} construct will first distribute the iterations of the associated
loop(s) according to the semantics of the \code{distribute} construct and any clauses that
apply to the distribute construct. The resulting chunks of iterations will then be
converted to a SIMD loop in a manner consistent with any clauses that apply to the
\code{simd} construct. The effect of any clause that applies to both constructs is as if it were applied to both constructs separately except the \code{collapse} clause, which is applied once.

\events

This composite construct generates the same events as the \code{distribute} construct.

\tools

This composite construct dispatches the same callbacks as the \code{distribute} construct.

\restrictions
\begin{itemize}
\item The restrictions for the \code{distribute} and \code{simd} constructs apply.

\item A list item may not appear in a \code{linear} clause, unless it is the loop iteration variable.

\item The \code{conditional} modifier may not appear in a \code{lastprivate} clause.
\end{itemize}

\crossreferences
\begin{itemize}
\item \code{simd} construct, see
\specref{subsec:simd Construct}.

\item \code{distribute} construct, see
\specref{subsec:distribute Construct}.

\item Data attribute clauses, see
\specref{subsec:Data-Sharing Attribute Clauses}.

\item Events and tool callbacks for the \code{distribute} construct, see
\specref{subsec:simd Construct}.

\end{itemize}









\subsubsection{Distribute Parallel Loop Construct}
\index{distribute parallel loop construct}
\index{constructs!distribute parallel loop}
\index{device constructs!distribute parallel loop}
\index{constructs!distribute parallel for@{\code{distribute}~\code{parallel}~\code{for}}}
\index{constructs!distribute parallel do@{\code{distribute}~\code{parallel}~\code{do}}}
\label{subsec:Distribute Parallel Loop Construct}
\summary
The distribute parallel loop construct specifies a loop that can be executed in parallel by
multiple threads that are members of multiple teams. The distribute parallel loop construct is a composite construct.

\syntax
The syntax of the distribute parallel loop construct is as follows:

\begin{ccppspecific}
\begin{ompcPragma}
#pragma omp distribute parallel for \plc{[clause[ [},\plc{] clause] ... ] newline}
    \plc{for-loops}
\end{ompcPragma}

where \plc{clause} can be any of the clauses accepted by the \code{distribute} or parallel loop
directives with identical meanings and restrictions.
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfPragma}
!$omp distribute parallel do \plc{[clause[ [},\plc{] clause] ... ]}
    \plc{do-loops}
\plc{[}!$omp end distribute parallel do\plc{]}
\end{ompfPragma}

where \plc{clause} can be any of the clauses accepted by the \code{distribute} or parallel loop
directives with identical meanings and restrictions.

If an \code{end}~\code{distribute}~\code{parallel}~\code{do} directive is not specified, an
\code{end}~\code{distribute}~\code{parallel}~\code{do} directive is assumed at the end of the \plc{do-loops}.
\end{fortranspecific}

\descr
The distribute parallel loop construct will first distribute the iterations of the associated loop(s) into chunks according to the semantics of the \code{distribute} construct and any clauses that apply to the \code{distribute} construct. Each of these chunks will form a loop. Each resulting loop will then be distributed across the threads within the teams region to which the \code{distribute} construct binds in a manner consistent with any clauses that apply to the parallel loop construct.
The effect of any clause that applies to both constructs is as if it were applied to both constructs separately except the \code{collapse} clause, which is applied once.

\events

This composite construct generates the same events as the \code{distribute} and parallel loop constructs.

\tools

This composite construct dispatches the same callbacks as the \code{distribute} and parallel loop constructs.

%% BRONIS: Ugly trick to avoid page starting with end c/C++ sentinel
\vspace{-6pt}

\restrictions
\begin{itemize}
\item The restrictions for the \code{distribute} and parallel loop constructs apply.
\item No \code{ordered} clause can be specified.
\item No \code{linear} clause can be specified.
\item The \code{conditional} modifier may not appear in a \code{lastprivate} clause.
\end{itemize}

%% BRONIS: Another ugly trick to avoid page starting with end c/C++ sentinel
\vspace{-6pt}

\crossreferences
\begin{itemize}
\item \code{distribute} construct, see
\specref{subsec:distribute Construct}.

\item Parallel loop construct, see
\specref{subsec:Parallel Loop Construct}.

\item Data attribute clauses, see
\specref{subsec:Data-Sharing Attribute Clauses}.

\item Events and tool callbacks for \code{distribute} construct, see
\specref{subsec:distribute Construct}.

\item Events and tool callbacks for parallel loop construct, see
\specref{subsec:Parallel Loop Construct}.

\end{itemize}






\subsubsection{Distribute Parallel Loop SIMD Construct}
\label{subsec:Distribute Parallel Loop SIMD Construct}
\index{distribute parallel loop SIMD construct}
\index{constructs!distribute parallel loop SIMD}
\index{constructs!distribute parallel for simd@{\code{distribute}~\code{parallel}~\code{for}~\code{simd}}}
\index{constructs!distribute parallel do simd@{\code{distribute}~\code{parallel}~\code{do}~\code{simd}}}
\index{device constructs!distribute parallel loop SIMD}
\summary
The distribute parallel loop SIMD construct specifies a loop that can be executed
concurrently using SIMD instructions in parallel by multiple threads that are members
of multiple teams. The distribute parallel loop SIMD construct is a composite construct.

\syntax
\begin{ccppspecific}
The syntax of the distribute parallel loop SIMD construct is as follows:

\begin{ompcPragma}
#pragma omp distribute parallel for simd \plc{\}
            \plc{[clause[ [},\plc{] clause] ... ] newline}
    \plc{for-loops}
\end{ompcPragma}

where \plc{clause} can be any of the clauses accepted by the \code{distribute} or parallel loop
SIMD directives with identical meanings and restrictions
\end{ccppspecific}

\begin{fortranspecific}
The syntax of the distribute parallel loop SIMD construct is as follows:

\begin{ompfPragma}
!$omp distribute parallel do simd \plc{[clause[ [},\plc{] clause] ... ]}
    \plc{do-loops}
\plc{[}!$omp end distribute parallel do simd\plc{]}
\end{ompfPragma}

where \plc{clause} can be any of the clauses accepted by the \code{distribute} or parallel loop
SIMD directives with identical meanings and restrictions.

If an \code{end}~\code{distribute}~\code{parallel}~\code{do}~\code{simd} directive is not specified, an
\code{end}~\code{distribute}~\code{parallel}~\code{do}~\code{simd} directive is assumed at the end of the \plc{do-loops}.
\end{fortranspecific}

\descr
The distribute parallel loop SIMD construct will first distribute the iterations of the
associated loop(s) according to the semantics of the \code{distribute} construct and any
clauses that apply to the \code{distribute} construct. The resulting loops will then be
distributed across the threads contained within the \code{teams} region to which the
\code{distribute} construct binds in a manner consistent with any clauses that apply to the
parallel loop construct. The resulting chunks of iterations will then be converted to a
SIMD loop in a manner consistent with any clauses that apply to the \code{simd} construct.
The effect of any clause that applies to both constructs is as if it were applied to both constructs separately except the \code{collapse} clause, which is applied once.

\events

This composite construct generates the same events as the \code{distribute} and parallel loop constructs.

\tools

This composite construct dispatches the same callbacks as the \code{distribute} and parallel loop constructs.

\restrictions
\begin{itemize}
\item The restrictions for the \code{distribute} and parallel loop SIMD constructs apply.
\item No \code{ordered} clause can be specified.
\item A list item may not appear in a \code{linear} clause, unless it is the loop iteration variable.
\item The \code{conditional} modifier may not appear in a \code{lastprivate} clause.
\end{itemize}

\crossreferences
\begin{itemize}
\item \code{distribute} construct, see
\specref{subsec:distribute Construct}.

\item Parallel loop SIMD construct, see
\specref{subsec:Parallel Loop SIMD Construct}.

\item Data attribute clauses, see \specref{subsec:Data-Sharing Attribute Clauses}.

\item Events and tool callbacks for \code{distribute} construct, see
\specref{subsec:distribute Construct}.

\item Events and tool callbacks for parallel loop construct, see
\specref{subsec:Parallel Loop Construct}.

\end{itemize}


\subsection{concurrent Construct}
THE SECTION ``CONCURRENT CONSTRUCT'' SHOULD GO HERE.
