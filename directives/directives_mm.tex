\section{Memory Management Directives}
\label{sec:Memory Management Directives}
\index{memory management}
\index{directives!memory management directives}
\index{memory management directives!memory management directives}

\subsection{\code{declare alloc} Directive}
\index{declare alloc@{\code{declare alloc}}}
\index{directives!declare@{\code{declare alloc}}}
\label{subsec:declare alloc Directive}

\summary

\syntax

\descr

\subsection{\code{allocate} Directive}
\index{allocate@{\code{allocate}}}
\index{directives!allocate@{\code{allocate}}}
\label{subsec:allocate Directive}
\summary
 
The \code{allocate} directive specifies how a set of variables are allocated. The \code{allocate} directive is a declarative directive if it is not associated with an allocation statement.
 
\syntax
\begin{ccppspecific}
The syntax of the \code{allocate} directive is as follows:

\begin{boxedcode}
\#pragma omp allocate(\plc{list}) \plc{[clause[ [ [},\plc{] clause] ... ]] new-line}
\end{boxedcode}

\needspace{10\baselineskip}
where \plc{clause} is one of the following:

\begin{indentedcodelist}
allocator(\plc{allocator})
\end{indentedcodelist}

where \plc{allocator} is an expression of the \code{omp\_allocator\_t} type.
\end{ccppspecific}
\medskip

\begin{fortranspecific}
\fortranspecificstart
The syntax of the \code{allocate} directive is as follows:

\begin{boxedcode}
!\$omp allocate(\plc{list}) \plc{[clause[ [ [},\plc{] clause] ... ]]}
\end{boxedcode}

or
\begin{boxedcode}
!\$omp allocate[(\plc{list})] \plc{clause[ [ [},\plc{] clause] ... ]}
   \plc{allocate statement}
\end{boxedcode}

where \plc{clause} is one of the following:

\begin{indentedcodelist}
allocator(\plc{allocator})
\end{indentedcodelist}

where \plc{allocator} is an integer expression of the \code{omp\_allocator\_kind} \plc{kind}.

\end{fortranspecific}

\descr

If the directive is not associated with a Fortran \code{allocate} statement, the storage for each \plc{list item} that appears in the directive will be provided by an allocation through an allocator. If no clause is specified then the allocator specified by the \plc{def-allocator-var} ICV will be used. If the \plc{allocator} clause is specified, the allocator specified in the clause will be used. Otherwise, the allocation will be provided as if using an allocator that had been built with the specified allocator traits, memory traits and/or the \plc{memspace} memory space. If the \code{safe\_align} clause is specified, then the allocation alignment of the request will the value of the \code{safe\_align} clause.

The scope of this allocation is that of the list item in the base language. When the allocation reaches the end of the scope it will be deallocated through the specified allocator or as if using an allocator that had been built with the specified allocator traits, memory traits and/or the \plc{memspace} memory space. If the execution leaves the scope in a manner not supported by the base language it is unspecified whether the deallocation happens or not.

\begin{fortranspecific}
If the directive is associated with a Fortran \code{allocate} statement, the allocation of the specified list items will be provided through an allocator. If no clause is specified then the allocator specified by the \plc{def-allocator-var} ICV will be used. If the \plc{allocator} clause is specified, the allocator specified in the clause will be used. Otherwise, the allocation will be provided as if using an allocator that had been built with the specified allocator traits, memory traits and/or the \plc{memspace} memory space. If no list item is specified then all variables allocated by the \code{allocate} statement will be provided by the allocator.
\end{fortranspecific}

For allocations that arise from this directive the \code{null\_fb} value of the \code{fallback} allocator trait will behave as if the \code{abort\_fb} had been specified.

\restrictions
\begin{itemize}
\item A variable that is part of another variable (as an array or structure element) cannot appear in an \code{allocate} directive.
\item The directive must appear in the same scope of the \plc{list item} declaration and before its first use.
\item If the \code{allocator} clause is present, no other clause must be specified.
\item If the \code{allocator} clause is present, the \plc{allocator} must be an allocator returned by the \code{omp\_init\_allocator} routine.
\item At most one \code{allocator} clause can appear on the \code{allocate} directive.
\item If the \code{memspace} clause is present, the  \code{memtraits} clause must not be specified.
\item If the \code{memspace} clause is present, the \plc{memspace} must be a memory space returned by the \code{omp\_init\_memspace} routine.
\item At most one \code{memspace} clause can appear on the \code{allocate} directive.
\item If the \code{safe\_align} clause is present, its value must a power of two.
\begin{ccppspecific}
\item If a list item has a static storage type, the \code{allocator} and the \code{memspace} clauses must not be specified.
\item If a list item has a static storage type, the \code{fallback} allocator trait must not have the \code{allocator\_fb} value.
\end{ccppspecific}
\begin{fortranspecific}
\item List items specified in the \code{allocate} directive must not have the \code{ALLOCATABLE} attribute unless the directive is associated with an \code{allocate} statement.
\item List items specified in an \code{allocate} directive that is associated with an \code{allocate} statement must be \code{ALLOCATABLE} variables allocated by the \code{allocate} statement.
\end{fortranspecific}
\end{itemize}

\crossreferences
\begin{itemize}
\item Memory spaces, allocators and their traits, see \specref{sec:Memory allocation}.
\item \code{omp\_memspace\_t} and \code{omp\_allocator\_t}, see \specref{subsec:Memory Management Types}.
\item \code{omp\_memspace\_kind} and \code{omp\_allocator\_kind}, see \specref{subsec:Memory Management Types}.
\end{itemize}

\subsection{The \code{deallocate} Directive}
\index{deallocate@{\code{deallocate}}}
\index{directives!deallocate@{\code{deallocate}}}
\label{subsec:deallocate Directive}
\summary

\syntax

\descr

\subsection{The \code{allocate} Clause}
\index{allocate@{\code{allocate}}}
\index{clauses!allocate@{\code{allocate}}}
\label{subsec:allocate Clause}
\summary
The \code{allocate} clause specifies the allocator to be used to obtain storage for private variables of a directive.

\syntax

The syntax of the \code{allocate} clause is as follows:

\begin{boxedcode}
allocate(\plc{[allocator}:\plc{] list})
\end{boxedcode}
\needspace{10\baselineskip}

\ccppspecificstart
\begin{ccppspecific}
where \plc{allocator} is an integer expression of the \code{omp\_allocator\_t} type.
\end{ccppspecific}
\begin{fortranspecific}
where \plc{allocator} is an integer expression of the \code{omp\_allocator\_kind} \plc{kind}.
\end{fortranspecific}

\descr

The storage for new list items that arise from \plc{list item} that appear in the directive will be provided by an allocation through an allocator. If an \plc{allocator} is specified in the clause this will be the allocator used for allocations. For all directives except for the \code{target} construct, if no allocator is specified in the clause then the allocator specified by the \plc{def-allocator-var} ICV will be used. For the \code{target} construct, if no allocator is specified in the clause then the allocator specified by the \plc{target-def-allocator-var} ICV will be used.  The inability of an allocator to fulfil the allocation request for any list item results in undefined behavior.

\restrictions
\begin{itemize}
\item List items specified in the \code{allocate} clause must also be specified in a \code{private}, \code{firstprivate}, \code{lastprivate}, \code{linear} or 
      \code{reduction} clause in the same directive.
\end{itemize}

\crossreferences
\begin{itemize}
\item Allocators, see \specref{sec:Memory allocation}.
\item TODO: ICVs
\end{itemize}