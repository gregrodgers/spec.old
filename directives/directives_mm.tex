\section{Memory Management Directives}
\label{sec:Memory Management Directives}
\index{memory management}
\index{directives!memory management directives}
\index{memory management directives!memory management directives}

\subsection{\code{declare alloc} Directive}
\index{declare alloc@{\code{declare alloc}}}
\index{directives!declare@{\code{declare alloc}}}
\label{subsec:declare alloc Directive}

\begin{ccppspecific}

\summary

The \code{declare alloc} directive allows to describe the behavior of function with respect to memory allocations and/or deallocations.

\syntax

The syntax of the \code{declare alloc} directive is as follows:

\begin{boxedcode}
#pragma omp declare alloc(\plc{[ kind }:\plc{]function-name}) \plc{[clause[ [ [},\plc{] clause] ... ]] new-line}
\end{boxedcode}

where \plc{kind} is one of the following:
\begin{indentedcodelist}
alloc
realloc
dealloc
\end{indentedcodelist}

where clause is one of the following:
\begin{indentedcodelist}
allocate(\plc{argument}|\code{omp\_return})
deallocate(\plc{argument})
size(\plc{integer expression})
error(\plc{argument} | \code{omp\_return})
\end{indentedcodelist}

\descr

The \code{declare alloc} directive allows to describe how the existing \plc{function-name} function allocates and/or deallocates memory.

The special array \code{omp\_args} can be used in the clauses of this directive. The size of the \code{omp\_args} array is that of the number of arguments of the \plc{function-name} function. Each element of the array represents the corresponding argument of the function and has its type. For clauses allowing an \plc{argument} to be specified, this will be an element of the \code{omp\_args} array.

If the \code{alloc} \plc{kind} is specified, then calling the \plc{function-name} function can result in memory allocations. The \code{allocate} clause specifies how the user function returns the result of the allocation. If \code{omp\_return} is specified, then user function must return the allocation result as its return value. If an \plc{argument} is specified, the user function returns the allocation result by storing in the specified argument. The \code{size} clause specifies how to compute the size of the allocation request that will be made by the function. The \plc{expression} of the \code{size} clause can contain references to the \code{omp\_args} array.

If the \code{dealloc} \plc{kind} is specified, then calling the \plc{function-name} function can result in memory deallocations. The \code{deallocate} clauses specifies which argument of the function contains the address of the memory to deallocate.

If the \code{realloc} \plc{kind} is specified, the calling the \plc{function-name} function can result in memory allocations and deallocations.

If no \plc{kind} is specified it is assumed to be the \code{alloc} kind.

The \code{error} clause specifies that the user function returns a status code indicating the success or failure of the allocation or deallocation. If \code{omp\_return} is specified, then the status code must returned as the function return value. If an \plc{argument} is specified, then the status code will be returned by storing it in the specified argument.

\restrictions
\begin{itemize}
\item If the \plc{kind} \code{alloc} or the \plc{kind} \code{realloc} is used, then one, and only one, \code{allocate} clause and one, and only one, \code{size} clause must be specified.
\item If the \plc{kind} \code{alloc} is used, then no \code{deallocate} clause can be specified.
\item If the \plc{kind} \code{dealloc} or the \plc{kind} \code{realloc} is used, then one, and only one, \code{deallocate} clause must be specified.
\item If the \plc{kind} \code{dealloc} is used, then no \code{allocate} clause can be specified.
\item If \code{omp\_return} is specified in the \code{allocate} clause then the return type of the function must be of pointer type.
\item If a \plc{argument} is specified in the \code{allocate} clause then type of the argument must be of a pointer to a pointer type or, in C++, reference to a pointer type.
\item The \plc{argument} of the \code{deallocate} clause must be of pointer type.
\item If \code{omp\_return} is specified in the \code{error} clause then the return type of the function must be of integer type.
\item If a \plc{argument} is specified in the \code{error} clause then type of the argument must be of a pointer to an integer type or, in C++, reference to an integer type.
\item The only variable allowed in the \code{size} clause is \code{omp\_args}.
\item No function call is allowed the \plc{expression} of the \code{size} clause.
\end{itemize}

\end{ccppspecific}



\subsection{\code{allocate} Directive}
\index{allocate@{\code{allocate}}}
\index{directives!allocate@{\code{allocate}}}
\label{subsec:allocate Directive}
\summary

The \code{allocate} directive specifies how a set of variables are allocated. The \code{allocate} directive is a declarative directive if it is not associated with an allocation statement.

\syntax
\begin{ccppspecific}
The syntax of the \code{allocate} directive is as follows:

\begin{boxedcode}
\#pragma omp allocate(\plc{list}) \plc{[clause[ [ [},\plc{] clause] ... ]] new-line}
\end{boxedcode}

or

\begin{boxedcode}
\#pragma omp allocate \plc{[clause[ [ [},\plc{] clause] ... ]] new-line}
   \plc{allocation-stmt}
\end{boxedcode}

\needspace{10\baselineskip}
where \plc{clause} is one of the following:

\begin{indentedcodelist}
allocator(\plc{allocator})
\end{indentedcodelist}

where \plc{allocator} is an expression of the \code{omp\_allocator\_t} type.

where \plc{allocation-stmt} is an expression statement with one of the following form:
\begin{codepar}
    function(arguments);
    expression = function(arguments);
\end{codepar}

\end{ccppspecific}
\medskip

\begin{fortranspecific}
\fortranspecificstart
The syntax of the \code{allocate} directive is as follows:

\begin{boxedcode}
!\$omp allocate(\plc{list}) \plc{[clause[ [ [},\plc{] clause] ... ]]}
\end{boxedcode}

or
\begin{boxedcode}
!\$omp allocate[(\plc{list})] \plc{clause[ [ [},\plc{] clause] ... ]}
   \plc{allocate statement}
\end{boxedcode}

where \plc{clause} is one of the following:

\begin{indentedcodelist}
allocator(\plc{allocator})
\end{indentedcodelist}

where \plc{allocator} is an integer expression of the \code{omp\_allocator\_kind} \plc{kind}.

\end{fortranspecific}

\descr

If the directive is not associated with a statement, the storage for each \plc{list item} that appears in the directive will be provided by an allocation through an allocator. If no clause is specified then the allocator specified by the \plc{def-allocator-var} ICV will be used. If the \plc{allocator} clause is specified, the allocator specified in the clause will be used.

The scope of this allocation is that of the list item in the base language. When the allocation reaches the end of the scope it will be deallocated using the same allocator used for the allocation. If the execution leaves the scope in a manner not supported by the base language it is unspecified whether the deallocation happens or not.

\begin{ccppspecific}
If the directive is associated with an \plc{allocation-stmt}, then the statement will be replaced by a request to an allocator according to the mapping rules expressed for the \plc{function} in the statement with the \code{declare alloc} directive.
\end{ccppspecific}

\begin{fortranspecific}
If the directive is associated with an \code{allocate} statement, the allocation of the specified list items will be provided through an allocator. If no list item is specified then all variables allocated by the \code{allocate} statement will be provided by the allocator.
\end{fortranspecific}

If no clause is specified then the allocator specified by the \plc{def-allocator-var} ICV will be used. If the \plc{allocator} clause is specified, the allocator specified in the clause will be used.

%TODO
%For allocations that arise from this directive the \code{null\_fb} value of the \code{fallback} allocator trait will behave as if the \code{abort\_fb} had been specified.

\restrictions
\begin{itemize}
\item A variable that is part of another variable (as an array or structure element) cannot appear in an \code{allocate} directive.
\item The directive must appear in the same scope of the \plc{list item} declaration and before its first use.
\item At most one \code{allocator} clause can appear on the \code{allocate} directive.
\begin{ccppspecific}
\item If the directive is associated with an \plc{allocation-stmt}, the \plc{function} must appear in a previous \code{declare alloc} directive.
\item If a list item has a static storage type, only pre-defined allocator variables can be used in the \code{allocator} clause.
\end{ccppspecific}
\begin{fortranspecific}
\item List items specified in the \code{allocate} directive must not have the \code{ALLOCATABLE} attribute unless the directive is associated with an \code{allocate} statement.
\item List items specified in an \code{allocate} directive that is associated with an \code{allocate} statement must be \code{ALLOCATABLE} variables or \code{POINTER} variables allocated by the \code{allocate} statement.
\end{fortranspecific}
\end{itemize}

\crossreferences
\begin{itemize}
\item Allocators, see \specref{sec:Memory Allocators}.
\item \code{omp\_memspace\_t} and \code{omp\_allocator\_t}, see \specref{subsec:Memory Management Types}.
\item \code{omp\_memspace\_kind} and \code{omp\_allocator\_kind}, see \specref{subsec:Memory Management Types}.
\end{itemize}



\subsection{The \code{deallocate} Directive}
\index{deallocate@{\code{deallocate}}}
\index{directives!deallocate@{\code{deallocate}}}
\label{subsec:deallocate Directive}

\begin{ccppspecific}

\summary

The \code{deallocate} directive specifies how a set of variables is deallocated.
The \code{deallocate} directive is a declarative directive if it is not
associated with an deallocation statement.


\syntax
The syntax of the \code{deallocate} directive is as follows:

\begin{boxedcode}
\#pragma omp deallocate(\plc{list}) \plc{[clause[ [ [},\plc{] clause] ... ]] new-line}
\end{boxedcode}

\needspace{10\baselineskip}

where \plc{clause} is one of the following:

\begin{indentedcodelist}
allocator(\plc{allocator})
\end{indentedcodelist}

where \plc{allocator} is an expression of the \code{omp\_allocator\_t} type.


\descr

If the directive is not associated with a statement, the storage for each
\plc{list item} that appears in the directive will be freed by an deallocation
through an allocator.
If no clause is specified then the allocator specified by the
\plc{def-allocator-var} ICV will be used.
If the \plc{allocator} clause is specified, the allocator specified in the
clause will be used.

The scope of this deallocation is that of the list item in the base language.
When the deallocation reaches the end of the scope it will be deallocated using
the same allocator used for the allocation.
If the execution leaves the scope in a manner not supported by the base language
it is unspecified whether the deallocation happens or not.

If no clause is specified then the allocator specified by the
\plc{def-allocator-var} ICV will be used.
If the \plc{allocator} clause is specified, the allocator specified in the
clause will be used.


\restrictions
\begin{itemize}
\item A variable that is part of another variable (as an array or structure
element) cannot appear in an \code{deallocate} directive.
\item The directive must appear in the same scope of the \plc{list item}
declaration and before its first use.
\item At most one \code{allocator} clause can appear on the \code{deallocate}
directive.
\item If a list item has a static storage type, only pre-defined allocator
variables can be used in the \code{allocator} clause.
\end{itemize}


\crossreferences
\begin{itemize}
\item Allocators, see \specref{sec:Memory Allocators}.
\item \code{omp\_memspace\_t} and \code{omp\_allocator\_t}, see \specref{subsec:Memory Management Types}.
\item \code{omp\_memspace\_kind} and \code{omp\_allocator\_kind}, see \specref{subsec:Memory Management Types}.
\end{itemize}


\end{ccppspecific}



\subsection{The \code{allocate} Clause}
\index{allocate@{\code{allocate}}}
\index{clauses!allocate@{\code{allocate}}}
\label{subsec:allocate Clause}
\summary
The \code{allocate} clause specifies the allocator to be used to obtain storage for private variables of a directive.

\syntax

The syntax of the \code{allocate} clause is as follows:

\begin{boxedcode}
allocate(\plc{[allocator}:\plc{] list})
\end{boxedcode}
\needspace{10\baselineskip}

\ccppspecificstart
\begin{ccppspecific}
where \plc{allocator} is an integer expression of the \code{omp\_allocator\_t} type.
\end{ccppspecific}
\begin{fortranspecific}
where \plc{allocator} is an integer expression of the \code{omp\_allocator\_kind} \plc{kind}.
\end{fortranspecific}

\descr

The storage for new list items that arise from \plc{list item} that appear in the directive will be provided by an allocation through an allocator. If an \plc{allocator} is specified in the clause this will be the allocator used for allocations. For all directives except for the \code{target} construct, if no allocator is specified in the clause then the allocator specified by the \plc{def-allocator-var} ICV will be used. For the \code{target} construct, if no allocator is specified in the clause then the allocator specified by the \plc{target-def-allocator-var} ICV will be used.  The inability of an allocator to fulfil the allocation request for any list item results in undefined behavior.

\restrictions
\begin{itemize}
\item List items specified in the \code{allocate} clause must also be specified in a \code{private}, \code{firstprivate}, \code{lastprivate}, \code{linear} or
      \code{reduction} clause in the same directive.
\end{itemize}

\crossreferences
\begin{itemize}
\item Allocators, see \specref{sec:Memory allocation}.
\item TODO: ICVs
\end{itemize}
