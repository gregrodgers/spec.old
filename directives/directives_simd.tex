% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. There are environments that provide special formatting, e.g. language bars.
%       Please use them whereever appropriate.  Examples are:
%
%         \begin{fortranspecific}
%         This is text that appears enclosed in blue language bars for Fortran.
%         \end{fortranspecific}
%
%         \begin{note}
%         This is a note.  The "Note -- " header appears automatically.
%         \end{note}
%
%    6. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of 
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%


\section{SIMD Constructs}
\label{sec:SIMD Constructs}
\index{SIMD Constructs}
\subsection{\code{simd} Construct}
\index{simd@{\code{simd}}}
\index{constructs!simd@{\code{simd}}}
\label{subsec:simd Construct}
\summary
The \code{simd} construct can be applied to a loop to indicate that the loop can be transformed 
into a SIMD loop (that is, multiple iterations of the loop can be executed concurrently 
using SIMD instructions).

\syntax
The syntax of the \code{simd} construct is as follows:

\begin{ccppspecific}
\begin{boxedcode}
\#pragma omp simd \plc{[clause[ [},\plc{] clause] ... ] new-line}
   \plc{for-loops}
\end{boxedcode}

where \plc{clause} is one of the following:

\begin{indentedcodelist}
safelen(\plc{length})
simdlen(\plc{length})
linear(\plc{list[ }:\plc{ linear-step]})
aligned(\plc{list[ }:\plc{ alignment]})
private(\plc{list})
lastprivate(\plc{[ lastprivate-modifier}:\plc{] list})
reduction(\plc{reduction-identifier }:\plc{ list})
collapse(\plc{n})
\end{indentedcodelist}

The \code{simd} directive places restrictions on the structure of the associated \plc{for-loops}. 
Specifically, all associated \plc{for-loops} must have \plc{canonical loop form} 
(\specref{sec:Canonical Loop Form}).
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
!\$omp simd \plc{[clause[ [},\plc{] clause ... ]}
   \plc{do-loops}
\plc{[}!\$omp end simd\plc{]}
\end{boxedcode}

where \plc{clause} is one of the following:

\begin{indentedcodelist}
safelen(\plc{length})
simdlen(\plc{length})
linear(\plc{list[ }:\plc{ linear-step]})
aligned(\plc{list[ }:\plc{ alignment]})
private(\plc{list})
lastprivate(\plc{[ lastprivate-modifier}:\plc{] list})
reduction(\plc{reduction-identifier }:\plc{ list})
collapse(\plc{n})
\end{indentedcodelist}

If an \code{end}~\code{simd} directive is not specified, an \code{end}~\code{simd} directive is assumed at the end 
of the \plc{do-loops}.

Any associated \plc{do-loop} must be a \plc{do-construct} or an 
\plc{inner-shared-do-construct} as defined by the Fortran standard. If an 
\code{end}~\code{simd} directive follows a \plc{do-construct} in which 
several loop statements share a \code{DO} termination statement, then the 
directive can only be specified for the outermost of these 
\code{DO} statements. 
\end{fortranspecific}

\binding
A \code{simd} region binds to the current task region. The binding thread set of the \code{simd} 
region is the current team.

\descr
The \code{simd} construct enables the execution of multiple iterations of the associated loops 
concurrently by means of SIMD instructions.

The \code{collapse} clause may be used to specify how many loops are associated with the 
construct. The parameter of the \code{collapse} clause must be a constant positive integer 
expression. If no \code{collapse} clause is present, the only loop that is associated with the 
loop construct is the one that immediately follows the directive.

If more than one loop is associated with the \code{simd} construct, then the iterations of all 
associated loops are collapsed into one larger iteration space that is then executed with 
SIMD instructions. The sequential execution of the iterations in all associated loops 
determines the order of the iterations in the collapsed iteration space.

If more than one loop is associated with the \code{simd} construct
then the number of times that any intervening code between any two
associated loops will be executed is unspecified but will be at least
once per iteration of the loop enclosing the intervening code and at
most once per iteration of the innermost loop associated with the
construct.

The iteration count for each associated loop is computed before entry to the outermost 
loop. If execution of any associated loop changes any of the values used to compute any 
of the iteration counts, then the behavior is unspecified.

The integer type (or kind, for Fortran) used to compute the iteration count for the 
collapsed loop is implementation defined.

A SIMD loop has logical iterations numbered 0,1,...,N-1 where N is the number of loop 
iterations, and the logical numbering denotes the sequence in which the iterations would 
be executed if the associated loop(s) were executed with no SIMD instructions.
The number of iterations that are executed concurrently at any given time is implementation 
defined. Each concurrent iteration will be executed by a different SIMD lane. Each set 
of concurrent iterations is a SIMD chunk. Lexical forward dependencies in the iterations of the original loop must be preserved within each SIMD chunk.

The \code{safelen} clause specifies that no two concurrent iterations within a SIMD chunk can have a distance in the logical iteration space that is greater than or equal to the value given in the clause.
The parameter of the \code{safelen} clause must be a constant positive integer expression.
The \code{simdlen} clause specifies the preferred number of iterations to be executed concurrently.
The parameter of the \code{simdlen} clause must be a constant positive integer expression.

%\begin{note}
%The value of the \code{safelen} clause defines the maximum number of logical iterations that can be executed concurrently within a SIMD chunk by a SIMD instruction.
%\end{note}

\begin{ccppspecific}
The \code{aligned} clause declares that the object to which each list item points is aligned to 
the number of bytes expressed in the optional parameter of the \code{aligned} clause.
\end{ccppspecific}

\begin{fortranspecific}

The \code{aligned} clause declares that the location of each list item
is aligned to the number of bytes expressed in the optional parameter
of the \code{aligned} clause.

\end{fortranspecific}

The optional parameter of the \code{aligned} clause, \plc{alignment}, must be a constant positive 
integer expression. If no optional parameter is specified, implementation-defined default 
alignments for SIMD instructions on the target platforms are assumed.

\restrictions
\begin{itemize}
\item There must be no OpenMP directive in the region between any
associated loops.

\item If a \code{collapse} clause is specified, exactly one loop must
occur in the region at each nesting level up to the number of loops
specified by the parameter of the \code{collapse} clause.

\item If the \code{ordered} clause is present, all loops associated
with the construct must be perfectly nested; that is there must be
no intervening code between any two loops.

\item The associated loops must be structured blocks.

\item A program that branches into or out of a \code{simd} region is non-conforming. 

\item Only one \code{collapse} clause can appear on a \code{simd} directive.

\item A \plc{list-item} cannot appear in more than one \code{aligned} clause.

\item Only one \code{safelen} clause can appear on a \code{simd} directive.

\item Only one \code{simdlen} clause can appear on a \code{simd} directive.

\item If both \code{simdlen} and \code{safelen} clauses are specified, the value of the \code{simdlen} parameter must be less than or equal to the value of the \code{safelen} parameter.

\item A \plc{modifier} may not be specified on a \code{linear} clause.

\item An \code{atomic} construct or an \code{ordered} construct with the \code{simd} clause is the only OpenMP
construct that can be encountered during execution of a \code{simd}
region.

\begin{ccppspecific}
\item The \code{simd} region cannot contain calls to the \code{longjmp} or \code{setjmp} functions. 
\end{ccppspecific}
\bigskip

\begin{cspecific}
\item The type of list items appearing in the \code{aligned} clause must be array or pointer.
\end{cspecific}

\begin{cppspecific}
\item The type of list items appearing in the \code{aligned} clause must be array, pointer, 
reference to array, or reference to pointer. 

\item No exception can be raised in the \code{simd} region. 
\end{cppspecific}

\begin{fortranspecific}
\item The \plc{do-loop} iteration variable must be of type \code{integer}.

\item The \plc{do-loop} cannot be a \code{DO WHILE} or a \code{DO} loop without loop control. 

\item If a list item on the \code{aligned} clause has the
  \code{ALLOCATABLE} attribute, the allocation status must be
  allocated.

\item If a list item on the \code{aligned} clause has the
  \code{POINTER} attribute, the association status must be associated.

\item If the type of a list item on the \code{aligned} clause is
  either \code{C\_PTR} or Cray pointer, the list item must be defined.

\end{fortranspecific}
\end{itemize}

\crossreferences
\begin{itemize}
\item \code{private}, \code{lastprivate}, \code{linear} and \code{reduction} clauses, see 
\specref{subsec:Data-Sharing Attribute Clauses}.
\end{itemize}








\subsection{\code{declare}~\code{simd} Directive}
\index{declare simd@{\code{declare}~\code{simd}}}
\index{directives!declare simd@{\code{declare}~\code{simd}}}
\label{subsec:declare simd Directive}
\summary
The \code{declare}~\code{simd} directive can be applied to a function (C, C++ and Fortran) or a 
subroutine (Fortran) to enable the creation of one or more versions that can process 
multiple arguments using SIMD instructions from a single invocation in a SIMD 
loop. The \code{declare}~\code{simd} directive is a declarative directive. There may be multiple 
\code{declare}~\code{simd} directives for a function (C, C++, Fortran) or subroutine (Fortran).

\syntax
The syntax of the \code{declare}~\code{simd} directive is as follows:

\begin{ccppspecific}
\begin{boxedcode}
\#pragma omp declare simd \plc{[clause[ [},\plc{] clause] ... ] new-line}
\plc{[}\#pragma omp declare simd \plc{[clause[ [},\plc{] clause] ... ] new-line]}
\plc{[ ... ]}
   \plc{function definition or declaration}
\end{boxedcode}

where \plc{clause} is one of the following:

\begin{indentedcodelist}
simdlen(\plc{length})
linear(\plc{linear-list[ }:\plc{ linear-step]})
aligned(\plc{argument-list[ }:\plc{ alignment]})
uniform(\plc{argument-list})
inbranch
notinbranch
\end{indentedcodelist}
\end{ccppspecific}


\begin{fortranspecific}
\begin{boxedcode}
!\$omp declare simd \plc{[}(\plc{proc-name})\plc{] [clause[ [},\plc{] clause] ... ]}
\end{boxedcode}

where \plc{clause} is one of the following:
\begin{indentedcodelist}
simdlen(\plc{length})
linear(\plc{linear-list[ }:\plc{ linear-step]})
aligned(\plc{argument-list[ }:\plc{ alignment]})
uniform(\plc{argument-list})
inbranch
notinbranch
\end{indentedcodelist}
\end{fortranspecific}


\descr
\begin{ccppspecific}
The use of one or more \code{declare}~\code{simd} directives immediately prior
to a function declaration or definition enables the
creation of corresponding SIMD 
versions of the associated function that can be used to process multiple arguments from 
a single invocation in a SIMD loop concurrently.

The expressions appearing in the clauses of each directive are evaluated in the scope of 
the arguments of the function declaration or definition.
\end{ccppspecific}

\begin{samepage}
\begin{fortranspecific}
The use of one or more \code{declare}~\code{simd} directives for a specified
subroutine or function enables the creation of corresponding SIMD versions of the 
subroutine or function that can be used to process multiple arguments from a 
single invocation in a SIMD loop concurrently. 
\end{fortranspecific}
\end{samepage}

If a SIMD version is created, the number of concurrent arguments for the function is 
determined by the \code{simdlen} clause. If the \code{simdlen} clause is used its value 
corresponds to the number of concurrent arguments of the function. The parameter of 
the \code{simdlen} clause must be a constant positive integer expression. Otherwise, the 
number of concurrent arguments for the function is implementation defined.

\begin{cppspecific}
The special \plc{this} pointer can be used as if was one of the arguments to the function in any of the \code{linear}, \code{aligned}, or \code{uniform} clauses.
\end{cppspecific}

The \code{uniform} clause declares one or more arguments to have an invariant value for all 
concurrent invocations of the function in the execution of a single SIMD loop.

\begin{samepage}
\begin{ccppspecific}
The \code{aligned} clause declares that the object to which each list item points is aligned to 
the number of bytes expressed in the optional parameter of the \code{aligned} clause.
\end{ccppspecific}
\end{samepage}

\needspace{15\baselineskip}\begin{samepage}
\begin{fortranspecific}
The \code{aligned} clause declares that the target of each list item is aligned to the number 
of bytes expressed in the optional parameter of the \code{aligned} clause.
\end{fortranspecific}
\end{samepage}

The optional parameter of the \code{aligned} clause, \plc{alignment}, must be a constant positive 
integer expression. If no optional parameter is specified, implementation-defined default 
alignments for SIMD instructions on the target platforms are assumed.

The \code{inbranch} clause specifies that the SIMD version of the function will always be called from inside a 
conditional statement of a SIMD loop. The \code{notinbranch} clause specifies that the 
SIMD version of the function will never be called from inside a conditional statement of a SIMD loop. If 
neither clause is specified, then the SIMD version of the function may or may not be called from inside a 
conditional statement of a SIMD loop.

\restrictions
\begin{itemize}
\item Each argument can appear in at most one \code{uniform} or \code{linear} clause.

\item At most one \code{simdlen} clause can appear in a \code{declare}~\code{simd} directive.

\item Either \code{inbranch} or \code{notinbranch} may be specified, but not both.

\item When a \plc{linear-step} expression is specified in a \code{linear} clause it must be
either a constant integer expression or an integer-typed parameter that is specified in
a \code{uniform} clause on the directive.

\item The function or subroutine body must be a structured block.

\item The execution of the function or subroutine, when called from a SIMD loop, cannot result in the execution of an OpenMP construct except for an \code{ordered} construct with the \code{simd} clause or an \code{atomic} construct. 

\item The execution of the function or subroutine cannot have any side effects that would 
alter its execution for concurrent iterations of a SIMD chunk.

\item A program that branches into or out of the function is non-conforming.

\begin{ccppspecific}
\item If the function has any declarations, then the \code{declare}~\code{simd} construct for any 
declaration that has one must be equivalent to the one specified for the definition. 
Otherwise, the result is unspecified.

\item The function cannot contain calls to the \code{longjmp} or \code{setjmp} functions. 
\end{ccppspecific}

\begin{cspecific}
\item The type of list items appearing in the \code{aligned} clause must be array or pointer. 
\end{cspecific}

\begin{cppspecific}
\item The function cannot contain any calls to \code{throw}. 

\item The type of list items appearing in the \code{aligned} clause must be array, pointer, 
reference to array, or reference to pointer.
\end{cppspecific}

\begin{fortranspecific}
\item \plc{proc-name} must not be a generic name, procedure pointer or entry name.

\item If \plc{proc-name} is omitted, the \code{declare}~\code{simd}
  directive must appear in the specification part of a subroutine
  subprogram or a function subprogram for which creation of the SIMD
  versions is enabled.

\item Any \code{declare}~\code{simd} directive must appear in the specification part of a subroutine 
subprogram, function subprogram or interface body to which it applies.

\item If a \code{declare}~\code{simd} directive is specified in an interface block for a procedure, it 
must match a \code{declare}~\code{simd} directive in the definition of the procedure.

\item If a procedure is declared via a procedure declaration statement, the procedure 
\plc{proc-name} should appear in the same specification. 

\item If a \code{declare}~\code{simd} directive is specified for a procedure name with explicit 
interface and a \code{declare}~\code{simd} directive is also specified for the definition of the 
procedure then the two \code{declare}~\code{simd} directives must match. Otherwise the result 
is unspecified.

\item Procedure pointers may not be used to access versions created by the \code{declare}~\code{simd} directive.

\item The type of list items appearing in the \code{aligned} clause must be \code{C\_PTR} or Cray 
pointer, or the list item must have the \code{POINTER} or \code{ALLOCATABLE} attribute.
\end{fortranspecific}
\end{itemize}

\crossreferences
\begin{itemize}
\item \code{reduction} clause, see 
\specref{subsubsec:reduction clause}.

\item \code{linear} clause, see 
\specref{subsubsec:linear clause}.
\end{itemize}










\begin{samepage}
\subsection{Loop SIMD Construct}
\label{subsec:Loop SIMD Construct}
\index{loop SIMD Construct}
\index{constructs!Loop SIMD}
\index{do SIMD@{\code{do}~\code{simd}}}
\index{for SIMD@{\code{for}~\code{simd}}}
\summary
The loop SIMD construct specifies that the iterations of one or more associated loops will be distributed across threads that already exist in the team and that the iterations executed by each thread can also be executed concurrently using SIMD instructions. The loop SIMD construct is a composite construct.
\end{samepage}

\begin{samepage}
\syntax
\begin{ccppspecific}
\begin{boxedcode}
\#pragma omp for simd \plc{[clause[ [},\plc{] clause] ... ] new-line}
   \plc{for-loops}
\end{boxedcode}

where \plc{clause} can be any of the clauses accepted by the \code{for} or \code{simd} directives with 
identical meanings and restrictions.
\end{ccppspecific}
\end{samepage}

\begin{fortranspecific}
\begin{boxedcode}
!\$omp do simd \plc{[clause[ [},\plc{] clause] ... ]}
   \plc{do-loops}
\plc{[}!\$omp end do simd \plc{[}nowait\plc{] ]}
\end{boxedcode}

where \plc{clause} can be any of the clauses accepted by the \code{simd} or \code{do} directives, with 
identical meanings and restrictions.

If an \code{end}~\code{do}~\code{simd} directive is not specified, an \code{end}~\code{do}~\code{simd} directive is 
assumed at the end of the \plc{do-loops}.
\end{fortranspecific}

\descr
The loop SIMD construct will first distribute the iterations of the associated loop(s) 
across the implicit tasks of the parallel region in a manner consistent with any clauses 
that apply to the loop construct. The resulting chunks of iterations will then be converted 
to a SIMD loop in a manner consistent with any clauses that apply to the \code{simd} 
construct. The effect of any clause that applies to both constructs is as if it were applied to both constructs separately except the \code{collapse} clause, which is applied once.

\events

This composite construct generates the same events as the loop construct.

\tools

This composite construct dispatches the same callbacks as the loop construct.

\restrictions
All restrictions to the loop construct and the \code{simd} construct apply to the loop SIMD 
construct. In addition, the following restrictions apply:

\begin{itemize}
\item No \code{ordered} clause with a parameter can be specified.
\item A list item may appear in a \code{linear} or \code{firstprivate} clause but not both.
\end{itemize}

\begin{samepage}
\crossreferences
\begin{itemize}
\item loop construct, see 
\specref{subsec:Loop Construct}.

\item \code{simd} construct, see 
\specref{subsec:simd Construct}.

\item Data attribute clauses, see 
\specref{subsec:Data-Sharing Attribute Clauses}. 

\item Events and tool callbacks for the loop construct, see
\specref{subsec:Loop Construct}.
\end{itemize}
\end{samepage}

\pagebreak
