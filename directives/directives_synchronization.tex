% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. There are environments that provide special formatting, e.g. language bars.
%       Please use them whereever appropriate.  Examples are:
%
%         \begin{fortranspecific}
%         This is text that appears enclosed in blue language bars for Fortran.
%         \end{fortranspecific}
%
%         \begin{note}
%         This is a note.  The "Note -- " header appears automatically.
%         \end{note}
%
%    6. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%


\section{Master and Synchronization Constructs and Clauses}
\label{sec:Master and Synchronization Constructs and Clauses}
\index{master and synchronization constructs and clauses}
\index{synchronization constructs}
OpenMP provides the following synchronization constructs:
\begin{itemize}
\item the \code{master} construct;

\item the \code{critical} construct;

\item the \code{barrier} construct;

\item the \code{taskwait} construct;

\item the \code{taskgroup} construct;

\item the \code{atomic} construct;

\item the \code{flush} construct;

\item the \code{ordered} construct.
\end{itemize}


\subsection{\hcode{master} Construct}
\index{maste@{\code{master}}}
\index{constructs!master@{\code{master}}}
\label{subsec:master Construct}
\summary
The \code{master} construct specifies a structured block that is executed by the master thread
of the team.

\syntax
\begin{ccppspecific}
The syntax of the \code{master} construct is as follows:

\begin{ompcPragma}
#pragma omp master \plc{new-line}
   \plc{structured-block}
\end{ompcPragma}
\end{ccppspecific}

\begin{fortranspecific}
The syntax of the \code{master} construct is as follows:

\begin{ompfPragma}
!$omp master
   \plc{structured-block}
!$omp end master
\end{ompfPragma}
\end{fortranspecific}

\binding
The binding thread set for a \code{master} region is the current team. A \code{master} region
binds to the innermost enclosing \code{parallel} region. Only the master thread of the team
executing the binding \code{parallel} region participates in the execution of the structured
block of the \code{master} region.

\descr
Other threads in the team do not execute the associated structured block. There is no
implied barrier either on entry to, or exit from, the \code{master} construct.

\events

The \plc{master-begin} event occurs in the thread encountering the \code{master}
construct on entry to the master region, if it is the master thread of the team.

The \plc{master-end} event occurs in the thread encountering the \code{master}
construct on exit of the master region, if it is the master thread of the team.

\tools

A thread dispatches a registered \code{ompt_callback_master}
callback for each occurrence of a \plc{master-begin} and a
\plc{master-end} event in that thread.

The callback occurs  in the context of the task executed by the master thread.
This callback has the type signature
\code{ompt_callback_master_t}. The callback receives
\code{ompt_scope_begin} or \code{ompt_scope_end}
as its \plc{endpoint} argument, as appropriate.

\restrictions
\begin{cppspecific}
\begin{itemize}
\item A throw executed inside a \code{master} region must cause execution to resume within the
same \code{master} region, and the same thread that threw the exception must catch it
\end{itemize}
\end{cppspecific}

\crossreferences
\begin{itemize}

\item \code{ompt_scope_begin} and \code{ompt_scope_end}, see
\specref{sec:ompt_scope_endpoint_t}.

\item \code{ompt_callback_master_t}, see
\specref{sec:ompt_callback_master_t}.


\end{itemize}









\vspace{-12pt} %% UGLY HACK
\subsection{\hcode{critical} Construct}
\index{critical@{\code{critical}}}
\index{constructs!critical@{\code{critical}}}
\label{subsec:critical Construct}
\summary
The \code{critical} construct restricts execution of the associated structured block to a
single thread at a time.

\syntax
\begin{ccppspecific}
The syntax of the \code{critical} construct is as follows:

\begin{ompcPragma}
  #pragma omp critical \plc{[}(\plc{name}) \plc{[[},\plc{]} hint(\plc{hint-expression})\plc{] ] new-line}
    \plc{structured-block}
\end{ompcPragma}

where \plc{hint-expression} is an integer constant expression that
evaluates to a valid synchronization hint (as described in~\specref{subsec:Synchronization Hints}).
\end{ccppspecific}

\begin{fortranspecific}
The syntax of the \code{critical} construct is as follows:

\begin{ompfPragma}
!$omp critical \plc{[}(\plc{name}) \plc{[[},\plc{]} hint(\plc{hint-expression})\plc{] ]}
    \plc{structured-block}
!$omp end critical \plc{[}(\plc{name})\plc{]}
\end{ompfPragma}

where \plc{hint-expression} is a constant expression that evaluates to
a scalar value with kind \code{omp_sync_hint_kind} and  a value
that is a valid synchronization hint (as described
in~\specref{subsec:Synchronization Hints}).
\end{fortranspecific}

\binding
The binding thread set for a \code{critical} region is all threads in the contention group.
The region is executed as if only a single thread at a time among all threads in the
contention group is entering the region for execution, without regard to the team(s) to which the threads belong.

\descr
An optional \plc{name} may be used to identify the \code{critical} construct. All \code{critical}
constructs without a name are considered to have the same unspecified name.

\begin{ccppspecific}
Identifiers used to identify a \code{critical} construct have external linkage and are in a
name space that is separate from the name spaces used by labels, tags, members, and
ordinary identifiers.
\end{ccppspecific}

\begin{fortranspecific}
The names of \code{critical} constructs are global entities of the program. If a name
conflicts with any other entity, the behavior of the program is unspecified.
\end{fortranspecific}

The threads of a contention group execute the \code{critical} region as if only one thread of the contention group is executing the \code{critical} region at a time.
The \code{critical} construct enforces these execution semantics with respect to all \code{critical} constructs with the same name in all
threads in the contention group, not just those threads in the current team.

If present, the \code{hint} clause gives the implementation additional
information about the expected runtime properties of the \code{critical} region
that can optionally be used to optimize the implementation.
The presence of a \code{hint} clause does not affect the isolation
guarantees provided by the \code{critical} construct. If no
\code{hint} clause is specified, the effect is as if \code{hint(omp_sync_hint_none)}
had been specified.

\def\omptMutex#1#2{
\events
The \plc{#1-acquire} event occurs in the thread encountering the
\code{#1} construct on entry to the #1 region before
initiating synchronization for the region.

The \plc{#1-acquired} event occurs in the thread encountering the
\code{#1} construct after entering the region, but before executing the
structured block of the \code{#1} region.

The \plc{#1-release} event occurs in the thread encountering the
\code{#1} construct after completing any synchronization
on exit from the \code{#1} region.

\tools
A thread dispatches a registered \code{ompt_callback_mutex_acquire}
callback for each occurrence of #2 \plc{#1-acquire} event
in that thread.
This callback has the type signature \code{ompt_callback_mutex_acquire_t}.

A thread dispatches a registered \code{ompt_callback_mutex_acquired}
callback for each occurrence of #2 \plc{#1-acquired} event
in that thread.  This callback has the type signature \code{ompt_callback_mutex_t}.

A thread dispatches a registered \code{ompt_callback_mutex_released}
callback for each occurrence of #2 \plc{#1-release} event
in that thread.  This callback has the type signature \code{ompt_callback_mutex_t}.
The callbacks occur in the task encountering
the #1 construct.  The callbacks should receive \code{ompt_mutex_#1}
as their \plc{kind} argument if practical, but a less specific kind is acceptable.
}

\omptMutex{critical}{a}

\restrictions
\begin{itemize}
\item If the \code{hint} clause is specified, the \code{critical}
      construct must have a \plc{name}.
\item If the \code{hint} clause is specified, each of the
  \code{critical} constructs with the same \plc{name} must have a
  \code{hint} clause for which the \plc{hint-expression} evaluates to the same
  value.

% \item All \code{critical} constructs with the same \plc{name} must
%       have a \code{hint} clause for which the \plc{hint-expression} evaluates
%       to the same value if any of them has a \code{hint} clause.
\end{itemize}

\begin{cppspecific}
\begin{itemize}
\item A throw executed inside a \code{critical} region must cause execution to resume within
the same \code{critical} region, and the same thread that threw the exception must catch
it.
\end{itemize}
\end{cppspecific}

\vspace{-6pt} %% UGLY HACK
\begin{fortranspecific}
The following restrictions apply to the critical construct:

\begin{itemize}
\item If a \plc{name} is specified on a \code{critical} directive, the same \plc{name} must also be
specified on the \code{end}~\code{critical} directive.

\item If no \plc{name} appears on the \code{critical} directive, no \plc{name} can appear on the
\code{end}~\code{critical} directive.
\end{itemize}
\end{fortranspecific}

\crossreferences
\begin{itemize}
\item Synchronization Hints, see
\specref{subsec:Synchronization Hints}.

\item \code{ompt_mutex_critical}, see
\specref{sec:ompt_mutex_t}.

\item \code{ompt_callback_mutex_acquire_t}, see
\specref{sec:ompt_callback_mutex_acquire_t}.

\item \code{ompt_callback_mutex_t}, see
\specref{sec:ompt_callback_mutex_t}.

\end{itemize}









\subsection{\hcode{barrier} Construct}
\index{barrier@{\code{barrier}}}
\index{constructs!barrier@{\code{barrier}}}
\label{subsec:barrier Construct}
\summary
The \code{barrier} construct specifies an explicit barrier at the point at which the construct
appears. The \code{barrier} construct is a stand-alone directive.

\syntax
\begin{ccppspecific}
The syntax of the \code{barrier} construct is as follows:

\begin{ompcPragma}
#pragma omp barrier \plc{new-line}
\end{ompcPragma}
\end{ccppspecific}

\begin{fortranspecific}
The syntax of the \code{barrier} construct is as follows:

\begin{ompfPragma}
!$omp barrier
\end{ompfPragma}
\end{fortranspecific}

\binding
The binding thread set for a \code{barrier} region is the current team. A \code{barrier} region
binds to the innermost enclosing \code{parallel} region.

\descr
All threads of the team executing the binding \code{parallel} region must execute the
\code{barrier} region and complete execution of all explicit tasks bound to this \code{parallel}
region before any are allowed to continue execution beyond the barrier.

The \code{barrier} region includes an implicit task scheduling point in the current task
region.

\def\omptSyncRegionEvents#1{
The \plc{#1-begin} event occurs in each thread encountering the
\code{#1} construct on entry to the \code{#1} region.

The \plc{#1-wait-begin} event occurs when a task begins an interval of active or passive waiting
in a \code{#1} region.

The \plc{#1-wait-end} event occurs when a task ends an interval of active or passive waiting
and resumes execution in a \code{#1} region.

The \plc{#1-end} event occurs in each thread encountering the
\code{#1} construct after the #1 synchronization on exit from the
\code{#1} region.
}

\def\omptSyncRegionTools#1{
A thread dispatches a registered \code{ompt_callback_sync_region}
callback for each occurrence of a \plc{#1-begin} and \plc{#1-end} event
in that thread.  The callback occurs in the task encountering
the #1 construct.  This callback has the type signature
\code{ompt_callback_sync_region_t}.
The callback receives
\code{ompt_sync_region_#1} as its \plc{kind} argument and
\code{ompt_scope_begin} or \code{ompt_scope_end}
as its \plc{endpoint} argument, as appropriate.

A thread dispatches a registered
\code{ompt_callback_sync_region_wait} callback
for each occurrence of a \plc{#1-wait-begin} and \plc{#1-wait-end} event.
This callback has type signature \code{ompt_callback_sync_region_t}.
This callback executes in the context of the task that encountered the
\code{#1} construct. The callback receives
\code{ompt_sync_region_#1} as its \plc{kind} argument and
\code{ompt_scope_begin} or \code{ompt_scope_end}
as its \plc{endpoint} argument, as appropriate.
}

\def\omptSyncRegion#1{
\events
\omptSyncRegionEvents{#1}
\tools
\omptSyncRegionTools{#1}
}

\events
\omptSyncRegionEvents{barrier}

A \plc{cancellation} event occurs if cancellation is activated at an implicit cancellation point in an barrier region.

\tools

\omptSyncRegionTools{barrier}

A thread dispatches a registered \code{ompt_callback_cancel}
callback for each occurrence of a \plc{cancellation} event in that thread.
The callback occurs in the context of the encountering task.  The callback has type signature
\code{ompt_callback_cancel_t}.
The callback receives \code{ompt_cancel_detected} as its \plc{flags} argument.

\restrictions
The following restrictions apply to the \code{barrier} construct:

\begin{itemize}
\item Each \code{barrier} region must be encountered by all threads in a team or by none at all,
unless cancellation has been requested for the innermost enclosing parallel region.

\item The sequence of worksharing regions and \code{barrier} regions encountered must be the
same for every thread in a team.
\end{itemize}

\crossreferences
\begin{itemize}
\item \code{ompt_scope_begin} and \code{ompt_scope_end}, see
\specref{sec:ompt_scope_endpoint_t}.

\item \code{ompt_sync_region_barrier}, see
\specref{sec:ompt_sync_region_t}.

\item \code{ompt_callback_sync_region_t}, see
\specref{sec:ompt_callback_sync_region_t}.

\item \code{ompt_callback_cancel_t}, see
\specref{sec:ompt_callback_cancel_t}.

\end{itemize}






\subsection{Implicit Barriers}
\index{implicit barrier}
\index{barrier, implicit}
\label{subsec:implict-barrier}

Implicit tasks in a parallel region synchronize with one another using
implicit barriers at the end of worksharing constructs and at the end
of the \code{parallel} region. This section describes the OMPT events and
tool callbacks associated with implicit barriers.

Implicit barriers are task scheduling points. For a description of
task sheduling points, associated events, and tool callbacks, see
\specref{subsec:Task Scheduling}.

\events

A \plc{cancellation} event occurs if cancellation is activated at an
implicit cancellation point in an implicit barrier region.

The \plc{implicit-barrier-begin} event occurs in each implicit task
at the beginning of an implicit barrier.

The \plc{implicit-barrier-wait-begin} event occurs when a task begins an interval of
active or passive waiting while executing in an implicit barrier region.

The \plc{implicit-barrier-wait-end} event occurs when a task ends an interval of
active or waiting and resumes execution of an implicit barrier region.

The \plc{implicit-barrier-end} event occurs in each implicit task
at the end of an implicit barrier.

\tools

A thread dispatches a registered \code{ompt_callback_sync_region}
callback for each occurrence of a \plc{implicit-barrier-begin} and
\plc{implicit-barrier-end} event in that thread.  The callback occurs
in the implicit task executing in a parallel region.
This callback has the type signature
\code{ompt_callback_sync_region_t}.  The callback receives
\code{ompt_sync_region_barrier} as its \plc{kind} argument and
\code{ompt_scope_begin} or \code{ompt_scope_end} as its
\plc{endpoint} argument, as appropriate.

A thread dispatches a registered \code{ompt_callback_cancel}
callback for each occurrence of a \plc{cancellation} event in that thread.
The callback occurs in the context of the encountering task.  The
callback has type signature \code{ompt_callback_cancel_t}.  The
callback receives \code{ompt_cancel_detected} as its \plc{flags}
argument.

A thread dispatches a registered
\code{ompt_callback_sync_region_wait} callback for each occurrence
of a \plc{implicit-barrier-wait-begin} and
\plc{implicit-barrier-wait-end} event.  This callback has type
signature \code{ompt_callback_sync_region_t}.  The callback occurs
in each implicit task participating in an implicit barrier.  The
callback receives \code{ompt_sync_region_barrier} as its \plc{kind}
argument and \code{ompt_scope_begin} or \code{ompt_scope_end} as
its \plc{endpoint} argument, as appropriate.

\restrictions
If a thread is in the state \code{omp_state_wait_barrier_implicit_parallel},
a call to \code{ompt_get_parallel_info}
may return a pointer to a copy of the current parallel region's \plc{parallel_data}
rather than a pointer to the data word for the region itself. This convention enables the master thread
for a parallel region to free storage for the region immediately after the region ends, yet
avoid having some other thread in the region's team
potentially reference the region's \plc{parallel_data} object after it has been freed.

\crossreferences
\begin{itemize}

\item \code{ompt_scope_begin} and \code{ompt_scope_end}, see
  \specref{sec:ompt_scope_endpoint_t}.

\item \code{ompt_sync_region_barrier}, see
  \specref{sec:ompt_sync_region_t}

\item \code{ompt_cancel_detected}, see
  \specref{sec:ompt_cancel_flag_t}.

\item \code{ompt_callback_sync_region_t}, see
  \specref{sec:ompt_callback_sync_region_t}.

\item \code{ompt_callback_cancel_t}, see
  \specref{sec:ompt_callback_cancel_t}.

\end{itemize}









\subsection{\hcode{taskwait} Construct}
\index{taskwait@{\code{taskwait}}}
\index{constructs!taskwait@{\code{taskwait}}}
\label{subsec:taskwait Construct}
\summary
The \code{taskwait} construct specifies a wait on the completion of child tasks
of the current task. The \code{taskwait} construct is a stand-alone directive.

\syntax
\begin{ccppspecific}
The syntax of the \code{taskwait} construct is as follows:

\begin{ompcPragma}
#pragma omp taskwait \plc{[clause[ [},\plc{] clause] ... ] new-line}
\end{ompcPragma}

where \plc{clause} is one of the following:

\begin{indentedcodelist}
depend(\plc{dependence-type }:\plc{ locator-list}[:\plc{iterators-definition}])
\end{indentedcodelist}
\end{ccppspecific}

\begin{fortranspecific}
The syntax of the \code{taskwait} construct is as follows:

\begin{ompfPragma}
!$omp taskwait \plc{[clause[ [},\plc{] clause] ... ]}
\end{ompfPragma}

where \plc{clause} is one of the following:

\begin{indentedcodelist}
depend(\plc{dependence-type }:\plc{ locator-list}[:\plc{iterators-definition}])
\end{indentedcodelist}

\end{fortranspecific}

\binding
The \code{taskwait} region binds to the current task region. The binding thread set of the
\code{taskwait} region is the current team.

\descr

If no \code{depend} clause is present on the \code{taskwait} construct, the
current task region is suspended at an implicit task scheduling point
associated with the construct. The current task region remains suspended until
all child tasks that it generated before the \code{taskwait} region complete
execution.

Otherwise, if one or more \code{depend} clauses are present on the
\code{taskwait} construct, the behavior is as if these clauses were applied to
a \code{task} construct with an empty associated structured block that
generates a \emph{mergeable} and \emph{included task}. Thus, the current task region is
suspended until the \emph{predecessor tasks} of this task complete execution.

\omptSyncRegion{taskwait}

\restrictions

The \code{mutexinoutset} \plc{dependence-type} may not appear in a
\code{depend} clause on a \code{taskwait} construct.

\crossreferences
\begin{itemize}
\item \code{task} construct, see \specref{subsec:task Construct}.

\item Task scheduling, see
\specref{subsec:Task Scheduling}.

\item \code{depend} clause, see \specref{subsec:depend Clause}.

\item \code{ompt_scope_begin} and \code{ompt_scope_end}, see
\specref{sec:ompt_scope_endpoint_t}.

\item \code{ompt_sync_region_taskwait}, see
\specref{sec:ompt_sync_region_t}.

\item \code{ompt_callback_sync_region_t}, see
\specref{sec:ompt_callback_sync_region_t}.

\end{itemize}







\subsection{\hcode{taskgroup} Construct}
\index{taskgroup@{\code{taskgroup}}}
\index{constructs!taskgroup@{\code{taskgroup}}}
\label{subsec:taskgroup Construct}
\summary
The \code{taskgroup} construct specifies a wait on completion of child tasks of the current
task and their descendent tasks.

\syntax
\begin{ccppspecific}
The syntax of the \code{taskgroup} construct is as follows:

\begin{ompcPragma}
#pragma omp taskgroup \plc{[clause[[,] clause] ...]} \plc{new-line}
    \plc{structured-block}
\end{ompcPragma}

where \plc{clause} is one of the following:

\begin{indentedcodelist}
task_reduction(\plc{reduction-identifier }:\plc{ list})
allocate(\plc{[allocator: ]}\plc{list})
\end{indentedcodelist}
\end{ccppspecific}

\begin{fortranspecific}
The syntax of the \code{taskgroup} construct is as follows:

\begin{ompfPragma}
!$omp taskgroup \plc{[clause [ [},\plc{] clause] ...]}
    \plc{structured-block}
!$omp end taskgroup
\end{ompfPragma}

where \plc{clause} is one of the following:

\begin{indentedcodelist}
task_reduction(\plc{reduction-identifier }:\plc{ list})
allocate(\plc{[allocator: ]}\plc{list})
\end{indentedcodelist}

\end{fortranspecific}

\binding
A \code{taskgroup} region binds to the current task region. A \code{taskgroup} region binds to
the innermost enclosing \code{parallel} region.

\descr
When a thread encounters a \code{taskgroup} construct, it starts executing
the region. All child tasks generated in the \code{taskgroup} region and all
of their descendants that bind to the same \code{parallel} region as the
\code{taskgroup} region are part of the \plc{taskgroup set} associated with
the \code{taskgroup} region.

There is an implicit task scheduling point at the end of the \code{taskgroup}
region. The current task is suspended at the task scheduling point until all
tasks in the \plc{taskgroup set} complete execution.

\omptSyncRegion{taskgroup}

\crossreferences
\begin{itemize}
\item Task scheduling, see
\specref{subsec:Task Scheduling}.
\item \code{task_reduction} Clause, see \specref{subsubsec:task_reduction clause}.

\item \code{ompt_scope_begin} and \code{ompt_scope_end}, see
\specref{sec:ompt_scope_endpoint_t}.

\item \code{ompt_sync_region_taskgroup}, see
\specref{sec:ompt_sync_region_t}.

\item \code{ompt_callback_sync_region_t}, see
\specref{sec:ompt_callback_sync_region_t}.

\end{itemize}










\subsection{\hcode{atomic} Construct}
\index{atomic@{\code{atomic}}}
\index{constructs!atomic@{\code{atomic}}}
\index{constructs!atomic@{\code{atomic}}}
\index{write, atomic@{\code{write, atomic}}}
\index{read, atomic@{\code{read, atomic}}}
\index{update, atomic@{\code{update, atomic}}}
\index{capture, atomic@{\code{capture, atomic}}}
\label{subsec:atomic Construct}
\summary
The \code{atomic} construct ensures that a specific storage location is accessed atomically,
rather than exposing it to the possibility of multiple, simultaneous reading and writing
threads that may result in indeterminate values.

\syntax
In the following syntax, \plc{atomic-clause} is a clause that indicates
the semantics for which atomicity is enforced and \plc{memory-order-clause} is
a clause that indicates the memory ordering behavior of the construct.
Specifically, \plc{atomic-clause} is one of the following:

\begin{indentedcodelist}
read
write
update
capture
\end{indentedcodelist}

and \plc{memory-order-clause} is one of the following:

\begin{indentedcodelist}
seq_cst
acq_rel
release
acquire
\end{indentedcodelist}

\begin{ccppspecific}
The syntax of the \code{atomic} construct takes one of the following forms:

\begin{ompcPragma}
#pragma omp atomic \plc{[memory-order-clause[},\plc{]]} \plc{atomic-clause}
                   \plc{[[},\plc{]}hint(\plc{hint-expression})\plc{]}
                   \plc{[[},\plc{]memory-order-clause]} \plc{new-line}
    \plc{expression-stmt}
\end{ompcPragma}

%% where \plc{atomic-clause} is one of the following:
%%
%% \begin{indentedcodelist}
%% read
%% write
%% update
%% capture
%% \end{indentedcodelist}

or

\begin{ompcPragma}
#pragma omp atomic \plc{[memory-order-clause]} \plc{[[},\plc{]}hint(\plc{hint-expression})\plc{]} \plc{new-line}
    \plc{expression-stmt}
\end{ompcPragma}

or

\begin{ompcPragma}
#pragma omp atomic \plc{[memory-order-clause[},\plc{]]} capture
                   \plc{[[},\plc{]}\plc{[}hint(\plc{hint-expression})\plc{]}
                   \plc{[[},\plc{]memory-order-clause]} \plc{new-line}
    \plc{structured-block}
\end{ompcPragma}

%% \needspace{6\baselineskip}
where \plc{expression-stmt} is an expression statement with one of the following forms:

\begin{itemize}
\item If \plc{atomic-clause} is \code{read}:
\begin{ompSyntax}
\plc{v} = \plc{x};
\end{ompSyntax}


\item If \plc{atomic-clause} is \code{write}:
\begin{ompSyntax}
\plc{x} = \plc{expr};
\end{ompSyntax}

\item If \plc{atomic-clause} is \code{update} or not present:
\begin{ompSyntax}
\plc{x}++;
\plc{x}--;
++\plc{x};
--\plc{x};
\plc{x} \plc{binop}= \plc{expr};
\plc{x} = \plc{x} \plc{binop} \plc{expr};
\plc{x} = \plc{expr} \plc{binop} \plc{x};
\end{ompSyntax}

\item If \plc{atomic-clause} is \code{capture}:
\begin{ompSyntax}
\plc{v} = \plc{x}++;
\plc{v} = \plc{x}--;
\plc{v} = ++\plc{x};
\plc{v} = --\plc{x};
\plc{v} = \plc{x} \plc{binop}= \plc{expr};
\plc{v} = \plc{x} = \plc{x} \plc{binop} \plc{expr};
\plc{v} = \plc{x} = \plc{expr} \plc{binop} \plc{x};
\end{ompSyntax}

and where \plc{structured-block} is a structured block with one of the following forms:

\begin{ompSyntax}
\plc{v} = \plc{x}; \plc{x} \plc{binop}= \plc{expr};
\plc{x} \plc{binop}= \plc{expr}; \plc{v} = \plc{x};
\plc{v} = \plc{x}; \plc{x} = \plc{x} \plc{binop} \plc{expr};
\plc{v} = \plc{x}; \plc{x} = \plc{expr} \plc{binop} \plc{x};
\plc{x} = \plc{x} \plc{binop} \plc{expr}; \plc{v} = \plc{x};
\plc{x} = \plc{expr} \plc{binop} \plc{x}; \plc{v} = \plc{x};
\plc{v} = \plc{x}; \plc{x} = \plc{expr};
\plc{v} = \plc{x}; \plc{x}++;
\plc{v} = \plc{x}; ++\plc{x};
++\plc{x}; \plc{v} = \plc{x};
\plc{x}++\code{;} \plc{v} = \plc{x};
\plc{v} = \plc{x}; \plc{x}--;
\plc{v} = \plc{x}; --\plc{x};
--\plc{x}; \plc{v} = \plc{x};
\plc{x}--; \plc{v} = \plc{x};
\end{ompSyntax}
\end{itemize}

In the preceding expressions:

\begin{itemize}
\item \plc{x} and \plc{v} (as applicable) are both \plc{l-value} expressions with scalar type.

\item During the execution of an atomic region, multiple syntactic occurrences of \plc{x} must
designate the same storage location.

\item Neither of \plc{v} and \plc{expr} (as applicable) may access the storage location designated by \plc{x}.

\item Neither of \plc{x} and \plc{expr} (as applicable) may access the storage location designated by \plc{v}.

\item \plc{expr} is an expression with scalar type.

\item \plc{binop} is one of \code{+}, \code{*}, \code{-}, \code{/},
\code{&}, \code{^}, \code{|}, \code{<<}, or
\code{>>}.

\item \plc{binop}, \plc{binop}\code{=}, \code{++}, and \code{--} are not overloaded operators.

\item The expression \plc{x} \plc{binop} \plc{expr} must be numerically equivalent to
\plc{x} \plc{binop} \plc{(expr)}. This
requirement is satisfied if the operators in \plc{expr} have precedence greater than \plc{binop},
or by using parentheses around \plc{expr} or subexpressions of \plc{expr}.

\item The expression \plc{expr} \plc{binop} \plc{x} must be numerically equivalent to
\plc{(expr)} \plc{binop} \plc{x}. This
requirement is satisfied if the operators in \plc{expr} have precedence equal to or greater
than \plc{binop}, or by using parentheses around \plc{expr} or subexpressions of \plc{expr}.

\item For forms that allow multiple occurrences of \plc{x}, the number of times that \plc{x} is
evaluated is unspecified.
\end{itemize}

\end{ccppspecific}

\begin{fortranspecific}
The syntax of the \code{atomic} construct takes any of the following forms:

\begin{ompfPragma}
!$omp atomic \plc{[memory-order-clause[},\plc{]]} read \plc{[[},\plc{]}hint(\plc{hint-expression})\plc{]}
             \plc{[[},\plc{]memory-order-clause]}
    \plc{capture-statement }
\plc{[}!$omp end atomic\plc{]}
\end{ompfPragma}

or

\begin{ompfPragma}
!$omp atomic \plc{[memory-order-clause[},\plc{]]} write \plc{[[},\plc{]}hint(\plc{hint-expression})\plc{]}
             \plc{[[},\plc{]memory-order-clause]}
    \plc{write-statement }
\plc{[}!$omp end atomic\plc{]}
\end{ompfPragma}

or

\begin{ompfPragma}
!$omp atomic \plc{[memory-order-clause[},\plc{]]} update \plc{[[},\plc{]}hint(\plc{hint-expression})\plc{]}
             \plc{[[},\plc{]memory-order-clause]}
    \plc{update-statement }
\plc{[}!$omp end atomic\plc{]}
\end{ompfPragma}

or

%\newpage %% HACK
\begin{ompfPragma}
!$omp atomic \plc{[memory-order-clause]} \plc{[[},\plc{]}hint(\plc{hint-expression})\plc{]}
             \plc{[[},\plc{]memory-order-clause]}
    \plc{update-statement}
\plc{[}!$omp end atomic\plc{]}
\end{ompfPragma}

or

\begin{ompfPragma}
!$omp atomic \plc{[memory-order-clause[},\plc{]]} capture \plc{[[},\plc{]}hint(\plc{hint-expression})\plc{]}
             \plc{[[},\plc{]memory-order-clause]}
    \plc{update-statement }
    \plc{capture-statement}
!$omp end atomic
\end{ompfPragma}

or

\begin{ompfPragma}
!$omp atomic \plc{[memory-order-clause[},\plc{]]} capture \plc{[[},\plc{]}hint(\plc{hint-expression})\plc{]}
             \plc{[[},\plc{]memory-order-clause]}
    \plc{capture-statement}
    \plc{update-statement}
!$omp end atomic
\end{ompfPragma}

or

\begin{ompfPragma}
!$omp atomic \plc{[memory-order-clause[},\plc{]]} capture \plc{[[},\plc{]}hint(\plc{hint-expression})\plc{]}
             \plc{[[},\plc{]memory-order-clause]}
    \plc{capture-statement}
    \plc{write-statement}
!$omp end atomic
\end{ompfPragma}

where \plc{write-statement} has the following form (if \plc{atomic-clause}
is \code{capture} or \code{write}):

\begin{indentedcodelist}
\plc{x} = \plc{expr}
\end{indentedcodelist}

where \plc{capture-statement} has the following form (if \plc{atomic-clause}
is \code{capture} or \code{read}):

\begin{indentedcodelist}
\plc{v} = \plc{x}
\end{indentedcodelist}

and where \plc{update-statement} has one of the following forms (if \plc{atomic-clause} is \code{update},
\code{capture}, or not present):

\begin{indentedcodelist}
\plc{x} = \plc{x operator expr}

\plc{x} = \plc{expr operator x}

\plc{x} = \plc{intrinsic_procedure_name} (\plc{x}, \plc{expr_list})

\plc{x} = \plc{intrinsic_procedure_name} (\plc{expr_list}, \plc{x})
\end{indentedcodelist}

In the preceding statements:

\begin{itemize}
\item \plc{x} and \plc{v} (as applicable) are both scalar variables of intrinsic type.

\vspace{-2 pt} %% UGLY HACK
\item \plc{x} must not have the \code{ALLOCATABLE} attribute.

\vspace{-2 pt} %% UGLY HACK
\item During the execution of an atomic region, multiple syntactic occurrences of \plc{x} must
designate the same storage location.

\vspace{-2 pt} %% UGLY HACK
\item None of \plc{v}, \plc{expr}, and \plc{expr_list} (as applicable) may access the same storage location as
\plc{x}.

\vspace{-2 pt} %% UGLY HACK
\item None of \plc{x}, \plc{expr}, and \plc{expr_list} (as applicable) may access the same storage location as
\plc{v}.

\vspace{-2 pt} %% UGLY HACK
\item \plc{expr} is a scalar expression.

\vspace{-2 pt} %% UGLY HACK
\item \plc{expr_list} is a comma-separated, non-empty list of scalar expressions. If
\plc{intrinsic_procedure_name} refers to \code{IAND}, \code{IOR}, or \code{IEOR}, exactly one expression
must appear in \plc{expr_list}.

\vspace{-2 pt} %% UGLY HACK
\item \plc{intrinsic_procedure_name} is one of \code{MAX}, \code{MIN}, \code{IAND}, \code{IOR}, or \code{IEOR}.

\vspace{-2 pt} %% UGLY HACK
\item \plc{operator} is one of \code{+}, \code{*}, \code{-}, \code{/}, \code{.AND.}, \code{.OR.}, \code{.EQV.}, or \code{.NEQV.}.

\vspace{-2 pt} %% UGLY HACK
\item The expression \plc{x operator expr} must be numerically equivalent to \plc{x operator (expr)}.
This requirement is satisfied if the operators in \plc{expr} have precedence greater than
\plc{operator}, or by using parentheses around \plc{expr} or subexpressions of \plc{expr}.

\vspace{-2 pt} %% UGLY HACK
\item The expression \plc{expr operator x} must be numerically equivalent to \plc{(expr) operator  x}. This requirement is satisfied if the operators in \plc{expr} have precedence equal to or
greater than \plc{operator}, or by using parentheses around \plc{expr} or subexpressions of \plc{expr}.

\vspace{-2 pt} %% UGLY HACK
\item \plc{intrinsic_procedure_name} must refer to the intrinsic procedure name and not to other
program entities.

\vspace{-2 pt} %% UGLY HACK
\item \plc{operator} must refer to the intrinsic operator and not to a user-defined operator.

\vspace{-2 pt} %% UGLY HACK
\item All assignments must be intrinsic assignments.

\vspace{-2 pt} %% UGLY HACK
\item For forms that allow multiple occurrences of \plc{x}, the number of times that \plc{x} is
evaluated is unspecified.
%% \item In all \code{atomic} construct forms, the \code{seq_cst} clause and the clause that denotes the
%% type of the atomic construct can appear in any order. In addition, an optional comma
%% may be used to separate the clauses
\end{itemize}
\end{fortranspecific}
%% \end{fortranspecific} %% TODO: this needs to be changed.


\begin{samepage}

\binding
If the size of \plc{x} is 8, 16, 32, or 64 bits and \plc{x} is aligned to a
multiple of its size, the binding thread set for the \code{atomic} region is
all threads on the device. Otherwise, the binding thread set for the
\code{atomic} region is all threads in the contention group.  \code{atomic}
regions enforce exclusive access with respect to other \code{atomic} regions
that access the same storage location \plc{x} among all threads in the
binding thread set without regard to the teams to which the threads belong.

\descr

All \code{atomic} constructs force an atomic operation on the storage location
designated by \plc{x} to be performed by the encountering thread, preceded
and/or followed by implicit flush operations as described in this section. The
implicit flushes are performed as if they are part of the same atomic
operation applied to \plc{x}.  Each non-synchronizable implicit flush is a
strong flush. If \plc{memory-order-clause} is present and is \code{seq_cst},
each synchronizable implicit flush is a strong flush; otherwise,
each synchronizable implicit flush is a weak flush.

The \code{atomic} construct with the \code{read} clause forces an atomic read of the location
designated by \plc{x} regardless of the native machine word size. The atomic
read is immediately preceded by a non-synchronizable read flush of \plc{x}.
\end{samepage}

The \code{atomic} construct with the \code{write} clause forces an atomic write of the location
designated by \plc{x} regardless of the native machine word size. The atomic
write is immediately followed by a non-synchronizable write flush of \plc{x}.

The \code{atomic} construct with the \code{update} clause forces an atomic update of the location
designated by \plc{x} using the designated operator or intrinsic. Note that when no clause is
present, the semantics are equivalent to atomic update. Only the read and write of the
location designated by \plc{x} are performed mutually atomically. The evaluation of \plc{expr} or
\plc{expr_list} need not be atomic with respect to the read or write of the location designated
by \plc{x}. No task scheduling points are allowed between the read and the write of the
location designated by \plc{x}. The atomic update is immediately preceded by
a non-synchronizable read flush of \plc{x} and immediately followed by a
non-synchronizable write flush of \plc{x}.

The \code{atomic} construct with the \code{capture} clause forces an atomic
captured update --- an atomic update of the
location designated by \plc{x} using the designated operator or intrinsic while also capturing
the original or final value of the location designated by \plc{x} with respect to the atomic
update. The original or final value of the location designated by \plc{x} is written in the
location designated by \plc{v} depending on the form of the \code{atomic} construct structured
block or statements following the usual language semantics. Only the read and write of
the location designated by \plc{x} are performed mutually atomically. Neither the evaluation
of \plc{expr} or \plc{expr_list}, nor the write to the location designated by \plc{v}, need be atomic with
respect to the read or write of the location designated by \plc{x}. No task scheduling points
are allowed between the read and the write of the location designated by
\plc{x}. The atomic captured update is immediately preceded by a
non-synchronizable read flush of \plc{x} and immediately followed by a
non-synchronizable write flush of \plc{x}.

A release flush operation applied to all variables, with a
sync-set containing \plc{x}, is implied at entry to the atomic operation when
the \code{read} clause is not present and the \code{release}, \code{acq_rel},
or \code{seq_cst} clause is present.  An acquire flush
operation applied to all variables, with a sync-set containing \plc{x}, is
implied at exit from the atomic operation when the \code{read} or
\code{capture} clause is present and the \code{acquire}, \code{acq_rel}, or
\code{seq_cst} clause is present.

% \begin{note}
% As with other implicit flush regions,
% \specref{subsec:OpenMP Memory Consistency}
% reduces the
% ordering that must be enforced. The intent is that, when the analogous operation exists
% in C++11 or C11, a sequentially consistent \code{atomic} construct has the same semantics as
% a \code{memory_order_seq_cst} atomic operation in C++11/C11. Similarly, a
% non-sequentially consistent \code{atomic} construct on which
% \plc{memory-order-clause} is not present has the same semantics as a
% \code{memory_order_relaxed} atomic operation in C++11/C11.
%
% Unlike non-sequentially consistent \code{atomic} constructs, sequentially consistent \code{atomic}
% constructs preserve the interleaving (sequentially consistent) behavior of correct,
% data race free programs. However, they are not designed to replace the \code{flush} directive
% as a mechanism to enforce ordering for non-sequentially consistent \code{atomic} constructs,
% and attempts to do so require extreme caution. For example, a sequentially consistent
% \code{atomic}~\code{write} construct may appear to be reordered with a subsequent
% non-sequentially consistent \code{atomic}~\code{write} construct that modifies
% a different variable, since such reordering would not be observable by a
% correct program if the second write were outside an \code{atomic} directive.
% \end{note}

For all forms of the \code{atomic} construct, any combination of two or more
of these \code{atomic} constructs enforces mutually exclusive access to the
locations designated by \plc{x} among threads in the binding thread set.  To
avoid race conditions, all accesses of the locations designated by \plc{x}
that could potentially occur in parallel must be protected with an
\code{atomic} construct.

\code{atomic} regions do not guarantee exclusive access with respect to any accesses outside
of \code{atomic} regions to the same storage location \plc{x} even if those accesses occur during a
\code{critical} or \code{ordered} region, while an OpenMP lock is owned by the executing
task, or during the execution of a \code{reduction} clause.

However, other OpenMP synchronization can ensure the desired exclusive access. For
example, a barrier following a series of atomic updates to \plc{x} guarantees that subsequent
accesses do not form a race with the atomic accesses.

A compliant implementation may enforce exclusive access between \code{atomic} regions
that update different storage locations. The circumstances under which this occurs are
implementation defined.

If the storage location designated by \plc{x} is not size-aligned (that is, if the byte alignment
of \plc{x} is not a multiple of the size of \plc{x}), then the behavior of the \code{atomic} region is
implementation defined.

If present, the \code{hint} clause gives the implementation additional
information about the expected properties of the atomic operation
that can optionally be used to optimize the implementation.
The presence of a \code{hint} clause does not affect the semantics of
the \code{atomic} construct, and it is legal to ignore all hints.
If no \code{hint} clause is specified, the effect is as if \code{hint(omp_sync_hint_none)} had been specified.

\needspace{16\baselineskip}\begin{samepage}

\omptMutex{atomic}{an}

\restrictions

The following restrictions apply to the \code{atomic} construct:

\begin{itemize}
\item At most one \plc{memory-order-clause} may appear on the construct.

\item If \plc{atomic-clause} is \code{read} then \plc{memory-order-clause}
    must not be \code{acq_rel} or \code{release}.

\item If \plc{atomic-clause} is \code{write} then \plc{memory-order-clause}
    must not be \code{acq_rel} or \code{acquire}.

\item If \plc{atomic-clause} is \code{update} or not present then \plc{memory-order-clause}
    must not be \code{acq_rel} or \code{acquire}.
\end{itemize}

\newpage  %% HACK
\begin{ccppspecific}
\begin{itemize}
\item All atomic accesses to the storage locations designated by \plc{x} throughout the program
are required to have a compatible type.
\end{itemize}
\end{ccppspecific}
\end{samepage}

\begin{fortranspecific}
\begin{itemize}
\item All atomic accesses to the storage locations designated by \plc{x} throughout the program
are required to have the same type and type parameters.
\end{itemize}
\end{fortranspecific}

% Do we want this? I do not believe that we need it. This is not like
% a critical section where different lock implementations might be used
% by lexically different critical sections that name the same
% lock. Here all implementations must inter-operate anyway.
% \begin{itemize}
% \item When a \code{hint} is present at the construct, all \code{atomic} constructs which
% may simultaneously access the storage locations designated by
% \plc{x} must have a hint expression that evaluates to the same value.
% \end{itemize}

\begin{itemize}
\item OpenMP constructs may not be encountered during execution of an
\code{atomic} region.
\end{itemize}


\crossreferences
\begin{itemize}
\item \code{critical} construct, see
\specref{subsec:critical Construct}.

\item \code{barrier} construct, see
\specref{subsec:barrier Construct}.

\item \code{flush} construct, see
\specref{subsec:flush Construct}.

\item \code{ordered} construct, see
\specref{subsec:ordered Construct}.

\item \code{reduction} clause, see
\specref{subsubsec:reduction clause}.

\item lock routines, see
\specref{sec:Lock Routines}.

\item Synchronization Hints, see
\specref{subsec:Synchronization Hints}.

\item \code{ompt_mutex_atomic}, see
\specref{sec:ompt_mutex_t}.

\item \code{ompt_callback_mutex_acquire_t}, see
\specref{sec:ompt_callback_mutex_acquire_t}.

\item \code{ompt_callback_mutex_t}, see
\specref{sec:ompt_callback_mutex_t}.

\end{itemize}









\subsection{\hcode{flush} Construct}
\index{flush@{\code{flush}}}
\index{constructs!flush@{\code{flush}}}
\label{subsec:flush Construct}
\summary
The \code{flush} construct executes the OpenMP flush operation. This operation makes a
thread's temporary view of memory consistent with memory and enforces an order on
the memory operations of the variables explicitly specified or implied. See the memory
model description in \specref{sec:Memory Model} for more details. The \code{flush} construct is a
stand-alone directive.

\syntax
\begin{ccppspecific}
The syntax of the \code{flush} construct is as follows:

\begin{ompcPragma}
#pragma omp flush \plc{[memory-order-clause]} \plc{[}(\plc{list})\plc{] new-line}
\end{ompcPragma}
\begin{samepage}
where \plc{memory-order-clause} is one of the following:

\begin{indentedcodelist}
acq_rel
release
acquire
\end{indentedcodelist}
\end{samepage}
\end{ccppspecific}

\begin{fortranspecific}
The syntax of the \code{flush} construct is as follows:

\begin{ompfPragma}
!$omp flush \plc{[memory-order-clause]} \plc{[}(\plc{list})\plc{]}
\end{ompfPragma}
\begin{samepage}
where \plc{memory-order-clause} is one of the following:

\begin{indentedcodelist}
acq_rel
release
acquire
\end{indentedcodelist}
\end{samepage}
\end{fortranspecific}

\binding
The binding thread set for a \code{flush} region is the encountering thread. Execution of a
\code{flush} region affects the memory and the temporary view of memory of only the thread
that executes the region. It does not affect the temporary view of other threads. Other
threads must themselves execute a flush operation in order to be guaranteed to observe
the effects of the encountering thread's flush operation

\descr
A \code{flush} construct without a list, executed on a given thread, operates as if the whole
thread-visible data state of the program, as defined by the base language, is flushed. A
\code{flush} construct with a list applies the flush operation to the items in the list, and does
not return until the operation is complete for all specified list items. An implementation
may implement a \code{flush} with a list by ignoring the list, and treating it the same as a
\code{flush} without a list.

If list items are specified on the \code{flush} construct, the flush operation
is a non-synchronizable flush.  Otherwise, the flush operation is a
synchronizable flush for which the sync-set contains all variables that are
flushed.

The flush operation's flush properties are determined according to
\plc{memory-order-clause}, if present:

\begin{itemize}
\item If \plc{memory-order-clause} is not specified, the flush operation has the
strong, write, and read flush properties and is both a release flush and an
acquire flush if the flush does not have a list.

\item If \plc{memory-order-clause} is \code{acq_rel}, the flush operation has the
write and read flush properties and is both a release flush and an acquire flush.

\item If \plc{memory-order-clause} is \code{release}, the flush operation has
the write flush property and is a release flush.

\item If \plc{memory-order-clause} is \code{acquire}, the flush operation has
the read flush property and is an acquire flush.
\end{itemize}


\begin{ccppspecific}
If a pointer is present in the list, the pointer itself is flushed, not the memory block to
which the pointer refers.
\end{ccppspecific}

\begin{fortranspecific}
If the list item or a subobject of the list item has the \code{POINTER} attribute, the allocation
or association status of the \code{POINTER} item is flushed, but the pointer target is not. If the
list item is a Cray pointer, the pointer is flushed, but the object to which it points is not.
If the list item is of type \code{C_PTR}, the variable is flushed, but the storage that corresponds
to that address is not flushed. If the list item or the subobject of the list item has the
\code{ALLOCATABLE} attribute and has an allocation status of allocated, the
allocated variable is flushed; otherwise the allocation status is flushed.
\end{fortranspecific}

\begin{note}
Use of a \code{flush} construct with a list is extremely error prone and users are
strongly discouraged from attempting it. The following examples illustrate the ordering
properties of the flush operation. In the following incorrect pseudocode example, the
programmer intends to prevent simultaneous execution of the protected section by the
two threads, but the program does not work properly because it does not enforce the
proper ordering of the operations on variables \code{a} and \code{b}. Any shared data accessed in the
protected section is not guaranteed to be current or consistent during or after the
protected section. The atomic notation in the pseudocode in the following two examples
indicates that the accesses to \code{a} and \code{b} are \code{ATOMIC} writes and captures. Otherwise both
examples would contain data races and automatically result in unspecified behavior.

% Outlined mixed code and text:

\parbox{\linewidth}{%
\begin{spacing}{0.90}\begin{framed}
\emph{Incorrect example:}\\
\hspace{0.3\textwidth}\code{a = b = 0}
\begin{tabular}{ p{0.5\textwidth} p{0.5\textwidth}}\\
\hspace{0.1\textwidth}{\splc{thread 1}} & \hspace{0.1\textwidth}{\splc{thread 2}}\\[1.0em]
{\scode{atomic(b = 1)}} & {\scode{atomic(a = 1)}}\\
{\splc{flush}\scode{(b)}} & {\splc{flush}\scode{(a)}}\\
{\splc{flush}\scode{(a)}} & {\splc{flush}\scode{(b)}}\\
{\scode{atomic(tmp = a)}} & {\scode{atomic(tmp = b)}}\\
{\scode{if (tmp == 0) then}} & {\scode{if (tmp == 0) then}}\\
\hspace{1.25em}{\splc{protected section}} & \hspace{1.25em}{\splc{protected section}}\\
{\scode{end if}} & {\scode{end if}}\\
\end{tabular}
\end{framed}\end{spacing}} % use \parbox to keep the lines together for code only

The problem with this example is that operations on variables \code{a} and \code{b} are not ordered
with respect to each other. For instance, nothing prevents the compiler from moving the
flush of \code{b} on thread 1 or the flush of \code{a} on thread 2 to a position completely after the
protected section (assuming that the protected section on thread 1 does not reference \code{b} and
the protected section on thread 2 does not reference \code{a}). If either re-ordering happens, both
threads can simultaneously execute the protected section.

The following pseudocode example correctly ensures that the protected section is executed
by not more than one of the two threads at any one time. Execution of the
protected section by neither thread is considered correct in this example. This occurs if
both flushes complete prior to either thread executing its \code{if} statement.

\parbox{\linewidth}{%
\begin{spacing}{0.95}\begin{framed}
\emph{Correct example:}\\
\hspace{0.3\textwidth}\code{a = b = 0}
\begin{tabular}{ p{0.5\textwidth} p{0.5\textwidth}}\\
\hspace{0.1\textwidth}{\splc{thread 1}} & \hspace{0.1\textwidth}{\splc{thread 2}}\\[1.0em]
{\scode{atomic(b = 1)}} & {\scode{atomic(a = 1)}}\\
{\splc{flush}\scode{(a,b)}} & {\splc{flush}\scode{(a,b)}}\\
{\scode{atomic(tmp = a)}} & {\scode{atomic(tmp = b)}}\\
{\scode{if (tmp == 0) then}} & {\scode{if (tmp == 0) then}}\\
\hspace{1.25em}{\splc{protected section}} & \hspace{1.25em}{\splc{protected section}}\\
{\scode{end if}} & {\scode{end if}}\\
\end{tabular}
\end{framed}\end{spacing}} % use \parbox to keep lines together for code only
\bigskip

The compiler is prohibited from moving the flush at all for either thread, ensuring that the
respective assignment is complete and the data is flushed before the \code{if} statement is
executed.
\end{note}
\bigskip

Flush operations implied when executing an \code{atomic} region are described in
Section \ref{subsec:atomic Construct}.

A \code{flush} region arising from a \code{flush} directive without a list and
without \plc{memory-order-clause} present is implied at the following locations:
\begin{itemize}
\item During a barrier region.
\item At entry to a \code{target update} region whose corresponding construct has a \code{to} clause.
\item At exit from a \code{target update} region whose corresponding construct has a \code{from} clause.
\item At entry to and exit from \code{parallel}, \code{critical}, \code{target} and \code{target data} regions.
\item At entry to and exit from an \code{ordered} region, if a \code{threads} clause or a \code{depend} clause is present, or if no clauses are present.
\item At entry to a \code{target enter data} region.
\item At exit from a \code{target exit data} region.
\item At exit from worksharing regions unless a \code{nowait} is present.
\item During \code{omp_set_lock} and \code{omp_unset_lock} regions.
\item During \code{omp_test_lock}, \code{omp_set_nest_lock}, \code{omp_unset_nest_lock}
and \code{omp_test_nest_lock} regions, if the region causes the lock to be set or unset.
\item Immediately before and immediately after every task scheduling point.
\item During a \code{cancel} or \code{cancellation point} region, if the \plc{cancel-var} ICV is \plc{true} and cancellation has been activated.
\end{itemize}

\begin{note}
A \code{flush} region is not implied at the following locations:

\begin{itemize}
\item At entry to worksharing regions.

\item At entry to or exit from a \code{master} region.
\end{itemize}
\end{note}

\events

The \plc{flush} event occurs in a thread encountering the
\code{flush} construct.

\tools

A thread dispatches a registered \code{ompt_callback_flush} callback
for each occurrence of a \plc{flush} event in that thread. This
callback has the type signature \code{ompt_callback_flush_t}.

\restrictions

The following restrictions apply to the \code{flush} construct:

\begin{itemize}
\item If \plc{memory-order-clause} is \code{release}, \code{acquire}, or
    \code{acq_rel}, list items must not be specified on the \code{flush} directive.
\end{itemize}

\crossreferences
\begin{itemize}
\item \code{ompt_callback_flush_t}, see
\specref{sec:ompt_callback_flush_t}.
\end{itemize}





\subsection{\hcode{ordered} Construct}
\index{ordered@{\code{ordered}}}
\index{constructs!ordered@{\code{ordered}}}
\label{subsec:ordered Construct}
\summary
The \code{ordered} construct either specifies a structured block in a loop,
\code{simd}, or loop SIMD region that will be executed in the order of the
loop iterations, or it is a stand-alone directive that specifies
cross-iteration dependences in a doacross loop nest. The \code{ordered}
construct sequentializes and orders the execution of \code{ordered} regions
while allowing code outside the region to run in parallel.

\begin{samepage}
\syntax
\begin{ccppspecific}
The syntax of the \code{ordered} construct is as follows:

\begin{ompcPragma}
#pragma omp ordered \plc{[clause[ [},\plc{] clause] ]} \plc{new-line}
   \plc{structured-block}
\end{ompcPragma}

where \plc{clause} is one of the following:
\begin{indentedcodelist}
threads
simd
\end{indentedcodelist}

or

\begin{ompcPragma}
#pragma omp ordered \plc{clause [[[},\plc{] clause] ... ]} \plc{new-line}
\end{ompcPragma}
where \plc{clause} is one of the following:
\begin{indentedcodelist}
depend(source)
depend(sink : \plc{vec})
\end{indentedcodelist}


\end{ccppspecific}
\end{samepage}

\begin{fortranspecific}
The syntax of the \code{ordered} construct is as follows:

\begin{ompfPragma}
!$omp ordered \plc{[clause[ [},\plc{] clause] ]}
    \plc{structured-block}
!$omp end ordered
\end{ompfPragma}

where \plc{clause} is one of the following:
\begin{indentedcodelist}
threads
simd
\end{indentedcodelist}

or

\begin{ompfPragma}
!$omp ordered \plc{clause [[[},\plc{] clause] ... ]}
\end{ompfPragma}

where \plc{clause} is one of the following:
\begin{indentedcodelist}
depend(source)
depend(sink : \plc{vec})
\end{indentedcodelist}
\end{fortranspecific}

If the \code{depend} clause is specified, the \code{ordered} construct is a stand-alone directive.

\binding
The binding thread set for an \code{ordered} region is the current team. An \code{ordered} region
binds to the innermost enclosing \code{simd} or loop SIMD region if the
\code{simd} clause is present, and otherwise it binds to the innermost
enclosing loop region. \code{ordered} regions that bind to different regions
execute independently of each other.

\descr
If no clause is specified, the \code{ordered} construct behaves as if the
\code{threads} clause had been specified. If the \code{threads} clause is
specified, the threads in the team executing the loop region execute
\code{ordered} regions sequentially in the order of the loop iterations.
If any \code{depend} clauses are specified then those clauses specify the
order in which the threads in the team execute \code{ordered} regions. If
the \code{simd} clause is specified, the \code{ordered} regions encountered by
any thread will use only a single SIMD lane to execute the \code{ordered}
regions in the order of the loop iterations.

When the thread executing the first iteration of the loop encounters an
\code{ordered} construct, it can enter the \code{ordered} region without
waiting. When a thread executing any subsequent iteration encounters an
\code{ordered} construct without a \code{depend} clause, it waits at the
beginning of the \code{ordered} region until execution of all \code{ordered}
regions belonging to all previous iterations has completed. When a thread
executing any subsequent iteration encounters an \code{ordered} construct with
one or more {\pcode{depend(sink:\plc{vec})}} clauses, it waits until its dependences on
all valid iterations specified by the \code{depend} clauses
are satisfied before it completes execution of the \code{ordered} region.
A specific dependence is satisfied when a thread executing the corresponding
iteration encounters an \code{ordered} construct with a \code{depend(source)} clause.

\omptMutex{ordered}{an}


\restrictions
Restrictions to the \code{ordered} construct are as follows:

\begin{itemize}
\item At most one \code{threads} clause can appear on an \code{ordered} construct.

\item At most one \code{simd} clause can appear on an \code{ordered} construct.

\item At most one \code{depend(source)} clause can appear on an \code{ordered} construct.

\item Either {\pcode{depend(sink:\plc{vec})}} clauses or \code{depend(source)}
clauses may appear on an \code{ordered} construct, but not both.

\item The loop or loop SIMD region to which an \code{ordered}
region arising from an \code{ordered} construct without a \code{depend}
clause binds must have an \code{ordered} clause without the parameter
specified on the corresponding loop or loop SIMD directive.

\item The loop region to which an \code{ordered} region arising from an
\code{ordered} construct with any \code{depend}
clauses binds must have an \code{ordered} clause with the parameter specified
on the corresponding loop directive.

\item An \code{ordered} construct with the \code{depend} clause specified must
be closely nested inside a loop (or parallel loop) construct.

\item An \code{ordered} region arising from an \code{ordered} construct with
the \code{simd} clause specified must be closely nested inside a
\code{simd} or loop SIMD region.

\item An \code{ordered} region arising from an \code{ordered} construct with
  both the \code{simd} and \code{threads} clauses must be closely nested inside
  a loop SIMD region.

\item During execution of an iteration of a loop or a loop nest within a loop, \code{simd}, or loop SIMD
region, a thread must not execute more than one \code{ordered} region arising
from an \code{ordered} construct without a \code{depend} clause.
\end{itemize}
\begin{cppspecific}
\begin{itemize}
\item A throw executed inside a \code{ordered} region must cause execution to
resume within the same \code{ordered} region, and the same thread that threw
the exception must catch it.
\end{itemize}
\end{cppspecific}



\crossreferences
\begin{itemize}
\item loop construct, see
\specref{subsec:Loop Construct}.

\item \code{simd} construct, see
\specref{subsec:simd Construct}.

\item parallel loop construct, see
\specref{subsec:Parallel Loop Construct}.

\item \code{depend} Clause, see
\specref{subsec:depend Clause}

\item \code{ompt_mutex_ordered}, see
\specref{sec:ompt_mutex_t}.

\item \code{ompt_callback_mutex_acquire_t}, see
\specref{sec:ompt_callback_mutex_acquire_t}.

\item \code{ompt_callback_mutex_t}, see
\specref{sec:ompt_callback_mutex_t}.

\end{itemize}


\subsection{\hcode{depend} Clause}
\index{depend@{\code{depend}}}
\index{clauses!depend@{\code{depend}}}
\label{subsec:depend Clause}
\summary
The \code{depend} clause enforces additional constraints on the scheduling of tasks or loop iterations.  These
constraints establish dependences only between sibling tasks or between loop iterations.

\syntax
The syntax of the \code{depend} clause is as follows:

\begin{ompSyntax}
depend(\plc{dependence-type }:\plc{ locator-list}[:\plc{iterators-definition}])
\end{ompSyntax}

where \plc{dependence-type} is one of the following:
\begin{indentedcodelist}
in
out
inout
mutexinoutset
\end{indentedcodelist}

or

\begin{ompSyntax}
depend(\plc{dependence-type})
\end{ompSyntax}

where \plc{dependence-type} is:
\begin{indentedcodelist}
source
\end{indentedcodelist}

or

\begin{ompSyntax}
depend(\plc{dependence-type} : \plc{vec})
\end{ompSyntax}

where \plc{dependence-type} is:
\begin{indentedcodelist}
sink
\end{indentedcodelist}

and where \plc{vec} is the iteration vector, which has the form:

x\textsubscript{1} [$\pm $ d\textsubscript{1}], x\textsubscript{2} [$\pm $ d\textsubscript{2}], \ldots, x\textsubscript{\plc{n}} [$\pm $ d\textsubscript{\plc{n}}]

where \plc{n} is the value specified by the \code{ordered} clause in the loop
directive, x\textsubscript{\plc{i}} denotes the loop iteration variable of the \plc{i}-th
nested loop associated with the loop directive, and d\textsubscript{\plc{i}} is a
constant non-negative integer.

\descr
Task dependences are derived from the \plc{dependence-type} of a \code{depend} clause and its list
items when \plc{dependence-type} is \code{in}, \code{out}, \code{inout}, or \code{mutexinoutset}.

For the \code{in} \plc{dependence-type}, if the storage location of at least one
of the list items is the same as the storage location of a list item appearing
in a \code{depend} clause with an \code{out}, \code{inout}, or \code{mutexinoutset} \plc{dependence-type} on a construct
from which a sibling task was previously generated, then the generated task
will be a dependent task of that sibling task.

For the \code{out} and \code{inout} \plc{dependence-types}, if the storage location of at least one
of the list items is the same as the storage location of a list item appearing
in a \code{depend} clause with an \code{in}, \code{out}, \code{inout}, or \code{mutexinoutset} \plc{dependence-type} on
a construct from which a sibling task was previously generated, then the
generated task will be a dependent task of that sibling task.

For the \code{mutexinoutset} \plc{dependence-type}, if the storage location of at least one
of the list items is the same as the storage location of a list item appearing
in a \code{depend} clause with an \code{in}, \code{out}, or \code{inout} \plc{dependence-type} on
a construct from which a sibling task was previously generated, then the
generated task will be a dependent task of that sibling task.

If a list item appearing in a \code{depend} clause with a \code{mutexinoutset}
\plc{dependence-type} on a task-generating construct has the same storage location as
a list item appearing in a \code{depend} clause with a \code{mutexinoutset}
\plc{dependence-type} on a different task generating construct, and both constructs
generate sibling tasks, the sibling tasks will be mutually exclusive tasks.

The list items that appear in the \code{depend} clause may reference iterators
defined by an \plc{iterators-definition} appearing on the same clause.

\begin{fortranspecific}
If a list item has the \code{ALLOCATABLE} attribute and its allocation
status is unallocated, the behavior is unspecified. If a list item has
the \code{POINTER} attribute and its association status is
disassociated or undefined, the behavior is unspecified.
\end{fortranspecific}

The list items that appear in the \code{depend} clause may include array sections.

\begin{note}
The enforced task dependence establishes a synchronization of memory
accesses performed by a dependent task with respect to accesses performed by the
predecessor tasks. However, it is the responsibility of the programmer to synchronize properly with respect to other concurrent accesses that occur outside of those tasks.
\end{note}

The \code{source} \plc{dependence-type} specifies the satisfaction of
cross-iteration dependences that arise from the current iteration.

The \code{sink} \plc{dependence-type} specifies a cross-iteration dependence,
where the iteration vector \plc{vec} indicates the iteration that satisfies
the dependence.

If the iteration vector \plc{vec} does not occur in the iteration space,
the \code{depend} clause is ignored.  If all \code{depend} clauses on an
\code{ordered} construct are ignored then the construct is ignored.

\begin{note}
If the iteration vector \plc{vec} does not indicate a lexicographically earlier iteration, it can cause a deadlock.
\end{note}

\events

The \plc{task-dependences} event occurs in a thread encountering a
tasking construct with a \code{depend} clause immediately after the
\plc{task-create} event for the new task.

The \plc{task-dependence} event indicates an unfulfilled dependence for the generated task.
This event occurs in a thread that observes the unfulfilled dependence before it is satisfied.
%unfulfilled dependence... already implies that if the dependence is satisfied (not unfulfilled)
% then there is no events... so can skip the sentence below.
%A dependence will not cause an event if the
%dependence producing task finishes before a dependence consuming task is created.

\tools

A thread dispatches the \code{ompt_callback_task_dependences} callback
for each occurrence of the \plc{task-dependences} event to
announce its dependences with respect to the list items in the \code{depend} clause.
This callback has type signature
\code{ompt_callback_task_dependences_t}.

A thread dispatches the \code{ompt_callback_task_dependence}
callback for a \plc{task-dependence} event to report a
dependence between a predecessor task  (\plc{src_task_data}) and a dependent task
(\plc{sink_task_data}).  This callback has type signature
\code{ompt_callback_task_dependence_t}.

\restrictions
Restrictions to the \code{depend} clause are as follows:

\begin{itemize}
\item List items used in \code{depend} clauses of the same task or sibling tasks must indicate
identical storage locations or disjoint storage locations.

\item List items used in \code{depend} clauses cannot be zero-length array sections.

\begin{fortranspecific}
\item A common block name cannot appear in a \code{depend} clause.
\end{fortranspecific}

\item For a \plc{vec} element of \code{sink} \plc{dependence-type} of the form
x\textsubscript{i} $+$ d\textsubscript{i} or x\textsubscript{i} $-$ d\textsubscript{i} if the loop iteration variable
x\textsubscript{i} has an integral or pointer type, the expression x\textsubscript{i} $+$ d\textsubscript{i} or
x\textsubscript{i} $-$ d\textsubscript{i} for any value of the loop iteration variable x\textsubscript{i} that
can encounter the \code{ordered} construct must be computable in the
loop iteration variable's type without overflow.

\begin{cppspecific}
\item For a \plc{vec} element of \code{sink} \plc{dependence-type} of the form
x\textsubscript{i} $+$ d\textsubscript{i} or x\textsubscript{i} $-$ d\textsubscript{i} if the loop iteration variable
x\textsubscript{i} is of a random access iterator type other than pointer type,
the expression $($ x\textsubscript{i} - lb\textsubscript{i} $)$ $+$ d\textsubscript{i} or
$($ x\textsubscript{i} - lb\textsubscript{i} $)$ $-$ d\textsubscript{i} for any value of the loop iteration variable
x\textsubscript{i} that can encounter the \code{ordered} construct must be computable in the
type that would be used by \plc{std::distance} applied to variables of the
type of x\textsubscript{i} without overflow.
\end{cppspecific}

\begin{ccppspecific}
\item A bit-field cannot appear in a \code{depend} clause.
\end{ccppspecific}

\end{itemize}

\crossreferences
\begin{itemize}
\item Array sections, see
\specref{sec:Array Sections}.

\item \code{task} construct, see
\specref{subsec:task Construct}.

\item \code{target}~\code{enter}~\code{data} construct, see
\specref{subsec:target enter data Construct}.

\item \code{target}~\code{exit}~\code{data} construct, see
\specref{subsec:target exit data Construct}.

\item \code{target} construct, see
\specref{subsec:target Construct}.

\item \code{target}~\code{update} construct, see
\specref{subsec:target update Construct}.

\item Task scheduling constraints, see
\specref{subsec:Task Scheduling}.

\item \code{ordered} construct, see
\specref{subsec:ordered Construct}.

\item Iterators, see
\specref{sec:iterators}.

\item \code{ompt_callback_task_dependences_t}, see
\specref{sec:ompt_callback_task_dependences_t}.

\item \code{ompt_callback_task_dependence_t}, see
\specref{sec:ompt_callback_task_dependence_t}.
\end{itemize}

\subsection{Synchronization Hints}
\index{synchronization hints}
\index{clauses!hint@{\code{hint}}}
\label{subsec:Synchronization Hints}
Hints about the expected dynamic behavior or suggested implementation
can be provided by the programmer to locks (by using
the \code{omp_init_lock_with_hint} or
\code{omp_init_nest_lock_with_hint} functions to initialize the lock), and to
\code{atomic} and \code{critical} directives by using the \code{hint}
clause.  The effect of a hint is implementation defined. The OpenMP
implementation is free to ignore the hint since doing so cannot change
program semantics.

The C/C++ header file (\code{omp.h}) and the Fortran include file (\code{omp_lib.h}) and/or Fortran~90 module file (\code{omp_lib}) define the valid hint constants.
The valid constants must include the following, which can be extended with implementation-defined values:

\begin{ccppspecific}
\begin{ompcEnum}
typedef enum omp_sync_hint_t {
  omp_sync_hint_none = 0,
  omp_lock_hint_none = omp_sync_hint_none,
  omp_sync_hint_uncontended = 1,
  omp_lock_hint_uncontended = omp_sync_hint_uncontended,
  omp_sync_hint_contended = 2,
  omp_lock_hint_contended = omp_sync_hint_contended,
  omp_sync_hint_nonspeculative = 4,
  omp_lock_hint_nonspeculative = omp_sync_hint_nonspeculative,
  omp_sync_hint_speculative = 8
  omp_lock_hint_speculative = omp_sync_hint_speculative
} omp_sync_hint_t;

typedef omp_sync_hint_t omp_lock_hint_t;
\end{ompcEnum}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfEnum}
integer, parameter :: omp_lock_hint_kind = omp_sync_hint_kind

integer (kind=omp_sync_hint_kind), &
  parameter :: omp_sync_hint_none = 0
integer (kind=omp_lock_hint_kind), &
  parameter :: omp_lock_hint_none = omp_sync_hint_none
integer (kind=omp_sync_hint_kind), &
  parameter :: omp_sync_hint_uncontended = 1
integer (kind=omp_lock_hint_kind), &
  parameter :: omp_lock_hint_uncontended = &
                    omp_sync_hint_uncontended
integer (kind=omp_sync_hint_kind), &
  parameter :: omp_sync_hint_contended = 2
integer (kind=omp_lock_hint_kind), &
  parameter :: omp_lock_hint_contended = &
                   omp_sync_hint_contended
integer (kind=omp_sync_hint_kind), &
  parameter :: omp_sync_hint_nonspeculative = 4
integer (kind=omp_lock_hint_kind), &
  parameter :: omp_lock_hint_nonspeculative = &
                   omp_sync_hint_nonspeculative
integer (kind=omp_sync_hint_kind), &
  parameter :: omp_sync_hint_speculative = 8
integer (kind=omp_lock_hint_kind), &
  parameter :: omp_lock_hint_speculative = &
                   omp_sync_hint_speculative
\end{ompfEnum}
\end{fortranspecific}

The hints can be combined by using the \code{+} or \code{|} operators in C/C++ or the \code{+} operator in Fortran.
The effect of the combined hint is implementation defined and can be ignored by the implementation.
Combining \code{omp_sync_hint_none} with any other hint is equivalent to specifying the other hint.
The following restrictions apply to combined hints; violating these
restrictions results in unspecified behavior:
\begin{itemize}
\item the hints \code{omp_sync_hint_uncontended} and \code{omp_sync_hint_contended} cannot be combined,
\item the hints \code{omp_sync_hint_nonspeculative} and \code{omp_sync_hint_speculative} cannot be combined.
\end{itemize}
The rules for combining multiple values of \code{omp_sync_hint} apply equally to the
corresponding values of \code{omp_lock_hint}, and expressions mixing the two types.

The intended meaning of hints is
\begin{itemize}
\item \code{omp_sync_hint_uncontended}: low contention is expected in this operation, that is,
few threads are expected to be performing the operation simultaneously in a manner that requires synchronization.
\item \code{omp_sync_hint_contended}: high contention is expected in this operation, that is,
many threads are expected to be performing the operation simultaneously in a manner that requires synchronization.
\item \code{omp_sync_hint_speculative}: the programmer suggests that the operation should be implemented using
speculative techniques such as transactional memory.
\item \code{omp_sync_hint_nonspeculative}: the programmer suggests that the operation should not be
implemented using speculative techniques such as transactional memory.
\end{itemize}

\begin{note}
Future OpenMP specifications may add additional hints to the
\code{omp_sync_hint_t} type and the \code{omp_sync_hint_kind} kind.
Implementers are advised to add implementation-defined hints starting from
the most significant bit of the \code{omp_sync_hint_t} type and
\code{omp_sync_hint_kind} kind and to include the name of the
implementation in the name of the added hint to avoid name conflicts
with other OpenMP implementations.
\end{note}

The \code{omp_sync_hint_t} and \code{omp_lock_hint_t} enumeration types and the equivalent types in Fortran
are synonyms for each other.
The type \code{omp_lock_hint_t} has been deprecated.

\crossreferences
\begin{itemize}
\item \code{atomic} construct, see
\specref{subsec:atomic Construct}

\item \code{critical} construct, see
\specref{subsec:critical Construct}.
\item \code{omp_init_lock_with_hint} and
  \code{omp_init_nest_lock_with_hint}, see
\specref{subsec:omp_init_lock_with_hint and omp_init_nest_lock_with_hint}.
\end{itemize}
