% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. There are environments that provide special formatting, e.g. language bars.
%       Please use them whereever appropriate.  Examples are:
%
%         \begin{fortranspecific}
%         This is text that appears enclosed in blue language bars for Fortran.
%         \end{fortranspecific}
%
%         \begin{note}
%         This is a note.  The "Note -- " header appears automatically.
%         \end{note}
%
%    6. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%

\section{\code{master} Construct}
\index{master@{\code{master}}}
\index{constructs!master@{\code{master}}}
\label{sec:master}
\summary
The \code{master} construct specifies a structured block that is executed by 
the master thread of the team.

\syntax
\begin{ccppspecific}
The syntax of the \code{master} construct is as follows:

\begin{ompcPragma}
#pragma omp master \plc{new-line}
   \plc{structured-block}
\end{ompcPragma}
\end{ccppspecific}

\begin{fortranspecific}
The syntax of the \code{master} construct is as follows:

\begin{ompfPragma}
!$omp master
   \plc{structured-block}
!$omp end master
\end{ompfPragma}
\end{fortranspecific}

\binding
The binding thread set for a \code{master} region is the current team. 
A \code{master} region binds to the innermost enclosing \code{parallel} region. 

\descr
Only the master thread of the team that executes the binding \code{parallel} region
participates in the execution of the structured block of the \code{master} region.
Other threads in the team do not execute the associated structured block. There is no
implied barrier either on entry to, or exit from, the \code{master} construct.

\events

The \plc{master-begin} event occurs in the master thread of a team that 
encounters \code{master} construct on entry to the master region.

The \plc{master-end} event occurs in the master thread of a team that 
encounters the \code{master} construct on exit from the master region.

\tools

A thread dispatches a registered \code{ompt_callback_master} callback 
with \code{ompt_scope_begin} as its \plc{endpoint} argument for each 
occurrence of a \plc{master-begin} event in that thread. Similarly, a
thread dispatches a registered \code{ompt_callback_master} callback 
with \code{ompt_scope_end} as its \plc{endpoint} argument for each 
occurrence of a \plc{master-end} event in that thread. These callbacks 
occur in the context of the task executed by the master thread and have
the type signature \code{ompt_callback_master_t}. 

\restrictions
\begin{cppspecific}
\begin{itemize}
\item A throw executed inside a \code{master} region must cause execution 
      to resume within the same \code{master} region, and the same thread 
      that threw the exception must catch it
\end{itemize}
\end{cppspecific}

\crossreferences
\begin{itemize}
\item \code{parallel} construct, see \specref{sec:parallel Construct}.

\item \code{ompt_scope_begin} and \code{ompt_scope_end}, see
\specref{sec:ompt_scope_endpoint_t}.

\item \code{ompt_callback_master_t}, see
\specref{sec:ompt_callback_master_t}.


\end{itemize}

\section{Synchronization Constructs and Clauses}
\label{sec:Synchronization Constructs and Clauses}
\index{synchronization constructs and clauses}
\index{synchronization constructs}
A synchronization construct orders the completion of code executed by
different threads. This ordering is imposed by synchronizing flush operations
that are executed as part of the region that corresponds to the construct.

Synchronization through the use of synchronizing flush operations and atomic
operations is described in \specref{subsec:The Flush Operation} and 
\specref{subsec:OpenMP Memory Consistency}. \specref{subsec:implicit flushes}
defines the behavior of synchronizing flush operations that are
implied at various other locations in an OpenMP program.

\subsection{\hcode{critical} Construct}
\index{critical@{\code{critical}}}
\index{constructs!critical@{\code{critical}}}
\label{subsec:critical Construct}
\summary
The \code{critical} construct restricts execution of the associated structured block to a
single thread at a time.

\syntax
\begin{ccppspecific}
The syntax of the \code{critical} construct is as follows:

\begin{ompcPragma}
  #pragma omp critical \plc{[}(\plc{name}) \plc{[[},\plc{]} hint(\plc{hint-expression})\plc{] ] new-line}
    \plc{structured-block}
\end{ompcPragma}

where \plc{hint-expression} is an integer constant expression that
evaluates to a valid synchronization hint (as described in~\specref{subsec:Synchronization Hints}).
\end{ccppspecific}

\begin{fortranspecific}
The syntax of the \code{critical} construct is as follows:

\begin{ompfPragma}
!$omp critical \plc{[}(\plc{name}) \plc{[[},\plc{]} hint(\plc{hint-expression})\plc{] ]}
    \plc{structured-block}
!$omp end critical \plc{[}(\plc{name})\plc{]}
\end{ompfPragma}

where \plc{hint-expression} is a constant expression that evaluates to
a scalar value with kind \code{omp_sync_hint_kind} and  a value
that is a valid synchronization hint (as described
in~\specref{subsec:Synchronization Hints}).
\end{fortranspecific}

\binding
The binding thread set for a \code{critical} region is all threads in the contention group.

\descr
The region that corresponds to a \code{critical} construct is executed as if only 
a single thread at a time among all threads in the contention group enters the 
region for execution, without regard to the team(s) to which the threads belong.
An optional \plc{name} may be used to identify the \code{critical} construct. All 
\code{critical} constructs without a name are considered to have the same 
unspecified name.

\begin{ccppspecific}
Identifiers used to identify a \code{critical} construct have external linkage and are in a
name space that is separate from the name spaces used by labels, tags, members, and
ordinary identifiers.
\end{ccppspecific}

\begin{fortranspecific}
The names of \code{critical} constructs are global entities of the program. If a name
conflicts with any other entity, the behavior of the program is unspecified.
\end{fortranspecific}

The threads of a contention group execute the \code{critical} region as if only one 
thread of the contention group executes the \code{critical} region at a time.
The \code{critical} construct enforces these execution semantics with respect to all 
\code{critical} constructs with the same name in all threads in the contention group.

If present, the \code{hint} clause gives the implementation additional
information about the expected runtime properties of the \code{critical} region
that can optionally be used to optimize the implementation.
The presence of a \code{hint} clause does not affect the isolation
guarantees provided by the \code{critical} construct. If no \code{hint} 
clause is specified, the effect is as if \code{hint(omp_sync_hint_none)}
had been specified.

\events
The \plc{critical-acquiring} event occurs in a thread that encounters the
\code{critical} construct on entry to the \code{critical} region before
initiating synchronization for the region.

The \plc{critical-acquired} event occurs in a thread that encounters the
\code{critical} construct after it enters the region, but before it executes 
the structured block of the \code{critical} region.

The \plc{critical-released} event occurs in a thread that encounters the
\code{critical} construct after it completes any synchronization on exit 
from the \code{critical} region.

\tools
A thread dispatches a registered \code{ompt_callback_mutex_acquire}
callback for each occurrence of a \plc{critical-acquiring} event
in that thread.
This callback has the type signature \code{ompt_callback_mutex_acquire_t}.

A thread dispatches a registered \code{ompt_callback_mutex_acquired}
callback for each occurrence of a \plc{critical-acquired} event
in that thread.  This callback has the type signature \code{ompt_callback_mutex_t}.

A thread dispatches a registered \code{ompt_callback_mutex_released}
callback for each occurrence of a \plc{critical-released} event
in that thread.  This callback has the type signature \code{ompt_callback_mutex_t}.

The callbacks occur in the task that encounters the critical construct. The 
callbacks should receive \code{ompt_mutex_critical} as their \plc{kind} argument 
if practical, but a less specific kind is acceptable.

\restrictions
The following restrictions apply to the critical construct:

\begin{itemize}
\item Unless the effect is as if \code{hint}(\code{omp_sync_hint_none}) was 
      specified, the \code{critical} construct must specify a name.
\item If the \code{hint} clause is specified, each of the \code{critical} 
      constructs with the same \plc{name} must have a \code{hint} clause 
      for which the \plc{hint-expression} evaluates to the same value.
\end{itemize}

\begin{cppspecific}
\begin{itemize}
\item A throw executed inside a \code{critical} region must cause execution 
      to resume within the same \code{critical} region, and the same thread 
      that threw the exception must catch it.
\end{itemize}
\end{cppspecific}

\begin{fortranspecific}
\begin{itemize}
\item If a \plc{name} is specified on a \code{critical} directive, the same 
      \plc{name} must also be specified on the \code{end}~\code{critical} directive.
\item If no \plc{name} appears on the \code{critical} directive, no \plc{name} 
      can appear on the \code{end}~\code{critical} directive.
\end{itemize}
\end{fortranspecific}

\crossreferences
\begin{itemize}
\item Synchronization Hints, see
\specref{subsec:Synchronization Hints}.

\item \code{ompt_mutex_critical}, see
\specref{sec:ompt_mutex_t}.

\item \code{ompt_callback_mutex_acquire_t}, see
\specref{sec:ompt_callback_mutex_acquire_t}.

\item \code{ompt_callback_mutex_t}, see
\specref{sec:ompt_callback_mutex_t}.
\end{itemize}



\subsection{\hcode{barrier} Construct}
\index{barrier@{\code{barrier}}}
\index{constructs!barrier@{\code{barrier}}}
\label{subsec:barrier Construct}
\summary
The \code{barrier} construct specifies an explicit barrier at the point at which 
the construct appears. The \code{barrier} construct is a stand-alone directive.

\syntax
\begin{ccppspecific}
The syntax of the \code{barrier} construct is as follows:

\begin{ompcPragma}
#pragma omp barrier \plc{new-line}
\end{ompcPragma}
\end{ccppspecific}

\begin{fortranspecific}
The syntax of the \code{barrier} construct is as follows:

\begin{ompfPragma}
!$omp barrier
\end{ompfPragma}
\end{fortranspecific}

\binding
The binding thread set for a \code{barrier} region is the current team. A 
\code{barrier} region binds to the innermost enclosing \code{parallel} region.

\descr
All threads of the team that is executing the binding \code{parallel} region must 
execute the \code{barrier} region and complete execution of all explicit tasks 
bound to this \code{parallel} region before any are allowed to continue execution 
beyond the barrier.

The \code{barrier} region includes an implicit task scheduling point in the current 
task region.

\events

The \plc{explicit-barrier-begin} event occurs in each thread that encounters the
\code{barrier} construct on entry to the \code{barrier} region.

The \plc{explicit-barrier-wait-begin} event occurs when a task begins an interval 
of active or passive waiting in a \code{barrier} region.

The \plc{explicit-barrier-wait-end} event occurs when a task ends an interval of 
active or passive waiting and resumes execution in a \code{barrier} region.

The \plc{explicit-barrier-end} event occurs in each thread that encounters the
\code{barrier} construct after the barrier synchronization on exit from the
\code{barrier} region.

A \plc{cancellation} event occurs if cancellation is activated at an implicit 
cancellation point in a \code{barrier} region.

\tools

A thread dispatches a registered \code{ompt_callback_sync_region}
callback with \code{ompt_sync_region_barrier_explicit} --- or
\code{ompt_sync_region_barrier}, if the implementation cannot make a
distinction --- as its \plc{kind} argument and \code{ompt_scope_begin} 
as its \plc{endpoint} argument for each occurrence of an \plc{explicit-barrier-begin} 
event in the task that encounters the \code{barrier} construct. Similarly, 
a thread dispatches a registered \code{ompt_callback_sync_region} callback 
with \code{ompt_sync_region_barrier_explicit} --- or \code{ompt_sync_region_barrier}, 
if the implementation cannot make a distinction --- as its \plc{kind} argument 
and \code{ompt_scope_end} as its \plc{endpoint} argument for each  occurrence 
of an \plc{explicit-barrier-end} event in the task that encounters the 
\code{barrier} construct. These callbacks occur in the task that encounters 
the \code{barrier} construct and have the type signature 
\code{ompt_callback_sync_region_t}.

A thread dispatches a registered \code{ompt_callback_sync_region_wait} callback
with \code{ompt_sync_region_barrier_explicit} --- or \code{ompt_sync_region_barrier}, 
if the implementation cannot make a distinction --- as its \plc{kind} argument and
\code{ompt_scope_begin} as its \plc{endpoint} argument for each occurrence of 
an \plc{explicit-barrier-wait-begin} event. Similarly, a thread dispatches a 
registered \code{ompt_callback_sync_region_wait} callback with 
\code{ompt_sync_region_barrier_explicit} --- or \code{ompt_sync_region_barrier}, 
if the implementation cannot make a distinction --- as its \plc{kind} argument and
\code{ompt_scope_end} as its \plc{endpoint} argument for each occurrence of an 
\plc{explicit-barrier-wait-end} event. These callbacks occur in the context of 
the task that encountered the \code{barrier} construct and have type signature 
\code{ompt_callback_sync_region_t}.

A thread dispatches a registered \code{ompt_callback_cancel} callback with 
\code{ompt_cancel_detected} as its \plc{flags} argument for each occurrence 
of a \plc{cancellation} event in that thread. The callback occurs in the 
context of the encountering task. The callback has type signature
\code{ompt_callback_cancel_t}. 

\restrictions
The following restrictions apply to the \code{barrier} construct:

\begin{itemize}
\item Each \code{barrier} region must be encountered by all threads in a team 
      or by none at all, unless cancellation has been requested for the innermost 
      enclosing parallel region.
\item The sequence of worksharing regions and \code{barrier} regions encountered 
      must be the same for every thread in a team.
\end{itemize}

\crossreferences
\begin{itemize}
\item \code{ompt_scope_begin} and \code{ompt_scope_end}, see
\specref{sec:ompt_scope_endpoint_t}.

\item \code{ompt_sync_region_barrier}, see
\specref{sec:ompt_sync_region_t}.

\item \code{ompt_callback_sync_region_t}, see
\specref{sec:ompt_callback_sync_region_t}.

\item \code{ompt_callback_cancel_t}, see
\specref{sec:ompt_callback_cancel_t}.
\end{itemize}



\subsection{Implicit Barriers}
\index{implicit barrier}
\index{barrier, implicit}
\label{subsec:implict-barrier}

This section describes the OMPT events and tool callbacks associated 
with implicit barriers, which occur at the end of various regions as
defined in the description of the constructs to which they correspond.
Implicit barriers are task scheduling points. For a description of
task sheduling points, associated events, and tool callbacks, see
\specref{subsec:Task Scheduling}.

\events

The \plc{implicit-barrier-begin} event occurs in each implicit task
at the beginning of an implicit barrier region.

The \plc{implicit-barrier-wait-begin} event occurs when a task begins an interval of
active or passive waiting in an implicit barrier region.

The \plc{implicit-barrier-wait-end} event occurs when a task ends an interval of
active or waiting and resumes execution of an implicit barrier region.

The \plc{implicit-barrier-end} event occurs in each implicit task after the
barrier synchronization on exit from an implicit barrier region.

A \plc{cancellation} event occurs if cancellation is activated at an
implicit cancellation point in an implicit barrier region.

\tools

A thread dispatches a registered \code{ompt_callback_sync_region}
callback with \code{ompt_sync_region_barrier_implicit} --- or
\code{ompt_sync_region_barrier}, if the implementation cannot make a
distinction --- as its \plc{kind} argument and \code{ompt_scope_begin} 
as its \plc{endpoint} argument for each occurrence of an \plc{implicit-barrier-begin} 
event in that thread. Similarly, a thread dispatches a registered 
\code{ompt_callback_sync_region} callback with 
\code{ompt_sync_region_barrier_implicit} --- or \code{ompt_sync_region_barrier}, 
if the implementation cannot make a distinction --- as its \plc{kind} argument 
and \code{ompt_scope_end} as its \plc{endpoint} argument for each  occurrence 
of an \plc{implicit-barrier-end} event in that thread. These callbacks occur in 
the implicit task that executes the parallel region and have the type signature 
\code{ompt_callback_sync_region_t}.

A thread dispatches a registered \code{ompt_callback_sync_region_wait} callback
with \code{ompt_sync_region_barrier_implicit} --- or \code{ompt_sync_region_barrier}, 
if the implementation cannot make a distinction --- as its \plc{kind} argument and
\code{ompt_scope_begin} as its \plc{endpoint} argument for each occurrence of 
a \plc{implicit-barrier-wait-begin} event in that thread. Similarly, a thread 
dispatches a registered \code{ompt_callback_sync_region_wait} callback with 
\code{ompt_sync_region_barrier_explicit} --- or \code{ompt_sync_region_barrier}, 
if the implementation cannot make a distinction --- as its \plc{kind} argument and
\code{ompt_scope_end} as its \plc{endpoint} argument for each occurrence of an 
\plc{implicit-barrier-wait-end} event in that thread. These callbacks occur in 
the implicit task that executes the parallel region and have type signature 
\code{ompt_callback_sync_region_t}.

A thread dispatches a registered \code{ompt_callback_cancel} callback with 
\code{ompt_cancel_detected} as its \plc{flags} argument for each occurrence 
of a \plc{cancellation} event in that thread. The callback occurs in the 
context of the encountering task. The callback has type signature
\code{ompt_callback_cancel_t}. 

\restrictions

If a thread is in the state \code{omp_state_wait_barrier_implicit_parallel}, 
a call to \code{ompt_get_parallel_info} may return a pointer to a copy of the 
data object associated with the parallel region rather than a pointer to 
the associated data object itself. Writing to the data object 
returned by \code{omp_get_parallel_info} when a thread is in the 
\code{omp_state_wait_barrier_implicit_parallel} results in unspecified behavior.

\crossreferences
\begin{itemize}

\item \code{ompt_scope_begin} and \code{ompt_scope_end}, see
  \specref{sec:ompt_scope_endpoint_t}.

\item \code{ompt_sync_region_barrier}, see
  \specref{sec:ompt_sync_region_t}

\item \code{ompt_cancel_detected}, see
  \specref{sec:ompt_cancel_flag_t}.

\item \code{ompt_callback_sync_region_t}, see
  \specref{sec:ompt_callback_sync_region_t}.

\item \code{ompt_callback_cancel_t}, see
  \specref{sec:ompt_callback_cancel_t}.
\end{itemize}



\subsection{Implementation-Specific Barriers}
\label{subsec:implementation-specific-barrier}

An OpenMP implementation can execute implementation-specific barriers 
that are not implied by the OpenMP specification; therefore, no 
\emph{execution model events} are bound to these barriers. The 
implementation can handle these barriers like implicit barriers and
dispatch all events as for implicit barriers. These callbacks 
are dispatched with \code{ompt_sync_region_barrier_implementation} --- or
\code{ompt_sync_region_barrier}, if the implementation cannot make a
distinction --- as the \plc{kind} argument.



\subsection{\hcode{taskwait} Construct}
\index{taskwait@{\code{taskwait}}}
\index{constructs!taskwait@{\code{taskwait}}}
\label{subsec:taskwait Construct}
\summary
The \code{taskwait} construct specifies a wait on the completion of child tasks
of the current task. The \code{taskwait} construct is a stand-alone directive.

\syntax
\begin{ccppspecific}
The syntax of the \code{taskwait} construct is as follows:

\begin{ompcPragma}
#pragma omp taskwait \plc{[clause[ [},\plc{] clause] ... ] new-line}
\end{ompcPragma}

where \plc{clause} is one of the following:

\begin{indentedcodelist}
depend(\plc{[depend-modifier},\plc{]dependence-type }:\plc{ locator-list})
\end{indentedcodelist}
\end{ccppspecific}

\begin{fortranspecific}
The syntax of the \code{taskwait} construct is as follows:

\begin{ompfPragma}
!$omp taskwait \plc{[clause[ [},\plc{] clause] ... ]}
\end{ompfPragma}

where \plc{clause} is one of the following:

\begin{indentedcodelist}
depend(\plc{[depend-modifier},\plc{]dependence-type }:\plc{ locator-list})
\end{indentedcodelist}

\end{fortranspecific}

\binding
The \code{taskwait} region binds to the current task region. The binding thread 
set of the \code{taskwait} region is the current team.

\descr

If no \code{depend} clause is present on the \code{taskwait} construct, the
current task region is suspended at an implicit task scheduling point
associated with the construct. The current task region remains suspended until
all child tasks that it generated before the \code{taskwait} region complete
execution.

Otherwise, if one or more \code{depend} clauses are present on the
\code{taskwait} construct, the behavior is as if these clauses were applied to
a \code{task} construct with an empty associated structured block that
generates a \emph{mergeable} and \emph{included task}. Thus, the current task region 
is suspended until the \emph{predecessor tasks} of this task complete execution.

\events

The \plc{taskwait-begin} event occurs in each thread that encounters the
\code{taskwait} construct on entry to the \code{taskwait} region.

The \plc{taskwait-wait-begin} event occurs when a task begins an interval 
of active or passive waiting in a \code{taskwait} region.

The \plc{taskwait-wait-end} event occurs when a task ends an interval of 
active or passive waiting and resumes execution in a \code{taskwait} region.

The \plc{taskwait-end} event occurs in each thread that encounters the
\code{taskwait} construct after the taskwait synchronization on exit 
from the \code{taskwait} region.

\tools

A thread dispatches a registered \code{ompt_callback_sync_region}
callback with \code{ompt_sync_region_taskwait} as its \plc{kind} argument
and \code{ompt_scope_begin} as its \plc{endpoint} argument for each
occurrence of a \plc{taskwait-begin} event in the task that encounters
the \code{taskwait} construct. Similarly, a thread dispatches a registered
\code{ompt_callback_sync_region} callback with \code{ompt_sync_region_taskwait}
as its \plc{kind} argument and \code{ompt_scope_end} as its \plc{endpoint}
argument for each  occurrence of a \plc{taskwait-end} event in the task that
encounters the \code{taskwait} construct. These callbacks occur in the task that
encounters the \code{taskwait} construct and have the type signature
\code{ompt_callback_sync_region_t}.

A thread dispatches a registered \code{ompt_callback_sync_region_wait} callback
with \code{ompt_sync_region_taskwait} as its \plc{kind} argument and
\code{ompt_scope_begin} as its \plc{endpoint} argument for each occurrence of
a \plc{taskwait-wait-begin} event. Similarly, a thread dispatches a registered
\code{ompt_callback_sync_region_wait} callback with \code{ompt_sync_region_taskwait}
as its \plc{kind} argument and \code{ompt_scope_end} as its \plc{endpoint} argument
for each occurrence of a \plc{taskwait-wait-end} event. These callbacks occur in the
context of the task that encounters the \code{taskwait} construct and have type 
signature \code{ompt_callback_sync_region_t}.

\restrictions
The following restrictions apply to the \code{taskwait} construct:

\begin{itemize}
\item The \code{mutexinoutset} \plc{dependence-type} may not appear in a
      \code{depend} clause on a \code{taskwait} construct.
\item If the \plc{dependence-type} of a \code{depend} clause is \code{depobj}
      then the dependence  objects cannot represent dependences of the 
       \code{mutexinoutset} dependence type.
\end{itemize}

\crossreferences
\begin{itemize}
\item \code{task} construct, see \specref{subsec:task Construct}.

\item Task scheduling, see
\specref{subsec:Task Scheduling}.

\item \code{depend} clause, see \specref{subsec:depend Clause}.

\item \code{ompt_scope_begin} and \code{ompt_scope_end}, see
\specref{sec:ompt_scope_endpoint_t}.

\item \code{ompt_sync_region_taskwait}, see
\specref{sec:ompt_sync_region_t}.

\item \code{ompt_callback_sync_region_t}, see
\specref{sec:ompt_callback_sync_region_t}.
\end{itemize}



\subsection{\hcode{taskgroup} Construct}
\index{taskgroup@{\code{taskgroup}}}
\index{constructs!taskgroup@{\code{taskgroup}}}
\label{subsec:taskgroup Construct}
\summary
The \code{taskgroup} construct specifies a wait on completion of child tasks 
of the current task and their descendent tasks.

\syntax
\begin{ccppspecific}
The syntax of the \code{taskgroup} construct is as follows:

\begin{ompcPragma}
#pragma omp taskgroup \plc{[clause[[},\plc{] clause] ...]} \plc{new-line}
    \plc{structured-block}
\end{ompcPragma}

where \plc{clause} is one of the following:

\begin{indentedcodelist}
task_reduction(\plc{reduction-identifier }:\plc{ list})
allocate(\plc{[allocator: ]}\plc{list})
\end{indentedcodelist}
\end{ccppspecific}

\begin{fortranspecific}
The syntax of the \code{taskgroup} construct is as follows:

\begin{ompfPragma}
!$omp taskgroup \plc{[clause [ [},\plc{] clause] ...]}
    \plc{structured-block}
!$omp end taskgroup
\end{ompfPragma}

where \plc{clause} is one of the following:

\begin{indentedcodelist}
task_reduction(\plc{reduction-identifier }:\plc{ list})
allocate(\plc{[allocator: ]}\plc{list})
\end{indentedcodelist}

\end{fortranspecific}

\binding
The binding task set of a \code{taskgroup} region is all tasks of the 
current team that are generated in the region. A \code{taskgroup} region 
binds to the innermost enclosing \code{parallel} region.

\descr
When a thread encounters a \code{taskgroup} construct, it starts executing
the region. All child tasks generated in the \code{taskgroup} region and all
of their descendants that bind to the same \code{parallel} region as the
\code{taskgroup} region are part of the \plc{taskgroup set} associated with
the \code{taskgroup} region.

There is an implicit task scheduling point at the end of the \code{taskgroup}
region. The current task is suspended at the task scheduling point until all
tasks in the \plc{taskgroup set} complete execution.

\events

The \plc{taskgroup-begin} event occurs in each thread that encounters the
\code{taskgroup} construct on entry to the \code{taskgroup} region.

The \plc{taskgroup-wait-begin} event occurs when a task begins an interval 
of active or passive waiting in a \code{taskgroup} region.

The \plc{taskgroup-wait-end} event occurs when a task ends an interval of 
active or passive waiting and resumes execution in a \code{taskgroup} region.

The \plc{taskgroup-end} event occurs in each thread that encounters the
\code{taskgroup} construct after the taskgroup synchronization on exit from the
\code{taskgroup} region.

\tools

A thread dispatches a registered \code{ompt_callback_sync_region}
callback with \code{ompt_sync_region_taskgroup} as its \plc{kind} argument
and \code{ompt_scope_begin} as its \plc{endpoint} argument for each
occurrence of a \plc{taskgroup-begin} event in the task that encounters
the \code{taskgroup} construct. Similarly, a thread dispatches a registered
\code{ompt_callback_sync_region} callback with \code{ompt_sync_region_taskgroup}
as its \plc{kind} argument and \code{ompt_scope_end} as its \plc{endpoint}
argument for each  occurrence of a \plc{taskgroup-end} event in the task that
encounters the \code{taskgroup} construct. These callbacks occur in the task that
encounters the \code{taskgroup} construct and have the type signature
\code{ompt_callback_sync_region_t}.

A thread dispatches a registered \code{ompt_callback_sync_region_wait} callback
with \code{ompt_sync_region_taskgroup} as its \plc{kind} argument and
\code{ompt_scope_begin} as its \plc{endpoint} argument for each occurrence of
a \plc{taskgroup-wait-begin} event. Similarly, a thread dispatches a registered
\code{ompt_callback_sync_region_wait} callback with \code{ompt_sync_region_taskgroup}
as its \plc{kind} argument and \code{ompt_scope_end} as its \plc{endpoint} argument
for each occurrence of a \plc{taskgroup-wait-end} event. These callbacks occur in the
context of the task that encounters the \code{taskgroup} construct and have type
signature \code{ompt_callback_sync_region_t}.

\crossreferences
\begin{itemize}
\item Task scheduling, see
\specref{subsec:Task Scheduling}.

\item \code{task_reduction} Clause, see \specref{subsubsec:task_reduction clause}.

\item \code{ompt_scope_begin} and \code{ompt_scope_end}, see
\specref{sec:ompt_scope_endpoint_t}.

\item \code{ompt_sync_region_taskgroup}, see
\specref{sec:ompt_sync_region_t}.

\item \code{ompt_callback_sync_region_t}, see
\specref{sec:ompt_callback_sync_region_t}.
\end{itemize}



\subsection{\hcode{atomic} Construct}
\index{atomic@{\code{atomic}}}
\index{constructs!atomic@{\code{atomic}}}
\index{constructs!atomic@{\code{atomic}}}
\index{write, atomic@{\code{write, atomic}}}
\index{read, atomic@{\code{read, atomic}}}
\index{update, atomic@{\code{update, atomic}}}
\index{capture, atomic@{\code{capture, atomic}}}
\label{subsec:atomic Construct}
\summary
The \code{atomic} construct ensures that a specific storage location is accessed 
atomically, rather than exposing it to the possibility of multiple, simultaneous 
reading and writing threads that may result in indeterminate values.

\syntax
In the following syntax, \plc{atomic-clause} is a clause that indicates
the semantics for which atomicity is enforced, \plc{memory-order-clause} is
a clause that indicates the memory ordering behavior of the construct and
\plc{clause} is a clause other than \plc{atomic-clause}.
Specifically, \plc{atomic-clause} is one of the following:

\begin{indentedcodelist}
read
write
update
capture
\end{indentedcodelist}

\plc{memory-order-clause} is one of the following:

\begin{indentedcodelist}
seq_cst
acq_rel
release
acquire
relaxed
\end{indentedcodelist}

and \plc{clause} is either \plc{memory-order-clause} or one of the following:

\begin{indentedcodelist}
hint(\plc{hint-expression})
\end{indentedcodelist}

\begin{ccppspecific}
The syntax of the \code{atomic} construct takes one of the following forms:

\begin{ompcPragma}
#pragma omp atomic \plc{[clause[[[},\plc{] clause] ... ] [},\plc{]]} \plc{atomic-clause}
                   \plc{[[},\plc{] clause [[[},\plc{] clause] ... ]]} \plc{new-line}
    \plc{expression-stmt}
\end{ompcPragma}

or

\begin{ompcPragma}
#pragma omp atomic \plc{[clause[[},\plc{] clause] ... ]} \plc{new-line}
    \plc{expression-stmt}
\end{ompcPragma}

or

\begin{ompcPragma}
#pragma omp atomic \plc{[clause[[[},\plc{] clause] ... ] [},\plc{]]} capture
                   \plc{[[},\plc{] clause [[[},\plc{] clause] ... ]]} \plc{new-line}
    \plc{structured-block}
\end{ompcPragma}

where \plc{expression-stmt} is an expression statement with one of the following forms:

\begin{itemize}
\item If \plc{atomic-clause} is \code{read}:
\begin{ompSyntax}
\plc{v} = \plc{x};
\end{ompSyntax}

\item If \plc{atomic-clause} is \code{write}:
\begin{ompSyntax}
\plc{x} = \plc{expr};
\end{ompSyntax}

\item If \plc{atomic-clause} is \code{update} or not present:
\begin{ompSyntax}
\plc{x}++;
\plc{x}--;
++\plc{x};
--\plc{x};
\plc{x} \plc{binop}= \plc{expr};
\plc{x} = \plc{x} \plc{binop} \plc{expr};
\plc{x} = \plc{expr} \plc{binop} \plc{x};
\end{ompSyntax}

\item If \plc{atomic-clause} is \code{capture}:
\begin{ompSyntax}
\plc{v} = \plc{x}++;
\plc{v} = \plc{x}--;
\plc{v} = ++\plc{x};
\plc{v} = --\plc{x};
\plc{v} = \plc{x} \plc{binop}= \plc{expr};
\plc{v} = \plc{x} = \plc{x} \plc{binop} \plc{expr};
\plc{v} = \plc{x} = \plc{expr} \plc{binop} \plc{x};
\end{ompSyntax}

and where \plc{structured-block} is a structured block with one of the following forms:

\begin{ompSyntax}
{ \plc{v} = \plc{x}; \plc{x} \plc{binop}= \plc{expr}; }
{ \plc{x} \plc{binop}= \plc{expr}; \plc{v} = \plc{x}; }
{ \plc{v} = \plc{x}; \plc{x} = \plc{x} \plc{binop} \plc{expr}; }
{ \plc{v} = \plc{x}; \plc{x} = \plc{expr} \plc{binop} \plc{x}; }
{ \plc{x} = \plc{x} \plc{binop} \plc{expr}; \plc{v} = \plc{x}; }
{ \plc{x} = \plc{expr} \plc{binop} \plc{x}; \plc{v} = \plc{x}; }
{ \plc{v} = \plc{x}; \plc{x} = \plc{expr}; }
{ \plc{v} = \plc{x}; \plc{x}++; }
{ \plc{v} = \plc{x}; ++\plc{x}; }
{ ++\plc{x}; \plc{v} = \plc{x}; }
{ \plc{x}++\code{;} \plc{v} = \plc{x}; }
{ \plc{v} = \plc{x}; \plc{x}--; }
{ \plc{v} = \plc{x}; --\plc{x}; }
{ --\plc{x}; \plc{v} = \plc{x}; }
{ \plc{x}--; \plc{v} = \plc{x}; }
\end{ompSyntax}
\end{itemize}

In the preceding expressions:

\begin{itemize}
\item \plc{x} and \plc{v} (as applicable) are both \plc{l-value} expressions 
      with scalar type.
\item During the execution of an atomic region, multiple syntactic occurrences 
      of \plc{x} must designate the same storage location.
\item Neither of \plc{v} and \plc{expr} (as applicable) may access the storage 
      location designated by \plc{x}.
\item Neither of \plc{x} and \plc{expr} (as applicable) may access the storage 
      location designated by \plc{v}.
\item \plc{expr} is an expression with scalar type.
\item \plc{binop} is one of \code{+}, \code{*}, \code{-}, \code{/},
      \code{&}, \code{^}, \code{|}, \code{<<}, or \code{>>}.
\item \plc{binop}, \plc{binop}\code{=}, \code{++}, and \code{--} are not 
      overloaded operators.
\item The expression \plc{x} \plc{binop} \plc{expr} must be numerically 
      equivalent to \plc{x} \plc{binop} \plc{(expr)}. This requirement is 
      satisfied if the operators in \plc{expr} have precedence greater than 
      \plc{binop}, or by using parentheses around \plc{expr} or 
      subexpressions of \plc{expr}.
\item The expression \plc{expr} \plc{binop} \plc{x} must be numerically 
      equivalent to \plc{(expr)} \plc{binop} \plc{x}. This requirement is 
      satisfied if the operators in \plc{expr} have precedence equal to or 
      greater than \plc{binop}, or by using parentheses around \plc{expr} 
      or subexpressions of \plc{expr}.
\item For forms that allow multiple occurrences of \plc{x}, the number of 
      times that \plc{x} is evaluated is unspecified.
\item \plc{hint-expression} is a constant integer expression that evaluates 
      to a valid synchronization hint.
\end{itemize}

\end{ccppspecific}

\begin{fortranspecific}
The syntax of the \code{atomic} construct takes any of the following forms:

\begin{ompfPragma}
!$omp atomic \plc{[clause[[[},\plc{] clause] ... ] [},\plc{]]} read \plc{[[},\plc{] clause [[[},\plc{] clause] ... ]]}
    \plc{capture-statement}
\plc{[}!$omp end atomic\plc{]}
\end{ompfPragma}

or

\begin{ompfPragma}
!$omp atomic \plc{[clause[[[},\plc{] clause] ... ] [},\plc{]]} write \plc{[[},\plc{] clause [[[},\plc{] clause] ... ]]}
    \plc{write-statement}
\plc{[}!$omp end atomic\plc{]}
\end{ompfPragma}

or

\begin{ompfPragma}
!$omp atomic \plc{[clause[[[},\plc{] clause] ... ] [},\plc{]]} update \plc{[[},\plc{] clause [[[},\plc{] clause] ... ]]}
    \plc{update-statement}
\plc{[}!$omp end atomic\plc{]}
\end{ompfPragma}

or


\begin{ompfPragma}
!$omp atomic \plc{[clause[[},\plc{] clause] ... ]}
    \plc{update-statement}
\plc{[}!$omp end atomic\plc{]}
\end{ompfPragma}

or

\begin{ompfPragma}
!$omp atomic \plc{[clause[[[},\plc{] clause] ... ] [},\plc{]]} capture \plc{[[},\plc{] clause [[[},\plc{] clause] ... ]]}
    \plc{update-statement}
    \plc{capture-statement}
!$omp end atomic
\end{ompfPragma}

or

\begin{ompfPragma}
!$omp atomic \plc{[clause[[[},\plc{] clause] ... ] [},\plc{]]} capture \plc{[[},\plc{] clause [[[},\plc{] clause] ... ]]}
    \plc{capture-statement}
    \plc{update-statement}
!$omp end atomic
\end{ompfPragma}

or

\begin{ompfPragma}
!$omp atomic \plc{[clause[[[},\plc{] clause] ... ] [},\plc{]]} capture \plc{[[},\plc{] clause [[[},\plc{] clause] ... ]]}
    \plc{capture-statement}
    \plc{write-statement}
!$omp end atomic
\end{ompfPragma}

where \plc{write-statement} has the following form (if \plc{atomic-clause}
is \code{capture} or \code{write}):

\begin{indentedcodelist}
\plc{x} = \plc{expr}
\end{indentedcodelist}

where \plc{capture-statement} has the following form (if \plc{atomic-clause}
is \code{capture} or \code{read}):

\begin{indentedcodelist}
\plc{v} = \plc{x}
\end{indentedcodelist}

and where \plc{update-statement} has one of the following forms (if 
\plc{atomic-clause} is \code{update}, \code{capture}, or not present):

\begin{indentedcodelist}
\plc{x} = \plc{x operator expr}

\plc{x} = \plc{expr operator x}

\plc{x} = \plc{intrinsic_procedure_name} (\plc{x}, \plc{expr_list})

\plc{x} = \plc{intrinsic_procedure_name} (\plc{expr_list}, \plc{x})
\end{indentedcodelist}

In the preceding statements:

\begin{itemize}
\item \plc{x} and \plc{v} (as applicable) are both scalar variables of intrinsic type.
\item \plc{x} must not have the \code{ALLOCATABLE} attribute.
\item During the execution of an atomic region, multiple syntactic occurrences 
      of \plc{x} must designate the same storage location.
\item None of \plc{v}, \plc{expr}, and \plc{expr_list} (as applicable) may access 
      the same storage location as \plc{x}.
\item None of \plc{x}, \plc{expr}, and \plc{expr_list} (as applicable) may access 
      the same storage location as \plc{v}.
\item \plc{expr} is a scalar expression.
\item \plc{expr_list} is a comma-separated, non-empty list of scalar expressions. 
      If \plc{intrinsic_procedure_name} refers to \code{IAND}, \code{IOR}, or 
      \code{IEOR}, exactly one expression must appear in \plc{expr_list}.
\item \plc{intrinsic_procedure_name} is one of \code{MAX}, \code{MIN}, 
      \code{IAND}, \code{IOR}, or \code{IEOR}.
\item \plc{operator} is one of \code{+}, \code{*}, \code{-}, \code{/}, 
      \code{.AND.}, \code{.OR.}, \code{.EQV.}, or \code{.NEQV.}.
\item The expression \plc{x operator expr} must be numerically equivalent to 
      \plc{x operator (expr)}. This requirement is satisfied if the operators 
      in \plc{expr} have precedence greater than \plc{operator}, or by using 
      parentheses around \plc{expr} or subexpressions of \plc{expr}.
\item The expression \plc{expr operator x} must be numerically equivalent to 
      \plc{(expr) operator  x}. This requirement is satisfied if the operators 
      in \plc{expr} have precedence equal to or greater than \plc{operator}, or 
      by using parentheses around \plc{expr} or subexpressions of \plc{expr}.
\item \plc{intrinsic_procedure_name} must refer to the intrinsic procedure name 
      and not to other program entities.
\item \plc{operator} must refer to the intrinsic operator and not to a 
      user-defined operator.
\item All assignments must be intrinsic assignments.
\item For forms that allow multiple occurrences of \plc{x}, the number of times 
      that \plc{x} is evaluated is unspecified.
\item Where \plc{hint-expression} is a constant expression that evaluates to a 
      scalar value with kind \code{omp_sync_hint_kind} and a value that is a 
      valid synchronization hint.
\end{itemize}
\end{fortranspecific}

\binding
If the size of \plc{x} is 8, 16, 32, or 64 bits and \plc{x} is aligned to a
multiple of its size, the binding thread set for the \code{atomic} region is
all threads on the device. Otherwise, the binding thread set for the
\code{atomic} region is all threads in the contention group.  \code{atomic}
regions enforce exclusive access with respect to other \code{atomic} regions
that access the same storage location \plc{x} among all threads in the
binding thread set without regard to the teams to which the threads belong.

\descr

If \plc{atomic-clause} is not present on the construct, the behavior is as if
the \code{update} clause is specified.

The \code{atomic} construct with the \code{read} clause results in 
an atomic read of the location designated by \plc{x} regardless of 
the native machine word size.

The \code{atomic} construct with the \code{write} clause results in
an atomic write of the location designated by \plc{x} regardless of 
the native machine word size.

The \code{atomic} construct with the \code{update} clause results in 
an atomic update of the location designated by \plc{x} using the
designated operator or intrinsic.  Only the read and write of the
location designated by \plc{x} are performed mutually atomically. The
evaluation of \plc{expr} or \plc{expr_list} need not be atomic with respect to
the read or write of the location designated by \plc{x}. No task scheduling
points are allowed between the read and the write of the location designated
by \plc{x}. 

The \code{atomic} construct with the \code{capture} clause results in
an atomic captured update --- an atomic update of the location designated 
by \plc{x} using the designated operator or intrinsic while also capturing 
the original or final value of the location designated by \plc{x} with 
respect to the atomic update. The original or final value of the
location designated by \plc{x} is written in the location designated by
\plc{v}  based on the base language semantics of structured block or 
statements of the \code{atomic} construct. Only the read and write
of the location designated by \plc{x} are performed mutually atomically.
Neither the evaluation of \plc{expr} or \plc{expr_list}, nor the write to the
location designated by \plc{v}, need be atomic with respect to the read or
write of the location designated by \plc{x}. No task scheduling points are
allowed between the read and the write of the location designated by \plc{x}.

The \code{atomic} construct may be used to enforce memory consistency between
threads, based on the guarantees provided by \specref{subsec:OpenMP Memory
Consistency}.  A strong flush on the location designated by \plc{x}
is performed on entry to and exit from the atomic operation, ensuring that the
set of all atomic operations in the program applied to the same location has a
total completion order.  If the \code{write}, \code{update}, or \code{capture}
clause is specified and the \code{release}, \code{acq_rel}, or
\code{seq_cst} clause is specified, the flush on entry to the atomic operation is a
release flush.  If the \code{read} or \code{capture} clause
is specified and the \code{acquire}, \code{acq_rel}, or \code{seq_cst}
clause is specified, the flush on exit from the atomic operation is an acquire flush.
Therefore, if \plc{memory-order-clause} is specified and is not
\code{relaxed}, release and/or acquire flush operations are implied and permit
synchronization between the threads without the use of explicit \code{flush}
directives.

% \begin{note}
% As with other implicit flush regions,
% \specref{subsec:OpenMP Memory Consistency}
% reduces the
% ordering that must be enforced. The intent is that, when the analogous operation exists
% in C++11 or C11, a sequentially consistent \code{atomic} construct has the same semantics as
% a \code{memory_order_seq_cst} atomic operation in C++11/C11. Similarly, a
% non-sequentially consistent \code{atomic} construct on which
% \plc{memory-order-clause} is not present has the same semantics as a
% \code{memory_order_relaxed} atomic operation in C++11/C11.
%
% Unlike non-sequentially consistent \code{atomic} constructs, sequentially consistent \code{atomic}
% constructs preserve the interleaving (sequentially consistent) behavior of correct,
% data race free programs. However, they are not designed to replace the \code{flush} directive
% as a mechanism to enforce ordering for non-sequentially consistent \code{atomic} constructs,
% and attempts to do so require extreme caution. For example, a sequentially consistent
% \code{atomic}~\code{write} construct may appear to be reordered with a subsequent
% non-sequentially consistent \code{atomic}~\code{write} construct that modifies
% a different variable, since such reordering would not be observable by a
% correct program if the second write were outside an \code{atomic} directive.
% \end{note}

For all forms of the \code{atomic} construct, any combination of two or more
of these \code{atomic} constructs enforces mutually exclusive access to the
locations designated by \plc{x} among threads in the binding thread set.  To
avoid race conditions, all accesses of the locations designated by \plc{x}
that could potentially occur in parallel must be protected with an
\code{atomic} construct.

\code{atomic} regions do not guarantee exclusive access with respect to any accesses outside
of \code{atomic} regions to the same storage location \plc{x} even if those accesses occur during a
\code{critical} or \code{ordered} region, while an OpenMP lock is owned by the executing
task, or during the execution of a \code{reduction} clause.

However, other OpenMP synchronization can ensure the desired exclusive access. For
example, a barrier that follows a series of atomic updates to \plc{x} guarantees 
that subsequent accesses do not form a race with the atomic accesses.

A compliant implementation may enforce exclusive access between \code{atomic} regions
that update different storage locations. The circumstances under which this occurs are
implementation defined.

If the storage location designated by \plc{x} is not size-aligned (that is, if the byte alignment
of \plc{x} is not a multiple of the size of \plc{x}), then the behavior of the \code{atomic} region is
implementation defined.

If present, the \code{hint} clause gives the implementation additional
information about the expected properties of the atomic operation
that can optionally be used to optimize the implementation.
The presence of a \code{hint} clause does not affect the semantics of
the \code{atomic} construct, and all hints may be ignored. If no \code{hint} 
clause is specified, the effect is as if \code{hint(omp_sync_hint_none)} 
had been specified.

\events
The \plc{atomic-acquiring} event occurs in the thread that encounters the
\code{atomic} construct on entry to the atomic region before
initiating synchronization for the region.

The \plc{atomic-acquired} event occurs in the thread that encounters the
\code{atomic} construct after it enters the region, but before it executes 
the structured block of the \code{atomic} region.

The \plc{atomic-released} event occurs in the thread that encounters the
\code{atomic} construct after it completes any synchronization on exit 
from the \code{atomic} region.

\tools

A thread dispatches a registered \code{ompt_callback_mutex_acquire}
callback for each occurrence of an \plc{atomic-acquiring} event
in that thread. This callback has the type signature 
\code{ompt_callback_mutex_acquire_t}.

A thread dispatches a registered \code{ompt_callback_mutex_acquired}
callback for each occurrence of an \plc{atomic-acquired} event
in that thread.  This callback has the type signature \code{ompt_callback_mutex_t}.

A thread dispatches a registered \code{ompt_callback_mutex_released}
callback with  \code{ompt_mutex_atomic} as the \plc{kind} argument if 
practical, although a less specific \plc{kind} may be used, for each 
occurrence of an \plc{atomic-released} event in that thread.  This 
callback has the type signature \code{ompt_callback_mutex_t} and 
occurs in the task that encounters the atomic construct.

\restrictions
The following restrictions apply to the \code{atomic} construct:

\begin{itemize}
\item OpenMP constructs may not be encountered during execution of an
      \code{atomic} region.
\item At most one \plc{memory-order-clause} may appear on the construct.
\item At most one \code{hint} clause may appear on the construct.
\item If \plc{atomic-clause} is \code{read} then \plc{memory-order-clause}
      must not be \code{acq_rel} or \code{release}.
\item If \plc{atomic-clause} is \code{write} then \plc{memory-order-clause}
      must not be \code{acq_rel} or \code{acquire}.
\item If \plc{atomic-clause} is \code{update} or not present then 
      \plc{memory-order-clause} must not be \code{acq_rel} or \code{acquire}.
\end{itemize}

\begin{ccppspecific}
\begin{itemize}
\item All atomic accesses to the storage locations designated by \plc{x} 
      throughout the program are required to have a compatible type.
\end{itemize}
\end{ccppspecific}

\begin{fortranspecific}
\begin{itemize}
\item All atomic accesses to the storage locations designated by \plc{x} 
      throughout the program are required to have the same type and type parameters.
\end{itemize}
\end{fortranspecific}

\crossreferences
\begin{itemize}
\item \code{critical} construct, see
\specref{subsec:critical Construct}.

\item \code{barrier} construct, see
\specref{subsec:barrier Construct}.

\item \code{flush} construct, see
\specref{subsec:flush Construct}.

\item \code{ordered} construct, see
\specref{subsec:ordered Construct}.

\item Synchronization Hints, see
\specref{subsec:Synchronization Hints}.

\item \code{reduction} clause, see
\specref{subsubsec:reduction clause}.

\item lock routines, see \specref{sec:Lock Routines}.

\item \code{ompt_mutex_atomic}, see
\specref{sec:ompt_mutex_t}.

\item \code{ompt_callback_mutex_acquire_t}, see
\specref{sec:ompt_callback_mutex_acquire_t}.

\item \code{ompt_callback_mutex_t}, see
\specref{sec:ompt_callback_mutex_t}.

\end{itemize}



\subsection{\hcode{flush} Construct}
\index{flush@{\code{flush}}}
\index{constructs!flush@{\code{flush}}}
\label{subsec:flush Construct}
\summary
The \code{flush} construct executes the OpenMP flush operation. This operation makes a
thread's temporary view of memory consistent with memory and enforces an order on
the memory operations of the variables explicitly specified or implied. See the memory
model description in \specref{sec:Memory Model} for more details. The \code{flush} 
construct is a stand-alone directive.

\syntax
\begin{ccppspecific}
The syntax of the \code{flush} construct is as follows:

\begin{ompcPragma}
#pragma omp flush \plc{[memory-order-clause]} \plc{[}(\plc{list})\plc{] new-line}
\end{ompcPragma}
\begin{samepage}
where \plc{memory-order-clause} is one of the following:

\begin{indentedcodelist}
acq_rel
release
acquire
\end{indentedcodelist}
\end{samepage}
\end{ccppspecific}

\begin{fortranspecific}
The syntax of the \code{flush} construct is as follows:

\begin{ompfPragma}
!$omp flush \plc{[memory-order-clause]} \plc{[}(\plc{list})\plc{]}
\end{ompfPragma}
\begin{samepage}
where \plc{memory-order-clause} is one of the following:

\begin{indentedcodelist}
acq_rel
release
acquire
\end{indentedcodelist}
\end{samepage}
\end{fortranspecific}

\binding
The binding thread set for a \code{flush} region is the encountering thread. 
Execution of a \code{flush} region affects the memory and the temporary view 
of memory of only the thread that executes the region. It does not affect the 
temporary view of other threads. Other threads must themselves execute a flush 
operation in order to be guaranteed to observe the effects of the flush operation
of the encountering thread.

\descr
If \plc{memory-order-clause} is not specified then the \code{flush} construct
results in a strong flush operation with the following behavior. A \code{flush}
construct without a list, executed on a given thread, operates as if the whole
thread-visible data state of the program, as defined by the base language, is
flushed. A \code{flush} construct with a list applies the flush operation to
the items in the list, and does not return until the operation is complete for
all specified list items. An implementation may implement a \code{flush} with
a list by ignoring the list, and treating it the same as a \code{flush}
without a list.

If no list items are specified, the flush operation has the release and/or
acquire flush properties:

\begin{itemize}
\item If \plc{memory-order-clause} is not specified or is \code{acq_rel}, the 
      flush operation is both a release flush and an acquire flush.
\item If \plc{memory-order-clause} is \code{release}, the flush operation is a 
      release flush.
\item If \plc{memory-order-clause} is \code{acquire}, the flush operation is an 
      acquire flush.
\end{itemize}

\begin{ccppspecific}
If a pointer is present in the list, the pointer itself is flushed, not the 
memory block to which the pointer refers.
\end{ccppspecific}

\begin{fortranspecific}
If the list item or a subobject of the list item has the \code{POINTER} attribute, 
the allocation or association status of the \code{POINTER} item is flushed, but 
the pointer target is not. If the list item is a Cray pointer, the pointer is 
flushed, but the object to which it points is not. If the list item is of type 
\code{C_PTR}, the variable is flushed, but the storage that corresponds to that 
address is not flushed. If the list item or the subobject of the list item has the
\code{ALLOCATABLE} attribute and has an allocation status of allocated, the
allocated variable is flushed; otherwise the allocation status is flushed.
\end{fortranspecific}

\begin{note}
Use of a \code{flush} construct with a list is extremely error prone and users are
strongly discouraged from attempting it. The following examples illustrate the ordering
properties of the flush operation. In the following incorrect pseudocode example, the
programmer intends to prevent simultaneous execution of the protected section by the
two threads, but the program does not work properly because it does not enforce the
proper ordering of the operations on variables \code{a} and \code{b}. Any shared data 
accessed in the protected section is not guaranteed to be current or consistent during 
or after the protected section. The atomic notation in the pseudocode in the following 
two examples indicates that the accesses to \code{a} and \code{b} are \code{ATOMIC} 
writes and captures. Otherwise both examples would contain data races and 
automatically result in unspecified behavior.

\parbox{\linewidth}{%
\begin{spacing}{0.90}\begin{framed}
\emph{Incorrect example:}\\
\hspace{0.3\textwidth}\code{a = b = 0}
\begin{tabular}{ p{0.5\textwidth} p{0.5\textwidth}}\\
\hspace{0.1\textwidth}{\splc{thread 1}} & \hspace{0.1\textwidth}{\splc{thread 2}}\\[1.0em]
{\scode{atomic(b = 1)}} & {\scode{atomic(a = 1)}}\\
{\splc{flush}\scode{(b)}} & {\splc{flush}\scode{(a)}}\\
{\splc{flush}\scode{(a)}} & {\splc{flush}\scode{(b)}}\\
{\scode{atomic(tmp = a)}} & {\scode{atomic(tmp = b)}}\\
{\scode{if (tmp == 0) then}} & {\scode{if (tmp == 0) then}}\\
\hspace{1.25em}{\splc{protected section}} & \hspace{1.25em}{\splc{protected section}}\\
{\scode{end if}} & {\scode{end if}}\\
\end{tabular}
\end{framed}\end{spacing}} % use \parbox to keep the lines together for code only

The problem with this example is that operations on variables \code{a} and \code{b} 
are not ordered with respect to each other. For instance, nothing prevents the 
compiler from moving the flush of \code{b} on thread 1 or the flush of \code{a} on 
thread 2 to a position completely after the protected section (assuming that the 
protected section on thread 1 does not reference \code{b} and the protected section 
on thread 2 does not reference \code{a}). If either re-ordering happens, both
threads can simultaneously execute the protected section.

The following pseudocode example correctly ensures that the protected section 
is executed by not more than one of the two threads at any one time. Execution 
of the protected section by neither thread is considered correct in this example. 
This occurs if both flushes complete prior to either thread executing its 
\code{if} statement.

\parbox{\linewidth}{%
\begin{spacing}{0.95}\begin{framed}
\emph{Correct example:}\\
\hspace{0.3\textwidth}\code{a = b = 0}
\begin{tabular}{ p{0.5\textwidth} p{0.5\textwidth}}\\
\hspace{0.1\textwidth}{\splc{thread 1}} & \hspace{0.1\textwidth}{\splc{thread 2}}\\[1.0em]
{\scode{atomic(b = 1)}} & {\scode{atomic(a = 1)}}\\
{\splc{flush}\scode{(a,b)}} & {\splc{flush}\scode{(a,b)}}\\
{\scode{atomic(tmp = a)}} & {\scode{atomic(tmp = b)}}\\
{\scode{if (tmp == 0) then}} & {\scode{if (tmp == 0) then}}\\
\hspace{1.25em}{\splc{protected section}} & \hspace{1.25em}{\splc{protected section}}\\
{\scode{end if}} & {\scode{end if}}\\
\end{tabular}
\end{framed}\end{spacing}} % use \parbox to keep lines together for code only

The compiler is prohibited from moving the flush at all for either thread, 
ensuring that the respective assignment is complete and the data is flushed 
before the \code{if} statement is executed.
\end{note}
\bigskip

\events

The \plc{flush} event occurs in a thread that encounters the \code{flush} construct.

\tools

A thread dispatches a registered \code{ompt_callback_flush} callback
for each occurrence of a \plc{flush} event in that thread. This
callback has the type signature \code{ompt_callback_flush_t}.

\restrictions
The following restrictions apply to the \code{flush} construct:

\begin{itemize}
\item If \plc{memory-order-clause} is \code{release}, \code{acquire}, or
      \code{acq_rel}, list items must not be specified on the \code{flush} directive.
\end{itemize}

\crossreferences
\begin{itemize}
\item \code{ompt_callback_flush_t}, see
\specref{sec:ompt_callback_flush_t}.
\end{itemize}

\subsubsection{Implicit Flushes}
\index{implicit flushes}
\label{subsec:implicit flushes}

Flush operations implied when executing an \code{atomic} region are described in
Section \ref{subsec:atomic Construct}.

A \code{flush} region that corresponds to a \code{flush} directive with the
\code{release} clause present is implied at the following locations:

\begin{itemize}
\item During a barrier region;
\item At entry to a \code{parallel} region;
\item At entry to a \code{teams} region;
\item At exit from a \code{critical} region;
\item During an \code{omp_unset_lock} region;
\item During an \code{omp_unset_nest_lock} region;
\item Immediately before every task scheduling point;
\item At exit from the task region of each implicit task;
\item At exit from an \code{ordered} region, if a \code{threads} clause or 
      a \code{depend} clause with a \code{source} dependence type is present, 
      or if no clauses are present; and
\item During a \code{cancel} region, if the \plc{cancel-var} ICV is \plc{true}.
\end{itemize}

A \code{flush} region that corresponds to a \code{flush} directive with the
\code{acquire} clause present is implied at the following locations:

\begin{itemize}
\item During a barrier region;
\item At exit from a \code{teams} region;
\item At entry to a \code{critical} region;
\item If the region causes the lock to be set, during:
\begin{itemize}
\item an \code{omp_set_lock} region;
\item an \code{omp_test_lock} region;
\item an \code{omp_set_nest_lock} region; and 
\item an \code{omp_test_nest_lock} region;
\end{itemize} 
\item Immediately after every task scheduling point;
\item At entry to the task region of each implicit task;
\item At entry to an \code{ordered} region, if a \code{threads} clause or a 
      \code{depend} clause with a \code{sink} dependence type is present, or 
      if no clauses are present; and
\item Immediately before a cancellation point, if the \plc{cancel-var} ICV is
      \plc{true} and cancellation has been activated.
\end{itemize}

\begin{note}
A \code{flush} region is not implied at the following locations:
\begin{itemize}
\item At entry to worksharing regions; and
\item At entry to or exit from \code{master} regions.
\end{itemize}
\end{note}

The synchronization behavior of implicit flushes is as follows:

\begin{itemize}
\item When a thread executes a \code{critical} region that has a given
      name, the behavior is as if the release flush performed on exit from
      the region synchronizes with the acquire flush performed on entry to
      the next \code{critical} region with the same name that is performed
      by a different thread, if it exists.
\item When a thread team executes a \code{barrier} region, the
      behavior is as if the release flush performed by each thread within
      the region synchronizes with the acquire flush performed by all other
      threads within the region.
\item When a thread executes a \code{taskwait} region that does not result
      in the creation of a dependent task, the behavior is as if each thread
      that executes a remaining child task performs a release flush upon
      completion of the child task that synchronizes with an acquire flush
      performed in the \code{taskwait} region.
\item When a thread executes a \code{taskgroup} region, the behavior is as
      if each thread that executes a remaining descendant task performs a
      release flush upon completion of the descendant task that synchronizes
      with an acquire flush performed on exit from the \code{taskgroup} region.
\item When a thread executes an \code{ordered} region that does not arise from
      a stand-alone \code{ordered} directive, the behavior is as if the
      release flush performed on exit from the region
      synchronizes with the acquire flush performed on entry to an
      \code{ordered} region encountered in the next logical iteration to be
      executed by a different thread, if it exists.
\item When a thread executes an \code{ordered} region that arises from a
      stand-alone \code{ordered} directive, the behavior is as if the
      release flush performed in the \code{ordered} region from a given
      source iteration synchronizes with the acquire flush performed in all
      \code{ordered} regions executed by a different thread that are waiting
      for dependences on that iteration to be satisfied.
\item When a thread team begins execution of a \code{parallel} region, the
      behavior is as if the release flush performed by the master thread on
      entry to the \code{parallel} region synchronizes with the acquire
      flush performed on entry to each implicit task that is assigned to a
      different thread.
\item When an initial thread begins execution of a \code{target} region
      that is generated by a different thread from a target task, the
      behavior is as if the release flush performed by the generating thread
      in the target task synchronizes with the acquire flush performed by the
      initial thread on entry to its initial task region.
\item When an initial thread completes execution of a \code{target} region that is
      generated by a different thread from a target task, the behavior is as
      if the release flush performed by the initial thread on exit from its
      initial task region synchronizes with the acquire flush performed by
      the generating thread in the target task.
\item When a thread encounters a \code{teams} construct, the behavior is as if the
      release flush performed by the thread on entry to the \code{teams} region
      synchronizes with the acquire flush performed on entry to each initial
      task that is executed by a different initial thread that participates
      in the execution of the \code{teams} region.
\item When a thread that encounters a \code{teams} construct reaches the end
      of the \code{teams} region, the behavior is as if the release flush
      performed by each different participating initial thread at exit from
      its initial task synchronizes with the acquire flush performed by the
      thread at exit from the \code{teams} region.
\item When a task generates an explicit task that begins execution on a
      different thread, the behavior is as if the thread that is executing
      the generating task performs a release flush that synchronizes with
      the acquire flush performed by the thread that begins to execute the
      explicit task.
\item When a dependent task with one or more predecessor tasks begins
      execution on a given thread, the behavior is as if each release flush
      performed by a different thread on completion of a predecessor task
      synchronizes with the acquire flush performed by the thread that
      begins to execute the dependent task.
\item When a task begins execution on a given thread and it is mutually
      exclusive with respect to another sibling task that is executed by a
      different thread, the behavior is as if each release flush performed
      on completion of the sibling task synchronizes with the acquire flush
      performed by the thread that begins to execute the task.
\item When a thread executes a \code{cancel} region, the \plc{cancel-var}
      ICV is \plc{true}, and cancellation is not already activated for the
      specified region, the behavior is as if the release flush performed
      during the \code{cancel} region synchronizes with the acquire flush
      performed by a different thread immediately before a cancellation
      point in which that thread observes cancellation was activated for the region.
\item When a thread executes an \code{omp_unset_lock} region that causes the
      specified lock to be unset, the behavior is as if a release flush is
      performed during the \code{omp_unset_lock} region that synchronizes
      with an acquire flush that is performed during the next
      \code{omp_set_lock} or \code{omp_test_lock} region to be executed by a
      different thread that causes the specified lock to be set.
\item When a thread executes an \code{omp_unset_nest_lock} region that causes
      the specified nested lock to be unset, the behavior is as if a release flush
      is performed during the \code{omp_unset_nest_lock} region that
      synchronizes with an acquire flush that is performed during the next
      \code{omp_set_nest_lock} or \code{omp_test_nest_lock} region to be
      executed by a different thread that causes the specified nested lock to be set.  
\end{itemize}



\subsection{\hcode{ordered} Construct}
\index{ordered@{\code{ordered}}}
\index{constructs!ordered@{\code{ordered}}}
\label{subsec:ordered Construct}
\summary
The \code{ordered} construct either specifies a structured block in a
worksharing-loop, \code{simd}, or worksharing-loop SIMD region that will 
be executed in the order of the loop iterations, or it is a stand-alone 
directive that specifies cross-iteration dependences in a doacross loop 
nest. The \code{ordered} construct sequentializes and orders the execution 
of \code{ordered} regions while allowing code outside the region to run in parallel.

\syntax
\begin{ccppspecific}
The syntax of the \code{ordered} construct is as follows:

\begin{ompcPragma}
#pragma omp ordered \plc{[clause[ [},\plc{] clause] ]} \plc{new-line}
   \plc{structured-block}
\end{ompcPragma}

where \plc{clause} is one of the following:
\begin{indentedcodelist}
threads
simd
\end{indentedcodelist}

or

\begin{ompcPragma}
#pragma omp ordered \plc{clause [[[},\plc{] clause] ... ]} \plc{new-line}
\end{ompcPragma}
where \plc{clause} is one of the following:
\begin{indentedcodelist}
depend(source)
depend(sink : \plc{vec})
\end{indentedcodelist}


\end{ccppspecific}

\begin{fortranspecific}
The syntax of the \code{ordered} construct is as follows:

\begin{ompfPragma}
!$omp ordered \plc{[clause[ [},\plc{] clause] ]}
    \plc{structured-block}
!$omp end ordered
\end{ompfPragma}

where \plc{clause} is one of the following:
\begin{indentedcodelist}
threads
simd
\end{indentedcodelist}

or

\begin{ompfPragma}
!$omp ordered \plc{clause [[[},\plc{] clause] ... ]}
\end{ompfPragma}

where \plc{clause} is one of the following:
\begin{indentedcodelist}
depend(source)
depend(sink : \plc{vec})
\end{indentedcodelist}
\end{fortranspecific}

If the \code{depend} clause is specified, the \code{ordered} construct is a 
stand-alone directive.

\binding
The binding thread set for an \code{ordered} region is the current team. An 
\code{ordered} region binds to the innermost enclosing \code{simd} or 
worksharing-loop SIMD region if the \code{simd} clause is present, and otherwise 
it binds to the innermost enclosing worksharing-loop region. \code{ordered} 
regions that bind to different regions execute independently of each other.

\descr
If no clause is specified, the \code{ordered} construct behaves as if the
\code{threads} clause had been specified. If the \code{threads} clause is
specified, the threads in the team that is executing the worksharing-loop 
region execute \code{ordered} regions sequentially in the order of the loop 
iterations. If any \code{depend} clauses are specified then those clauses 
specify the order in which the threads in the team execute \code{ordered} 
regions. If the \code{simd} clause is specified, the \code{ordered} regions 
encountered by any thread will execute one at a time in the order of the 
loop iterations.

When the thread that is executing the first iteration of the loop encounters an
\code{ordered} construct, it can enter the \code{ordered} region without
waiting. When a thread that is executing any subsequent iteration encounters an
\code{ordered} construct without a \code{depend} clause, it waits at the
beginning of the \code{ordered} region until execution of all \code{ordered}
regions belonging to all previous iterations has completed. When a thread that
is executing any subsequent iteration encounters an \code{ordered} construct with
one or more {\pcode{depend(sink:\plc{vec})}} clauses, it waits until its dependences 
on all valid iterations specified by the \code{depend} clauses are satisfied before 
it completes execution of the \code{ordered} region. A specific dependence is 
satisfied when a thread that is executing the corresponding iteration encounters 
an \code{ordered} construct with a \code{depend(source)} clause.

\events

The \plc{ordered-acquiring} event occurs in the task that encounters the
\code{ordered} construct on entry to the ordered region before it initiates 
synchronization for the region.

The \plc{ordered-acquired} event occurs in the task that encounters the
\code{ordered} construct after it enters the region, but before it executes the
structured block of the \code{ordered} region.

The \plc{ordered-released} event occurs in the task that encounters the
\code{ordered} construct after it completes any synchronization on exit 
from the \code{ordered} region.

The \plc{doacross-sink} event occurs in the task that encounters a
\code{ordered} construct for each {\pcode{depend(sink:\plc{vec})}}
clause after the dependence is fulfilled.

The \plc{doacross-source} event occurs in the task that encounters a
\code{ordered} construct with a {\pcode{depend(source:\plc{vec})}} 
clause before signaling the dependence to be fulfilled.

\tools

A thread dispatches a registered \code{ompt_callback_mutex_acquire} callback 
for each occurrence of an \plc{ordered-acquiring} event in that thread. This 
callback has the type signature \code{ompt_callback_mutex_acquire_t}.

A thread dispatches a registered \code{ompt_callback_mutex_acquired} callback 
for each occurrence of an \plc{ordered-acquired} event in that thread. This 
callback has the type signature \code{ompt_callback_mutex_t}.

A thread dispatches a registered \code{ompt_callback_mutex_released} callback 
with \code{ompt_mutex_ordered} as the \plc{kind} argument if practical, although 
a less specific kind may be used, for each occurrence of an \plc{ordered-released} 
event in that thread. This callback has the type signature 
\code{ompt_callback_mutex_t} and occurs in the task that encounters the atomic 
construct.

A thread dispatches a registered \code{ompt_callback_dependences} callback 
with all vector entries listed as \code{ompt_dependence_type_sink} in the 
\plc{deps} argument for each occurrence of a \plc{doacross-sink} event in 
that thread. A thread dispatches a registered \code{ompt_callback_dependences} 
callback with all vector entries listed as \code{ompt_dependence_type_source} 
in the \plc{deps} argument for each occurrence of a \plc{doacross-source} event 
in that thread. These callbacks have the type signature 
\code{ompt_callback_dependences_t}.

\restrictions
Restrictions to the \code{ordered} construct are as follows:

\begin{itemize}
\item At most one \code{threads} clause can appear on an \code{ordered} construct.
\item At most one \code{simd} clause can appear on an \code{ordered} construct.
\item At most one \code{depend(source)} clause can appear on an \code{ordered} 
      construct.
\item The construct corresponding to the binding region of an \code{ordered} region 
      must not specify a \code{reduction} clause with the \code{inscan} modifier.
\item Either {\pcode{depend(sink:\plc{vec})}} clauses or \code{depend(source)}
      clauses may appear on an \code{ordered} construct, but not both.
\item The worksharing-loop or worksharing-loop SIMD region to which an \code{ordered}
      region corresponding to an \code{ordered} construct without a \code{depend}
      clause binds must have an \code{ordered} clause without the parameter
      specified on the corresponding worksharing-loop or worksharing-loop SIMD 
      directive.
\item The worksharing-loop region to which an \code{ordered} region corresponding
      to an \code{ordered} construct with any \code{depend} clauses binds must have 
      an \code{ordered} clause with the parameter specified on the corresponding 
      worksharing-loop directive.
\item An \code{ordered} construct with the \code{depend} clause specified must
      be closely nested inside a worksharing-loop (or parallel worksharing-loop) 
      construct.
\item An \code{ordered} region corresponding to an \code{ordered} construct
      without the \code{simd} clause specified must be closely nested inside a
      loop region.
\item An \code{ordered} region corresponding to an \code{ordered} construct with
      the \code{simd} clause specified must be closely nested inside a
      \code{simd} or worksharing-loop SIMD region.
\item An \code{ordered} region corresponding to an \code{ordered} construct with
      both the \code{simd} and \code{threads} clauses must be closely nested inside
      a worksharing-loop SIMD region or must be closely nested inside a
      worksharing-loop and \code{simd} region.
\item During execution of an iteration of a worksharing-loop or a loop nest
      within a worksharing-loop, \code{simd}, or worksharing-loop SIMD
      region, a thread must not execute more than one \code{ordered} region
      corresponding to an \code{ordered} construct without a \code{depend} clause.
\end{itemize}

\begin{cppspecific}
\begin{itemize}
\item A throw executed inside a \code{ordered} region must cause execution to
      resume within the same \code{ordered} region, and the same thread that threw
      the exception must catch it.
\end{itemize}
\end{cppspecific}

\crossreferences
\begin{itemize}
\item worksharing-loop construct, see
\specref{subsec:Worksharing-Loop Construct}.

\item \code{simd} construct, see
\specref{subsubsec:simd Construct}.

\item parallel Worksharing-loop construct, see
\specref{subsec:Parallel Worksharing-Loop Construct}.

\item \code{depend} Clause, see
\specref{subsec:depend Clause}

\item \code{ompt_mutex_ordered}, see
\specref{sec:ompt_mutex_t}.

\item \code{ompt_callback_mutex_acquire_t}, see
\specref{sec:ompt_callback_mutex_acquire_t}.

\item \code{ompt_callback_mutex_t}, see
\specref{sec:ompt_callback_mutex_t}.
\end{itemize}



\subsection{Depend Objects}
\index{Depend Object}
\label{subsec:Depend Object}

This section describes constructs that support OpenMP depend objects that 
can be used to supply user-computed dependences to \code{depend} clauses. 
OpenMP depend objects must be accessed only through the \code{depobj} 
construct or through the \code{depend} clause; programs that otherwise 
access OpenMP depend objects are non-conforming.

An OpenMP depend object can be in one of the following states: 
\plc{uninitialized} or \plc{initialized}. Initially OpenMP depend objects 
are in the \plc{uninitialized} state.

\subsubsection{\hcode{depobj} Construct}
\index{depobj@{\code{depobj}}}
\index{constructs!depobj@{\code{depobj}}}
\label{subsubsec:depobj Construct}
\summary
The \code{depobj} construct initalizes, updates or destroys an OpenMP depend 
object. The \code{depobj} construct is a stand-alone directive.

\syntax

\begin{ccppspecific}
\begin{samepage}
The syntax of the \code{depobj} construct is as follows:

\begin{ompcPragma}
#pragma omp depobj(\plc{depobj}) \plc{clause new-line}
\end{ompcPragma}
\end{samepage}
where \plc{depobj} is an lvalue expression of type \code{omp_depend_t}.

where \plc{clause} is one of the following{}:

\begin{indentedcodelist}
depend(\plc{dependence-type }:\plc{ locator})
destroy
update(\plc{dependence-type})
\end{indentedcodelist}
\end{ccppspecific}

\begin{fortranspecific}
The syntax of the \code{depobj} construct is as follows:

\begin{ompfPragma}
!$omp depobj(\plc{depobj) \plc{clause}
\end{ompfPragma}
where \plc{depobj} is a scalar integer variable of the \code{omp_depend_kind} \plc{kind}.

where \plc{clause} is one of the following{}:

\begin{indentedcodelist}
depend(\plc{dependence-type }:\plc{ locator})
destroy
update(\plc{dependence-type})
\end{indentedcodelist}
\end{fortranspecific}

\binding
The binding thread set for \code{depobj} regions is the encountering thread.

\descr
A \code{depobj} construct with a \code{depend} clause present sets the state 
of \plc{depobj} to initialized. The \plc{depobj} is initialized to represent 
the dependence that the \code{depend} clause specifies.

A \code{depobj} construct with a \code{destroy} clause present changes the 
state of the \plc{depobj} to uninitialized.

A \code{depobj} construct with a \code{update} clause present changes the 
dependence type of the dependence represented by \plc{depobj} to the one 
specified by the \plc{update} clause.

\restrictions
\begin{itemize}
\item A \code{depend} clause on a \code{depobj} construct must not have 
      \code{source}, \code{sink} or \code{depobj} as \plc{dependence-type}.
\item A \code{depend} clause on a \code{depobj} construct can only specify 
      one locator.
\item The \plc{depobj} of a \code{depobj} construct with the \code{depend} 
      clause present must be in the uninitialized state.
\item The \plc{depobj} of a \code{depobj} construct with the \code{destroy} 
      clause present must be in the initialized state.
\item The \plc{depobj} of a \code{depobj} construct with the \code{update} 
      clause present must be in the initialized state.
\end{itemize}

\crossreferences
\begin{itemize}
 \item \code{depend} clause, see \specref{subsec:depend Clause}.
\end{itemize}



\subsection{\hcode{depend} Clause}
\index{depend@{\code{depend}}}
\index{clauses!depend@{\code{depend}}}
\label{subsec:depend Clause}
\summary
The \code{depend} clause enforces additional constraints on the scheduling 
of tasks or loop iterations. These constraints establish dependences only 
between sibling tasks or between loop iterations.

\syntax
The syntax of the \code{depend} clause is as follows:

\begin{ompSyntax}
depend(\plc{[depend-modifier},\plc{]dependence-type }:\plc{ locator-list})
\end{ompSyntax}

where \plc{dependence-type} is one of the following:
\begin{indentedcodelist}
in
out
inout
mutexinoutset
depobj
\end{indentedcodelist}

where \plc{depend-modifier} is one of the following:
\begin{indentedcodelist}
iterator(\plc{iterators-definition}) 
\end{indentedcodelist}

or

\begin{ompSyntax}
depend(\plc{dependence-type})
\end{ompSyntax}

where \plc{dependence-type} is:
\begin{indentedcodelist}
source
\end{indentedcodelist}

or

\begin{ompSyntax}
depend(\plc{dependence-type} : \plc{vec})
\end{ompSyntax}

where \plc{dependence-type} is:
\begin{indentedcodelist}
sink
\end{indentedcodelist}

and where \plc{vec} is the iteration vector, which has the form:

x\textsubscript{1} [$\pm $ d\textsubscript{1}], x\textsubscript{2} [$\pm $ d\textsubscript{2}], \ldots, x\textsubscript{\plc{n}} [$\pm $ d\textsubscript{\plc{n}}]

where \plc{n} is the value specified by the \code{ordered} clause in the 
worksharing-loop directive, x\textsubscript{\plc{i}} denotes the loop 
iteration variable of the \plc{i}-th nested loop associated with the 
worksharing-loop directive, and d\textsubscript{\plc{i}} is a constant 
non-negative integer.

\descr
Task dependences are derived from the \plc{dependence-type} of a \code{depend} 
clause and its list items when \plc{dependence-type} is \code{in}, \code{out}, 
\code{inout}, or \code{mutexinoutset}. When the \plc{dependence-type} is 
\code{depobj}, the task dependences are derived from the dependences represented 
by the depend objects specified in the \code{depend} clause as if the \code{depend} 
clauses of the \code{depobj} constructs were specified in the current construct. 

For the \code{in} \plc{dependence-type}, if the storage location of at least one
of the list items is the same as the storage location of a list item appearing
in a \code{depend} clause with an \code{out}, \code{inout}, or \code{mutexinoutset} 
\plc{dependence-type} on a construct from which a sibling task was previously 
generated, then the generated task will be a dependent task of that sibling task.

For the \code{out} and \code{inout} \plc{dependence-types}, if the storage 
location of at least one of the list items is the same as the storage location 
of a list item appearing in a \code{depend} clause with an \code{in}, \code{out}, 
\code{inout}, or \code{mutexinoutset} \plc{dependence-type} on a construct from 
which a sibling task was previously generated, then the generated task will be 
a dependent task of that sibling task.

For the \code{mutexinoutset} \plc{dependence-type}, if the storage location of 
at least one of the list items is the same as the storage location of a list 
item appearing in a \code{depend} clause with an \code{in}, \code{out}, or 
\code{inout} \plc{dependence-type} on a construct from which a sibling task 
was previously generated, then the generated task will be a dependent task 
of that sibling task.

If a list item appearing in a \code{depend} clause with a \code{mutexinoutset}
\plc{dependence-type} on a task-generating construct has the same storage location as
a list item appearing in a \code{depend} clause with a \code{mutexinoutset}
\plc{dependence-type} on a different task generating construct, and both constructs
generate sibling tasks, the sibling tasks will be mutually exclusive tasks.

The list items that appear in the \code{depend} clause may reference iterators
defined by an \plc{iterators-definition} appearing on an \code{iterator} modifier.

The list items that appear in the \code{depend} clause may include array sections.

\begin{fortranspecific}
If a list item has the \code{ALLOCATABLE} attribute and its allocation
status is unallocated, the behavior is unspecified. If a list item has
the \code{POINTER} attribute and its association status is
disassociated or undefined, the behavior is unspecified.
\end{fortranspecific}

\begin{ccppspecific}
The list items that appear in the \code{depend} clause may use shape-operators.
\end{ccppspecific}

\begin{note}
The enforced task dependence establishes a synchronization of memory
accesses performed by a dependent task with respect to accesses performed by the
predecessor tasks. However, it is the responsibility of the programmer to synchronize properly with respect to other concurrent accesses that occur outside of those tasks.
\end{note}

The \code{source} \plc{dependence-type} specifies the satisfaction of
cross-iteration dependences that arise from the current iteration.

The \code{sink} \plc{dependence-type} specifies a cross-iteration dependence,
where the iteration vector \plc{vec} indicates the iteration that satisfies
the dependence.

If the iteration vector \plc{vec} does not occur in the iteration space,
the \code{depend} clause is ignored.  If all \code{depend} clauses on an
\code{ordered} construct are ignored then the construct is ignored.

\begin{note}
If the iteration vector \plc{vec} does not indicate a lexicographically 
earlier iteration, it can cause a deadlock.
\end{note}

\events

The \plc{task-dependences} event occurs in a thread encountering a
\code{task} construct, a construct generating a target task or a \code{taskwait}
construct with a \code{depend} clause immediately after 
the \plc{task-create} event for the new task or the \plc{taskwait-begin} event.

The \plc{task-dependence} event indicates an unfulfilled dependence for the 
generated task. This event occurs in a thread that observes the unfulfilled 
dependence before it is satisfied. 

\tools

A thread dispatches the \code{ompt_callback_dependences} callback
for each occurrence of the \plc{task-dependences} event to
announce its dependences with respect to the list items in the 
\code{depend} clause. This callback has type signature
\code{ompt_callback_dependences_t}.

A thread dispatches the \code{ompt_callback_task_dependence}
callback for a \plc{task-dependence} event to report a
dependence between a predecessor task  (\plc{src_task_data}) 
and a dependent task (\plc{sink_task_data}).  This callback 
has type signature \code{ompt_callback_task_dependence_t}.

\restrictions
Restrictions to the \code{depend} clause are as follows:

\begin{itemize}
\item List items used in \code{depend} clauses of the same task or 
      sibling tasks must indicate identical storage locations or 
      disjoint storage locations.
\item List items used in \code{depend} clauses cannot be zero-length array sections.
\item Array sections cannot be specified in \code{depend} clauses 
      with the \code{depobj} dependence type.
\item List items used in \code{depend} clauses with the \code{depobj} 
      dependence type must be depend objects in the initialized state.

\begin{ccppspecific}
\item List items used in \code{depend} clauses with the \code{depobj} 
      depedence type must be expressions of the \code{omp_depend_t} type.
\item List items used in \code{depend} clauses with the \code{in}, \code{out}, 
      \code{inout} or \code{mutexinoutset} dependence types cannot be 
      expressions of the \code{omp_depend_t} type.
\end{ccppspecific}

\begin{fortranspecific}
\item A common block name cannot appear in a \code{depend} clause.
\item List items used in \code{depend} clauses with the \code{depobj} dependence 
      type must be integer expressions of the \code{omp_depend_kind} \plc{kind}.
\end{fortranspecific}

\item For a \plc{vec} element of \code{sink} \plc{dependence-type} of the form
      x\textsubscript{i} $+$ d\textsubscript{i} or 
      x\textsubscript{i} $-$ d\textsubscript{i} if the loop iteration variable
      x\textsubscript{i} has an integral or pointer type, the expression 
      x\textsubscript{i} $+$ d\textsubscript{i} or
      x\textsubscript{i} $-$ d\textsubscript{i} for any value of the loop 
      iteration variable x\textsubscript{i} that can encounter the \code{ordered} 
      construct must be computable in the loop iteration variable's type 
      without overflow.

\begin{cppspecific}
\item For a \plc{vec} element of \code{sink} \plc{dependence-type} of the form
      x\textsubscript{i} $+$ d\textsubscript{i} or 
      x\textsubscript{i} $-$ d\textsubscript{i} if the loop iteration variable
      x\textsubscript{i} is of a random access iterator type other than pointer type,
      the expression $($ x\textsubscript{i} - lb\textsubscript{i} $)$ $+$ d\textsubscript{i} or
      $($ x\textsubscript{i} - lb\textsubscript{i} $)$ $-$ d\textsubscript{i} 
      for any value of the loop iteration variable x\textsubscript{i} that can 
      encounter the \code{ordered} construct must be computable in the
      type that would be used by \plc{std::distance} applied to variables of the
      type of x\textsubscript{i} without overflow.
\end{cppspecific}

\begin{ccppspecific}
\item A bit-field cannot appear in a \code{depend} clause.
\end{ccppspecific}
\end{itemize}

\crossreferences
\begin{itemize}
\item Array sections, see
\specref{sec:Array Sections}.

\item Iterators, see \specref{sec:iterators}.

\item \code{task} construct, see
\specref{subsec:task Construct}.

\item Task scheduling constraints, see \specref{subsec:Task Scheduling}.

\item \code{target}~\code{enter}~\code{data} construct, see
\specref{subsec:target enter data Construct}.

\item \code{target}~\code{exit}~\code{data} construct, see
\specref{subsec:target exit data Construct}.

\item \code{target} construct, see
\specref{subsec:target Construct}.

\item \code{target}~\code{update} construct, see
\specref{subsec:target update Construct}.

\item \code{ordered} construct, see
\specref{subsec:ordered Construct}.

\item \code{ompt_callback_dependences_t}, see
\specref{sec:ompt_callback_dependences_t}.

\item \code{ompt_callback_task_dependence_t}, see
\specref{sec:ompt_callback_task_dependence_t}.
\end{itemize}



\subsection{Synchronization Hints}
\index{synchronization hints}
\index{clauses!hint@{\code{hint}}}
\label{subsec:Synchronization Hints}
Hints about the expected dynamic behavior or suggested implementation
can be provided by the programmer to locks (by using
the \code{omp_init_lock_with_hint} or
\code{omp_init_nest_lock_with_hint} functions to initialize the lock), and to
\code{atomic} and \code{critical} directives by using the \code{hint}
clause. The effect of a hint does not
change the semantics of the associated construct; if ignoring the 
hint changes the program semantics, the result is unspecified.

The C/C++ header file (\code{omp.h}) and the Fortran include file (\code{omp_lib.h}) and/or Fortran~90 module file (\code{omp_lib}) define the valid hint constants.
The valid constants must include the following, which can be extended with implementation-defined values:

\begin{ccppspecific}
\begin{ompcEnum}
typedef enum omp_sync_hint_t {
  omp_sync_hint_none = 0x0,
  omp_lock_hint_none = omp_sync_hint_none,
  omp_sync_hint_uncontended = 0x1,
  omp_lock_hint_uncontended = omp_sync_hint_uncontended,
  omp_sync_hint_contended = 0x2,
  omp_lock_hint_contended = omp_sync_hint_contended,
  omp_sync_hint_nonspeculative = 0x4,
  omp_lock_hint_nonspeculative = omp_sync_hint_nonspeculative,
  omp_sync_hint_speculative = 0x8
  omp_lock_hint_speculative = omp_sync_hint_speculative
} omp_sync_hint_t;

typedef omp_sync_hint_t omp_lock_hint_t;
\end{ompcEnum}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfEnum}
integer, parameter :: omp_lock_hint_kind = omp_sync_hint_kind

integer (kind=omp_sync_hint_kind), &
  parameter :: omp_sync_hint_none = Z'0'
integer (kind=omp_lock_hint_kind), &
  parameter :: omp_lock_hint_none = omp_sync_hint_none
integer (kind=omp_sync_hint_kind), &
  parameter :: omp_sync_hint_uncontended = Z'1'
integer (kind=omp_lock_hint_kind), &
  parameter :: omp_lock_hint_uncontended = &
                    omp_sync_hint_uncontended
integer (kind=omp_sync_hint_kind), &
  parameter :: omp_sync_hint_contended = Z'2'
integer (kind=omp_lock_hint_kind), &
  parameter :: omp_lock_hint_contended = &
                   omp_sync_hint_contended
integer (kind=omp_sync_hint_kind), &
  parameter :: omp_sync_hint_nonspeculative = Z'4'
integer (kind=omp_lock_hint_kind), &
  parameter :: omp_lock_hint_nonspeculative = &
                   omp_sync_hint_nonspeculative
integer (kind=omp_sync_hint_kind), &
  parameter :: omp_sync_hint_speculative = Z'8'
integer (kind=omp_lock_hint_kind), &
  parameter :: omp_lock_hint_speculative = &
                   omp_sync_hint_speculative
\end{ompfEnum}
\end{fortranspecific}

The hints can be combined by using the \code{+} or \code{|} operators in C/C++ or the \code{+} operator in Fortran.
Combining \code{omp_sync_hint_none} with any other hint is equivalent to specifying the other hint.

The intended meaning of hints is
\begin{itemize}
\item \code{omp_sync_hint_uncontended}: low contention is expected in this operation, that is,
few threads are expected to be performing the operation simultaneously in a manner that requires synchronization.
\item \code{omp_sync_hint_contended}: high contention is expected in this operation, that is,
many threads are expected to be performing the operation simultaneously in a manner that requires synchronization.
\item \code{omp_sync_hint_speculative}: the programmer suggests that the operation should be implemented using
speculative techniques such as transactional memory.
\item \code{omp_sync_hint_nonspeculative}: the programmer suggests that the operation should not be
implemented using speculative techniques such as transactional memory.
\end{itemize}

\begin{note}
Future OpenMP specifications may add additional hints to the
\code{omp_sync_hint_t} type and the \code{omp_sync_hint_kind} kind.
Implementers are advised to add implementation-defined hints starting from
the most significant bit of the \code{omp_sync_hint_t} type and
\code{omp_sync_hint_kind} kind and to include the name of the
implementation in the name of the added hint to avoid name conflicts
with other OpenMP implementations.
\end{note}

The \code{omp_sync_hint_t} and \code{omp_lock_hint_t} enumeration types and the equivalent types in Fortran
are synonyms for each other.
The type \code{omp_lock_hint_t} has been deprecated.

\restrictions

Restrictions to the synchronization hints are as follows:
\begin{itemize}
\item the hints \code{omp_sync_hint_uncontended} and \code{omp_sync_hint_contended} cannot be combined,
\item the hints \code{omp_sync_hint_nonspeculative} and \code{omp_sync_hint_speculative} cannot be combined.
\end{itemize}

The restrictions for combining multiple values of \code{omp_sync_hint} apply equally to the
corresponding values of \code{omp_lock_hint}, and expressions that mix the two types.

\crossreferences
\begin{itemize}
\item \code{critical} construct, see \specref{subsec:critical Construct}.

\item \code{atomic} construct, see
\specref{subsec:atomic Construct}

\item \code{omp_init_lock_with_hint} and
  \code{omp_init_nest_lock_with_hint}, see
\specref{subsec:omp_init_lock_with_hint and omp_init_nest_lock_with_hint}.
\end{itemize}
