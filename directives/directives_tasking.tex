% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. There are environments that provide special formatting, e.g. language bars.
%       Please use them whereever appropriate.  Examples are:
%
%         \begin{fortranspecific}
%         This is text that appears enclosed in blue language bars for Fortran.
%         \end{fortranspecific}
%
%         \begin{note}
%         This is a note.  The "Note -- " header appears automatically.
%         \end{note}
%
%    6. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%



\section{Tasking Constructs}
\label{sec:Tasking Constructs}
\index{tasking constructs}
\index{constructs!tasking constructs}
\subsection{\hcode{task} Construct}
\index{task@{\code{task}}}
\index{constructs!task@{\code{task}}}
\label{subsec:task Construct}
\summary
The \code{task} construct defines an explicit task.

\syntax
\begin{ccppspecific}
\begin{samepage}
The syntax of the \code{task} construct is as follows:

\begin{ompcPragma}
#pragma omp task \plc{[clause[ [},\plc{] clause] ... ] new-line}
    \plc{structured-block}
\end{ompcPragma}
\end{samepage}

\begin{samepage}
% CT: {} to fix a bug in the diffing
where \plc{clause} is one of the following{}:

\begin{indentedcodelist}
if(\plc{[} task :\plc{] scalar-expression})
final(\plc{scalar-expression})
untied
default(shared \textnormal{|} none)
mergeable
private(\plc{list})
firstprivate(\plc{list})
shared(\plc{list})
in_reduction(\plc{reduction-identifier }:\plc{ list})
depend(\plc{[depend-modifier}:\plc{][dependence-type }:\plc{] locator-list})
priority(\plc{priority-value})
allocate(\plc{[allocator }:\plc{] list})
affinity(\plc{[aff-modifier }:\plc{] locator-list})
detach(\plc{event-handle})
\end{indentedcodelist}

where \plc{aff-modifier} is one of the following{}:
\begin{indentedcodelist}
iterator(\plc{iterators-definition}) 
\end{indentedcodelist}

where \plc{event-handle} is a variable of the \code{omp_event_t *} type.

\end{samepage}
\end{ccppspecific}

\begin{fortranspecific}
The syntax of the \code{task} construct is as follows:

\begin{ompfPragma}
!$omp task \plc{[clause[ [},\plc{] clause] ... ]}
    \plc{structured-block}
!$omp end task
\end{ompfPragma}

% CT: {} to fix a bug in the diffing
where \plc{clause} is one of the following{}:

\begin{indentedcodelist}
if(\plc{[} task :\plc{] scalar-logical-expression})
final(\plc{scalar-logical-expression})
untied
default(private \textnormal{|} firstprivate \textnormal{|} shared \textnormal{|} none)
mergeable
private(\plc{list})
firstprivate(\plc{list})
shared(\plc{list})
in_reduction(\plc{reduction-identifier }:\plc{ list})
depend(\plc{[depend-modifier}:\plc{][dependence-type }:\plc{] locator-list})
priority(\plc{priority-value})
allocate(\plc{[allocator }:\plc{] list})
affinity(\plc{[aff-modifier }:\plc{] locator-list})
detach(\plc{event-handle})
\end{indentedcodelist}

where \plc{aff-modifier} is one of the following{}:
\begin{indentedcodelist}
iterator(\plc{iterators-definition}) 
\end{indentedcodelist}

where \plc{event-handle} is an integer variable of \code{omp_event_kind} \plc{kind}

\end{fortranspecific}

\binding
The binding thread set of the \code{task} region is the current team. A \code{task} region binds to
the innermost enclosing \code{parallel} region.

\descr

The \code{task} construct is a \emph{task generating construct}. When a thread
encounters a \code{task} construct, an explicit task is generated from the code
for the associated \plc{structured-block}. The data environment of the task is
created according to the data-sharing attribute clauses on the \code{task}
construct, per-data environment ICVs, and any defaults that apply. The data environment of the task is destroyed 
when the execution code of the associated \plc{structured-block} is completed.

The encountering thread may immediately execute the task, or defer its execution. In the
latter case, any thread in the team may be assigned the task. Completion of the task can
be guaranteed using task synchronization constructs.
If a \code{task} construct is encountered during execution of an outer
task, the generated \code{task} region corresponding to this construct is not a
part of the outer task region unless the generated task is
an included task.

If a \code{detach} clause is present on a \code{task} construct a new event 
of type \code{omp_event_t} (\code{omp_event_kind} \plc{kind}, for Fortran), 
\plc{allow-completion-event}, is created. The \plc{allow-completion-event} is 
connected to the completion of the associated \code{task} region. The original 
\plc{event-handle} will be updated to point to the \plc{allow-completion-event}
event before the task data environment is created. The \plc{event-handle} will 
be considered as if it was specified on a \code{firstprivate} clause.  
The use of a variable in a \code{detach} clause expression of a \code{task} 
construct causes an implicit reference to the variable in all enclosing constructs.

If no \code{detach} clause is present on a \code{task} construct the generated \code{task} is completed when the execution of its associated \plc{structured-block} is completed. If a \code{detach} clause is present on a \code{task} construct the task is completed when the execution of its associated \plc{structured-block} is completed and the \plc{allow-completion-event} is fulfilled.

When an \code{if} clause is present on a \code{task} construct, and the \code{if} clause expression
evaluates to \plc{false}, an undeferred task is generated, and the encountering thread must
suspend the current task region, for which execution cannot be resumed until the
generated task is completed. The use of a variable in an \code{if} clause expression
of a \code{task} construct causes an implicit reference to the variable in all enclosing
constructs.

When a \code{final} clause is present on a \code{task} construct and the \code{final} clause expression
evaluates to \plc{true}, the generated task will be a final task. All \code{task} constructs
encountered during execution of a final task will generate final and included tasks. Note
that the use of a variable in a \code{final} clause expression of a \code{task} construct causes an
implicit reference to the variable in all enclosing constructs. Encountering a \code{task} construct with the \code{detach} clause
during the execution of a final task results in unspecified behavior.

The \code{if} clause expression and the \code{final} clause expression are evaluated in the context
outside of the \code{task} construct.

A thread that encounters a task scheduling point within the \code{task} region may
temporarily suspend the \code{task} region. By default, a task is tied and its suspended \code{task}
region can only be resumed by the thread that started its execution. If the \code{untied}
clause is present on a \code{task} construct, any thread in the team can resume the \code{task}
region after a suspension. The \code{untied} clause is ignored if a \code{final} clause is present
on the same \code{task} construct and the \code{final} clause expression evaluates to \plc{true}, or if a
task is an included task.

The \code{task} construct includes a task scheduling point in the task region of its generating
task, immediately following the generation of the explicit task. Each explicit \code{task}
region includes a task scheduling point at the end of its associated \plc{structured-block}.

When the \code{mergeable} clause is present on a \code{task} construct, the generated task is a \plc{mergeable task}.

The \code{priority} clause is a hint for the priority of the generated task. The \plc{priority-value} is a
non-negative integer expression that provides a hint for task execution order. Among all
tasks ready to be executed, higher priority tasks (those with a higher numerical value in the
\code{priority} clause expression) are recommended to execute before lower priority ones. The default
\plc{priority-value} when no \code{priority} clause is specified is zero (the lowest priority). If a value is
specified in the \code{priority} clause that is higher than the \plc{max-task-priority-var} ICV then the
implementation will use the value of that ICV. A program that relies on task execution order
being determined by this \plc{priority-value} may have unspecified behavior.

The \code{affinity} clause is a hint to indicate data affinity of the generated
task. The task is recommended to execute closely to the location of the list items. 
A program that relies on the task execution location
being determined by this list may have unspecified behavior.

The list items that appear in the \code{affinity} clause may reference iterators
defined by an \plc{iterators-definition} appearing in the same clause.
The list items that appear in the \code{affinity} clause may include array sections.
\begin{ccppspecific}
The list items that appear in the \code{affinity} clause may use shape-operators.
\end{ccppspecific}

If a list item appears in an \code{affinity} clause then data affinity refers to the original list item.

\begin{note}
When storage is shared by an explicit \code{task} region, the
programmer must ensure, by adding proper synchronization, that the storage does not
reach the end of its lifetime before the explicit \code{task} region completes its execution.
\end{note}

\events

The \plc{task-create} event occurs when a thread encounters a construct
that causes a new task to be created.
The event occurs after the task is initialized but before
it begins execution or is deferred.

\tools

A thread dispatches a registered \code{ompt_callback_task_create}
callback for each occurrence of a \plc{task-create} event
in the context of the encountering task.
This callback has the type signature    \code{ompt_callback_task_create_t}.
In the dispatched callback,             \code{(}\plc{flag} \code{& ompt_task_explicit)} always evaluates to \plc{true}.
If the task is an undeferred task, then \code{(}\plc{flag} \code{& ompt_task_undeferred)} evaluates to \plc{true}.
If the task is a final task,            \code{(}\plc{flag} \code{& ompt_task_final)} evaluates to \plc{true}.
If the task is an untied task,          \code{(}\plc{flag} \code{& ompt_task_untied)} evaluates to \plc{true}.
If the task is a mergeable task,        \code{(}\plc{flag} \code{& ompt_task_mergeable)} evaluates to \plc{true}.
If the task is a merged task,           \code{(}\plc{flag} \code{& ompt_task_merged)} evaluates to \plc{true}.

\restrictions
Restrictions to the \code{task} construct are as follows:

\begin{itemize}
\item A program that branches into or out of a \code{task} region is non-conforming.

\item A program must not depend on any ordering of the evaluations of the clauses of the
\code{task} directive, or on any side effects of the evaluations of the clauses.

\item At most one \code{if} clause can appear on the directive.

\item At most one \code{final} clause can appear on the directive.

\item At most one \code{priority} clause can appear on the directive.

\item At most one \code{detach} clause can appear on the directive.

\item If a \code{detach} clause appears on the directive, then a \code{mergeable} clause cannot appear on the same directive.

\begin{ccppspecific}
\item A throw executed inside a \code{task} region must cause execution to resume within the
same \code{task} region, and the same thread that threw the exception must catch it.
\end{ccppspecific}

\crossreferences
\begin{itemize}
\item Task scheduling constraints, see \specref{subsec:Task Scheduling}.
\item \code{if} clause, see \specref{sec:if Clause}.
\item \code{default} clause, see \specref{subsubsec:default clause}.
\item \code{in\_reduction} clause, see \specref{subsubsec:in_reduction clause}.
\item \code{depend} clause, see \specref{subsec:depend Clause}.
\item \code{allocate} clause, see \specref{subsec:allocate Clause}.
\item Data-sharing attribute clauses, \specref{subsec:Data-Sharing Attribute Clauses}.
\item \code{omp_fulfill_event}, see \specref{subsec:omp_fulfill_event}.
\item \code{ompt_callback_task_create_t}, see
\specref{sec:ompt_callback_task_create_t}.
%\item \code{ompt_callback_task_schedule_t}, see
%\specref{sec:ompt_callback_task_schedule_t}.
\end{itemize}











% TASKLOOP
\subsection{\hcode{taskloop} Construct}
\index{taskloop@{\code{taskloop}}}
\index{constructs!taskloop@{\code{taskloop}}}
\label{subsec:taskloop Construct}
\summary
The \code{taskloop} construct specifies that the iterations of one or more associated loops will be executed in parallel using explicit tasks. The iterations are distributed across tasks generated by the construct and scheduled to be executed.
\syntax
\begin{ccppspecific}
The syntax of the \code{taskloop} construct is as follows:
\begin{ompcPragma}
#pragma omp taskloop \plc{[clause[[},\plc{] clause] ...] new-line}
    \plc{for-loops}
\end{ompcPragma}
where \plc{clause} is one of the following:
\begin{indentedcodelist}
if(\plc{[} taskloop :\plc{] scalar-expression})
shared(\plc{list})
private(\plc{list})
firstprivate(\plc{list})
lastprivate(\plc{list})
reduction(\plc{reduction-identifier }:\plc{ list})
in_reduction(\plc{reduction-identifier }:\plc{ list})
default(shared \textnormal{|} none)
grainsize(\plc{grain-size})
num_tasks(\plc{num-tasks})
collapse(\plc{n})
final(\plc{scalar-expr})
priority(\plc{priority-value})
untied
mergeable
nogroup
allocate(\plc{[allocator }:\plc{] list})
\end{indentedcodelist}

The \code{taskloop} directive places restrictions on the structure of all associated \plc{for-loops}. Specifically, all associated \plc{for-loops} must have canonical loop form (see \specref{subsec:Canonical Loop Form}).
\end{ccppspecific}
\begin{fortranspecific}
The syntax of the \code{taskloop} construct is as follows:
\begin{ompfPragma}
!$omp taskloop \plc{[clause[[},\plc{] clause] ...]}
    \plc{do-loops}
\plc{[}!$omp end taskloop\plc{]}
\end{ompfPragma}
where \plc{clause} is one of the following:
\begin{indentedcodelist}
if(\plc{[} taskloop :\plc{] scalar-logical-expression})
shared(\plc{list})
private(\plc{list})
firstprivate(\plc{list})
lastprivate(\plc{list})
reduction(\plc{reduction-identifier }:\plc{ list})
in_reduction(\plc{reduction-identifier }:\plc{ list})
default(private \textnormal{|} firstprivate \textnormal{|} shared \textnormal{|} none)
grainsize(\plc{grain-size})
num_tasks(\plc{num-tasks})
collapse(\plc{n})
final(\plc{scalar-logical-expr})
priority(\plc{priority-value})
untied
mergeable
nogroup
allocate(\plc{[allocator }:\plc{] list})
\end{indentedcodelist}

If an \code{end}~\code{taskloop} directive is not specified, an
\code{end}~\code{taskloop} directive is assumed at the end of the
\plc{do-loops}.

The \code{taskloop} directive places restrictions on the structure of all
associated \plc{do-loops}. Specifically, all associated \plc{do-loops} must
have canonical loop form (see \specref{subsec:Canonical Loop Form}).
\end{fortranspecific}

\binding
The binding thread set of the \code{taskloop} region is the current team. A \code{taskloop} region binds to the innermost enclosing \code{parallel} region.

\descr
The \code{taskloop} construct is a \emph{task generating construct}. When a thread encounters a \code{taskloop} construct, the construct partitions the associated loops into explicit tasks for parallel execution of the loops' iterations. The data environment of each generated task is created according to the data-sharing attribute clauses on the \code{taskloop} construct, per-data environment ICVs, and any defaults that apply. The order of the creation of the loop tasks is unspecified.
Programs that rely on any execution order of the logical loop iterations are non-conforming.

By default, the \code{taskloop} construct executes as if it was enclosed in a \code{taskgroup} construct with no statements or directives outside of the \code{taskloop} construct. Thus, the \code{taskloop} construct creates an implicit \code{taskgroup} region. If the \code{nogroup} clause is present, no implicit \code{taskgroup} region is created.

If a \code{reduction} clause is present on the \code{taskloop} construct, the behavior is as if a \code{task_reduction} clause with the same reduction operator and list items was applied to the implicit \code{taskgroup} construct enclosing the \code{taskloop} construct.
Furthermore, the \code{taskloop} construct executes as if each generated task was defined by a \code{task} construct on which an \code{in_reduction} clause with the same reduction operator and list items is present. Thus, the generated tasks are participants of the reduction defined by the \code{task_reduction} clause that was applied to the implicit \code{taskgroup} construct.

If an \code{in_reduction} clause is present on the \code{taskloop} construct, the behavior is as if each generated task was defined by a \code{task} construct on which an \code{in_reduction} clause with the same reduction operator and list items is present. Thus, the generated tasks are participants of a reduction previously defined by a reduction scoping clause.

If a \code{grainsize} clause is present on the \code{taskloop} construct, the number of logical loop iterations assigned to each generated task is greater than or equal to the minimum of the value of the \plc{grain-size} expression and the number of logical loop iterations, but less than two times the value of the \plc{grain-size} expression.

The parameter of the \code{grainsize} clause must be a positive integer expression.
If \code{num_tasks} is specified, the \code{taskloop} construct creates as many tasks as the minimum of the \plc{num-tasks} expression and the number of logical loop iterations.
Each task must have at least one logical loop iteration.
The parameter of the \code{num_tasks} clause must be a positive integer expression.
If neither a \code{grainsize} nor \code{num_tasks} clause is present, the number of loop tasks generated and the number of logical loop iterations assigned to these tasks is implementation defined.

The \code{collapse} clause may be used to specify how many loops are
associated with the \code{taskloop} construct.  The parameter of the
\code{collapse} clause must be a constant positive integer
expression.  If no \code{collapse} clause is present or its parameter
is 1, the only loop that is associated with the \code{taskloop}
construct is the one that immediately follows the \code{taskloop}
directive.  If a \code{collapse} clause is specified with a parameter
value greater than 1 and more than one loop is associated with the
\code{taskloop} construct, then the iterations of all associated loops
are collapsed into one larger iteration space that is then divided
according to the \code{grainsize} and \code{num_tasks} clauses. The
sequential execution of the iterations in all associated loops
determines the order of the iterations in the collapsed iteration
space.
%% TODO: Does this conflict with the note about the independence of loop iterations below?

If more than one loop is associated with the \code{taskloop} construct
then the number of times that any intervening code between any two
associated loops will be executed is unspecified but will be at least
once per iteration of the loop enclosing the intervening code and at
most once per iteration of the innermost loop associated with the
construct.  If the iteration count of any loop that is associated with the
\code{taskloop} construct and does not enclose intervening code is zero
then the behavior is unspecified.


A taskloop loop has logical iterations numbered 0,1,...,N-1 where N is
the number of loop iterations, and the logical numbering denotes the
sequence in which the iterations would be executed if the set of
associated loop(s) were executed sequentially.  At the beginning of
each logical iteration, the loop iteration variable of each associated
loop has the value that it would have if the set of the associated
loop(s) were executed sequentially.

The iteration count for each associated loop is computed before entry to the outermost loop. If execution of any associated loop changes any of the values used to compute any of the iteration counts, then the behavior is unspecified.

The integer type (or kind, for Fortran) used to compute the iteration count for the collapsed loop is implementation defined.

When an \code{if} clause is present on a \code{taskloop} construct, and if the \code{if} clause expression evaluates to \plc{false}, undeferred tasks are generated. The use of a variable in an \code{if} clause expression of a \code{taskloop} construct causes an implicit reference to the variable in all enclosing constructs.

When a \code{final} clause is present on a \code{taskloop} construct and the \code{final} clause expression evaluates to \plc{true}, the generated tasks will be final tasks. The use of a variable in a \code{final} clause expression of a \code{taskloop} construct causes an implicit reference to the variable in all enclosing constructs.

When a \code{priority} clause is present on a \code{taskloop} construct,
the generated tasks use the \plc{priority-value} as if it was
specified for each individual task.
If the \code{priority} clause is not specified, tasks generated by
the \code{taskloop} construct have the default task priority (zero).

If the \code{untied} clause is specified, all tasks generated by the \code{taskloop} construct are untied tasks.

When the \code{mergeable} clause is present on a \code{taskloop} construct, each generated task is a \plc{mergeable task}.

\begin{cppspecific}
For \code{firstprivate} variables of class type, the number of invocations of copy constructors to perform the initialization  is implementation-defined.
\end{cppspecific}

\begin{note}
When storage is shared by a \code{taskloop} region, the programmer must ensure, by adding proper synchronization, that the storage does not reach the end of its lifetime before the \code{taskloop} region and its descendant tasks complete their execution.
\end{note}

\def\omptWorksharingLoop#1#2
{
\events

The \plc{#1-begin} event occurs after a task encounters a
\code{#1} construct but before the task starts the execution of the structured
block of the \code{#1} region.

The \plc{#1-end} event occurs after a \code{#1} region finishes execution
but before resuming execution of the encountering task.

\tools

A thread dispatches a registered \code{ompt_callback_work}
callback for each occurrence of a \plc{#1-begin} and
\plc{#1-end} event in that thread. The callback occurs in the
context of the encountering task.  The callback has type signature
\code{ompt_callback_work_t}. The callback receives
\code{ompt_scope_begin} or \code{ompt_scope_end}
as its \plc{endpoint} argument, as appropriate, and
\code{#2} as its \plc{wstype} argument.
}
% \omptWorksharingLoop{taskloop}{ompt\_work\_taskloop}

\events

The \plc{taskloop-begin} event occurs after a task encounters a
\code{taskloop} construct but before any other events that may
trigger as a consequence of executing the \code{taskloop}.
Specifically, a \plc{taskloop-begin} event for a \code{taskloop}
will precede the \plc{taskgroup-begin} that occurs unless a
\code{nogroup} clause is present.  Regardless of whether an implicit
taskgroup is present, a \plc{taskloop-begin} will always precede
any \plc{task-create} events for generated tasks.

The \plc{taskloop-end} event occurs after a \code{taskloop} region finishes execution
but before resuming execution of the encountering task.

The \plc{taskloop-iteration-begin} event occurs before an explicit
task executes each iteration of a \code{taskloop}.

\tools

A thread dispatches a registered \code{ompt_callback_work}
callback for each occurrence of a \plc{taskloop-begin} and
\plc{taskloop-end} event in that thread. The callback occurs in the
context of the encountering task.  The callback has type signature
\code{ompt_callback_work_t}. The callback receives
\code{ompt_scope_begin} or \code{ompt_scope_end}
as its \plc{endpoint} argument, as appropriate, and
\code{ompt_work_taskloop} as its \plc{wstype} argument.

A thread dispatches a registered \code{ompt_callback_dispatch}
callback for each occurrence of a \plc{taskloop-iteration-begin} 
event in that thread. The callback occurs in the
context of the encountering task.  The callback has type signature
\code{ompt_callback_dispatch_t}. 

\restrictions
The restrictions of the \code{taskloop} construct are as follows:
\begin{itemize}
\item A program that branches into or out of a \code{taskloop} region is non-conforming.

\item There must be no OpenMP directive in the region between any
associated loops.

\item If a \code{collapse} clause is specified, exactly one loop must
occur in the region at each nesting level up to the number of loops
specified by the parameter of the \code{collapse} clause.

\item If a \code{reduction} clause is present on the \code{taskloop} directive, the \code{nogroup} clause must not be specified.
\item The same list item cannot appear in both a \code{reduction} and an \code{in_reduction} clause.
\item At most one \code{grainsize} clause can appear on a \code{taskloop} directive.
\item At most one \code{num_tasks} clause can appear on a \code{taskloop} directive.
\item The \code{grainsize} clause and \code{num_tasks} clause are mutually exclusive and may not appear on the same \code{taskloop} directive.
\item At most one \code{collapse} clause can appear on a \code{taskloop} directive.
\item At most one \code{if} clause can appear on the directive.
\item At most one \code{final} clause can appear on the directive.
\item At most one \code{priority} clause can appear on the directive.
\end{itemize}

\crossreferences
\begin{itemize}
\item \code{task} construct, \specref{subsec:task Construct}.
\item \code{if} clause, see \specref{sec:if Clause}.
\item \code{default} clause, see \specref{subsubsec:default clause}.
\item \code{taskgroup} construct, \specref{subsec:taskgroup Construct}.
\item Data-sharing attribute clauses, \specref{subsec:Data-Sharing Attribute Clauses}.
\item \code{ompt_scope_begin} and \code{ompt_scope_end}, see
  \specref{sec:ompt_scope_endpoint_t}.
\item \code{ompt_work_taskloop}, see \specref{sec:ompt_work_t}.
\item \code{ompt_callback_work_t}, see
\specref{sec:ompt_callback_work_t}.
\item \code{ompt_callback_dispatch_t}, see 
\specref{sec:ompt_callback_dispatch_t}.

\end{itemize}






%
%TASKLOOP SIMD
%
\subsection{\hcode{taskloop}~\hcode{simd} Construct}
\index{taskloop simd@{\code{taskloop}~\code{simd}}}
\index{constructs!taskloop simd@{\code{taskloop}~\code{simd}}}
\label{subsec:taskloop simd Construct}
\summary
The \code{taskloop}~\code{simd} construct specifies a loop that can be
executed concurrently using SIMD instructions and that those iterations
will also be executed in parallel using explicit tasks. The \code{taskloop}
\code{simd} construct is a composite construct.

\syntax
\begin{ccppspecific}
The syntax of the \code{taskloop}~\code{simd} construct is as follows:
\begin{ompcPragma}
#pragma omp taskloop simd \plc{[clause[[},\plc{] clause] ...] new-line}
    \plc{for-loops}
\end{ompcPragma}
where \plc{clause} can be any of the clauses accepted by the \code{taskloop} or \code{simd} directives with identical meanings and restrictions.
\end{ccppspecific}
\begin{fortranspecific}
The syntax of the \code{taskloop}~\code{simd} construct is as follows:
\begin{ompfPragma}
!$omp taskloop simd \plc{[clause[[},\plc{] clause] ...]}
    \plc{do-loops}
\plc{[}!$omp end taskloop simd\plc{]}
\end{ompfPragma}
where \plc{clause} can be any of the clauses accepted by the \code{taskloop} or \code{simd} directives with identical meanings and restrictions.

If an \code{end}~\code{taskloop}~\code{simd} directive is not specified, an \code{end}~\code{taskloop}~\code{simd} directive is assumed at the end of the \plc{do-loops}.
\end{fortranspecific}

\binding
The binding thread set of the \code{taskloop}~\code{simd} region is the current team. A \code{taskloop}~\code{simd} region binds to the innermost enclosing parallel region.

\descr
The \code{taskloop}~\code{simd} construct will first distribute the iterations of the associated loop(s) across tasks in a manner consistent with any clauses that apply to the \code{taskloop} construct. The resulting tasks will then be converted to a SIMD loop in a manner consistent with any clauses that apply to the \code{simd} construct, except for the \code{collapse} clause. For the purposes of each task's conversion to a SIMD loop, the \code{collapse} clause is ignored and the effect of any \code{in_reduction} clause is as if a \code{reduction} clause with the same reduction operator and list items is present on the construct.

\events

This composite construct generates the same events as the \code{taskloop} construct.

\tools

This composite construct dispatches the same callbacks as the \code{taskloop} construct.

\restrictions
\begin{itemize}
\item The restrictions for the \code{taskloop} and \code{simd} constructs apply.
\end{itemize}

\crossreferences
\begin{itemize}
\item \code{simd} construct, see \specref{subsubsec:simd Construct}.
\item \code{taskloop} construct, see \specref{subsec:taskloop Construct}.
\item Data-sharing attribute clauses, see \specref{subsec:Data-Sharing Attribute Clauses}.
\item Events and tool callbacks for \code{taskloop} construct, see
\specref{subsec:taskloop Construct}.

\end{itemize}




%
%   TASKYIELD CONSTRUCT
%
\subsection{\hcode{taskyield} Construct}
\index{taskyield@{\code{taskyield}}}
\index{constructs!taskyield@{\code{taskyield}}}
\label{subsec:taskyield Construct}
\summary
The \code{taskyield} construct specifies that the current task can be suspended in favor of
execution of a different task. The \code{taskyield} construct is a stand-alone directive.

\syntax
\begin{ccppspecific}
The syntax of the \code{taskyield} construct is as follows:

\begin{ompcPragma}
#pragma omp taskyield \plc{new-line}
\end{ompcPragma}
\end{ccppspecific}

\begin{fortranspecific}
The syntax of the \code{taskyield} construct is as follows:

\begin{ompfPragma}
!$omp taskyield
\end{ompfPragma}
\end{fortranspecific}

\binding
A \code{taskyield} region binds to the current task region. The binding thread set of the
\code{taskyield} region is the current team.

\descr
The \code{taskyield} region includes an explicit task scheduling point in the current task
region.

\crossreferences
\begin{itemize}
\item Task scheduling, see
\specref{subsec:Task Scheduling}.
\end{itemize}











\subsection{Initial Task}

\events
No events are associated with the implicit parallel region in each initial thread.

The \plc{initial-thread-begin} event occurs in an initial thread after the OpenMP runtime invokes the tool initializer
but before the initial thread begins to execute the first OpenMP region in the initial task.

The \plc{initial-task-create} event occurs after an \plc{initial-thread-begin} event
but before the first OpenMP region in which the initial task begins to execute.

The \plc{initial-thread-end} event occurs as the final event in an initial thread at the end of an initial task
immediately prior to invocation of the tool finalizer.

\tools

A thread dispatches a registered \code{ompt_callback_thread_begin}
callback for the \plc{initial-thread-begin} event in an initial thread.
The callback occurs in the context of the initial thread.
The callback has type signature \code{ompt_callback_thread_begin_t}.
The callback receives \code{ompt_thread_initial} as its \plc{thread_type} argument.

A thread dispatches a registered \code{ompt_callback_task_create}
callback for each occurrence of a \plc{initial-task-create} event
in the context of the encountering task.  This callback has the type signature
\code{ompt_callback_task_create_t}.
The callback receives \code{ompt_task_initial} as its \plc{type} argument.
The implicit parallel region does not dispatch a \code{ompt_callback_parallel_begin} callback;
however, the implicit parallel region can be initialized within this \code{ompt_callback_task_create}
callback.

A thread dispatches a registered \code{ompt_callback_thread_end}
callback for the \plc{initial-thread-end} event in that thread.
The callback occurs in the context of the thread.  The callback has type signature
\code{ompt_callback_thread_end_t}.
The implicit parallel region does not dispatch a \code{ompt_callback_parallel_end} callback;
however, the implicit parallel region can be finalized within this \code{ompt_callback_thread_end}
callback.

\crossreferences
\begin{itemize}

\item \code{ompt_thread_initial},            see \specref{sec:ompt_thread_t}.
\item \code{ompt_task_initial},              see \specref{sec:ompt_task_flag_t}.
\item \code{ompt_callback_thread_begin_t},   see \specref{sec:ompt_callback_thread_begin_t}.
\item \code{ompt_callback_thread_end_t},     see \specref{sec:ompt_callback_thread_end_t}.
\item \code{ompt_callback_parallel_begin_t}, see \specref{sec:ompt_callback_parallel_begin_t}.
\item \code{ompt_callback_parallel_end_t},   see \specref{sec:ompt_callback_parallel_end_t}.
\item \code{ompt_callback_task_create_t},    see \specref{sec:ompt_callback_task_create_t}.


\end{itemize}

\subsection{Task Scheduling}
\index{task scheduling}
\index{scheduling}
\label{subsec:Task Scheduling}
Whenever a thread reaches a task scheduling point, the implementation may cause it to
perform a task switch, beginning or resuming execution of a different task bound to the
current team. Task scheduling points are implied at the following locations:

\begin{itemize}
\item the point immediately following the generation of an explicit task;

\item after the point of completion of a \code{task} region;

\item in a \code{taskyield} region;

\item in a \code{taskwait} region;

\item at the end of a \code{taskgroup} region;

\item in an implicit and explicit \code{barrier} region;

\item the point immediately following the generation of a \code{target} region;

\item at the beginning and end of a \code{target}~\code{data} region;

\item in a \code{target}~\code{update} region;

\item in a \code{target}~\code{enter}~\code{data} region;

\item in a \code{target}~\code{exit}~\code{data} region;

\item in the \code{omp_target_memcpy} routine;

\item in the \code{omp_target_memcpy_rect} routine;

\end{itemize}

When a thread encounters a task scheduling point it may do one of the following,
subject to the \emph{Task Scheduling Constraints} (below):

\begin{itemize}
\item begin execution of a tied task bound to the current team

\item resume any suspended task region, bound to the current team, to which it is tied

\item begin execution of an untied task bound to the current team

\item resume any suspended untied task region bound to the current team.
\end{itemize}

If more than one of the above choices is available, it is unspecified as to which will be
chosen.

\emph{Task Scheduling Constraints} are as follows:

\begin{enumerate}
\item An included task is executed immediately after generation of the task.

\item Scheduling of new tied tasks is constrained by the set of task regions that are currently
tied to the thread, and that are not suspended in a \code{barrier} region. If this set is empty,
any new tied task may be scheduled. Otherwise, a new tied task may be scheduled only
if it is a descendent task of every task in the set.

\item A dependent task shall not be scheduled until its task dependences are fulfilled.

\item A task shall not be scheduled while any task with which it is
mutually exclusive has been scheduled, but has not yet completed.

\item When an explicit task is generated by a construct containing an \code{if} clause for which the
expression evaluated to \plc{false}, and the previous constraints are already met, the task is
executed immediately after generation of the task.
\end{enumerate}

A program relying on any other assumption about task scheduling is non-conforming.

\begin{note}
Task scheduling points dynamically divide task regions into parts. Each part is
executed uninterrupted from start to end. Different parts of the same task region are
executed in the order in which they are encountered. In the absence of task
synchronization constructs, the order in which a thread executes parts of different
schedulable tasks is unspecified.

Task scheduling will behave correctly and consistently with all conceivable
scheduling sequences that are compatible with the rules above.

For example, if \code{threadprivate} storage is accessed (explicitly in the source code or
implicitly in calls to library routines) in one part of a task region, its value cannot be
assumed to be preserved into the next part of the same task region if another schedulable
task exists that modifies it.

As another example, if a lock acquire and release happen in different parts of a task
region, no attempt should be made to acquire the same lock in any part of another task
that the executing thread may schedule. Otherwise, a deadlock is possible. A similar
situation can occur when a \code{critical} region spans multiple parts of a task and another
schedulable task contains a \code{critical} region with the same name.

The use of threadprivate variables and the use of locks or critical sections in an explicit
task with an \code{if} clause must take into account that when the \code{if} clause evaluates to
\plc{false}, the task is executed immediately, without regard to \emph{Task Scheduling Constraint}~2.
\end{note}

\events

The \plc{task-schedule} event occurs in a thread when the thread switches tasks at a task scheduling point;
no event occurs when switching to or from a merged task.

\tools

A thread dispatches a registered \code{ompt_callback_task_schedule}
callback for each occurrence of a \plc{task-schedule} event in
the context of the task that begins or resumes. This callback has the type signature
\code{ompt_callback_task_schedule_t}.
The argument  \plc{prior_task_status} is used to indicate the cause for suspending the prior task.
This cause may be the completion of the prior task region, the encountering of a
\code{taskyield} construct, or the encountering of an active cancellation point.

\crossreferences
\begin{itemize}
\item \code{ompt_callback_task_schedule_t}, see
\specref{sec:ompt_callback_task_schedule_t}.
\end{itemize}
