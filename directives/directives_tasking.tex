% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. There are environments that provide special formatting, e.g. language bars.
%       Please use them whereever appropriate.  Examples are:
%
%         \begin{fortranspecific}
%         This is text that appears enclosed in blue language bars for Fortran.
%         \end{fortranspecific}
%
%         \begin{note}
%         This is a note.  The "Note -- " header appears automatically.
%         \end{note}
%
%    6. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of 
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%


\section{Tasking Constructs}
\label{sec:Tasking Constructs}
\index{tasking constructs}
\index{constructs!tasking constructs}
\subsection{\code{task} Construct}
\index{task@{\code{task}}}
\index{constructs!task@{\code{task}}}
\label{subsec:task Construct}
\summary
The \code{task} construct defines an explicit task.

\syntax
\begin{ccppspecific}
\begin{samepage}
The syntax of the \code{task} construct is as follows: 

\begin{boxedcode}
\#pragma omp task \plc{[clause[ [},\plc{] clause] ... ] new-line}
    \plc{structured-block}
\end{boxedcode}
\end{samepage}

\begin{samepage}
where \plc{clause} is one of the following: 

\begin{indentedcodelist}
if(\plc{[} task :\plc{] scalar-expression})
final(\plc{scalar-expression})
untied
default(shared \textnormal{|} none)
mergeable
private(\plc{list})
firstprivate(\plc{list})
shared(\plc{list})
in_reduction(\plc{reduction-identifier }:\plc{ list})
depend(\plc{dependence-type }:\plc{ locator-list}[:\plc{iterators-definition}])
priority(\plc{priority-value})
\end{indentedcodelist}
\end{samepage}
\end{ccppspecific}

\begin{fortranspecific}
The syntax of the \code{task} construct is as follows: 

\begin{boxedcode}
!\$omp task \plc{[clause[ [},\plc{] clause] ... ]}
    \plc{structured-block}
!\$omp end task
\end{boxedcode}

where \plc{clause} is one of the following:

\begin{indentedcodelist}
if(\plc{[} task :\plc{] scalar-logical-expression})
final(\plc{scalar-logical-expression})
untied
default(private \textnormal{|} firstprivate \textnormal{|} shared \textnormal{|} none)
mergeable
private(\plc{list})
firstprivate(\plc{list})
shared(\plc{list})
in_reduction(\plc{reduction-identifier }:\plc{ list})
depend(\plc{dependence-type }:\plc{ locator-list}[:\plc{iterators-definition}])
priority(\plc{priority-value})
\end{indentedcodelist}
\end{fortranspecific}

\binding
The binding thread set of the \code{task} region is the current team. A \code{task} region binds to 
the innermost enclosing \code{parallel} region. 

\descr

The \code{task} construct is a \emph{task generating construct}. When a thread
encounters a \code{task} construct, an explicit task is generated from the code
for the associated structured block. The data environment of the task is
created according to the data-sharing attribute clauses on the \code{task}
construct, per-data environment ICVs, and any defaults that apply.

The encountering thread may immediately execute the task, or defer its execution. In the 
latter case, any thread in the team may be assigned the task. Completion of the task can 
be guaranteed using task synchronization constructs. 
If a \code{task} construct is encountered during execution of an outer
task, the generated \code{task} region associated with this construct is not a
part of the outer task region unless the generated task is
an included task.

When an \code{if} clause is present on a \code{task} construct, and the \code{if} clause expression 
evaluates to \plc{false}, an undeferred task is generated, and the encountering thread must 
suspend the current task region, for which execution cannot be resumed until the 
generated task is completed. The use of a variable in an \code{if} clause expression 
of a \code{task} construct causes an implicit reference to the variable in all enclosing 
constructs.

When a \code{final} clause is present on a \code{task} construct and the \code{final} clause expression 
evaluates to \plc{true}, the generated task will be a final task. All \code{task} constructs 
encountered during execution of a final task will generate final and included tasks. Note 
that the use of a variable in a \code{final} clause expression of a \code{task} construct causes an 
implicit reference to the variable in all enclosing constructs.

The \code{if} clause expression and the \code{final} clause expression are evaluated in the context 
outside of the \code{task} construct, and no ordering of those evaluations is specified.

A thread that encounters a task scheduling point within the \code{task} region may 
temporarily suspend the \code{task} region. By default, a task is tied and its suspended \code{task} 
region can only be resumed by the thread that started its execution. If the \code{untied} 
clause is present on a \code{task} construct, any thread in the team can resume the \code{task} 
region after a suspension. The \code{untied} clause is ignored if a \code{final} clause is present 
on the same \code{task} construct and the \code{final} clause expression evaluates to \plc{true}, or if a 
task is an included task.

The \code{task} construct includes a task scheduling point in the task region of its generating 
task, immediately following the generation of the explicit task. Each explicit \code{task} 
region includes a task scheduling point at its point of completion. 

When the \code{mergeable} clause is present on a \code{task} construct, the generated task is a \plc{mergeable task}. 

The \code{priority} clause is a hint for the priority of the generated task. The \plc{priority-value} is a
non-negative integer expression that provides a hint for task execution order. Among all
tasks ready to be executed, higher priority tasks (those with a higher numerical value in the
\code{priority} clause expression) are recommended to execute before lower priority ones. The default
\plc{priority-value} when no \code{priority} clause is specified is zero (the lowest priority). If a value is
specified in the \code{priority} clause that is higher than the \plc{max-task-priority-var} ICV then the
implementation will use the value of that ICV. A program that relies on task execution order
being determined by this \plc{priority-value} may have unspecified behavior.

\begin{note}
When storage is shared by an explicit \code{task} region, the 
programmer must ensure, by adding proper synchronization, that the storage does not 
reach the end of its lifetime before the explicit \code{task} region completes its execution.
\end{note}

\events

The \plc{task-create} event occurs when a thread encounters a construct 
that causes a new task to be created. 
The event occurs after the task is initialized but before 
it begins execution or is deferred. 

\tools

A thread dispatches a registered \code{ompt\_callback\_task\_create}
callback for each occurrence of a \plc{task-create} event
in the context of the encountering task.  
This callback has the type signature \code{ompt\_callback\_task\_create\_t}.
In the dispatched callback, \code{(task\_type \& ompt\_task\_explicit)} always
evaluates to \plc{true}.
If the task is an undeferred task, then \code{(task\_type \& ompt\_task\_undeferred)} evaluates to \plc{true}. 
If the task is a final task, \code{(task\_type \& ompt\_task\_final)} evaluates to \plc{true}.
If the task is an untied task, \code{(task\_type \& ompt\_task\_untied)} evaluates to \plc{true}. 
If the task is a mergeable task, \code{(task\_type \& ompt\_task\_mergeable)} evaluates to \plc{true}. 
If the task is a merged task, \code{(task\_type \& ompt\_task\_merged)} evaluates to \plc{true}. 

\restrictions
Restrictions to the \code{task} construct are as follows:

\begin{itemize}
\item A program that branches into or out of a \code{task} region is non-conforming. 

\item A program must not depend on any ordering of the evaluations of the clauses of the 
\code{task} directive, or on any side effects of the evaluations of the clauses. 

\item At most one \code{if} clause can appear on the directive. 

\item At most one \code{final} clause can appear on the directive.

\item At most one \code{priority} clause can appear on the directive.

\begin{ccppspecific}
\item A throw executed inside a \code{task} region must cause execution to resume within the 
same \code{task} region, and the same thread that threw the exception must catch it.
\end{ccppspecific}

\begin{fortranspecific}
\item Unsynchronized use of Fortran I/O statements by multiple tasks on the same unit has 
unspecified behavior
\end{fortranspecific}
\end{itemize}

\crossreferences
\begin{itemize}
\item Task scheduling constraints, see \specref{subsec:Task Scheduling}. 
\item \code{depend} clause, see \specref{subsec:depend Clause}.
\item \code{if} Clause, see \specref{sec:if Clause}.
\item Data-sharing attribute clauses, \specref{subsec:Data-Sharing Attribute Clauses}.
\item \code{ompt\_callback\_task\_create\_t}, see
\specref{sec:ompt_callback_task_create_t}.
%\item \code{ompt\_callback\_task\_schedule\_t}, see
%\specref{sec:ompt_callback_task_schedule_t}.
\end{itemize}











% TASKLOOP 
\subsection{\code{taskloop} Construct}
\index{taskloop@{\code{taskloop}}}
\index{constructs!taskloop@{\code{taskloop}}}
\label{subsec:taskloop Construct}
\summary
The \code{taskloop} construct specifies that the iterations of one or more associated loops will be executed in parallel using explicit tasks. The iterations are distributed across tasks generated by the construct and scheduled to be executed.
\syntax
\begin{ccppspecific}
The syntax of the \code{taskloop} construct is as follows:
\begin{boxedcode}
\#pragma omp taskloop \plc{[clause[[,] clause] ...] new-line}
    \plc{for-loops}
\end{boxedcode}
where \plc{clause} is one of the following:
\begin{indentedcodelist}
if(\plc{[} taskloop :\plc{] scalar-expr})
shared(\plc{list})
private(\plc{list})
firstprivate(\plc{list})
lastprivate(\plc{list})
reduction(\plc{reduction-identifier }:\plc{ list})
in_reduction(\plc{reduction-identifier }:\plc{ list})
default(shared \textnormal{|} none)
grainsize(\plc{grain-size})
num_tasks(\plc{num-tasks})
collapse(\plc{n})
final(\plc{scalar-expr})
priority(\plc{priority-value})
untied
mergeable
nogroup
\end{indentedcodelist}

The \code{taskloop} directive places restrictions on the structure of all associated \plc{for-loops}. Specifically, all associated \plc{for-loops} must have canonical loop form (see \specref{sec:Canonical Loop Form}).
\end{ccppspecific}
\begin{fortranspecific}
The syntax of the \code{taskloop} construct is as follows:
\begin{boxedcode}
!\$omp taskloop \plc{[clause[[,] clause] ...]}
    \plc{do-loops}
\plc{[}!\$omp end taskloop\plc{]}
\end{boxedcode}
where \plc{clause} is one of the following:
\begin{indentedcodelist}
if(\plc{[} taskloop :\plc{] scalar-logical-expr})
shared(\plc{list})
private(\plc{list})
firstprivate(\plc{list})
lastprivate(\plc{list})
reduction(\plc{reduction-identifier }:\plc{ list})
in_reduction(\plc{reduction-identifier }:\plc{ list})
default(private \textnormal{|} firstprivate \textnormal{|} shared \textnormal{|} none)
grainsize(\plc{grain-size})
num_tasks(\plc{num-tasks})
collapse(\plc{n})
final(\plc{scalar-logical-expr})
priority(\plc{priority-value})
untied
mergeable
nogroup
\end{indentedcodelist}

If an \code{end}~\code{taskloop} directive is not specified, an 
\code{end}~\code{taskloop} directive is assumed at the end of the 
\plc{do-loops}.

Any associated \plc{do-loop} must be \plc{do-construct} or an 
\plc{inner-shared-do-construct} as defined by the Fortran standard. 
If an \code{end}~\code{taskloop} directive follows a \plc{do-construct} 
in which several loop statements share a \code{DO} 
termination statement, then the directive can only be specified for the 
outermost of these \code{DO} statements.

If any of the loop iteration variables would otherwise be shared, they are implicitly made private for the loop-iteration tasks generated by the \code{taskloop} construct. Unless the loop iteration variables are specified in a \code{lastprivate} clause on the \code{taskloop} construct, their values after the loop are unspecified.
\end{fortranspecific}

\binding
The binding thread set of the \code{taskloop} region is the current team. A \code{taskloop} region binds to the innermost enclosing \code{parallel} region.

\descr
The \code{taskloop} construct is a \emph{task generating construct}. When a thread encounters a \code{taskloop} construct, the construct partitions the associated loops into explicit tasks for parallel execution of the loops' iterations. The data environment of each generated task is created according to the data-sharing attribute clauses on the \code{taskloop} construct, per-data environment ICVs, and any defaults that apply. The order of the creation of the loop tasks is unspecified.
Programs that rely on any execution order of the logical loop iterations are non-conforming. 

By default, the \code{taskloop} construct executes as if it was enclosed in a \code{taskgroup} construct with no statements or directives outside of the \code{taskloop} construct. Thus, the \code{taskloop} construct creates an implicit \code{taskgroup} region. If the \code{nogroup} clause is present, no implicit \code{taskgroup} region is created.

If a \code{reduction} clause is present on the \code{taskloop} construct, the behavior is as if a \code{task\_reduction} clause with the same reduction operator and list items was applied to the implicit \code{taskgroup} construct enclosing the \code{taskloop} construct.
Furthermore, the \code{taskloop} construct executes as if each generated task was defined by a \code{task} construct on which an \code{in\_reduction} clause with the same reduction operator and list items is present. Thus, the generated tasks are participants of the reduction defined by the \code{task\_reduction} clause that was applied to the implicit \code{taskgroup} construct.

If an \code{in\_reduction} clause is present on the \code{taskloop} construct, the behavior is as if each generated task was defined by a \code{task} construct on which an \code{in\_reduction} clause with the same reduction operator and list items is present. Thus, the generated tasks are participants of a reduction previously defined by a reduction scoping clause.

If a \code{grainsize} clause is present on the \code{taskloop} construct, the number of logical loop iterations assigned to each generated task is greater than or equal to the minimum of the value of the \plc{grain-size} expression and the number of logical loop iterations, but less than two times the value of the \plc{grain-size} expression.

The parameter of the \code{grainsize} clause must be a positive integer expression.
If \code{num\_tasks} is specified, the \code{taskloop} construct creates as many tasks as the minimum of the \plc{num-tasks} expression and the number of logical loop iterations.  
Each task must have at least one logical loop iteration.
The parameter of the \code{num\_tasks} clause must evaluate to a positive integer.
If neither a \code{grainsize} nor \code{num\_tasks} clause is present, the number of loop tasks generated and the number of logical loop iterations assigned to these tasks is implementation defined.

The \code{collapse} clause may be used to specify how many loops are associated with the \code{taskloop} construct. The parameter of the \code{collapse} clause must be a constant positive integer expression. If no \code{collapse} clause is present, the only loop that is associated with the \code{taskloop} construct is the one that immediately follows the \code{taskloop} directive.

If more than one loop is associated with the \code{taskloop} construct, then the iterations of all associated loops are collapsed into one larger iteration space that is then divided according to the \code{grainsize} and \code{num\_tasks} clauses. The sequential execution of the iterations in all associated loops determines the order of the iterations in the collapsed iteration space. 
%% TODO: Does this conflict with the note about the independence of loop iterations below?

The iteration count for each associated loop is computed before entry to the outermost loop. If execution of any associated loop changes any of the values used to compute any of the iteration counts, then the behavior is unspecified. 

The integer type (or kind, for Fortran) used to compute the iteration count for the collapsed loop is implementation defined.

When an \code{if} clause is present on a \code{taskloop} construct, and if the \code{if} clause expression evaluates to \plc{false}, undeferred tasks are generated. The use of a variable in an \code{if} clause expression of a \code{taskloop} construct causes an implicit reference to the variable in all enclosing constructs.

When a \code{final} clause is present on a \code{taskloop} construct and the \code{final} clause expression evaluates to \plc{true}, the generated tasks will be final tasks. The use of a variable in a \code{final} clause expression of a \code{taskloop} construct causes an implicit reference to the variable in all enclosing constructs.

When a \code{priority} clause is present on a \code{taskloop} construct,
the generated tasks have the \plc{priority-value} as if it was 
specified for each individual task.  
If the \code{priority} clause is not specified, tasks generated by 
the \code{taskloop} construct have the default task priority (zero).

If the \code{untied} clause is specified, all tasks generated by the \code{taskloop} construct are untied tasks.

When the \code{mergeable} clause is present on a \code{taskloop} construct, each generated task is a \plc{mergeable task}. 

\begin{cppspecific}
For \code{firstprivate} variables of class type, the number of invocations of copy constructors to perform the initialization  is implementation-defined.
\end{cppspecific}

\begin{note}
When storage is shared by a \code{taskloop} region, the programmer must ensure, by adding proper synchronization, that the storage does not reach the end of its lifetime before the \code{taskloop} region and its descendant tasks complete their execution.
\end{note}

\def\omptWorksharingLoop#1#2
{
\events

The \plc{#1{-begin}} event occurs after a task encounters a 
\code{#1} construct but before the task starts the execution of the structured 
block of the \code{#1} region.

The \plc{#1{-end}} event occurs after a \code{#1} region finishes execution 
but before resuming execution of the encountering task.

\tools

A thread dispatches a registered \code{ompt\_callback\_work}
callback for each occurrence of a \plc{#1{-begin}} and
\plc{#1{-end}} event in that thread. The callback occurs in the
context of the encountering task.  The callback has type signature
\code{ompt\_callback\_work\_t}. The callback receives
\code{ompt\_scope\_begin} or \code{ompt\_scope\_end} 
as its \plc{endpoint} argument, as appropriate, and 
\code{#2} as its \plc{wstype} argument.
}
% \omptWorksharingLoop{taskloop}{ompt\_work\_taskloop}

\events

The \plc{taskloop-begin} event occurs after a task encounters a
\code{taskloop} construct but before any other events that may 
trigger as a consequence of executing the \code{taskloop}.
Specifically, a \plc{taskloop-begin} event for a \code{taskloop}
will precede the \plc{taskgroup-begin} that occurs unless a
\code{nogroup} clause is present.  Regardless of whether an implicit
taskgroup is present, a \plc{taskloop-begin} will always precede
any \plc{task-create} events for generated tasks.

The \plc{taskloop-end} event occurs after a \code{taskloop} region finishes execution
but before resuming execution of the encountering task.

\tools

A thread dispatches a registered \code{ompt\_callback\_work}
callback for each occurrence of a \plc{taskloop-begin} and
\plc{taskloop-end} event in that thread. The callback occurs in the
context of the encountering task.  The callback has type signature
\code{ompt\_callback\_work\_t}. The callback receives
\code{ompt\_scope\_begin} or \code{ompt\_scope\_end}
as its \plc{endpoint} argument, as appropriate, and
\code{ompt\_work\_taskloop} as its \plc{wstype} argument.

\restrictions
The restrictions of the \code{taskloop} construct are as follows:
\begin{itemize}
\item A program that branches into or out of a \code{taskloop} region is non-conforming.
\item All loops associated with the \code{taskloop} construct must be perfectly nested; that is, there must be no intervening code nor any OpenMP directive between any two loops.
\item If a \code{reduction} clause is present on the \code{taskloop} directive, the \code{nogroup} clause must not be specified.
\item The same list item cannot appear in both a \code{reduction} and an \code{in\_reduction} clause.
\item At most one \code{grainsize} clause can appear on a \code{taskloop} directive.
\item At most one \code{num\_tasks} clause can appear on a \code{taskloop} directive.
\item The \code{grainsize} clause and \code{num\_tasks} clause are mutually exclusive and may not appear on the same \code{taskloop} directive.
\item At most one \code{collapse} clause can appear on a \code{taskloop} directive.
\item At most one \code{if} clause can appear on the directive.
\item At most one \code{final} clause can appear on the directive. 
\item At most one \code{priority} clause can appear on the directive.
\end{itemize}

\crossreferences
\begin{itemize}
\item \code{task} construct, \specref{subsec:task Construct}.
\item \code{taskgroup} construct, \specref{subsec:taskgroup Construct}.
\item Data-sharing attribute clauses, \specref{subsec:Data-Sharing Attribute Clauses}. 
\item \code{if} Clause, see \specref{sec:if Clause}.
\item \code{ompt\_scope\_begin} and \code{ompt\_scope\_end}, see
  \specref{sec:ompt_scope_endpoint_t}.
\item \code{ompt\_work\_taskloop}, see \specref{sec:ompt_work_type_t}.
\item \code{ompt\_callback\_work\_t}, see
\specref{sec:ompt_callback_work_t}.

\end{itemize}






%
%TASKLOOP SIMD
%
\subsection{\code{taskloop}~\code{simd} Construct}
\index{taskloop simd@{\code{taskloop}~\code{simd}}}
\index{constructs!taskloop simd@{\code{taskloop}~\code{simd}}}
\label{subsec:taskloop simd Construct}
\summary
The \code{taskloop}~\code{simd} construct specifies a loop that can be 
executed concurrently using SIMD instructions and that those iterations 
will also be executed in parallel using explicit tasks. The \code{taskloop}
\code{simd} construct is a composite construct.

\syntax
\begin{ccppspecific}
The syntax of the \code{taskloop}~\code{simd} construct is as follows:
\begin{boxedcode}
\#pragma omp taskloop simd \plc{[clause[[,] clause] ...] new-line}
    \plc{for-loops}
\end{boxedcode}
where \plc{clause} can be any of the clauses accepted by the \code{taskloop} or \code{simd} directives with identical meanings and restrictions.
\end{ccppspecific}
\begin{fortranspecific}
The syntax of the \code{taskloop}~\code{simd} construct is as follows:
\begin{boxedcode}
!\$omp taskloop simd \plc{[clause[[,] clause] ...]}
    \plc{do-loops}
\plc{[}!\$omp end taskloop simd\plc{]}
\end{boxedcode}
where \plc{clause} can be any of the clauses accepted by the \code{taskloop} or \code{simd} directives with identical meanings and restrictions.

If an \code{end}~\code{taskloop}~\code{simd} directive is not specified, an \code{end}~\code{taskloop}~\code{simd} directive is assumed at the end of the \plc{do-loops}.
\end{fortranspecific}

\binding
The binding thread set of the \code{taskloop}~\code{simd} region is the current team. A \code{taskloop}~\code{simd} region binds to the innermost enclosing parallel region.

\descr
The \code{taskloop}~\code{simd} construct will first distribute the iterations of the associated loop(s) across tasks in a manner consistent with any clauses that apply to the \code{taskloop} construct. The resulting tasks will then be converted to a SIMD loop in a manner consistent with any clauses that apply to the \code{simd} construct, except for the \code{collapse} clause. For the purposes of each task's conversion to a SIMD loop, the \code{collapse} clause is ignored and the effect of any \code{in\_reduction} clause is as if a \code{reduction} clause with the same reduction operator and list items is present on the construct.

\events

This composite construct generates the same events as the \code{taskloop} construct.

\tools

This composite construct dispatches the same callbacks as the \code{taskloop} construct.

\restrictions
\begin{itemize}
\item The restrictions for the \code{taskloop} and \code{simd} constructs apply.
\end{itemize}

\crossreferences
\begin{itemize}
\item \code{taskloop} construct, see \specref{subsec:taskloop Construct}.
\item \code{simd} construct, see \specref{subsec:simd Construct}.
\item Data-sharing attribute clauses, see \specref{subsec:Data-Sharing Attribute Clauses}. 
\item Events and tool callbacks for \code{taskloop} construct, see
\specref{subsec:taskloop Construct}.

\end{itemize}




%
%   TASKYIELD CONSTRUCT
%
\subsection{\code{taskyield} Construct}
\index{taskyield@{\code{taskyield}}}
\index{constructs!taskyield@{\code{taskyield}}}
\label{subsec:taskyield Construct}
\summary
The \code{taskyield} construct specifies that the current task can be suspended in favor of 
execution of a different task. The \code{taskyield} construct is a stand-alone directive.

\syntax
\begin{ccppspecific}
The syntax of the \code{taskyield} construct is as follows:

\begin{boxedcode}
\#pragma omp taskyield \plc{new-line}
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
The syntax of the \code{taskyield} construct is as follows:

\begin{boxedcode}
!\$omp taskyield
\end{boxedcode}
\end{fortranspecific}

\binding
A \code{taskyield} region binds to the current task region. The binding thread set of the 
\code{taskyield} region is the current team.

\descr
The \code{taskyield} region includes an explicit task scheduling point in the current task 
region.

\crossreferences
\begin{itemize}
\item Task scheduling, see 
\specref{subsec:Task Scheduling}. 
\end{itemize}











\subsection{Initial Task}

\events
No events are associated with the implicit parallel region in each initial thread.

The \plc{initial-thread-begin} event occurs in an initial thread after the OpenMP runtime invokes the tool initializer 
but before the initial thread begins to execute the first OpenMP region in the initial task. 

The \plc{initial-task-create} event occurs after an \plc{initial-thread-begin} event 
but before the first OpenMP region in the initial task begins to execute.

The \plc{initial-thread-end} event occurs as the final event in an initial thread at the end of an initial task 
immediately prior to invocation of the tool finalizer.

\tools

A thread dispatches a registered \code{ompt\_callback\_thread\_begin}
callback for the \plc{initial-thread-begin} event in an initial thread. 
The callback occurs in the context of the initial thread.  
The callback has type signature \code{ompt\_callback\_thread\_begin\_t}. 
The callback receives \code{ompt\_thread\_initial} as its \plc{thread\_type} argument.

A thread dispatches a registered \code{ompt\_callback\_task\_create}
callback for each occurrence of a \plc{initial-task-create} event
in the context of the encountering task.  This callback has the type signature
\code{ompt\_callback\_task\_create\_t}. 
The callback receives \code{ompt\_task\_initial} as its \plc{type} argument. 
The implicit parallel region does not dispatch a \code{ompt\_callback\_parallel\_begin} callback;
however, the implicit parallel region can be initialized within this \code{ompt\_callback\_task\_create}
callback.

A thread dispatches a registered \code{ompt\_callback\_thread\_end}
callback for the \plc{initial-thread-end} event in that thread. 
The callback occurs in the context of the thread.  The callback has type signature
\code{ompt\_callback\_thread\_end\_t}. 
The implicit parallel region does not dispatch a \code{ompt\_callback\_parallel\_end} callback;
however, the implicit parallel region can be finalized within this \code{ompt\_callback\_thread\_end}
callback.

\crossreferences
\begin{itemize}

\item \code{ompt\_task\_initial}, see
\specref{sec:ompt_task_type_t}.

\item \code{ompt\_callback\_thread\_begin\_t}, see
  \specref{sec:ompt_callback_thread_begin_t}.

\item \code{ompt\_callback\_thread\_end\_t}, see
  \specref{sec:ompt_callback_thread_end_t}.

\item \code{ompt\_callback\_task\_create\_t}, see
\specref{sec:ompt_callback_task_create_t}.


\end{itemize}

\subsection{Task Scheduling}
\index{task scheduling}
\index{scheduling}
\label{subsec:Task Scheduling}
Whenever a thread reaches a task scheduling point, the implementation may cause it to 
perform a task switch, beginning or resuming execution of a different task bound to the 
current team. Task scheduling points are implied at the following locations:

\begin{itemize}
\item the point immediately following the generation of an explicit task;

\item after the point of completion of a \code{task} region;

\item in a \code{taskyield} region;

\item in a \code{taskwait} region;

\item at the end of a \code{taskgroup} region;

\item in an implicit and explicit \code{barrier} region;

\item the point immediately following the generation of a \code{target} region;

\item at the beginning and end of a \code{target}~\code{data} region;

\item in a \code{target}~\code{update} region; 

\item in a \code{target}~\code{enter}~\code{data} region; 

\item in a \code{target}~\code{exit}~\code{data} region; 

\item in the \code{omp\_target\_memcpy} routine; 

\item in the \code{omp\_target\_memcpy\_rect} routine;

\end{itemize}

When a thread encounters a task scheduling point it may do one of the following, 
subject to the \emph{Task Scheduling Constraints} (below):

\begin{itemize}
\item begin execution of a tied task bound to the current team

\item resume any suspended task region, bound to the current team, to which it is tied

\item begin execution of an untied task bound to the current team

\item resume any suspended untied task region bound to the current team.
\end{itemize}

If more than one of the above choices is available, it is unspecified as to which will be 
chosen.

\emph{Task Scheduling Constraints} are as follows:

\begin{enumerate}
\item An included task is executed immediately after generation of the task.

\item Scheduling of new tied tasks is constrained by the set of task regions that are currently 
tied to the thread, and that are not suspended in a \code{barrier} region. If this set is empty, 
any new tied task may be scheduled. Otherwise, a new tied task may be scheduled only 
if it is a descendent task of every task in the set.

\item A dependent task shall not be scheduled until its task dependences are fulfilled.

\item When an explicit task is generated by a construct containing an \code{if} clause for which the 
expression evaluated to \plc{false}, and the previous constraints are already met, the task is 
executed immediately after generation of the task.
\end{enumerate}

A program relying on any other assumption about task scheduling is non-conforming.

\begin{note}
Task scheduling points dynamically divide task regions into parts. Each part is 
executed uninterrupted from start to end. Different parts of the same task region are 
executed in the order in which they are encountered. In the absence of task 
synchronization constructs, the order in which a thread executes parts of different 
schedulable tasks is unspecified.

A correct program must behave correctly and consistently with all conceivable 
scheduling sequences that are compatible with the rules above.

For example, if \code{threadprivate} storage is accessed (explicitly in the source code or 
implicitly in calls to library routines) in one part of a task region, its value cannot be 
assumed to be preserved into the next part of the same task region if another schedulable 
task exists that modifies it.

As another example, if a lock acquire and release happen in different parts of a task 
region, no attempt should be made to acquire the same lock in any part of another task 
that the executing thread may schedule. Otherwise, a deadlock is possible. A similar 
situation can occur when a \code{critical} region spans multiple parts of a task and another 
schedulable task contains a \code{critical} region with the same name.

The use of threadprivate variables and the use of locks or critical sections in an explicit 
task with an \code{if} clause must take into account that when the \code{if} clause evaluates to 
\plc{false}, the task is executed immediately, without regard to \emph{Task Scheduling Constraint}~2.
\end{note}

\events

The \plc{task-schedule} event occurs in a thread when the thread switches tasks at a task scheduling point;
no event occurs when switching to or from a merged task.

\tools

A thread dispatches a registered \code{ompt\_callback\_task\_schedule}
callback for each occurrence of a \plc{task-schedule} event in 
the context of the task that begins or resumes. This callback has the type signature
\code{ompt\_callback\_task\_schedule\_t}. 
The argument  \plc{prior\_task\_status} is used to indicate the cause for suspending the prior task. 
This cause may be the completion of the prior task region, the encountering of a 
\code{taskyield} construct, or the encountering of an active cancellation point.

\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_task\_schedule\_t}, see
\specref{sec:ompt_callback_task_schedule_t}.
\end{itemize}
