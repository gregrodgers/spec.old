% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. There are environments that provide special formatting, e.g. language bars.
%       Please use them whereever appropriate.  Examples are:
%
%         \begin{fortranspecific}
%         This is text that appears enclosed in blue language bars for Fortran.
%         \end{fortranspecific}
%
%         \begin{note}
%         This is a note.  The "Note -- " header appears automatically.
%         \end{note}
%
%    6. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of 
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%


\section{\code{declare}~\code{reduction} Directive}
\index{declare reduction@{\code{declare}~\code{reduction}}}
\index{directives!declare reduction@{\code{declare}~\code{reduction}}}
\label{sec:declare reduction Directive}
\summary
The following section describes the directive for declaring user-defined reductions. The 
\code{declare}~\code{reduction} directive declares a \plc{reduction-identifier} that can be used in a 
\code{reduction} clause. The \code{declare}~\code{reduction} directive is a declarative directive.

\syntax
\begin{cspecific}
\begin{boxedcode}
\#pragma omp declare reduction(\plc{reduction-identifier }:\plc{ typename-list }: 
\plc{combiner })\plc{[initializer-clause] new-line}
\end{boxedcode}

where:

\begin{itemize}

\item \plc{reduction-identifier} is either a base language identifier or one of the following 
operators: 
\code{+}, 
\code{-}, 
\code{*}, 
\code{\&}, 
\code{|}, 
\code{\^}, 
\code{\&\&} and 
\code{||} 

\item \plc{typename-list} is a list of type names 

\item \plc{combiner} is an expression 

\item \plc{initializer-clause} is \code{initializer(}\plc{initializer-expr}\code{)}
where \plc{initializer-expr} is\linebreak
\code{omp\_priv = }\plc{initializer} or \plc{function-name}\code{(}\plc{argument-list}\code{)} 
\end{itemize}
\end{cspecific}


\begin{cppspecific}
\begin{boxedcode}
\#pragma omp declare reduction(\plc{reduction-identifier }:\plc{ typename-list }: 
\plc{combiner})\plc{ [initializer-clause] new-line}
\end{boxedcode}

where:

\begin{itemize}
\item \plc{reduction-identifier} is either an \plc{id-expression} or one of the following 
operators: 
\code{+}, 
\code{-}, 
\code{*}, 
\code{\&}, 
\code{|}, 
\code{\^}, 
\code{\&\&} and 
\code{||} 

\item \plc{typename-list} is a list of type names 

\item \plc{combiner} is an expression 

% An equal sign is intentionally missing for C++, so that
% initializer (omp_priv (4)) syntax is also valid in addition to
% initializer (omp_priv = 4).
\item \plc{initializer-clause} is \code{initializer(}\plc{initializer-expr}\code{)} 
where \plc{initializer-expr} is\linebreak
\code{omp\_priv} \plc{initializer} or \plc{function-name}\code{(}\plc{argument-list}\code{)} 
\end{itemize}
\end{cppspecific}


\begin{fortranspecific}
\begin{boxedcode}
!\$omp declare reduction(\plc{reduction-identifier }:\plc{ type-list }:\plc{ combiner}) 
\plc{[initializer-clause]}
\end{boxedcode}

where:

\begin{itemize}
\item \plc{reduction-identifier} is either a base language identifier, or a user-defined operator, or 
one of the following operators: 
\code{+}, 
\code{-}, 
\code{*}, 
\code{.and.}, 
\code{.or.}, 
\code{.eqv.}, 
\code{.neqv.}, or one of the following intrinsic procedure names: 
\code{max}, 
\code{min}, 
\code{iand}, 
\code{ior}, 
\code{ieor}. 

\item \plc{type-list} is a list of type specifiers 

\item \plc{combiner} is either an assignment statement or a subroutine name followed by an 
argument list 

\item \plc{initializer-clause} is \code{initializer(}\plc{initializer-expr}\code{)}, 
where \plc{initializer-expr} is\linebreak
\code{omp\_priv = }\plc{expression} or \plc{subroutine-name}\code{(}\plc{argument-list}\code{)}
\end{itemize}
\end{fortranspecific}

\descr
Custom reductions can be defined using the \code{declare}~\code{reduction} directive; the 
\plc{reduction-identifier} and the type identify the \code{declare}~\code{reduction} directive. The 
\plc{reduction-identifier} can later be used in a \code{reduction} clause using variables of the 
type or types specified in the \code{declare}~\code{reduction} directive. If the directive applies 
to several types then it is considered as if there were multiple \code{declare}~\code{reduction} 
directives, one for each type.

\begin{fortranspecific}
If a type with deferred or assumed length type parameter is specified in a \code{declare}~\code{reduction} directive, the \plc{reduction-identifier} of that directive can be used in a \code{reduction} clause with any variable of the same type and the same kind parameter, regardless of the length type Fortran parameters with which the variable is declared.
\end{fortranspecific}

The visibility and accessibility of this declaration are the same as those of a variable 
declared at the same point in the program. The enclosing context of the \plc{combiner} and of 
the \plc{initializer-expr} will be that of the \code{declare}~\code{reduction} directive. The \plc{combiner} 
and the \plc{initializer-expr} must be correct in the base language as if they were the body of 
a function defined at the same point in the program.

\begin{fortranspecific}
If the \plc{reduction-identifier} is the same as the name of a user-defined operator or an extended operator, or the same as a generic name that is one of the allowed intrinsic procedures, and if the operator or procedure name appears in an accessibility statement in the same module, the accessibility of the corresponding \code{declare}~\code{reduction} directive is determined by the accessibility attribute of the statement.

If the \plc{reduction-identifier} is the same as a generic name that is one of the allowed intrinsic procedures and is accessible, and if it has the same name as a derived type in the same module, the accessibility of the corresponding \code{declare}~\code{reduction} directive is determined by the accessibility of the generic name according to the base language.
\end{fortranspecific}

\newpage %% HACK

\begin{cppspecific}
The \code{declare}~\code{reduction} directive can also appear at points in the program at which 
a static data member could be declared. In this case, the visibility and accessibility of 
the declaration are the same as those of a static data member declared at the same point 
in the program.
\end{cppspecific}

The \plc{combiner} specifies how partial results can be combined into a single value. The 
\plc{combiner} can use the special variable identifiers \code{omp\_in} and \code{omp\_out} that are of the 
type of the variables being reduced with this \plc{reduction-identifier}. Each of them will 
denote one of the values to be combined before executing the \plc{combiner}. It is assumed 
that the special \code{omp\_out} identifier will refer to the storage that holds the resulting 
combined value after executing the \plc{combiner}.

The number of times the \plc{combiner} is executed, and the order of these executions, for 
any \code{reduction} clause is unspecified.

\begin{fortranspecific}
If the \plc{combiner} is a subroutine name with an argument list, the \plc{combiner} is evaluated by 
calling the subroutine with the specified argument list.

If the \plc{combiner} is an assignment statement, the \plc{combiner} is evaluated by executing the 
assignment statement.
\end{fortranspecific}

As the \plc{initializer-expr} value of a user-defined reduction is not known \emph{a priori} the 
\plc{initializer-clause} can be used to specify one. Then the contents of the \plc{initializer-clause} 
will be used as the initializer for private copies of reduction list items where the 
\code{omp\_priv} identifier will refer to the storage to be initialized. The special identifier 
\code{omp\_orig} can also appear in the \plc{initializer-clause} and it will refer to the storage of the 
original variable to be reduced.

The number of times that the \plc{initializer-expr} is evaluated, and the order of these 
evaluations, is unspecified.

\begin{ccppspecific}
If the \plc{initializer-expr} is a function name with an argument list, the \plc{initializer-expr} is 
evaluated by calling the function with the specified argument list. Otherwise, the 
\plc{initializer-expr} specifies how \code{omp\_priv} is declared and initialized.
\end{ccppspecific}
\bigskip

\begin{cspecific}
If no \plc{initializer-clause} is specified, the private variables will be initialized following the 
rules for initialization of objects with static storage duration.
\end{cspecific}

\begin{cppspecific}
If no \plc{initializer-expr} is specified, the private variables will be initialized following the 
rules for \plc{default-initialization}.
\end{cppspecific}
\bigskip

\begin{fortranspecific}
If the \plc{initializer-expr} is a subroutine name with an argument list, the \plc{initializer-expr} is 
evaluated by calling the subroutine with the specified argument list.

If the \plc{initializer-expr} is an assignment statement, the \plc{initializer-expr} is evaluated by 
executing the assignment statement.

If no \plc{initializer-clause} is specified, the private variables will be initialized as follows:
\begin{itemize}
\item For \code{complex}, \code{real}, or \code{integer} types, the value 0 will be used.
\item For \code{logical} types, the value \code{.false.} will be used.
\item For derived types for which default initialization is specified, default initialization 
will be used.
\item Otherwise, not specifying an \plc{initializer-clause} results in unspecified behavior.
\end{itemize}
\end{fortranspecific}
\bigskip

\begin{ccppspecific}
If \plc{reduction-identifier} is used in a \code{target} region then a \code{declare}~\code{target} construct 
must be specified for any function that can be accessed through the \plc{combiner} and 
\plc{initializer-expr}.
\end{ccppspecific}
\bigskip

\begin{fortranspecific}
If \plc{reduction-identifier} is used in a \code{target} region then a \code{declare}~\code{target} construct 
must be specified for any function or subroutine that can be accessed through the \plc{combiner} 
and \plc{initializer-expr}.
\end{fortranspecific}

\restrictions
\begin{itemize}
  
\item The only variables allowed in the \plc{combiner} are
  \code{omp\_in} and \code{omp\_out}.

\item The only variables allowed in the \plc{initializer-clause} are
  \code{omp\_priv} and \code{omp\_orig}.

\item If the variable \code{omp\_orig} is modified in the \plc{initializer-clause}, the behavior is 
unspecified. 

\item If execution of the \plc{combiner} or the \plc{initializer-expr} results in the execution of an 
OpenMP construct or an OpenMP API call, then the behavior is unspecified.

\item A \plc{reduction-identifier} may not be re-declared in the current scope for the same type 
or for a type that is compatible according to the base language rules.

\item At most one \plc{initializer-clause} can be specified. 

\begin{ccppspecific}
\item A type name in a \code{declare}~\code{reduction} directive cannot be a function type, an 
array type, a reference type, or a type qualified with \code{const}, \code{volatile} or 
\code{restrict}. 
\end{ccppspecific}
\bigskip

\begin{cspecific}
\item If the \plc{initializer-expr} is a function name with an argument list, then one of the 
arguments must be the address of \code{omp\_priv}. 
\end{cspecific}
\bigskip

\begin{cppspecific}
\item If the \plc{initializer-expr} is a function name with an argument list, then one of the 
arguments must be \code{omp\_priv} or the address of \code{omp\_priv}. 
\end{cppspecific}
\bigskip

\begin{fortranspecific}
\item If the \plc{initializer-expr} is a subroutine name with an argument list, then one of the 
arguments must be \code{omp\_priv}.

\item If the \code{declare}~\code{reduction} directive appears in the specification part of a module and the corresponding reduction clause does not appear in the same module, the \plc{reduction-identifier} must be the same as the name of a user-defined operator, one of the allowed operators that is extended or a generic name that is the same as the name of one of the allowed intrinsic procedures. 

\item If the \code{declare}~\code{reduction} directive appears in the specification of a module, if the corresponding \code{reduction} clause does not appear in the same module, and if the \plc{reduction-identifier} is the same as the name of a user-defined operator or an extended operator, or the same as a generic name that is the same as one of the allowed intrinsic procedures then the interface for that operator or the generic name must be defined in the specification of the same module, or must be accessible by use association. 

\item Any subroutine or function used in the \code{initializer} clause or \plc{combiner} expression must be an intrinsic function, or must have an accessible interface. 

\item Any user-defined operator or extended operator used in the \code{initializer} clause or \plc{combiner} expression must have an accessible interface. 

\item If any subroutine, function, user-defined operator, or extended operator is used in the \code{initializer} clause or \plc{combiner} expression, it must be accessible to the subprogram in which the corresponding \code{reduction} clause is specified. 

\item If the length type parameter is specified for a character type, it must be a constant, a colon or an~\code{*}. 

\item If a character type with deferred or assumed length parameter is specified in a \code{declare}~\code{reduction} directive, no other \code{declare}~\code{reduction} directive with Fortran character type of the same kind parameter and the same \plc{reduction-identifier} is allowed in the same scope.

\item Any subroutine used in the \code{initializer} clause or \plc{combiner} expression must not have any alternate returns appear in the argument list.
\end{fortranspecific}
\end{itemize}

\crossreferences
\begin{itemize}
\item \code{reduction} clause, 
\specref{subsubsec:reduction clause}.
\end{itemize}










