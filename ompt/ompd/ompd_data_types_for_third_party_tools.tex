
\section{OMPD Data Types}
\label{subsec:ompd-data-types}

This section defines the OMPD types.

\subsection{Size Type}
\label{subsubsubsec:ompd_size_t}

\summary
The \code{ompd_size_t} type specifies the number of bytes in opaque 
data objects that are passed across the OMPD API.

\format
\begin{ccppspecific}
\begin{ompSyntax}
typedef uint64_t ompd_size_t;
\end{ompSyntax}
\end{ccppspecific}



\subsection{Wait ID Type}
\label{subsubsubsec:ompd_wait_id_t}

\summary
This \code{ompd_wait_id_t} type identifies the object on which a thread.

\format
\begin{ccppspecific}
\begin{ompSyntax}
typedef uint64_t ompd_wait_id_t;
\end{ompSyntax}
\end{ccppspecific}



\subsection{Basic Value Types}
\label{subsubsubsec:ompd_addr_t}
\label{subsubsubsec:ompd_word_t}
\label{subsubsubsec:ompd_seg_t}

\summary
These definitions represent a word, address, and segment value types.

\format

\begin{ccppspecific}
\begin{ompSyntax}
typedef uint64_t ompd_addr_t;
typedef int64_t  ompd_word_t;
typedef uint64_t ompd_seg_t;
\end{ompSyntax}
\end{ccppspecific}

\descr
The \plc{ompd_addr_t} type represents an unsigned integer address in an
OpenMP process. The \plc{ompd_word_t} type represents a signed version of 
\plc{ompd_addr_t} to hold a signed integer of the OpenMP process. The 
\plc{ompd_seg_t} type represents an unsigned integer segment value.



\subsection{Address Type}
\label{subsubsubsec:ompd_address_t}

\summary
The \code{ompd_address_t} type is used to specify device addresses.

\format
\begin{ccppspecific}
\begin{ompEnv}
typedef struct ompd_address_t {
  ompd_seg_t \plc{segment};
  ompd_addr_t \plc{address};
} ompd_address_t;
\end{ompEnv}
\end{ccppspecific}

\descr
The \code{ompd_address_t} type is a structure that OMPD uses to specify 
device addresses, which may or may not be segmented. For non-segmented 
architectures, \code{ompd_segment_none} is used in the \plc{segment} 
field of \code{ompd_address_t}; it is an instance of the \code{ompd_seg_t} 
type that has the value 0.

\subsection{Frame Information Type}
\label{subsubsubsec:ompd_frame_info_t}

\summary
The \code{ompd_frame_info_t} type is used to specify frame information.

\format
\begin{ccppspecific}
\begin{ompEnv}
typedef struct ompd_frame_info_t {
  ompd_address_t \plc{frame_address};
  ompd_word_t \plc{frame_flag};
} ompd_frame_info_t;
\end{ompEnv}
\end{ccppspecific}

\descr
The \code{ompd_frame_info_t} type is a structure that OMPD uses to specify 
frame information. The \plc{frame_address} field of \code{ompd_frame_info_t} 
identifies a frame.
The \plc{frame_flag} field of \code{ompd_frame_info_t} indicates what type
of information is provided in \plc{frame_address}. The values and meaning is
the same as defined for the \code{ompt_frame_t} enumeration type.

\begin{crossrefs}
\item \code{ompt_frame_t}, 
see \specref{subsubsubsec:ompt_frame_t}
\end{crossrefs}

\subsection{System Device Identifiers}
\label{ompd:omp_device_t}

\summary
The \code{ompd_device_t} type provides information about OpenMP devices.

\format
\begin{ccppspecific}
\begin{ompSyntax}
typedef uint64_t ompd_device_t;
\end{ompSyntax}
\end{ccppspecific}
\descr
Different OpenMP runtimes may utilize different underlying devices. The 
Device identifiers can vary in size and format and, thus, are not explicitly 
represented in OMPD. Instead, device identifiers are passed across the interface 
via the \code{ompd_device_t} type, which is a pointer to where the device 
identifier is stored, and the size of the device identifier in bytes. The 
OMPD library and a tool that uses it must agree on the format of the object 
that is passed. Each different kind of device identifier uses a unique 
unsigned 64-bit integer value.

Recommended values of \code{ompd_device_t} are defined in the \code{ompd-types.h}
header file, which is available on \textbf{\url{http://www.openmp.org/}}.



\subsection{Native Thread Identifiers}
\label{ompd:ompd_thread_id_t}

\summary
The \code{ompd_thread_id_t} type provides information about native threads.

\format
\begin{ccppspecific}
\begin{ompSyntax}
typedef uint64_t ompd_thread_id_t;
\end{ompSyntax}
\end{ccppspecific}

\descr
Different OpenMP runtimes may use different native thread implementations.
Native thread identifiers can vary in size and format and, thus, are not 
explicitly represented in the OMPD API. Instead, native thread identifiers 
are passed across the interface via the \code{ompd_thread_id_t} type, which 
is a pointer to where the native thread identifier is stored, and the size 
of the native thread identifier in bytes. The OMPD library and a tool that 
uses it must agree on the format of the object that is passed. Each different 
kind of native thread identifier uses a unique unsigned 64-bit integer value.

Recommended values of \code{ompd_thread_id_t} are defined in the 
\code{ompd-types.h} header file, which is available on 
\textbf{\url{http://www.openmp.org/}}.



\subsection{OMPD Handle Types}
\label{subsubsec:ompd_address_space_handle_t}
\label{subsubsec:ompd_thread_handle_t}
\label{subsubsec:ompd_parallel_handle_t}
\label{subsubsec:ompd_task_handle_t}

\summary
OMPD handle types are opaque types.

\format
\begin{ccppspecific}
\begin{ompSyntax}
typedef struct _ompd_aspace_handle ompd_address_space_handle_t;
typedef struct _ompd_thread_handle ompd_thread_handle_t;
typedef struct _ompd_parallel_handle ompd_parallel_handle_t;
typedef struct _ompd_task_handle ompd_task_handle_t;
\end{ompSyntax}
\end{ccppspecific}

\descr
OMPD uses handles for address spaces (\code{ompd_address_space_handle_t}),
threads (\code{ompd_thread_handle_t}), parallel regions 
(\code{ompd_parallel_handle_t}), and tasks (\code{ompd_task_handle_t}).
Each operation of the OMPD interface that applies to a particular address 
space, thread, parallel region, or task must explicitly specify a corresponding 
handle. A handle for an entity is constant while the entity itself is alive. 
Handles are defined by the OMPD library, and are opaque to the tool.

Defining externally visible type names in this way introduces type safety to 
the interface, and helps to catch instances where incorrect handles are passed 
by the tool to the OMPD library. The structures do not need to be defined;
instead, the OMPD library must cast incoming (pointers to) handles to the 
appropriate internal, private types.



\subsection{OMPD Scope Types}
\label{subsubsec:ompd_scope_t}

\summary
The \code{ompd_scope_t} type identifies OMPD scopes.

\format
\begin{ccppspecific}
\begin{ompSyntax}
typedef enum ompd_scope_t {
  ompd_scope_global = 1,
  ompd_scope_address_space = 2,
  ompd_scope_thread = 3,
  ompd_scope_parallel = 4,
  ompd_scope_implicit_task = 5,
  ompd_scope_task = 6
} ompd_scope_t;
\end{ompSyntax}
\end{ccppspecific}

\descr
The \code{ompd_scope_t} type identifies OpenMP scopes, including those
related to parallel regions and tasks. When used in an OMPD interface 
function call, the scope type and the ompd handle must match 
according to Table~\ref{table:scope-types}.

\begin{table}[h!]
\caption{Mapping of Scope Type and OMPD Handles\label{table:scope-types}}
\begin{tabular}{p{1.7in} p{3.0in}}
\hline
\textsf{\textbf{Scope types}} & \textsf{\textbf{Handles}}\\
\hline
{\splc{ompd_scope_global}}        & Address space handle for the host device \\
{\splc{ompd_scope_address_space}} & Any address space handle \\
{\splc{ompd_scope_thread}}        & Any thread handle \\
{\splc{ompd_scope_parallel}}      & Any parallel handle \\
{\splc{ompd_scope_implicit_task}} & Task handle for an implicit task \\
{\splc{ompd_scope_task}}          & Any task handle \\
\hline
\end{tabular}%
\end{table}%



\subsection{ICV ID Type}
\label{subsubsec:ompd_icv_id_t}

\summary
The \code{ompd_icv_id_t} type identifies an OpenMP implementation ICV.

\format
\begin{ccppspecific}
\begin{ompSyntax}
typedef uint64_t ompd_icv_id_t;
\end{ompSyntax}
\end{ccppspecific}

The \code{ompd_icv_id_t} type identifies OpenMP implementation ICVs.
\code{ompd_icv_undefined} is an instance of this type with the value 0.



\subsection{Tool Context Types}
\label{subsubsec:ompd_address_space_context_t}
\label{subsubsec:ompd_thread_context_t}

\summary
A third-party tool uses contexts to uniquely identify abstractions. These 
contexts are opaque to the OMPD library and are defined as follows:

\format
\begin{ccppspecific}
\begin{ompSyntax}
typedef struct _ompd_aspace_cont ompd_address_space_context_t;
typedef struct _ompd_thread_cont ompd_thread_context_t;
\end{ompSyntax}
\end{ccppspecific}



\subsection{Return Code Types}
\label{subsubsec:ompd_rc_t}

\summary
The \code{ompd_rc_t} type is the return code type of OMPD operations

\format
\begin{ccppspecific}
\begin{ompSyntax}
typedef enum ompd_rc_t {
  ompd_rc_ok = 0,
  ompd_rc_unavailable = 1,
  ompd_rc_stale_handle = 2,
  ompd_rc_bad_input = 3,
  ompd_rc_error = 4,
  ompd_rc_unsupported = 5,
  ompd_rc_needs_state_tracking = 6,
  ompd_rc_incompatible = 7,
  ompd_rc_device_read_error = 8,
  ompd_rc_device_write_error = 9,
  ompd_rc_nomem = 10,
} ompd_rc_t;
\end{ompSyntax}
\end{ccppspecific}


\descr
The \code{ompd_rc_t} type is used for the return codes of OMPD operations. 
The return code types and their semantics are defined as follows:

\begin{itemize}
\label{ompd:ompd_rc_ok}
\item \code{ompd_rc_ok} is returned when the operation is successful;

\label{ompd:ompd_rc_unavailable}
\item \code{ompd_rc_unavailable} is returned when information is not 
      available for the specified context;

\label{ompd:ompd_rc_stale_handle}
\item \code{ompd_rc_stale_handle} is returned when the specified handle 
      is no longer valid;

\label{ompd:ompd_rc_bad_input}
\item \code{ompd_rc_bad_input} is returned when the input parameters 
      (other than handle) are invalid;

\label{ompd:ompd_rc_error}
\item \code{ompd_rc_error} is returned when a fatal error occurred;

\label{ompd:ompd_rc_unsupported}
\item \code{ompd_rc_unsupported} is returned when the requested 
      operation is not supported;

\label{ompd:ompd_rc_needs_state_tracking}
\item \code{ompd_rc_needs_state_tracking} is returned when the state 
      tracking operation failed because state tracking is not currently enabled;

\label{ompd:ompd_rc_device_read_error}
\item \code{ompd_rc_device_read_error} is returned when a read operation 
      failed on the device;

\label{ompd:ompd_rc_device_write_error}
\item \code{ompd_rc_device_write_error} is returned when a write operation 
      failed on the device;

\label{ompd:ompd_rc_incompatible}
\item \code{ompd_rc_incompatible} is returned when this OMPD library is
      incompatible with, or is not capable of handling, the OpenMP program; and

\label{ompd:ompd_rc_nomem}
\item \code{ompd_rc_nomem} is returned when a memory allocation fails.
\end{itemize}



\subsection{Primitive Type Sizes}
\label{subsubsec:ompd_device_type_sizes_t}

\summary
The \code{ompd_device_type_sizes_t} type provides the ``sizeof'' of 
primitive types in the OpenMP architecture address space.

\format

\begin{ccppspecific}
\begin{ompSyntax}
typedef struct ompd_device_type_sizes_t {
  uint8_t \plc{sizeof_char};
  uint8_t \plc{sizeof_short};
  uint8_t \plc{sizeof_int};
  uint8_t \plc{sizeof_long};
  uint8_t \plc{sizeof_long_long};
  uint8_t \plc{sizeof_pointer};
} ompd_device_type_sizes_t;
\end{ompSyntax}
\end{ccppspecific}


\descr
The \code{ompd_device_type_sizes_t} type is used in operations through which 
the OMPD library can interrogate the tool about the ``sizeof'' of primitive 
types in the OpenMP architecture address space. The fields of 
\code{ompd_device_type_sizes_t} give the sizes of the eponymous basic types 
used by the OpenMP runtime. As the tool and the OMPD library, by definition, 
have the same architecture and programming model, the size of the fields can 
be given as \code{uint8_t}.

\begin{crossrefs}
\item \code{ompd_callback_sizeof_fn_t}, 
see \specref{subsubsubsec:ompd_callback_sizeof_fn_t}
\end{crossrefs}
