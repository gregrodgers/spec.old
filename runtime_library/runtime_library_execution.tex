% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. There are environments that provide special formatting, e.g. language bars.
%       Please use them whereever appropriate.  Examples are:
%
%         \begin{fortranspecific}
%         This is text that appears enclosed in blue language bars for Fortran.
%         \end{fortranspecific}
%
%         \begin{note}
%         This is a note.  The "Note -- " header appears automatically.
%         \end{note}
%
%    6. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of 
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%


\section{Execution Environment Routines}
\index{execution environment routines}
\label{sec:Execution Environment Routines}
This section describes routines that affect and monitor threads, processors, and the 
parallel environment. 






\subsection{\code{omp\_set\_num\_threads}}
\index{omp\_set\_num\_threads@{\code{omp\_set\_num\_threads}}}
\label{subsec:omp_set_num_threads}
\summary
The \code{omp\_set\_num\_threads} routine affects the number of threads to be used for 
subsequent parallel regions that do not specify a \code{num\_threads} clause, by setting the 
value of the first element of the \plc{nthreads-var} ICV of the current task.

\format
\begin{ccppspecific}
\begin{boxedcode}
void omp\_set\_num\_threads(int \plc{num\_threads});
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
subroutine omp\_set\_num\_threads(\plc{num\_threads})
integer \plc{num\_threads}
\end{boxedcode}
\end{fortranspecific}

\constraints
The value of the argument passed to this routine must evaluate to a positive integer, or 
else the behavior of this routine is implementation defined.

\binding
The binding task set for an \code{omp\_set\_num\_threads} region is the generating task.

\effect
The effect of this routine is to set the value of the first element of the \plc{nthreads-var} ICV 
of the current task to the value specified in the argument. 

\crossreferences
\begin{itemize}
\item \plc{nthreads-var} ICV, see 
\specref{sec:Internal Control Variables}.

\item \code{parallel} construct and \code{num\_threads} clause, see 
\specref{sec:parallel Construct}.

\item Determining the number of threads for a \code{parallel} region, see
\specref{subsec:Determining the Number of Threads for a parallel Region}. 

\item \code{omp\_get\_max\_threads} routine, see 
\specref{subsec:omp_get_max_threads}.

\item \code{OMP\_NUM\_THREADS} environment variable, see 
\specref{sec:OMP_NUM_THREADS}.
\end{itemize}









\subsection{\code{omp\_get\_num\_threads}}
\index{omp\_get\_num\_threads@{\code{omp\_get\_num\_threads}}}
\label{subsec:omp_get_num_threads}
\summary
The \code{omp\_get\_num\_threads} routine returns the number of threads in the current 
team.
\format
\begin{ccppspecific}
\begin{boxedcode}
int omp\_get\_num\_threads(void); 
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
integer function omp\_get\_num\_threads()
\end{boxedcode}
\end{fortranspecific}

\binding
The binding region for an \code{omp\_get\_num\_threads} region is the innermost enclosing 
\code{parallel} region.

\effect
The \code{omp\_get\_num\_threads} routine returns the number of threads in the team 
executing the \code{parallel} region to which the routine region binds. If called from the 
sequential part of a program, this routine returns 1. 

\crossreferences
\begin{itemize}
\item \code{parallel} construct, see 
\specref{sec:parallel Construct}.

\item Determining the number of threads for a \code{parallel} region, see
\specref{subsec:Determining the Number of Threads for a parallel Region}. 

\item \code{omp\_set\_num\_threads} routine, see 
\specref{subsec:omp_set_num_threads}.

\item \code{OMP\_NUM\_THREADS} environment variable, see 
\specref{sec:OMP_NUM_THREADS}.
\end{itemize}










\subsection{\code{omp\_get\_max\_threads}}
\index{omp\_get\_max\_threads@{\code{omp\_get\_max\_threads}}}
\label{subsec:omp_get_max_threads}
\summary
The \code{omp\_get\_max\_threads} routine returns an upper bound on the number of 
threads that could be used to form a new team if a \code{parallel} construct without a 
\code{num\_threads} clause were encountered after execution returns from this routine.

\format
\begin{ccppspecific}
\begin{boxedcode}
int omp\_get\_max\_threads(void);
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
integer function omp\_get\_max\_threads()
\end{boxedcode}
\end{fortranspecific}

\binding
The binding task set for an \code{omp\_get\_max\_threads} region is the generating task. 

\effect
The value returned by \code{omp\_get\_max\_threads} is the value of the first element of 
the \plc{nthreads-var} ICV of the current task. This value is also an upper bound on the 
number of threads that could be used to form a new team if a parallel region without a 
\code{num\_threads} clause were encountered after execution returns from this routine.

\begin{note}
The return value of the \code{omp\_get\_max\_threads} routine can be used to 
dynamically allocate sufficient storage for all threads in the team formed at the 
subsequent active \code{parallel} region.
\end{note}

\crossreferences
\begin{itemize}
\item \plc{nthreads-var} ICV, see 
\specref{sec:Internal Control Variables}.

\item \code{parallel} construct, see 
\specref{sec:parallel Construct}.

\item \code{num\_threads} clause, see 
\specref{sec:parallel Construct}.

\item Determining the number of threads for a \code{parallel} region, see
\specref{subsec:Determining the Number of Threads for a parallel Region}. 

\item \code{omp\_set\_num\_threads} routine, see 
\specref{subsec:omp_set_num_threads}.

\item \code{OMP\_NUM\_THREADS} environment variable, see 
\specref{sec:OMP_NUM_THREADS}.
\end{itemize}









\newpage %% HACK

\subsection{\code{omp\_get\_thread\_num}}
\index{omp\_get\_thread\_num@{\code{omp\_get\_thread\_num}}}
\label{subsec:omp_get_thread_num}
\summary
The \code{omp\_get\_thread\_num} routine returns the thread number, within the current 
team, of the calling thread.

\format
\begin{ccppspecific}
\begin{boxedcode}
int omp\_get\_thread\_num(void); 
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
integer function omp\_get\_thread\_num() 
\end{boxedcode}
\end{fortranspecific}

\binding
The binding thread set for an \code{omp\_get\_thread\_num} region is the current team. The 
binding region for an \code{omp\_get\_thread\_num} region is the innermost enclosing 
\code{parallel} region. 

\effect
The \code{omp\_get\_thread\_num} routine returns the thread number of the calling thread, 
within the team executing the \code{parallel} region to which the routine region binds. The 
thread number is an integer between 0 and one less than the value returned by 
\code{omp\_get\_num\_threads}, inclusive. The thread number of the master thread of the 
team is 0. The routine returns 0 if it is called from the sequential part of a program.

\begin{note}
The thread number may change during the execution of an untied task. The 
value returned by \code{omp\_get\_thread\_num} is not generally useful during the execution 
of such a task region.
\end{note}

\crossreferences
\begin{itemize}
\item \code{omp\_get\_num\_threads} routine, see 
\specref{subsec:omp_get_num_threads}.
\end{itemize}








\subsection{\code{omp\_get\_num\_procs}}
\index{omp\_get\_num\_procs@{\code{omp\_get\_num\_procs}}}
\label{subsec:omp_get_num_procs}
\summary
The \code{omp\_get\_num\_procs} routine returns the number of processors available to the 
device.

\format
\begin{ccppspecific}
\begin{boxedcode}
int omp\_get\_num\_procs(void);
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
integer function omp\_get\_num\_procs()
\end{boxedcode}
\end{fortranspecific}

\binding
The binding thread set for an \code{omp\_get\_num\_procs} region is all threads on a device. 
The effect of executing this routine is not related to any specific region corresponding to 
any construct or API routine.

\effect
The \code{omp\_get\_num\_procs} routine returns the number of processors that are available 
to the device at the time the routine is called. This value may change between 
the time that it is determined by the \code{omp\_get\_num\_procs} routine and the time that it 
is read in the calling context due to system actions outside the control of the OpenMP 
implementation.

\crossreferences
None.







\subsection{\code{omp\_in\_parallel}}
\index{omp\_in\_parallel@{\code{omp\_in\_parallel}}}
\label{subsec:omp_in_parallel}
\summary
The \code{omp\_in\_parallel} routine returns \plc{true} if the \plc{active-levels-var} ICV is greater 
than zero; otherwise, it returns \plc{false}.

\pagebreak
\format
\begin{ccppspecific}
\begin{boxedcode}
int omp\_in\_parallel(void);
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
logical function omp\_in\_parallel()
\end{boxedcode}
\end{fortranspecific}

\binding
The binding task set for an \code{omp\_in\_parallel} region is the generating task.

\effect
The effect of the \code{omp\_in\_parallel} routine is to return \plc{true} if the current task is 
enclosed by an active \code{parallel} region, and the \code{parallel} region is enclosed by the 
outermost initial task region on the device; otherwise it returns \plc{false}.

\crossreferences
\begin{itemize}
\item \plc{active-levels-var}, see 
\specref{sec:Internal Control Variables}.

\item \code{parallel} construct, see 
\specref{sec:parallel Construct}.

\item \code{omp\_get\_active\_level} routine, see 
\specref{subsec:omp_get_active_level}.
\end{itemize}








\bigskip
\subsection{\code{omp\_set\_dynamic}}
\index{omp\_set\_dynamic@{\code{omp\_set\_dynamic}}}
\label{subsec:omp_set_dynamic}
\summary
The \code{omp\_set\_dynamic} routine enables or disables dynamic adjustment of the 
number of threads available for the execution of subsequent \code{parallel} regions by 
setting the value of the \plc{dyn-var} ICV.


\pagebreak
\format
\begin{ccppspecific}
\begin{boxedcode}
void omp\_set\_dynamic(int \plc{dynamic\_threads});
\end{boxedcode}
\end{ccppspecific}
\bigskip

\begin{samepage}
\begin{fortranspecific}
\begin{boxedcode}
subroutine omp\_set\_dynamic(\plc{dynamic\_threads})
logical \plc{dynamic\_threads}
\end{boxedcode}
\end{fortranspecific}
\end{samepage}

\binding
The binding task set for an \code{omp\_set\_dynamic} region is the generating task. 

\effect
For implementations that support dynamic adjustment of the number of threads, if the 
argument to \code{omp\_set\_dynamic} evaluates to \plc{true}, dynamic adjustment is enabled for 
the current task; otherwise, dynamic adjustment is disabled for the current task. For 
implementations that do not support dynamic adjustment of the number of threads this 
routine has no effect: the value of \plc{dyn-var} remains \plc{false}.

\crossreferences
\begin{itemize}
\item \plc{dyn-var} ICV, see 
\specref{sec:Internal Control Variables}.

\item Determining the number of threads for a \code{parallel} region, see
\specref{subsec:Determining the Number of Threads for a parallel Region}. 

\item \code{omp\_get\_num\_threads} routine, see 
\specref{subsec:omp_get_num_threads}.

\item \code{omp\_get\_dynamic} routine, see 
\specref{subsec:omp_get_dynamic}.

\item \code{OMP\_DYNAMIC} environment variable, see 
\specref{sec:OMP_DYNAMIC}.
\end{itemize}








\subsection{\code{omp\_get\_dynamic}}
\index{omp\_get\_dynamic@{\code{omp\_get\_dynamic}}}
\label{subsec:omp_get_dynamic}
\summary
The \code{omp\_get\_dynamic} routine returns the value of the \plc{dyn-var} ICV, which 
determines whether dynamic adjustment of the number of threads is enabled or disabled.

\format
\begin{ccppspecific}
\begin{boxedcode}
int omp\_get\_dynamic(void);
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
logical function omp\_get\_dynamic()
\end{boxedcode}
\end{fortranspecific}

\binding
The binding task set for an \code{omp\_get\_dynamic} region is the generating task. 

\effect
This routine returns \plc{true} if dynamic adjustment of the number of threads is enabled for 
the current task; it returns \plc{false}, otherwise. If an implementation does not support 
dynamic adjustment of the number of threads, then this routine always returns \plc{false}.

\crossreferences
\begin{itemize}
\item \plc{dyn-var} ICV, see 
\specref{sec:Internal Control Variables}.

\item Determining the number of threads for a \code{parallel} region, see
\specref{subsec:Determining the Number of Threads for a parallel Region}. 

\item \code{omp\_set\_dynamic} routine, see 
\specref{subsec:omp_set_dynamic}.

\item \code{OMP\_DYNAMIC} environment variable, see 
\specref{sec:OMP_DYNAMIC}.
\end{itemize}









\subsection{\code{omp\_get\_cancellation}}
\index{omp\_get\_cancellation@{\code{omp\_get\_cancellation}}}
\label{subsec:omp_get_cancellation}
\summary
The \code{omp\_get\_cancellation} routine returns the value of the \plc{cancel-var} ICV, which determines if cancellation is enabled or disabled.

\format
\begin{ccppspecific}
\begin{boxedcode}
int omp\_get\_cancellation(void);
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
logical function omp\_get\_cancellation()
\end{boxedcode}
\end{fortranspecific}

\binding
The binding task set for an \code{omp\_get\_cancellation} region is the whole program.

\effect
This routine returns \plc{true} if cancellation is enabled. It returns \plc{false} otherwise.

\crossreferences
\begin{itemize}
\item \plc{cancel-var} ICV, see 
\specref{subsec:ICV Descriptions}.

\item \code{cancel} construct, see \specref{subsec:cancel Construct}

\item \code{OMP\_CANCELLATION} environment variable, see 
\specref{sec:OMP_CANCELLATION}
\end{itemize}









\subsection{\code{omp\_set\_nested}}
\index{omp\_set\_nested@{\code{omp\_set\_nested}}}
\label{subsec:omp_set_nested}
\summary
The \code{omp\_set\_nested} routine enables or disables nested parallelism, by setting the 
\plc{nest-var} ICV. 

\format
\begin{ccppspecific}
\begin{boxedcode}
void omp\_set\_nested(int \plc{nested});
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
subroutine omp\_set\_nested(\plc{nested})
logical \plc{nested}
\end{boxedcode}
\end{fortranspecific}

\binding
The binding task set for an \code{omp\_set\_nested} region is the generating task. 

\effect
For implementations that support nested parallelism, if the argument to 
\code{omp\_set\_nested} evaluates to \plc{true}, nested parallelism is enabled for the current task; 
otherwise, nested parallelism is disabled for the current task. For implementations that 
do not support nested parallelism, this routine has no effect: the value of \plc{nest-var} 
remains \plc{false}.

\crossreferences
\begin{itemize}
\item \plc{nest-var} ICV, see 
\specref{sec:Internal Control Variables}.

\item Determining the number of threads for a \code{parallel} region, see
\specref{subsec:Determining the Number of Threads for a parallel Region}. 

\item \code{omp\_set\_max\_active\_levels} routine, see 
\specref{subsec:omp_set_max_active_levels}.

\item \code{omp\_get\_max\_active\_levels} routine, see 
\specref{subsec:omp_get_max_active_levels}.

\item \code{omp\_get\_nested} routine, see 
\specref{subsec:omp_get_nested}.

\item \code{OMP\_NESTED} environment variable, see 
\specref{sec:OMP_NESTED}.
\end{itemize}








\subsection{\code{omp\_get\_nested}}
\index{omp\_get\_nested@{\code{omp\_get\_nested}}}
\label{subsec:omp_get_nested}
\summary
The \code{omp\_get\_nested} routine returns the value of the \plc{nest-var} ICV, which 
determines if nested parallelism is enabled or disabled.

\format
\begin{ccppspecific}
\begin{boxedcode}
int omp\_get\_nested(void);
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
logical function omp\_get\_nested()
\end{boxedcode}
\end{fortranspecific}

\binding
The binding task set for an \code{omp\_get\_nested} region is the generating task. 

\effect
This routine returns \plc{true} if nested parallelism is enabled for the current task; it returns 
\plc{false}, otherwise. If an implementation does not support nested parallelism, this routine 
always returns \plc{false}.

\crossreferences
\begin{itemize}
\item \plc{nest-var} ICV, see 
\specref{sec:Internal Control Variables}.

\item Determining the number of threads for a \code{parallel} region, see
\specref{subsec:Determining the Number of Threads for a parallel Region}. 

\item \code{omp\_set\_nested} routine, see 
\specref{subsec:omp_set_nested}.

\item \code{OMP\_NESTED} environment variable, see 
\specref{sec:OMP_NESTED}.
\end{itemize}









\subsection{\code{omp\_set\_schedule}}
\index{omp\_set\_schedule@{\code{omp\_set\_schedule}}}
\label{subsec:omp_set_schedule}
\summary
The \code{omp\_set\_schedule} routine affects the schedule that is applied when \code{runtime} 
is used as schedule kind, by setting the value of the \plc{run-sched-var} ICV. 

\format
\begin{ccppspecific}
\begin{boxedcode}
void omp\_set\_schedule(omp\_sched\_t \plc{kind}, int \plc{chunk\_size});
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
subroutine omp\_set\_schedule(\plc{kind}, \plc{chunk\_size}) 
integer (kind=omp\_sched\_kind) \plc{kind}
integer \plc{chunk\_size}
\end{boxedcode}
\end{fortranspecific}

\constraints
The first argument passed to this routine can be one of the valid OpenMP schedule kinds 
(except for \code{runtime}) or any implementation specific schedule. The C/C++ header file 
(\code{omp.h}) and the Fortran include file (\code{omp\_lib.h}) and/or Fortran~90 module file 
(\code{omp\_lib}) define the valid constants. The valid constants must include the following, 
which can be extended with implementation specific values:

\pagebreak
\begin{ccppspecific}
\begin{boxedcode}
typedef enum omp\_sched\_t \{
    omp\_sched\_static = 1,
    omp\_sched\_dynamic = 2,
    omp\_sched\_guided = 3,
    omp\_sched\_auto = 4
\} omp\_sched\_t;
\end{boxedcode}
\end{ccppspecific}

\begin{samepage}
\begin{fortranspecific}
\begin{boxedcode}
integer(kind=omp\_sched\_kind), parameter :: omp\_sched\_static = 1
integer(kind=omp\_sched\_kind), parameter :: omp\_sched\_dynamic = 2
integer(kind=omp\_sched\_kind), parameter :: omp\_sched\_guided = 3
integer(kind=omp\_sched\_kind), parameter :: omp\_sched\_auto = 4
\end{boxedcode}
\end{fortranspecific}
\end{samepage}

\binding
The binding task set for an \code{omp\_set\_schedule} region is the generating task. 

\effect
The effect of this routine is to set the value of the \plc{run-sched-var} ICV of the current task 
to the values specified in the two arguments. The schedule is set to the schedule type 
specified by the first argument \plc{kind}. It can be any of the standard schedule types or 
any other implementation specific one. For the schedule types \code{static}, \code{dynamic}, and 
\code{guided} the \plc{chunk\_size} is set to the value of the second argument, or to the default 
\plc{chunk\_size} if the value of the second argument is less than 1; for the schedule type 
\code{auto} the second argument has no meaning; for implementation specific schedule types, 
the values and associated meanings of the second argument are implementation defined.

\crossreferences
\begin{itemize}
\item \plc{run-sched-var} ICV, see 
\specref{sec:Internal Control Variables}.

\item Determining the schedule of a worksharing loop, see 
\specref{subsubsec:Determining the Schedule of a Worksharing Loop}.

\item \code{omp\_get\_schedule} routine, see 
\specref{subsec:omp_get_schedule}.

\item \code{OMP\_SCHEDULE} environment variable, see 
\specref{sec:OMP_SCHEDULE}.
\end{itemize}









\subsection{\code{omp\_get\_schedule}}
\index{omp\_get\_schedule@{\code{omp\_get\_schedule}}}
\label{subsec:omp_get_schedule}
\summary
The \code{omp\_get\_schedule} routine returns the schedule that is applied when the 
runtime schedule is used. 
\format
\begin{ccppspecific}
\begin{boxedcode}
void omp\_get\_schedule(omp\_sched\_t * \plc{kind}, int * \plc{chunk\_size}); 
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
subroutine omp\_get\_schedule(\plc{kind}, \plc{chunk\_size}) 
integer (kind=omp\_sched\_kind) \plc{kind} 
integer \plc{chunk\_size}
\end{boxedcode}
\end{fortranspecific}

\binding
The binding task set for an \code{omp\_get\_schedule} region is the generating task. 

\effect
This routine returns the \plc{run-sched-var} ICV in the task to which the routine binds. The 
first argument \plc{kind} returns the schedule to be used. It can be any of the standard 
schedule types as defined in 
\specref{subsec:omp_set_schedule}, 
or any implementation specific 
schedule type. The second argument is interpreted as in the \code{omp\_set\_schedule} call, 
defined in 
\specref{subsec:omp_set_schedule}.

\crossreferences
\begin{itemize}
\item \plc{run-sched-var} ICV, see 
\specref{sec:Internal Control Variables}.

\item Determining the schedule of a worksharing loop, see 
\specref{subsubsec:Determining the Schedule of a Worksharing Loop}.

\item \code{omp\_set\_schedule} routine, see 
\specref{subsec:omp_set_schedule}.

\item \code{OMP\_SCHEDULE} environment variable, see 
\specref{sec:OMP_SCHEDULE}.
\end{itemize}









\subsection{\code{omp\_get\_thread\_limit}}
\index{omp\_get\_thread\_limit@{\code{omp\_get\_thread\_limit}}}
\label{subsec:omp_get_thread_limit}
\summary
The \code{omp\_get\_thread\_limit} routine returns the maximum number of OpenMP 
threads available to participate in the current contention group. 

\format
\begin{ccppspecific}
\begin{boxedcode}
int omp\_get\_thread\_limit(void);
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
integer function omp\_get\_thread\_limit()
\end{boxedcode}
\end{fortranspecific}

\binding
The binding thread set for an \code{omp\_get\_thread\_limit} region is all threads on the 
device. The effect of executing this routine is not related to any specific region 
corresponding to any construct or API routine. 

\effect
The \code{omp\_get\_thread\_limit} routine returns the value of the \plc{thread-limit-var} ICV.

\crossreferences
\begin{itemize}
\item \plc{thread-limit-var} ICV, see 
\specref{sec:Internal Control Variables}.

\item \code{OMP\_THREAD\_LIMIT} environment variable, see 
\specref{sec:OMP_THREAD_LIMIT}.
\end{itemize}









\subsection{\code{omp\_set\_max\_active\_levels}}
\index{omp\_set\_max\_active\_levels@{\code{omp\_set\_max\_active\_levels}}}
\label{subsec:omp_set_max_active_levels}
\summary
The \code{omp\_set\_max\_active\_levels} routine limits the number of nested active 
parallel regions on the device, by setting the \plc{max-active-levels-var} ICV

\format
\begin{ccppspecific}
\begin{boxedcode}
void omp\_set\_max\_active\_levels(int \plc{max\_levels});
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
subroutine omp\_set\_max\_active\_levels(\plc{max\_levels})
integer \plc{max\_levels}
\end{boxedcode}
\end{fortranspecific}

\constraints
The value of the argument passed to this routine must evaluate to a non-negative integer, 
otherwise the behavior of this routine is implementation defined.

\binding
When called from a sequential part of the program, the binding thread set for an 
\code{omp\_set\_max\_active\_levels} region is the encountering thread. When called 
from within any explicit parallel region, the binding thread set (and binding region, if 
required) for the \code{omp\_set\_max\_active\_levels} region is implementation defined. 

\effect
The effect of this routine is to set the value of the \plc{max-active-levels-var} ICV to the value 
specified in the argument. 

If the number of parallel levels requested exceeds the number of levels of parallelism 
supported by the implementation, the value of the \plc{max-active-levels-var} ICV will be set 
to the number of parallel levels supported by the implementation.

This routine has the described effect only when called from a sequential part of the 
program. When called from within an explicit \code{parallel} region, the effect of this 
routine is implementation defined.

\crossreferences
\begin{itemize}
\item \plc{max-active-levels-var} ICV, see 
\specref{sec:Internal Control Variables}.

\item \code{omp\_get\_max\_active\_levels} routine, see 
\specref{subsec:omp_get_max_active_levels}.

\item \code{OMP\_MAX\_ACTIVE\_LEVELS} environment variable, see 
\specref{sec:OMP_MAX_ACTIVE_LEVELS}.
\end{itemize}










\subsection{\code{omp\_get\_max\_active\_levels}}
\index{omp\_get\_max\_active\_levels@{\code{omp\_get\_max\_active\_levels}}}
\label{subsec:omp_get_max_active_levels}
\summary
The \code{omp\_get\_max\_active\_levels} routine returns the value of the 
\plc{max-active-levels-var} ICV, which determines the maximum number of nested active parallel regions 
on the device. 

\format
\begin{ccppspecific}
\begin{boxedcode}
int omp\_get\_max\_active\_levels(void);
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
integer function omp\_get\_max\_active\_levels()
\end{boxedcode}
\end{fortranspecific}

\binding
When called from a sequential part of the program, the binding thread set for an 
\code{omp\_get\_max\_active\_levels} region is the encountering thread. When called 
from within any explicit parallel region, the binding thread set (and binding region, if 
required) for the \code{omp\_get\_max\_active\_levels} region is implementation defined. 

\effect
The \code{omp\_get\_max\_active\_levels} routine returns the value of the \plc{max-active-levels-var} ICV,
which determines the maximum number of nested active parallel regions 
on the device. 

\crossreferences
\begin{itemize}
\item \plc{max-active-levels-var} ICV, see 
\specref{sec:Internal Control Variables}.

\item \code{omp\_set\_max\_active\_levels} routine, see 
\specref{subsec:omp_set_max_active_levels}.

\item \code{OMP\_MAX\_ACTIVE\_LEVELS} environment variable, see 
\specref{sec:OMP_MAX_ACTIVE_LEVELS}.
\end{itemize}








\subsection{\code{omp\_get\_level}}
\index{omp\_get\_level@{\code{omp\_get\_level}}}
\label{subsec:omp_get_level}
\summary
The \code{omp\_get\_level} routine returns the value of the \plc{levels-var} ICV. 

\format
\begin{ccppspecific}
\begin{boxedcode}
int omp\_get\_level(void);
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
integer function omp\_get\_level()
\end{boxedcode}
\end{fortranspecific}

\binding
The binding task set for an \code{omp\_get\_level} region is the generating task. 

\effect
The effect of the \code{omp\_get\_level} routine is to return the number of nested 
\code{parallel} regions (whether active or inactive) enclosing the current task such that all 
of the \code{parallel} regions are enclosed by the outermost initial task region on the 
current device.

\crossreferences
\begin{itemize}
\item \plc{levels-var} ICV, see 
\specref{sec:Internal Control Variables}.

\item \code{omp\_get\_active\_level} routine, see 
\specref{subsec:omp_get_active_level}.

\item \code{OMP\_MAX\_ACTIVE\_LEVELS} environment variable, see 
\specref{sec:OMP_MAX_ACTIVE_LEVELS}.
\end{itemize}










\subsection{\code{omp\_get\_ancestor\_thread\_num}}
\index{omp\_get\_ancestor\_thread\_num@{\code{omp\_get\_ancestor\_thread\_num}}}
\label{subsec:omp_get_ancestor_thread_num}
\summary
The \code{omp\_get\_ancestor\_thread\_num} routine returns, for a given nested level of 
the current thread, the thread number of the ancestor of the current thread.

\begin{samepage}
\format
\begin{ccppspecific}
\begin{boxedcode}
int omp\_get\_ancestor\_thread\_num(int \plc{level});
\end{boxedcode}
\end{ccppspecific}
\end{samepage}

\begin{fortranspecific}
\begin{boxedcode}
integer function omp\_get\_ancestor\_thread\_num(\plc{level})
integer \plc{level}
\end{boxedcode}
\end{fortranspecific}

\binding
The binding thread set for an \code{omp\_get\_ancestor\_thread\_num} region is the 
encountering thread. The binding region for an \code{omp\_get\_ancestor\_thread\_num} 
region is the innermost enclosing \code{parallel} region. 

\effect
The \code{omp\_get\_ancestor\_thread\_num} routine returns the thread number of the 
ancestor at a given nest level of the current thread or the thread number of the current 
thread. If the requested nest level is outside the range of 0 and the nest level of the 
current thread, as returned by the \code{omp\_get\_level} routine, the routine returns -1.

\begin{note}
When the \code{omp\_get\_ancestor\_thread\_num} routine is called with a value 
of \code{level}=0, the routine always returns 0. If \code{level}=\code{omp\_get\_level()}, the routine 
has the same effect as the \code{omp\_get\_thread\_num} routine. 
\end{note}

\crossreferences
\begin{itemize}
\item \code{omp\_get\_thread\_num} routine, see 
\specref{subsec:omp_get_thread_num}.

\item \code{omp\_get\_level} routine, see 
\specref{subsec:omp_get_level}.

\item \code{omp\_get\_team\_size} routine, see 
\specref{subsec:omp_get_team_size}.
\end{itemize}










\subsection{\code{omp\_get\_team\_size}}
\index{omp\_get\_team\_size@{\code{omp\_get\_team\_size}}}
\label{subsec:omp_get_team_size}
\summary
The \code{omp\_get\_team\_size} routine returns, for a given nested level of the current 
thread, the size of the thread team to which the ancestor or the current thread belongs. 

\format
\begin{ccppspecific}
\begin{boxedcode}
int omp\_get\_team\_size(int \plc{level});
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
integer function omp\_get\_team\_size(\plc{level})
integer \plc{level}
\end{boxedcode}
\end{fortranspecific}

\binding
The binding thread set for an \code{omp\_get\_team\_size} region is the encountering 
thread. The binding region for an \code{omp\_get\_team\_size} region is the innermost 
enclosing \code{parallel} region.

\effect
The \code{omp\_get\_team\_size} routine returns the size of the thread team to which the 
ancestor or the current thread belongs. If the requested nested level is outside the range 
of 0 and the nested level of the current thread, as returned by the \code{omp\_get\_level} 
routine, the routine returns -1. Inactive parallel regions are regarded like active parallel 
regions executed with one thread. 

\begin{note}
When the \code{omp\_get\_team\_size} routine is called with a value of \code{level}=0, 
the routine always returns 1. If \code{level}=\code{omp\_get\_level()}, the routine has the same 
effect as the\linebreak \code{omp\_get\_num\_threads} routine. 
\end{note}

\crossreferences
\begin{itemize}
\item \code{omp\_get\_num\_threads} routine, see 
\specref{subsec:omp_get_num_threads}.

\item \code{omp\_get\_level} routine, see 
\specref{subsec:omp_get_level}.

\item \code{omp\_get\_ancestor\_thread\_num} routine, see 
\specref{subsec:omp_get_ancestor_thread_num}.
\end{itemize}









\subsection{\code{omp\_get\_active\_level}}
\index{omp\_get\_active\_level@{\code{omp\_get\_active\_level}}}
\label{subsec:omp_get_active_level}
\summary
The \code{omp\_get\_active\_level} routine returns the value of the \plc{active-level-vars} ICV..

\format
\begin{ccppspecific}
\begin{boxedcode}
int \code{omp\_get\_active\_level}(void);
\end{boxedcode}
\end{ccppspecific}

\pagebreak
\begin{fortranspecific}
\begin{boxedcode}
integer function omp\_get\_active\_level()
\end{boxedcode}
\end{fortranspecific}

\binding
The binding task set for the an \code{omp\_get\_active\_level} region is the generating 
task. 

\effect
The effect of the \code{omp\_get\_active\_level} routine is to return the number of nested, 
active \code{parallel} regions enclosing the current task such that all of the \code{parallel} 
regions are enclosed by the outermost initial task region on the current device. 

\crossreferences
\begin{itemize}
\item \plc{active-levels-var} ICV, see 
\specref{sec:Internal Control Variables}.

\item \code{omp\_get\_level} routine, see 
\specref{subsec:omp_get_level}. 
\end{itemize}











\subsection{\code{omp\_in\_final}}
\index{omp\_in\_final@{\code{omp\_in\_final}}}
\label{subsec:omp_in_final}
\summary
The \code{omp\_in\_final} routine returns \plc{true} if the routine is executed in a final task 
region; otherwise, it returns \plc{false}.

\format
\begin{ccppspecific}
\begin{boxedcode}
int omp\_in\_final(void);
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
logical function omp\_in\_final()
\end{boxedcode}
\end{fortranspecific}

\binding
The binding task set for an \code{omp\_in\_final} region is the generating task.

\effect
\code{omp\_in\_final} returns \plc{true} if the enclosing task region is final. Otherwise, it returns 
\plc{false}.

\crossreferences
\begin{itemize}
\item \code{task} construct, see 
\specref{subsec:task Construct}. 
\end{itemize}









\subsection{\code{omp\_get\_proc\_bind}}
\index{omp\_get\_proc\_bind@{\code{omp\_get\_proc\_bind}}}
\label{subsec:omp_get_proc_bind}
\summary
The \code{omp\_get\_proc\_bind} routine returns the thread affinity policy to be used for the 
subsequent nested \code{parallel} regions that do not specify a \code{proc\_bind} clause.

\format
\begin{ccppspecific}
\begin{boxedcode}
omp\_proc\_bind\_t omp\_get\_proc\_bind(void);
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
integer (kind=omp\_proc\_bind\_kind) function omp\_get\_proc\_bind()
\end{boxedcode}
\end{fortranspecific}

\constraints
The value returned by this routine must be one of the valid affinity policy kinds. The C/
C++ header file (\code{omp.h}) and the Fortran include file (\code{omp\_lib.h}) and/or Fortran~90 
module file (\code{omp\_lib}) define the valid constants. The valid constants must include the 
following:

\begin{ccppspecific}
\begin{codepar}
typedef enum omp\_proc\_bind\_t \{
  omp\_proc\_bind\_false = 0,
  omp\_proc\_bind\_true = 1,
  omp\_proc\_bind\_master = 2,
  omp\_proc\_bind\_close = 3,
  omp\_proc\_bind\_spread = 4
\} omp\_proc\_bind\_t;
\end{codepar}
\end{ccppspecific}

\begin{fortranspecific}
\begin{codepar}
integer (kind=omp\_proc\_bind\_kind), &
                parameter :: omp\_proc\_bind\_false = 0
integer (kind=omp\_proc\_bind\_kind), &
                parameter :: omp\_proc\_bind\_true = 1
integer (kind=omp\_proc\_bind\_kind), &
                parameter :: omp\_proc\_bind\_master = 2
integer (kind=omp\_proc\_bind\_kind), &
                parameter :: omp\_proc\_bind\_close = 3
integer (kind=omp\_proc\_bind\_kind), &
                parameter :: omp\_proc\_bind\_spread = 4
\end{codepar}
\end{fortranspecific}

\binding
The binding task set for an \code{omp\_get\_proc\_bind} region is the generating task

\effect
The effect of this routine is to return the value of the first element of the \plc{bind-var} ICV 
of the current task. See \specref{subsec:Controlling OpenMP Thread Affinity} 
for the rules governing the thread affinity policy.

\crossreferences
\begin{itemize}
\item \plc{bind-var} ICV, see 
\specref{sec:Internal Control Variables}.

\item Controlling OpenMP thread affinity, see 
\specref{subsec:Controlling OpenMP Thread Affinity}. 

\item \code{OMP\_PROC\_BIND} environment variable, see 
\specref{sec:OMP_PROC_BIND}.
\end{itemize}



%%%%%%%%%% begin 392

\subsection{\code{omp\_get\_num\_places}}
\index{omp\_get\_num\_places@{\code{omp\_get\_num\_places}}}
\label{subsec:omp_get_num_places}
\summary
The \code{omp\_get\_num\_places} routine returns the number of places 
available to the execution environment in the place list.

\format
\begin{ccppspecific}
\begin{boxedcode}
int omp\_get\_num\_places(void);
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
integer function omp\_get\_num\_places()
\end{boxedcode}
\end{fortranspecific}

\binding
The binding thread set for an \code{omp\_get\_num\_places}  region is all threads on a device. The effect of executing this routine is not related to any specific region corresponding to any construct or API routine.

\effect

The \code{omp\_get\_num\_places} routine returns the number of places in the place list. This value is equivalent to the number of places in the  \plc{place-partition-var} ICV in the execution environment of the initial task.

\crossreferences
\begin{itemize}
\item \plc{place-partition-var} ICV, see 
\specref{sec:Internal Control Variables}.

\item \code{OMP\_PLACES} environment variable, see 
\specref{sec:OMP_PLACES}.
\end{itemize}





\subsection{\code{omp\_get\_place\_num\_procs}}
\index{omp\_get\_place\_num\_procs@{\code{omp\_get\_place\_num\_procs}}}
\label{subsec:omp_get_place_num_procs}

\summary
The \code{omp\_get\_place\_num\_procs}  routine returns the number of processors available to the execution environment in the specified place.

\format
\begin{ccppspecific}
\begin{boxedcode}
int omp\_get\_place\_num\_procs(int \plc{place\_num});
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
integer function omp\_get\_place\_num\_procs(\plc{place\_num})
integer \plc{place\_num}
\end{boxedcode}
\end{fortranspecific}

\binding
The binding thread set for an \code{omp\_get\_place\_num\_procs}  region is all threads on a device. The effect of executing this routine is not related to any specific region corresponding to any construct or API routine.

\effect
The \code{omp\_get\_place\_num\_procs} routine returns the number of 
processors associated with the place numbered \plc{place\_num}. The 
routine returns zero when \plc{place\_num} is negative, or is equal 
to or larger than the value returned by \code{omp\_get\_num\_places()}. 

\crossreferences
\begin{itemize}
\item \code{OMP\_PLACES} environment variable, see 
\specref{sec:OMP_PLACES}.
\end{itemize}




\subsection{\code{omp\_get\_place\_proc\_ids}}
\index{omp\_get\_place\_proc\_ids@{\code{omp\_get\_place\_proc\_ids}}}
\label{subsec:omp_get_place_proc_ids}

\summary
The \code{omp\_get\_place\_proc\_ids} routine returns the numerical identifiers of the processors available to the execution environment in the specified place.

\format
\begin{ccppspecific}
\begin{boxedcode}
void omp\_get\_place\_proc\_ids(int \plc{place\_num}, int *\plc{ids});
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
subroutine omp\_get\_place\_proc\_ids(\plc{place_num}, \plc{ids})
integer \plc{place\_num}
integer \plc{ids}(*)
\end{boxedcode}
\end{fortranspecific}

\binding
The binding thread set for an \code{omp\_get\_place\_proc\_ids} region is all 
threads on a device. The effect of executing this routine is not related to 
any specific region corresponding to any construct or API routine.

\effect
The \code{omp\_get\_place\_proc\_ids} routine returns the numerical 
identifiers of each processor associated with the place numbered 
\plc{place\_num}. The numerical identifiers are non-negative, and 
their meaning is implementation defined.  The numerical identifiers 
are returned in the array \plc{ids} and their order in the array is 
implementation defined. The array must be sufficiently large to contain 
\code{omp\_get\_place\_num\_procs(}\plc{place\_num}\code{)} integers; 
otherwise, the behavior is unspecified.  The routine has no effect when 
\plc{place\_num} has a negative value, or a value equal or larger 
than \code{omp\_get\_num\_places()}.

\crossreferences
\begin{itemize}
\item \code{omp\_get\_place\_num\_procs} routine, see 
\specref{subsec:omp_get_place_num_procs}.

\item \code{omp\_get\_num\_places} routine, see 
\specref{subsec:omp_get_num_places}.

\item \code{OMP\_PLACES} environment variable, see 
\specref{sec:OMP_PLACES}.
\end{itemize}




\subsection{\code{omp\_get\_place\_num}}
\index{omp\_get\_place\_num@{\code{omp\_get\_place\_num}}}
\label{subsec:omp_get_place_num}

\summary
The \code{omp\_get\_place\_num} routine returns the place number of the place to which the encountering thread is bound.

\format
\begin{ccppspecific}
\begin{boxedcode}
int omp\_get\_place\_num(void);
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
integer function omp\_get\_place\_num()
\end{boxedcode}
\end{fortranspecific}

\binding
The binding thread set for an \code{omp\_get\_place\_num} region is the encountering thread.

\effect
When the encountering thread is bound to a place, the 
\code{omp\_get\_place\_num} routine returns the place number associated 
with the thread. The returned value is between 0 and one less than the 
value returned by \code{omp\_get\_num\_places()}, inclusive. When the 
encountering thread is not bound to a place, the routine returns -1.

\crossreferences
\begin{itemize}
\item Controlling OpenMP thread affinity, see 
\specref{subsec:Controlling OpenMP Thread Affinity}. 

\item \code{omp\_get\_num\_places} routine, see 
\specref{subsec:omp_get_num_places}.

\item \code{OMP\_PLACES} environment variable, see 
\specref{sec:OMP_PLACES}.
\end{itemize}





\subsection{\code{omp\_get\_partition\_num\_places}}
\index{omp\_get\_partition\_num\_places@{\code{omp\_get\_partition\_num\_places}}}
\label{subsec:omp_get_partition_num_places}

\summary
The \code{omp\_get\_partition\_num\_places} routine returns the number of places in the place partition of the innermost implicit task.

\format
\begin{ccppspecific}
\begin{boxedcode}
int omp\_get\_partition\_num\_places(void);
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
integer function omp\_get\_partition\_num\_places()
\end{boxedcode}
\end{fortranspecific}

\binding
The binding task set for an  \code{omp\_get\_partition\_num\_places} region is the encountering implicit task.

\effect
The \code{omp\_get\_partition\_num\_places} routine returns the number of places in the \plc{place-partition-var} ICV.

\crossreferences
\begin{itemize}
\item \plc{place-partition-var} ICV, see 
\specref{sec:Internal Control Variables}.

\item Controlling OpenMP thread affinity, see 
\specref{subsec:Controlling OpenMP Thread Affinity}. 

\item \code{OMP\_PLACES} environment variable, see 
\specref{sec:OMP_PLACES}.
\end{itemize}





\subsection{\code{omp\_get\_partition\_place\_nums}}
\index{omp\_get\_partition\_place\_nums@{\code{omp\_get\_partition\_place\_nums}}}
\label{subsec:omp_get_partition_place_nums}

\summary
The \code{omp\_get\_partition\_place\_nums} routine returns the list of place numbers corresponding to the places in the \plc{place-partition-var} ICV of the innermost implicit task.

\format
\begin{ccppspecific}
\begin{boxedcode}
void omp\_get\_partition\_place\_nums(int *\plc{place\_nums});
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
subroutine omp\_get\_partition\_place\_nums(\plc{place\_nums})
integer \plc{place\_nums}(*)
\end{boxedcode}
\end{fortranspecific}

\binding
The binding task set for an \code{omp\_get\_partition\_place\_nums} region is the encountering implicit task.

\effect
The \code{omp\_get\_partition\_place\_nums} routine returns the list of 
place numbers corresponding to the places in the \plc{place-partition-var} 
ICV of the innermost implicit task. The array must be sufficiently large 
to contain \code{omp\_get\_partition\_num\_places()} integers; otherwise, 
the behavior is unspecified.

\crossreferences
\begin{itemize}
\item \plc{place-partition-var} ICV, see 
\specref{sec:Internal Control Variables}.

\item Controlling OpenMP thread affinity, see 
\specref{subsec:Controlling OpenMP Thread Affinity}. 

\item \code{omp\_get\_partition\_num\_places} routine, see 
\specref{subsec:omp_get_partition_num_places}.

\item \code{OMP\_PLACES} environment variable, see 
\specref{sec:OMP_PLACES}.
\end{itemize}



%%%%%%%%%%


\subsection{\code{omp\_set\_default\_device}}
\index{omp\_set\_default\_device@{\code{omp\_set\_default\_device}}}
\label{subsec:omp_set_default_device}

\summary

The \code{omp\_set\_default\_device} routine controls the default target device by 
assigning the value of the \plc{default-device-var} ICV.

\format
\begin{ccppspecific}
\begin{boxedcode}
void omp\_set\_default\_device(int \plc{device\_num});
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
subroutine omp\_set\_default\_device(\plc{device\_num})
integer \plc{device\_num}
\end{boxedcode}
\end{fortranspecific}

\binding
The binding task set for an \code{omp\_set\_default\_device} region is the generating 
task.

\effect
The effect of this routine is to set the value of the \plc{default-device-var} ICV of the current 
task to the value specified in the argument. When called from within a \code{target} region 
the effect of this routine is unspecified.

\crossreferences
\begin{itemize}
\item \plc{default-device-var}, see 
\specref{sec:Internal Control Variables}.

\item \code{omp\_get\_default\_device}, see 
\specref{subsec:omp_get_default_device}.

\item \code{OMP\_DEFAULT\_DEVICE} environment variable, see 
\specref{sec:OMP_DEFAULT_DEVICE}
\end{itemize}










\subsection{\code{omp\_get\_default\_device}}
\index{omp\_get\_default\_device@{\code{omp\_get\_default\_device}}}
\label{subsec:omp_get_default_device}
\summary
The \code{omp\_get\_default\_device} routine returns the default target device.

\format
\begin{ccppspecific}
\begin{boxedcode}
int omp\_get\_default\_device(void);
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
integer function omp\_get\_default\_device()
\end{boxedcode}
\end{fortranspecific}

\binding
The binding task set for an \code{omp\_get\_default\_device} region is the generating 
task. 

\effect
The \code{omp\_get\_default\_device} routine returns the value of the \plc{default-device-var} 
ICV of the current task. When called from within a \code{target} region the effect of this 
routine is unspecified.

\crossreferences
\begin{itemize}
\item \plc{default-device-var}, see 
\specref{sec:Internal Control Variables}.

\item \code{omp\_set\_default\_device}, see 
\specref{subsec:omp_set_default_device}.

\item \code{OMP\_DEFAULT\_DEVICE} environment variable, see 
\specref{sec:OMP_DEFAULT_DEVICE}. 
\end{itemize}











\subsection{\code{omp\_get\_num\_devices}}
\index{omp\_get\_num\_devices@{\code{omp\_get\_num\_devices}}}
\label{subsec:omp_get_num_devices}
\summary
The \code{omp\_get\_num\_devices} routine returns the number of target devices.

\format
\begin{ccppspecific}
\begin{boxedcode}
int omp\_get\_num\_devices(void);
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
integer function omp\_get\_num\_devices()
\end{boxedcode}
\end{fortranspecific}

\binding
The binding task set for an \code{omp\_get\_num\_devices} region is the generating task.

\effect
The \code{omp\_get\_num\_devices} routine returns the number of available target devices. 
When called from within a \code{target} region the effect of this routine is unspecified.

\crossreferences
None.










\subsection{\code{omp\_get\_num\_teams}}
\index{omp\@{\code{omp\_get\_num\_teams}}}
\label{subsec:omp_get_num_teams}
\summary
The \code{omp\_get\_num\_teams} routine returns the number of teams in the current \code{teams} 
region.

\pagebreak
\format
\begin{ccppspecific}
\begin{boxedcode}
int omp\_get\_num\_teams(void);
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
integer function omp\_get\_num\_teams()
\end{boxedcode}
\end{fortranspecific}

\binding
The binding task set for an \code{omp\_get\_num\_teams} region is the generating task

\effect
The effect of this routine is to return the number of teams in the current \code{teams} region. 
The routine returns 1 if it is called from outside of a \code{teams} region.

\crossreferences
\begin{itemize}
\item \code{teams} construct, see 
\specref{subsec:teams Construct}. 
\end{itemize}










\pagebreak
\subsection{\code{omp\_get\_team\_num}}
\index{omp\_get\_team\_num@{\code{omp\_get\_team\_num}}}
\label{subsec:omp_get_team_num}
\summary
The \code{omp\_get\_team\_num} routine returns the team number of the calling thread.

\format
\begin{ccppspecific}
\begin{boxedcode}
int omp\_get\_team\_num(void);
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
integer function omp\_get\_team\_num()
\end{boxedcode}
\end{fortranspecific}

\binding
The binding task set for an \code{omp\_get\_team\_num} region is the generating task.

\effect
The \code{omp\_get\_team\_num} routine returns the team number of the calling thread. The 
team number is an integer between 0 and one less than the value returned by 
\code{omp\_get\_num\_teams()}, inclusive. The routine returns 0 if it is called outside of a 
\code{teams} region.

\crossreferences
\begin{itemize}
\item \code{teams} construct, see 
\specref{subsec:teams Construct}.

\item \code{omp\_get\_num\_teams} routine, see 
\specref{subsec:omp_get_num_teams}. 
\end{itemize}









\subsection{\code{omp\_is\_initial\_device}}
\index{omp\_is\_initial\_device@{\code{omp\_is\_initial\_device}}}
\label{subsec:omp_is_initial_device}
\summary
The \code{omp\_is\_initial\_device} routine returns \plc{true} if the current task is executing 
on the host device; otherwise, it returns \plc{false}.

\begin{samepage}
\format
\begin{ccppspecific}
\begin{boxedcode}
int omp\_is\_initial\_device(void);
\end{boxedcode}
\end{ccppspecific}
\end{samepage}

\begin{fortranspecific}
\begin{boxedcode}
logical function omp\_is\_initial\_device()
\end{boxedcode}
\end{fortranspecific}

\binding
The binding task set for an \code{omp\_is\_initial\_device} region is the generating task.

\effect
The effect of this routine is to return \plc{true} if the current task is executing on the host 
device; otherwise, it returns \plc{false}.

\crossreferences
\begin{itemize}
\item \code{target} construct, see 
\specref{subsec:target Construct}
\end{itemize}





\subsection{\code{omp\_get\_initial\_device}}
\index{omp\_get\_initial\_device@{\code{omp\_get\_initial\_device}}}
\label{subsec:omp_get_initial_device}
\summary
The \code{omp\_get\_initial\_device} routine returns a device number representing
the host device.

\pagebreak

\begin{samepage}
\format
\begin{ccppspecific}
\begin{boxedcode}
int omp\_get\_initial\_device(void);
\end{boxedcode}
\end{ccppspecific}
\end{samepage}

\begin{fortranspecific}
\begin{boxedcode}
integer function omp\_get\_initial\_device()
\end{boxedcode}
\end{fortranspecific}

\binding
The binding task set for an \code{omp\_get\_initial\_device} region is the generating task.

\effect
The effect of this routine is to return the device number of the host device.
The value of the device number is implementation defined. If it is between 0 
and one less than \code{omp\_get\_num\_devices()} then it is valid for use 
with all device constructs and routines; if it is outside that range, then 
it is only valid for use with the device memory routines and not in the 
\code{device} clause. When called from within a \code{target} region 
the effect of this routine is unspecified.

\crossreferences
\begin{itemize}
\item \code{target} construct, see 
\specref{subsec:target Construct}

\item Device memory routines, see \specref{sec:Device Memory Routines}.
\end{itemize}




\subsection{\code{omp\_get\_max\_task\_priority}}
\index{omp\_get\_max\_task\_priority@{\code{omp\_get\_max\_task\_priority}}}
\label{subsec:omp_get_max_task_priority}
\summary

The \code{omp\_get\_max\_task\_priority} routine returns the maximum value that can be
specified in the \code{priority} clause.

\pagebreak

\begin{samepage}
\format
\begin{ccppspecific}
\begin{boxedcode}
int omp\_get\_max\_task\_priority(void);
\end{boxedcode}
\end{ccppspecific}
\end{samepage}

\begin{fortranspecific}
\begin{boxedcode}
integer function omp\_get\_max\_task\_priority()
\end{boxedcode}
\end{fortranspecific}

\binding

The binding thread set for an \code{omp\_get\_max\_task\_priority} region is all threads
on the device. The effect of executing this routine is not related to any specific region
corresponding to any construct or API routine.

\effect

The \code{omp\_get\_max\_task\_priority} routine returns the value of the \plc{max-task-priority-var}
ICV, which determines the maximum value that can be specified in the \code{priority} clause.

\crossreferences

\begin{itemize}
\item \plc{max-task-priority-var}, see 
\specref{sec:Internal Control Variables}.

\item \code{task} construct, see 
\specref{subsec:task Construct}. 
\end{itemize}










%% \newpage
