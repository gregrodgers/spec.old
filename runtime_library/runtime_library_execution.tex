% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. There are environments that provide special formatting, e.g. language bars.
%       Please use them whereever appropriate.  Examples are:
%
%         \begin{fortranspecific}
%         This is text that appears enclosed in blue language bars for Fortran.
%         \end{fortranspecific}
%
%         \begin{note}
%         This is a note.  The "Note -- " header appears automatically.
%         \end{note}
%
%    6. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%


\section{Execution Environment Routines}
\index{execution environment routines}
\label{sec:Execution Environment Routines}
This section describes routines that affect and monitor threads, processors, and the
parallel environment.






\subsection{\hcode{omp_set_num_threads}}
\index{omp_set_num_threads@{\code{omp_set_num_threads}}}
\label{subsec:omp_set_num_threads}
\summary
The \code{omp_set_num_threads} routine affects the number of threads to be used for
subsequent parallel regions that do not specify a \code{num_threads} clause, by setting the
value of the first element of the \plc{nthreads-var} ICV of the current task.

\format
\begin{ccppspecific}
\begin{ompcFunction}
void omp_set_num_threads(int \plc{num_threads});
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfSubroutine}
subroutine omp_set_num_threads(\plc{num_threads})
integer \plc{num_threads}
\end{ompfSubroutine}
\end{fortranspecific}

\constraints
The value of the argument passed to this routine must evaluate to a positive integer, or
else the behavior of this routine is implementation defined.

\binding
The binding task set for an \code{omp_set_num_threads} region is the generating task.

\effect
The effect of this routine is to set the value of the first element of the \plc{nthreads-var} ICV
of the current task to the value specified in the argument.

\crossreferences
\begin{itemize}
\item \plc{nthreads-var} ICV, see
\specref{sec:Internal Control Variables}.

\item \code{parallel} construct and \code{num_threads} clause, see
\specref{sec:parallel Construct}.

\item Determining the number of threads for a \code{parallel} region, see
\specref{subsec:Determining the Number of Threads for a parallel Region}.

\item \code{omp_get_max_threads} routine, see
\specref{subsec:omp_get_max_threads}.

\item \code{omp_get_num_threads} routine, see
\specref{subsec:omp_get_num_threads}.

\item \code{OMP_NUM_THREADS} environment variable, see
\specref{sec:OMP_NUM_THREADS}.
\end{itemize}









\subsection{\hcode{omp_get_num_threads}}
\index{omp_get_num_threads@{\code{omp_get_num_threads}}}
\label{subsec:omp_get_num_threads}
\summary
The \code{omp_get_num_threads} routine returns the number of threads in the current
team.
\format
\begin{ccppspecific}
\begin{ompcFunction}
int omp_get_num_threads(void);
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfFunction}
integer function omp_get_num_threads()
\end{ompfFunction}
\end{fortranspecific}

\binding
The binding region for an \code{omp_get_num_threads} region is the innermost enclosing
\code{parallel} region.

\effect
The \code{omp_get_num_threads} routine returns the number of threads in the team
executing the \code{parallel} region to which the routine region binds. If called from the
sequential part of a program, this routine returns 1.

\crossreferences
\begin{itemize}


\item \plc{nthreads-var} ICV, see
\specref{sec:Internal Control Variables}.

\item \code{parallel} construct and \code{num_threads} clause, see
\specref{sec:parallel Construct}.

\item Determining the number of threads for a \code{parallel} region, see
\specref{subsec:Determining the Number of Threads for a parallel Region}.

\item \code{omp_set_num_threads} routine, see
\specref{subsec:omp_set_num_threads}.

\item \code{OMP_NUM_THREADS} environment variable, see
\specref{sec:OMP_NUM_THREADS}.
\end{itemize}




\subsection{\hcode{omp_get_max_threads}}
\index{omp_get_max_threads@{\code{omp_get_max_threads}}}
\label{subsec:omp_get_max_threads}
\summary
The \code{omp_get_max_threads} routine returns an upper bound on the number of
threads that could be used to form a new team if a \code{parallel} construct without a
\code{num_threads} clause were encountered after execution returns from this routine.

\format
\begin{ccppspecific}
\begin{ompcFunction}
int omp_get_max_threads(void);
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfFunction}
integer function omp_get_max_threads()
\end{ompfFunction}
\end{fortranspecific}

\binding
The binding task set for an \code{omp_get_max_threads} region is the generating task.

\effect
The value returned by \code{omp_get_max_threads} is the value of the first element of
the \plc{nthreads-var} ICV of the current task. This value is also an upper bound on the
number of threads that could be used to form a new team if a parallel region without a
\code{num_threads} clause were encountered after execution returns from this routine.

\begin{note}
The return value of the \code{omp_get_max_threads} routine can be used to
dynamically allocate sufficient storage for all threads in the team formed at the
subsequent active \code{parallel} region.
\end{note}

\crossreferences
\begin{itemize}
\item \plc{nthreads-var} ICV, see
\specref{sec:Internal Control Variables}.

\item \code{parallel} construct and \code{num_threads} clause, see
\specref{sec:parallel Construct}.

\item Determining the number of threads for a \code{parallel} region, see
\specref{subsec:Determining the Number of Threads for a parallel Region}.

\item \code{omp_set_num_threads} routine, see
\specref{subsec:omp_set_num_threads}.

\item \code{omp_get_num_threads} routine, see
\specref{subsec:omp_get_num_threads}.

\item \code{omp_get_thread_num} routine, see
\specref{subsec:omp_get_thread_num}.

\item \code{OMP_NUM_THREADS} environment variable, see
\specref{sec:OMP_NUM_THREADS}.
\end{itemize}











\subsection{\hcode{omp_get_thread_num}}
\index{omp_get_thread_num@{\code{omp_get_thread_num}}}
\label{subsec:omp_get_thread_num}
\summary
The \code{omp_get_thread_num} routine returns the thread number, within the current
team, of the calling thread.

\format
\begin{ccppspecific}
\begin{ompcFunction}
int omp_get_thread_num(void);
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfFunction}
integer function omp_get_thread_num()
\end{ompfFunction}
\end{fortranspecific}

\binding
The binding thread set for an \code{omp_get_thread_num} region is the current team. The
binding region for an \code{omp_get_thread_num} region is the innermost enclosing
\code{parallel} region.

\effect
The \code{omp_get_thread_num} routine returns the thread number of the calling thread,
within the team executing the \code{parallel} region to which the routine region binds. The
thread number is an integer between 0 and one less than the value returned by
\code{omp_get_num_threads}, inclusive. The thread number of the master thread of the
team is 0. The routine returns 0 if it is called from the sequential part of a program.

\begin{note}
The thread number may change during the execution of an untied task. The
value returned by \code{omp_get_thread_num} is not generally useful during the execution
of such a task region.
\end{note}

\crossreferences
\begin{itemize}
\item \plc{nthreads-var} ICV, see
\specref{sec:Internal Control Variables}.

\item \code{parallel} construct and \code{num_threads} clause, see
\specref{sec:parallel Construct}.

\item Determining the number of threads for a \code{parallel} region, see
\specref{subsec:Determining the Number of Threads for a parallel Region}.

\item \code{omp_get_num_threads} routine, see
\specref{subsec:omp_get_num_threads}.

\item \code{omp_set_num_threads} routine, see
\specref{subsec:omp_set_num_threads}.

\item \code{OMP_NUM_THREADS} environment variable, see
\specref{sec:OMP_NUM_THREADS}.
\end{itemize}








\subsection{\hcode{omp_get_num_procs}}
\index{omp_get_num_procs@{\code{omp_get_num_procs}}}
\label{subsec:omp_get_num_procs}
\summary
The \code{omp_get_num_procs} routine returns the number of processors available to the
device.

\format
\begin{ccppspecific}
\begin{ompcFunction}
int omp_get_num_procs(void);
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfFunction}
integer function omp_get_num_procs()
\end{ompfFunction}
\end{fortranspecific}

\binding
The binding thread set for an \code{omp_get_num_procs} region is all threads on a device.
The effect of executing this routine is not related to any specific region corresponding to
any construct or API routine.

\effect
The \code{omp_get_num_procs} routine returns the number of processors that are available
to the device at the time the routine is called. This value may change between
the time that it is determined by the \code{omp_get_num_procs} routine and the time that it
is read in the calling context due to system actions outside the control of the OpenMP
implementation.

\crossreferences

\begin{itemize}
\item \code{omp_get_num_places} routine, see
\specref{subsec:omp_get_num_places}.

\item \code{omp_get_place_num_procs} routine, see
\specref{subsec:omp_get_place_num_procs}.

\item \code{omp_get_place_proc_ids} routine, see
\specref{subsec:omp_get_place_proc_ids}.

\item \code{omp_get_place_num} routine, see
\specref{subsec:omp_get_place_num}.
\end{itemize}







\subsection{\hcode{omp_in_parallel}}
\index{omp_in_parallel@{\code{omp_in_parallel}}}
\label{subsec:omp_in_parallel}
\summary
The \code{omp_in_parallel} routine returns \plc{true} if the \plc{active-levels-var} ICV is greater
than zero; otherwise, it returns \plc{false}.

%\pagebreak
\format
\begin{ccppspecific}
\begin{ompcFunction}
int omp_in_parallel(void);
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfFunction}
logical function omp_in_parallel()
\end{ompfFunction}
\end{fortranspecific}

\binding
The binding task set for an \code{omp_in_parallel} region is the generating task.

\effect
The effect of the \code{omp_in_parallel} routine is to return \plc{true} if the current task is
enclosed by an active \code{parallel} region, and the \code{parallel} region is enclosed by the
outermost initial task region on the device; otherwise it returns \plc{false}.

\crossreferences
\begin{itemize}
\item \plc{active-levels-var}, see
\specref{sec:Internal Control Variables}.

\item \code{parallel} construct, see
\specref{sec:parallel Construct}.

\item \code{omp_get_active_level} routine, see
\specref{subsec:omp_get_active_level}.

\item \code{omp_get_num_threads} routine, see
\specref{subsec:omp_get_num_threads}.
\end{itemize}








\bigskip
\subsection{\hcode{omp_set_dynamic}}
\index{omp_set_dynamic@{\code{omp_set_dynamic}}}
\label{subsec:omp_set_dynamic}
\summary
The \code{omp_set_dynamic} routine enables or disables dynamic adjustment of the
number of threads available for the execution of subsequent \code{parallel} regions by
setting the value of the \plc{dyn-var} ICV.


%\pagebreak
\format
\begin{ccppspecific}
\begin{ompcFunction}
void omp_set_dynamic(int \plc{dynamic_threads});
\end{ompcFunction}
\end{ccppspecific}
\bigskip

\begin{samepage}
\begin{fortranspecific}
\begin{ompfSubroutine}
subroutine omp_set_dynamic(\plc{dynamic_threads})
logical \plc{dynamic_threads}
\end{ompfSubroutine}
\end{fortranspecific}
\end{samepage}

\binding
The binding task set for an \code{omp_set_dynamic} region is the generating task.

\effect
For implementations that support dynamic adjustment of the number of threads, if the
argument to \code{omp_set_dynamic} evaluates to \plc{true}, dynamic adjustment is enabled for
the current task; otherwise, dynamic adjustment is disabled for the current task. For
implementations that do not support dynamic adjustment of the number of threads this
routine has no effect: the value of \plc{dyn-var} remains \plc{false}.

\crossreferences
\begin{itemize}
\item \plc{dyn-var} ICV, see
\specref{sec:Internal Control Variables}.

\item Determining the number of threads for a \code{parallel} region, see
\specref{subsec:Determining the Number of Threads for a parallel Region}.

\item \code{omp_get_num_threads} routine, see
\specref{subsec:omp_get_num_threads}.

\item \code{omp_get_dynamic} routine, see
\specref{subsec:omp_get_dynamic}.

\item \code{OMP_DYNAMIC} environment variable, see
\specref{sec:OMP_DYNAMIC}.
\end{itemize}








\subsection{\hcode{omp_get_dynamic}}
\index{omp_get_dynamic@{\code{omp_get_dynamic}}}
\label{subsec:omp_get_dynamic}
\summary
The \code{omp_get_dynamic} routine returns the value of the \plc{dyn-var} ICV, which
determines whether dynamic adjustment of the number of threads is enabled or disabled.

\format
\begin{ccppspecific}
\begin{ompcFunction}
int omp_get_dynamic(void);
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfFunction}
logical function omp_get_dynamic()
\end{ompfFunction}
\end{fortranspecific}

\binding
The binding task set for an \code{omp_get_dynamic} region is the generating task.

\effect
This routine returns \plc{true} if dynamic adjustment of the number of threads is enabled for
the current task; it returns \plc{false}, otherwise. If an implementation does not support
dynamic adjustment of the number of threads, then this routine always returns \plc{false}.

\crossreferences
\begin{itemize}
\item \plc{dyn-var} ICV, see
\specref{sec:Internal Control Variables}.

\item Determining the number of threads for a \code{parallel} region, see
\specref{subsec:Determining the Number of Threads for a parallel Region}.

\item \code{omp_set_dynamic} routine, see
\specref{subsec:omp_set_dynamic}.

\item \code{OMP_DYNAMIC} environment variable, see
\specref{sec:OMP_DYNAMIC}.
\end{itemize}








\subsection{\hcode{omp_get_cancellation}}
\index{omp_get_cancellation@{\code{omp_get_cancellation}}}
\label{subsec:omp_get_cancellation}
\summary
The \code{omp_get_cancellation} routine returns the value of the \plc{cancel-var} ICV, which determines if cancellation is enabled or disabled.


\format
\begin{ccppspecific}
\begin{ompcFunction}
int omp_get_cancellation(void);
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfFunction}
logical function omp_get_cancellation()
\end{ompfFunction}
\end{fortranspecific}

\binding
The binding task set for an \code{omp_get_cancellation} region is the whole program.

\effect
This routine returns \plc{true} if cancellation is enabled. It returns \plc{false} otherwise.

\crossreferences
\begin{itemize}
\item \plc{cancel-var} ICV, see
\specref{subsec:ICV Descriptions}.

\item \code{cancel} construct, see \specref{subsec:cancel Construct}.

\item \code{OMP_CANCELLATION} environment variable, see
\specref{sec:OMP_CANCELLATION}.
\end{itemize}









\subsection{\hcode{omp_set_nested}}
\index{omp_set_nested@{\code{omp_set_nested}}}
\label{subsec:omp_set_nested}
\summary
The deprecated \code{omp_set_nested} routine enables or disables nested parallelism by setting the
\plc{max-active-levels-var} ICV.


\format
\begin{ccppspecific}
\begin{ompcFunction}
void omp_set_nested(int \plc{nested});
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfSubroutine}
subroutine omp_set_nested(\plc{nested})
logical \plc{nested}
\end{ompfSubroutine}
\end{fortranspecific}

\binding
The binding task set for an \code{omp_set_nested} region is the generating task.

\effect

If the argument to \code{omp_set_nested} evaluates to \plc{true}, the value of
the \plc{max-active-levels-var} ICV is set to the number of active levels of
parallelism that the implementation supports; otherwise, if the value of
\plc{max-active-levels-var} is greater than 1 then it is set to 1.
This routine has been deprecated.

\crossreferences
\begin{itemize}
\item \plc{max-active-levels-var} ICV, see
\specref{sec:Internal Control Variables}.

\item Determining the number of threads for a \code{parallel} region, see
\specref{subsec:Determining the Number of Threads for a parallel Region}.

\item \code{omp_get_nested} routine, see \specref{subsec:omp_get_nested}.

\item \code{omp_set_max_active_levels} routine, see
\specref{subsec:omp_set_max_active_levels}.

\item \code{omp_get_max_active_levels} routine, see
\specref{subsec:omp_get_max_active_levels}.

\item \code{OMP_NESTED} environment variable, see
\specref{sec:OMP_NESTED}.
\end{itemize}








\subsection{\hcode{omp_get_nested}}
\index{omp_get_nested@{\code{omp_get_nested}}}
\label{subsec:omp_get_nested}
\summary
The deprecated \code{omp_get_nested} routine returns whether nested parallelism is
enabled or disabled, according to the value of the \plc{max-active-levels-var}
ICV.

\format
\begin{ccppspecific}
\begin{ompcFunction}
int omp_get_nested(void);
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfFunction}
logical function omp_get_nested()
\end{ompfFunction}
\end{fortranspecific}

\binding
The binding task set for an \code{omp_get_nested} region is the generating task.

\effect
This routine returns \plc{true} if \plc{max-active-levels-var} is greater than
1 for the current task; it returns \plc{false}, otherwise. If an
implementation does not support nested parallelism, this routine always
returns \plc{false}.  This routine has been deprecated.

\crossreferences
\begin{itemize}
\item \plc{max-active-levels-var} ICV, see
\specref{sec:Internal Control Variables}.

\item Determining the number of threads for a \code{parallel} region, see
\specref{subsec:Determining the Number of Threads for a parallel Region}.

\item \code{omp_set_nested} routine, see
\specref{subsec:omp_set_nested}.

\item \code{omp_set_max_active_levels} routine, see
\specref{subsec:omp_set_max_active_levels}.

\item \code{omp_get_max_active_levels} routine, see
\specref{subsec:omp_get_max_active_levels}.

\item \code{OMP_NESTED} environment variable, see
\specref{sec:OMP_NESTED}.
\end{itemize}









\subsection{\hcode{omp_set_schedule}}
\index{omp_set_schedule@{\code{omp_set_schedule}}}
\label{subsec:omp_set_schedule}
\summary
The \code{omp_set_schedule} routine affects the schedule that is applied when \code{runtime}
is used as schedule kind, by setting the value of the \plc{run-sched-var} ICV.


\format
\begin{ccppspecific}
\begin{ompcFunction}
void omp_set_schedule(omp_sched_t \plc{kind}, int \plc{chunk_size});
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfSubroutine}
subroutine omp_set_schedule(\plc{kind}, \plc{chunk_size})
integer (kind=omp_sched_kind) \plc{kind}
integer \plc{chunk_size}
\end{ompfSubroutine}
\end{fortranspecific}

\constraints
The first argument passed to this routine can be one of the valid OpenMP schedule kinds
(except for \code{runtime}) or any implementation specific schedule. The C/C++ header file
(\code{omp.h}) and the Fortran include file (\code{omp_lib.h}) and/or Fortran~90 module file
(\code{omp_lib}) define the valid constants. The valid constants must include the following,
which can be extended with implementation specific values:

\begin{ccppspecific}
\begin{ompcEnum}
typedef enum omp_sched_t {
  omp_sched_static = 1,
  omp_sched_dynamic = 2,
  omp_sched_guided = 3,
  omp_sched_auto = 4
} omp_sched_t;
\end{ompcEnum}
\end{ccppspecific}

\begin{samepage}
\begin{fortranspecific}
\begin{ompfEnum}
integer(kind=omp_sched_kind), parameter :: omp_sched_static = 1
integer(kind=omp_sched_kind), parameter :: omp_sched_dynamic = 2
integer(kind=omp_sched_kind), parameter :: omp_sched_guided = 3
integer(kind=omp_sched_kind), parameter :: omp_sched_auto = 4
\end{ompfEnum}
\end{fortranspecific}
\end{samepage}

\binding
The binding task set for an \code{omp_set_schedule} region is the generating task.

\effect
The effect of this routine is to set the value of the \plc{run-sched-var} ICV of the current task
to the values specified in the two arguments. The schedule is set to the schedule type
specified by the first argument \plc{kind}. It can be any of the standard schedule types or
any other implementation specific one. For the schedule types \code{static}, \code{dynamic}, and
\code{guided} the \plc{chunk_size} is set to the value of the second argument, or to the default
\plc{chunk_size} if the value of the second argument is less than 1; for the schedule type
\code{auto} the second argument has no meaning; for implementation specific schedule types,
the values and associated meanings of the second argument are implementation defined.

\crossreferences
\begin{itemize}
\item \plc{run-sched-var} ICV, see
\specref{sec:Internal Control Variables}.

\item Determining the schedule of a worksharing loop, see
\specref{subsubsec:Determining the Schedule of a Worksharing Loop}.

\item \code{omp_get_schedule} routine, see
\specref{subsec:omp_get_schedule}.

\item \code{omp_set_schedule} routine, see
\specref{subsec:omp_set_schedule}.

\item \code{OMP_SCHEDULE} environment variable, see
\specref{sec:OMP_SCHEDULE}.
\end{itemize}









\subsection{\hcode{omp_get_schedule}}
\index{omp_get_schedule@{\code{omp_get_schedule}}}
\label{subsec:omp_get_schedule}
\summary
The \code{omp_get_schedule} routine returns the schedule that is applied when the
runtime schedule is used.
\format
\begin{ccppspecific}
\begin{ompcFunction}
void omp_get_schedule(omp_sched_t *\plc{kind}, int *\plc{chunk_size});
\end{ompcFunction}
\end{ccppspecific}


\begin{fortranspecific}
\begin{ompfSubroutine}
subroutine omp_get_schedule(\plc{kind}, \plc{chunk_size})
integer (kind=omp_sched_kind) \plc{kind}
integer \plc{chunk_size}
\end{ompfSubroutine}
\end{fortranspecific}

\binding
The binding task set for an \code{omp_get_schedule} region is the generating task.

\effect
This routine returns the \plc{run-sched-var} ICV in the task to which the
routine binds. The first argument \plc{kind} returns the schedule to be used.
It can be any of the standard schedule types as defined in
\specref{subsec:omp_set_schedule},
or any implementation specific schedule type. If the first
argument returns \code{static}, \code{dynamic}, or \code{guided}, then if the second
argument \plc{chunk_size} returned is greater than or equal to 1 then it is
the \plc{chunk_size} to be used; if it is less than 1 then the default
\plc{chunk_size} is to be used. The second argument \plc{chunk_size} returned
is implementation defined for any other schedule types.


\crossreferences
\begin{itemize}
\item \plc{run-sched-var} ICV, see
\specref{sec:Internal Control Variables}.

\item Determining the schedule of a worksharing loop, see
\specref{subsubsec:Determining the Schedule of a Worksharing Loop}.

\item \code{omp_set_schedule} routine, see
\specref{subsec:omp_set_schedule}.

\item \code{OMP_SCHEDULE} environment variable, see
\specref{sec:OMP_SCHEDULE}.
\end{itemize}









\subsection{\hcode{omp_get_thread_limit}}
\index{omp_get_thread_limit@{\code{omp_get_thread_limit}}}
\label{subsec:omp_get_thread_limit}
\summary
The \code{omp_get_thread_limit} routine returns the maximum number of OpenMP
threads available to participate in the current contention group.


\format
\begin{ccppspecific}
\begin{ompcFunction}
int omp_get_thread_limit(void);
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfFunction}
integer function omp_get_thread_limit()
\end{ompfFunction}
\end{fortranspecific}

\binding
The binding thread set for an \code{omp_get_thread_limit} region is all threads on the
device. The effect of executing this routine is not related to any specific region
corresponding to any construct or API routine.

\effect
The \code{omp_get_thread_limit} routine returns the value of the \plc{thread-limit-var} ICV.

\crossreferences
\begin{itemize}
\item \plc{thread-limit-var} ICV, see
\specref{sec:Internal Control Variables}.

\item \code{OMP_THREAD_LIMIT} environment variable, see
\specref{sec:OMP_THREAD_LIMIT}.

\item \code{omp_get_num_threads} routine, see
\specref{subsec:omp_get_num_threads}.

\item \code{OMP_NUM_THREADS} environment variable, see
\specref{sec:OMP_NUM_THREADS}.

\end{itemize}








\subsection{\hcode{omp_get_supported_active_levels}}
\index{omp_get_supported_active_levels@{\code{omp_get_supported_active_levels}}}
\label{subsec:omp_get_supported_active_levels}

\summary
The \code{omp_get_supported_active_levels} routine returns the
number of active levels of parallelism supported by the implementation.

\format
\begin{ccppspecific}
\begin{ompcFunction}
int omp_get_supported_active_levels(void);
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfFunction}
integer function omp_get_supported_active_levels()
\end{ompfFunction}
\end{fortranspecific}

\binding
The binding task set for an \code{omp_get_supported_active_levels}
region is the generating task.

\effect
The \code{omp_get_supported_active_levels} routine returns the
number of active levels of parallelism supported by the implementation. The
\plc{max-active-levels-var} ICV may not have a value that is greater than
this number. The value returned by the \code{omp_get_supported_active_levels}
routine is implementation defined, but it must be greater than 0.

\crossreferences
\begin{itemize}
\item \plc{max-active-levels-var} ICV, see
\specref{sec:Internal Control Variables}.

\item \code{omp_get_max_active_levels} routine, see
\specref{subsec:omp_get_max_active_levels}.

\item \code{omp_set_max_active_levels} routine, see
\specref{subsec:omp_set_max_active_levels}.
\end{itemize}








\subsection{\hcode{omp_set_max_active_levels}}
\index{omp_set_max_active_levels@{\code{omp_set_max_active_levels}}}
\label{subsec:omp_set_max_active_levels}
\summary
The \code{omp_set_max_active_levels} routine limits the number of nested active
parallel regions on the device, by setting the \plc{max-active-levels-var} ICV


\format
\begin{ccppspecific}
\begin{ompcFunction}
void omp_set_max_active_levels(int \plc{max_levels});
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfSubroutine}
subroutine omp_set_max_active_levels(\plc{max_levels})
integer \plc{max_levels}
\end{ompfSubroutine}
\end{fortranspecific}

\constraints
The value of the argument passed to this routine must evaluate to a non-negative integer,
otherwise the behavior of this routine is implementation defined.

\binding
When called from a sequential part of the program, the binding thread set for an
\code{omp_set_max_active_levels} region is the encountering thread. When called
from within any explicit parallel region, the binding thread set (and binding region, if
required) for the \code{omp_set_max_active_levels} region is implementation defined.

\effect
The effect of this routine is to set the value of the \plc{max-active-levels-var} ICV to the value
specified in the argument.

If the number of active levels requested exceeds the number of
active levels of parallelism
supported by the implementation, the value of the \plc{max-active-levels-var} ICV will be set
to the number of active levels supported by the implementation.

This routine has the described effect only when called from a sequential part of the
program. When called from within an explicit \code{parallel} region, the effect of this
routine is implementation defined.

\crossreferences
\begin{itemize}
\item \code{parallel} construct, see
\specref{sec:parallel Construct}.

\item \plc{max-active-levels-var} ICV, see
\specref{sec:Internal Control Variables}.

\item \code{omp_get_supported_active_levels} routine, see
\specref{subsec:omp_get_supported_active_levels}.

\item \code{omp_get_max_active_levels} routine, see
\specref{subsec:omp_get_max_active_levels}.

\item \code{OMP_MAX_ACTIVE_LEVELS} environment variable, see
\specref{sec:OMP_MAX_ACTIVE_LEVELS}.
\end{itemize}










\subsection{\hcode{omp_get_max_active_levels}}
\index{omp_get_max_active_levels@{\code{omp_get_max_active_levels}}}
\label{subsec:omp_get_max_active_levels}
\summary
The \code{omp_get_max_active_levels} routine returns the value of the
\plc{max-active-levels-var} ICV, which determines the maximum number of nested active parallel regions
on the device.

\format
\begin{ccppspecific}
\begin{ompcFunction}
int omp_get_max_active_levels(void);
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfFunction}
integer function omp_get_max_active_levels()
\end{ompfFunction}
\end{fortranspecific}

\binding
When called from a sequential part of the program, the binding thread set for an
\code{omp_get_max_active_levels} region is the encountering thread. When called
from within any explicit parallel region, the binding thread set (and binding region, if
required) for the \code{omp_get_max_active_levels} region is implementation defined.

\effect
The \code{omp_get_max_active_levels} routine returns the value of the \plc{max-active-levels-var} ICV,
which determines the maximum number of nested active parallel regions
on the device.

\crossreferences
\begin{itemize}
\item \code{parallel} construct, see
\specref{sec:parallel Construct}.

\item \plc{max-active-levels-var} ICV, see
\specref{sec:Internal Control Variables}.

\item \code{omp_get_supported_active_levels} routine, see
\specref{subsec:omp_get_supported_active_levels}.

\item \code{omp_set_max_active_levels} routine, see
\specref{subsec:omp_set_max_active_levels}.

\item \code{OMP_MAX_ACTIVE_LEVELS} environment variable, see
\specref{sec:OMP_MAX_ACTIVE_LEVELS}.
\end{itemize}








\subsection{\hcode{omp_get_level}}
\index{omp_get_level@{\code{omp_get_level}}}
\label{subsec:omp_get_level}
\summary
The \code{omp_get_level} routine returns the value of the \plc{levels-var} ICV.

\format
\begin{ccppspecific}
\begin{ompcFunction}
int omp_get_level(void);
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfFunction}
integer function omp_get_level()
\end{ompfFunction}
\end{fortranspecific}

\binding
The binding task set for an \code{omp_get_level} region is the generating task.

\effect
The effect of the \code{omp_get_level} routine is to return the number of nested
\code{parallel} regions (whether active or inactive) enclosing the current task such that all
of the \code{parallel} regions are enclosed by the outermost initial task region on the
current device.

\crossreferences
\begin{itemize}
\item \code{parallel} construct, see
\specref{sec:parallel Construct}.

\item \plc{levels-var} ICV, see
\specref{sec:Internal Control Variables}.

\item \code{omp_get_active_level} routine, see
\specref{subsec:omp_get_active_level}.

\item \code{OMP_MAX_ACTIVE_LEVELS} environment variable, see
\specref{sec:OMP_MAX_ACTIVE_LEVELS}.
\end{itemize}










\subsection{\hcode{omp_get_ancestor_thread_num}}
\index{omp_get_ancestor_thread_num@{\code{omp_get_ancestor_thread_num}}}
\label{subsec:omp_get_ancestor_thread_num}
\summary
The \code{omp_get_ancestor_thread_num} routine returns, for a given nested level of
the current thread, the thread number of the ancestor of the current thread.

\begin{samepage}
\format
\begin{ccppspecific}
\begin{ompcFunction}
int omp_get_ancestor_thread_num(int \plc{level});
\end{ompcFunction}
\end{ccppspecific}
\end{samepage}

\begin{fortranspecific}
\begin{ompfFunction}
integer function omp_get_ancestor_thread_num(\plc{level})
integer \plc{level}
\end{ompfFunction}
\end{fortranspecific}

\binding
The binding thread set for an \code{omp_get_ancestor_thread_num} region is the
encountering thread. The binding region for an \code{omp_get_ancestor_thread_num}
region is the innermost enclosing \code{parallel} region.

\effect
The \code{omp_get_ancestor_thread_num} routine returns the thread number of the
ancestor at a given nest level of the current thread or the thread number of the current
thread. If the requested nest level is outside the range of 0 and the nest level of the
current thread, as returned by the \code{omp_get_level} routine, the routine returns -1.

\begin{note}
When the \code{omp_get_ancestor_thread_num} routine is called with a value
of \code{level}=0, the routine always returns 0. If \code{level}=\code{omp_get_level()}, the routine
has the same effect as the \code{omp_get_thread_num} routine.
\end{note}

\crossreferences
\begin{itemize}
\item \code{parallel} construct, see
\specref{sec:parallel Construct}.

\item \code{omp_get_thread_num} routine, see
\specref{subsec:omp_get_thread_num}.

\item \code{omp_get_num_threads} routine, see
\specref{subsec:omp_get_num_threads}.

\item \code{omp_get_level} routine, see
\specref{subsec:omp_get_level}.

\item \code{omp_get_team_size} routine, see
\specref{subsec:omp_get_team_size}.
\end{itemize}










\subsection{\hcode{omp_get_team_size}}
\index{omp_get_team_size@{\code{omp_get_team_size}}}
\label{subsec:omp_get_team_size}
\summary
The \code{omp_get_team_size} routine returns, for a given nested level of the current
thread, the size of the thread team to which the ancestor or the current thread belongs.

\format
\begin{ccppspecific}
\begin{ompcFunction}
int omp_get_team_size(int \plc{level});
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfFunction}
integer function omp_get_team_size(\plc{level})
integer \plc{level}
\end{ompfFunction}
\end{fortranspecific}

\binding
The binding thread set for an \code{omp_get_team_size} region is the encountering
thread. The binding region for an \code{omp_get_team_size} region is the innermost
enclosing \code{parallel} region.

\effect
The \code{omp_get_team_size} routine returns the size of the thread team to which the
ancestor or the current thread belongs. If the requested nested level is outside the range
of 0 and the nested level of the current thread, as returned by the \code{omp_get_level}
routine, the routine returns -1. Inactive parallel regions are regarded like active parallel
regions executed with one thread.

\begin{note}
When the \code{omp_get_team_size} routine is called with a value of \code{level}=0,
the routine always returns 1. If \code{level}=\code{omp_get_level()}, the routine has the same
effect as the\linebreak \code{omp_get_num_threads} routine.
\end{note}

\crossreferences
\begin{itemize}
\item \code{omp_get_num_threads} routine, see
\specref{subsec:omp_get_num_threads}.

\item \code{omp_get_level} routine, see
\specref{subsec:omp_get_level}.

\item \code{omp_get_ancestor_thread_num} routine, see
\specref{subsec:omp_get_ancestor_thread_num}.
\end{itemize}









\subsection{\hcode{omp_get_active_level}}
\index{omp_get_active_level@{\code{omp_get_active_level}}}
\label{subsec:omp_get_active_level}
\summary
The \code{omp_get_active_level} routine returns the value of the \plc{active-levels-var} ICV.

\format
\begin{ccppspecific}
\begin{ompcFunction}
int omp_get_active_level(void);
\end{ompcFunction}
\end{ccppspecific}

%\pagebreak
\begin{fortranspecific}
\begin{ompfFunction}
integer function omp_get_active_level()
\end{ompfFunction}
\end{fortranspecific}

\binding
The binding task set for the an \code{omp_get_active_level} region is the generating
task.

\effect
The effect of the \code{omp_get_active_level} routine is to return the number of nested
active \code{parallel} regions enclosing the current task such that all of the \code{parallel}
regions are enclosed by the outermost initial task region on the current device.

\crossreferences
\begin{itemize}
\item \plc{active-levels-var} ICV, see
\specref{sec:Internal Control Variables}.

\item \code{omp_get_level} routine, see
\specref{subsec:omp_get_level}.

\item \code{omp_set_max_active_levels} routine, see
\specref{subsec:omp_set_max_active_levels}.

\item \code{omp_get_max_active_levels} routine, see
\specref{subsec:omp_get_max_active_levels}.

\item \code{OMP_MAX_ACTIVE_LEVELS} environment variable, see
\specref{sec:OMP_MAX_ACTIVE_LEVELS}.
\end{itemize}











\subsection{\hcode{omp_in_final}}
\index{omp_in_final@{\code{omp_in_final}}}
\label{subsec:omp_in_final}
\summary
The \code{omp_in_final} routine returns \plc{true} if the routine is executed in a final task
region; otherwise, it returns \plc{false}.

\format
\begin{ccppspecific}
\begin{ompcFunction}
int omp_in_final(void);
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfFunction}
logical function omp_in_final()
\end{ompfFunction}
\end{fortranspecific}

\binding
The binding task set for an \code{omp_in_final} region is the generating task.

\effect
\code{omp_in_final} returns \plc{true} if the enclosing task region is final. Otherwise, it returns
\plc{false}.

\crossreferences
\begin{itemize}
\item \code{task} construct, see
\specref{subsec:task Construct}.
\end{itemize}









\subsection{\hcode{omp_get_proc_bind}}
\index{omp_get_proc_bind@{\code{omp_get_proc_bind}}}
\label{subsec:omp_get_proc_bind}
\summary
The \code{omp_get_proc_bind} routine returns the thread affinity policy to be used for the
subsequent nested \code{parallel} regions that do not specify a \code{proc_bind} clause.

\format
\begin{ccppspecific}
\begin{ompcFunction}
omp_proc_bind_t omp_get_proc_bind(void);
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfFunction}
integer (kind=omp_proc_bind_kind) function omp_get_proc_bind()
\end{ompfFunction}
\end{fortranspecific}

\constraints
The value returned by this routine must be one of the valid affinity policy kinds. The C/
C++ header file (\code{omp.h}) and the Fortran include file (\code{omp_lib.h}) and/or Fortran~90
module file (\code{omp_lib}) define the valid constants. The valid constants must include the
following:

\begin{ccppspecific}
\begin{ompcEnum}
typedef enum omp_proc_bind_t {
  omp_proc_bind_false = 0,
  omp_proc_bind_true = 1,
  omp_proc_bind_master = 2,
  omp_proc_bind_close = 3,
  omp_proc_bind_spread = 4
} omp_proc_bind_t;
\end{ompcEnum}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfEnum}
integer (kind=omp_proc_bind_kind), &
                parameter :: omp_proc_bind_false = 0
integer (kind=omp_proc_bind_kind), &
                parameter :: omp_proc_bind_true = 1
integer (kind=omp_proc_bind_kind), &
                parameter :: omp_proc_bind_master = 2
integer (kind=omp_proc_bind_kind), &
                parameter :: omp_proc_bind_close = 3
integer (kind=omp_proc_bind_kind), &
                parameter :: omp_proc_bind_spread = 4
\end{ompfEnum}
\end{fortranspecific}

\binding
The binding task set for an \code{omp_get_proc_bind} region is the generating task.

\effect
The effect of this routine is to return the value of the first element of the \plc{bind-var} ICV
of the current task. See \specref{subsec:Controlling OpenMP Thread Affinity}
for the rules governing the thread affinity policy.

\crossreferences
\begin{itemize}
\item \plc{bind-var} ICV, see
\specref{sec:Internal Control Variables}.

\item Controlling OpenMP thread affinity, see
\specref{subsec:Controlling OpenMP Thread Affinity}.

\item \code{OMP_PROC_BIND} environment variable, see
\specref{sec:OMP_PROC_BIND}.

\item \code{omp_get_num_places} routine, see
\specref{subsec:omp_get_num_places}.

\item \code{OMP_PLACES} environment variable, see
\specref{sec:OMP_PLACES}.
\end{itemize}



%%%%%%%%%% begin 392

\subsection{\hcode{omp_get_num_places}}
\index{omp_get_num_places@{\code{omp_get_num_places}}}
\label{subsec:omp_get_num_places}
\summary
The \code{omp_get_num_places} routine returns the number of places
available to the execution environment in the place list.

\format
\begin{ccppspecific}
\begin{ompcFunction}
int omp_get_num_places(void);
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfFunction}
integer function omp_get_num_places()
\end{ompfFunction}
\end{fortranspecific}

\binding
The binding thread set for an \code{omp_get_num_places}  region is all threads on a device. The effect of executing this routine is not related to any specific region corresponding to any construct or API routine.

\effect

The \code{omp_get_num_places} routine returns the number of places in the place list. This value is equivalent to the number of places in the  \plc{place-partition-var} ICV in the execution environment of the initial task.

\crossreferences
\begin{itemize}
\item \plc{place-partition-var} ICV, see
\specref{sec:Internal Control Variables}.

\item Controlling OpenMP thread affinity, see
\specref{subsec:Controlling OpenMP Thread Affinity}.

\item \code{omp_get_place_num} routine, see
\specref{subsec:omp_get_place_num}.

\item \code{OMP_PLACES} environment variable, see
\specref{sec:OMP_PLACES}.
\end{itemize}





\subsection{\hcode{omp_get_place_num_procs}}
\index{omp_get_place_num_procs@{\code{omp_get_place_num_procs}}}
\label{subsec:omp_get_place_num_procs}

\summary
The \code{omp_get_place_num_procs}  routine returns the number of processors available to the execution environment in the specified place.

\format
\begin{ccppspecific}
\begin{ompcFunction}
int omp_get_place_num_procs(int \plc{place_num});
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfFunction}
integer function omp_get_place_num_procs(\plc{place_num})
integer \plc{place_num}
\end{ompfFunction}
\end{fortranspecific}

\binding
The binding thread set for an \code{omp_get_place_num_procs}  region is all threads on a device. The effect of executing this routine is not related to any specific region corresponding to any construct or API routine.

\effect
The \code{omp_get_place_num_procs} routine returns the number of
processors associated with the place numbered \plc{place_num}. The
routine returns zero when \plc{place_num} is negative, or is greater 
than or equal to the value returned by \code{omp_get_num_places()}.

\crossreferences
\begin{itemize}

\item Controlling OpenMP thread affinity, see
\specref{subsec:Controlling OpenMP Thread Affinity}.

\item \plc{place-partition-var} ICV, see
\specref{sec:Internal Control Variables}.

\item \code{omp_get_place_num_proc_ids} routine, see
\specref{subsec:omp_get_place_num_proc_ids}.

\item \code{omp_get_num_places} routine, see
\specref{subsec:omp_get_num_places}.

\item \code{OMP_PLACES} environment variable, see
\specref{sec:OMP_PLACES}.
\end{itemize}




\subsection{\hcode{omp_get_place_proc_ids}}
\index{omp_get_place_proc_ids@{\code{omp_get_place_proc_ids}}}
\label{subsec:omp_get_place_proc_ids}

\summary
The \code{omp_get_place_proc_ids} routine returns the numerical identifiers of the processors available to the execution environment in the specified place.

\format
\begin{ccppspecific}
\begin{ompcFunction}
void omp_get_place_proc_ids(int \plc{place_num}, int *\plc{ids});
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfSubroutine}
subroutine omp_get_place_proc_ids(\plc{place_num}, \plc{ids})
integer \plc{place_num}
integer \plc{ids}(*)
\end{ompfSubroutine}
\end{fortranspecific}

\binding
The binding thread set for an \code{omp_get_place_proc_ids} region is all
threads on a device. The effect of executing this routine is not related to
any specific region corresponding to any construct or API routine.

\effect
The \code{omp_get_place_proc_ids} routine returns the numerical
identifiers of each processor associated with the place numbered
\plc{place_num}. The numerical identifiers are non-negative, and
their meaning is implementation defined.  The numerical identifiers
are returned in the array \plc{ids} and their order in the array is
implementation defined. The array must be sufficiently large to contain
\code{omp_get_place_num_procs(}\plc{place_num}\code{)} integers;
otherwise, the behavior is unspecified.  The routine has no effect when
\plc{place_num} has a negative value, or a value greater than or equal 
to \code{omp_get_num_places()}.

\crossreferences
\begin{itemize}

\item Controlling OpenMP thread affinity, see
\specref{subsec:Controlling OpenMP Thread Affinity}.

\item \plc{place-partition-var} ICV, see
\specref{sec:Internal Control Variables}.

\item \code{omp_get_place_num_procs} routine, see
\specref{subsec:omp_get_place_num_procs}.

\item \code{omp_get_num_places} routine, see
\specref{subsec:omp_get_num_places}.

\item \code{OMP_PLACES} environment variable, see
\specref{sec:OMP_PLACES}.
\end{itemize}




\subsection{\hcode{omp_get_place_num}}
\index{omp_get_place_num@{\code{omp_get_place_num}}}
\label{subsec:omp_get_place_num}

\summary
The \code{omp_get_place_num} routine returns the place number of the place to which the encountering thread is bound.

\format
\begin{ccppspecific}
\begin{ompcFunction}
int omp_get_place_num(void);
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfFunction}
integer function omp_get_place_num()
\end{ompfFunction}
\end{fortranspecific}

\binding
The binding thread set for an \code{omp_get_place_num} region is the encountering thread.

\effect
When the encountering thread is bound to a place, the
\code{omp_get_place_num} routine returns the place number associated
with the thread. The returned value is between 0 and one less than the
value returned by \code{omp_get_num_places()}, inclusive. When the
encountering thread is not bound to a place, the routine returns -1.

\crossreferences
\begin{itemize}
\item Controlling OpenMP thread affinity, see
\specref{subsec:Controlling OpenMP Thread Affinity}.

\item \plc{place-partition-var} ICV, see
\specref{sec:Internal Control Variables}.

\item \code{omp_get_num_places} routine, see
\specref{subsec:omp_get_num_places}.

\item \code{OMP_PLACES} environment variable, see
\specref{sec:OMP_PLACES}.
\end{itemize}





\subsection{\hcode{omp_get_partition_num_places}}
\index{omp_get_partition_num_places@{\code{omp_get_partition_num_places}}}
\label{subsec:omp_get_partition_num_places}

\summary
The \code{omp_get_partition_num_places} routine returns the number of places in the place partition
of the innermost implicit task.

\format
\begin{ccppspecific}
\begin{ompcFunction}
int omp_get_partition_num_places(void);
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfFunction}
integer function omp_get_partition_num_places()
\end{ompfFunction}
\end{fortranspecific}

\binding
The binding task set for an  \code{omp_get_partition_num_places} region is the encountering implicit task.

\effect
The \code{omp_get_partition_num_places} routine returns the number of places in the \plc{place-partition-var} ICV.

\crossreferences
\begin{itemize}
\item \plc{place-partition-var} ICV, see
\specref{sec:Internal Control Variables}.

\item Controlling OpenMP thread affinity, see
\specref{subsec:Controlling OpenMP Thread Affinity}.


\item \code{omp_get_num_places} routine, see
\specref{subsec:omp_get_num_places}.

\item \code{OMP_PLACES} environment variable, see
\specref{sec:OMP_PLACES}.
\end{itemize}





\subsection{\hcode{omp_get_partition_place_nums}}
\index{omp_get_partition_place_nums@{\code{omp_get_partition_place_nums}}}
\label{subsec:omp_get_partition_place_nums}

\summary
The \code{omp_get_partition_place_nums} routine returns the list of place numbers corresponding to the places in the \plc{place-partition-var} ICV of the innermost implicit task.

\format
\begin{ccppspecific}
\begin{ompcFunction}
void omp_get_partition_place_nums(int *\plc{place_nums});
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfSubroutine}
subroutine omp_get_partition_place_nums(\plc{place_nums})
integer \plc{place_nums}(*)
\end{ompfSubroutine}
\end{fortranspecific}

\binding
The binding task set for an \code{omp_get_partition_place_nums} region is the encountering implicit task.

\effect
The \code{omp_get_partition_place_nums} routine returns the list of
place numbers corresponding to the places in the \plc{place-partition-var}
ICV of the innermost implicit task. The array must be sufficiently large
to contain \code{omp_get_partition_num_places()} integers; otherwise,
the behavior is unspecified.

\crossreferences
\begin{itemize}
\item \plc{place-partition-var} ICV, see
\specref{sec:Internal Control Variables}.

\item Controlling OpenMP thread affinity, see
\specref{subsec:Controlling OpenMP Thread Affinity}.

\item \code{omp_get_partition_num_places} routine, see
\specref{subsec:omp_get_partition_num_places}.

\item \code{OMP_PLACES} environment variable, see
\specref{sec:OMP_PLACES}.
\end{itemize}

\subsection{\hcode{omp_set_affinity_format}}
\index{omp_set_affinity_format@{\code{omp_set_affinity_format}}}
\label{subsec:omp_set_affinity_format}

\summary
The \code{omp_set_affinity_format} routine sets the affinity format to be used on the device
by setting the value of the \plc{affinity-format-var} ICV.

\format
\begin{ccppspecific}
\begin{ompcFunction}
void omp_set_affinity_format(char const *\plc{format});
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfSubroutine}
subroutine omp_set_affinity_format(\plc{format})
character(len=*),intent(in)::\plc{format}
\end{ompfSubroutine}
\end{fortranspecific}

\binding
When called from a sequential part of the program, the binding thread set for an
\code{omp_set_affinity_format} region is the encountering thread. When called
from within any explicit parallel region, the binding thread set (and binding region, if
required) for the \code{omp_set_affinity_format} region is implementation defined.

\effect
The effect of \code{omp_set_affinity_format} routine is to copy the
character string specified by the \plc{format} argument into the
\plc{affinity-format-var} ICV on the current device.

This routine has the described effect only when called from a sequential part of the
program. When called from within an explicit \code{parallel} region, the effect of this
routine is implementation defined.

\crossreferences
\begin{itemize}
\item Controlling OpenMP thread affinity, see
\specref{subsec:Controlling OpenMP Thread Affinity}.
\item \code{omp_get_affinity_format} routine, see \specref{subsec:omp_get_affinity_format}.
\item \code{omp_display_affinity} routine, see \specref{subsec:omp_display_affinity}.
\item \code{omp_capture_affinity} routine, see \specref{subsec:omp_capture_affinity}.
\item \code{OMP_DISPLAY_AFFINITY} environment variable, see
\specref{sec:OMP_DISPLAY_AFFINITY}.
\item \code{OMP_AFFINITY_FORMAT} environment variable, see
\specref{sec:OMP_AFFINITY_FORMAT}.
\end{itemize}

\subsection{\hcode{omp_get_affinity_format}}
\index{omp_get_affinity_format@{\code{omp_get_affinity_format}}}
\label{subsec:omp_get_affinity_format}

\summary
The \code{omp_get_affinity_format} routine returns the value of the
\plc{affinity-format-var} ICV on the device.

\format
\begin{ccppspecific}
\begin{ompcFunction}
size_t omp_get_affinity_format(char *\plc{buffer}, size_t \plc{size});
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfFunction}
integer function omp_get_affinity_format(\plc{buffer})
character(len=*),intent(out)::\plc{buffer}
\end{ompfFunction}
\end{fortranspecific}

\binding
When called from a sequential part of the program, the binding thread set for an
\code{omp_get_affinity_format} region is the encountering thread. When called
from within any explicit \code{parallel} region, the binding thread set (and binding region, if
required) for the \code{omp_get_affinity_format} region is implementation defined.

\effect
\begin{ccppspecific}
The \code{omp_get_affinity_format} routine returns the number of characters
in the \plc{affinity-format-var} ICV on the current device excluding the terminating
null byte (\code{'\0'}) and if \plc{size} is non-zero, writes the value of the
\plc{affinity-format-var} ICV on the current device to \plc{buffer} followed
by a null byte.  If the return value is greater than or equal to \plc{size},
the affinity format specification is truncated, with the terminating
null byte stored to {\pcode{\plc{buffer}[\plc{size}-1]}}.  If \plc{size} is
zero, nothing is stored and \plc{buffer} may be \code{NULL}.
\end{ccppspecific}

\begin{fortranspecific}
The \code{omp_get_affinity_format} routine returns the number of characters required
to hold the \plc{affinity-format-var} ICV on the current device and writes the value of the
\plc{affinity-format-var} ICV on the current device to \plc{buffer}.
If the return value is greater than {\pcode{len(\plc{buffer})}}, the affinity
format specification is truncated.
\end{fortranspecific}

If the \plc{buffer} argument does not conform to the specified format
then the result is implementation defined.

\crossreferences
\begin{itemize}
\item Controlling OpenMP thread affinity, see
\specref{subsec:Controlling OpenMP Thread Affinity}.
\item \code{omp_set_affinity_format} routine, see \specref{subsec:omp_set_affinity_format}.
\item \code{omp_display_affinity} routine, see \specref{subsec:omp_display_affinity}.
\item \code{omp_capture_affinity} routine, see \specref{subsec:omp_capture_affinity}.
\item \code{OMP_DISPLAY_AFFINITY} environment variable, see
\specref{sec:OMP_DISPLAY_AFFINITY}.
\item \code{OMP_AFFINITY_FORMAT} environment variable, see
\specref{sec:OMP_AFFINITY_FORMAT}.
\end{itemize}


\subsection{\hcode{omp_display_affinity}}
\index{omp_display_affinity@{\code{omp_display_affinity}}}
\label{subsec:omp_display_affinity}

\summary
The \code{omp_display_affinity} routine prints the OpenMP thread affinity information using the format specification provided.

\format
\begin{ccppspecific}
\begin{ompcFunction}
void omp_display_affinity(char const *\plc{format});
\end{ompcFunction}
\end{ccppspecific}


\begin{fortranspecific}
\begin{ompfSubroutine}
subroutine omp_display_affinity(\plc{format})
character(len=*),intent(in)::\plc{format}
\end{ompfSubroutine}
\end{fortranspecific}

\binding
The binding thread set for an \code{omp_display_affinity} region is the encountering thread.

\effect
The \code{omp_display_affinity} routine prints the thread affinity information of the current thread in the format
specified by the \plc{format} argument, followed by a \plc{new-line}.
If the \plc{format} is \code{NULL} (for C/C++) or a zero-length string
(for Fortran and C/C++), the value of the \plc{affinity-format-var} ICV is used.
If the \plc{format} argument does not conform to the specified format
then the result is implementation defined.

\crossreferences
\begin{itemize}
\item Controlling OpenMP thread affinity, see
\specref{subsec:Controlling OpenMP Thread Affinity}.
\item \code{omp_set_affinity_format} routine, see \specref{subsec:omp_set_affinity_format}.
\item \code{omp_get_affinity_format} routine, see \specref{subsec:omp_get_affinity_format}.
\item \code{omp_capture_affinity} routine, see \specref{subsec:omp_capture_affinity}.
\item \code{OMP_DISPLAY_AFFINITY} environment variable, see
\specref{sec:OMP_DISPLAY_AFFINITY}.
\item \code{OMP_AFFINITY_FORMAT} environment variable, see
\specref{sec:OMP_AFFINITY_FORMAT}.
\end{itemize}


\subsection{\hcode{omp_capture_affinity}}
\index{omp_capture_affinity@{\code{omp_capture_affinity}}}
\label{subsec:omp_capture_affinity}

\summary
The \code{omp_capture_affinity} routine prints the OpenMP thread affinity information into a buffer using
the format specification provided.


\format
\begin{ccppspecific}
\begin{ompcFunction}
size_t omp_capture_affinity(
  char *\plc{buffer},
  size_t \plc{size},
  char const *\plc{format}
);
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfFunction}
integer function omp_capture_affinity(\plc{buffer},\plc{format})
character(len=*),intent(out)::\plc{buffer}
character(len=*),intent(in)::\plc{format}
\end{ompfFunction}
\end{fortranspecific}

\binding
The binding thread set for an \code{omp_capture_affinity} region is the encountering thread.

\effect
\begin{ccppspecific}
The \code{omp_capture_affinity} routine returns the number of characters
in the entire thread affinity information string excluding the terminating
null byte (\code{'\0'}) and if \plc{size} is non-zero, writes the thread
affinity information of the current thread  in the format specified by 
the \plc{format} argument into the character string \code{buffer} followed 
by null byte.  If the return value is greater or equal to \plc{size}, the 
thread affinity information string is truncated, with the terminating
null byte stored to {\pcode{\plc{buffer}[\plc{size}-1]}}.  If \plc{size} is
zero, nothing is stored and \plc{buffer} may be \code{NULL}.
If the \plc{format} is \code{NULL} or a zero-length string, the value of the
\plc{affinity-format-var} ICV is used.
\end{ccppspecific}

\begin{fortranspecific}
The \code{omp_capture_affinity} routine returns the number of characters
required to hold the entire thread affinity information string
and prints the thread affinity information of the current thread
into the character string \code{buffer} with the size of
{\pcode{len(\plc{buffer})}} in the format specified by the \plc{format} 
argument. If the return value is greater than {\pcode{len(\plc{buffer})}}, 
the thread affinity information string is truncated. If the \plc{format} 
is a zero-length string, the value of the \plc{affinity-format-var} ICV 
is used.
\end{fortranspecific}

If the \plc{format} argument does not conform to the specified format
then the result is implementation defined.

\crossreferences
\begin{itemize}
\item Controlling OpenMP thread affinity, see
\specref{subsec:Controlling OpenMP Thread Affinity}.
\item \code{omp_set_affinity_format} routine, see \specref{subsec:omp_set_affinity_format}.
\item \code{omp_get_affinity_format} routine, see \specref{subsec:omp_get_affinity_format}.
\item \code{omp_display_affinity} routine, see \specref{subsec:omp_display_affinity}.
\item \code{OMP_DISPLAY_AFFINITY} environment variable, see
\specref{sec:OMP_DISPLAY_AFFINITY}.
\item \code{OMP_AFFINITY_FORMAT} environment variable, see
\specref{sec:OMP_AFFINITY_FORMAT}.
\end{itemize}


%%%%%%%%%%



\subsection{\hcode{omp_set_default_device}}
\index{omp_set_default_device@{\code{omp_set_default_device}}}
\label{subsec:omp_set_default_device}

\summary

The \code{omp_set_default_device} routine controls the default target device by
assigning the value of the \plc{default-device-var} ICV.

\format
\begin{ccppspecific}
\begin{ompcFunction}
void omp_set_default_device(int \plc{device_num});
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfSubroutine}
subroutine omp_set_default_device(\plc{device_num})
integer \plc{device_num}
\end{ompfSubroutine}
\end{fortranspecific}

\binding
The binding task set for an \code{omp_set_default_device} region is the generating
task.

\effect
The effect of this routine is to set the value of the \plc{default-device-var} ICV of the current
task to the value specified in the argument. When called from within a \code{target} region
the effect of this routine is unspecified.

\crossreferences
\begin{itemize}
\item \plc{default-device-var}, see
\specref{sec:Internal Control Variables}.

\item \code{omp_get_default_device}, see
\specref{subsec:omp_get_default_device}.

\item \code{OMP_DEFAULT_DEVICE} environment variable, see
\specref{sec:OMP_DEFAULT_DEVICE}

\item \code{target} construct, see
\specref{subsec:target Construct}

\end{itemize}










\subsection{\hcode{omp_get_default_device}}
\index{omp_get_default_device@{\code{omp_get_default_device}}}
\label{subsec:omp_get_default_device}
\summary
The \code{omp_get_default_device} routine returns the default target device.

\format
\begin{ccppspecific}
\begin{ompcFunction}
int omp_get_default_device(void);
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfFunction}
integer function omp_get_default_device()
\end{ompfFunction}
\end{fortranspecific}

\binding
The binding task set for an \code{omp_get_default_device} region is the generating
task.

\effect
The \code{omp_get_default_device} routine returns the value of the \plc{default-device-var}
ICV of the current task. When called from within a \code{target} region the effect of this
routine is unspecified.

\crossreferences
\begin{itemize}

\item \plc{default-device-var}, see
\specref{sec:Internal Control Variables}.

\item \code{omp_set_default_device}, see
\specref{subsec:omp_set_default_device}.

\item \code{OMP_DEFAULT_DEVICE} environment variable, see
\specref{sec:OMP_DEFAULT_DEVICE}.

\item \code{target} construct, see
\specref{subsec:target Construct}

\end{itemize}











\subsection{\hcode{omp_get_num_devices}}
\index{omp_get_num_devices@{\code{omp_get_num_devices}}}
\label{subsec:omp_get_num_devices}
\summary
The \code{omp_get_num_devices} routine returns the number of target devices.

\format
\begin{ccppspecific}
\begin{ompcFunction}
int omp_get_num_devices(void);
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfFunction}
integer function omp_get_num_devices()
\end{ompfFunction}
\end{fortranspecific}

\binding
The binding task set for an \code{omp_get_num_devices} region is the generating task.

\effect
The \code{omp_get_num_devices} routine returns the number of available target devices.
When called from within a \code{target} region the effect of this routine is unspecified.

\crossreferences

\end{itemize}
\item \code{omp_get_default_device}, see
\specref{subsec:omp_get_default_device}.

\item \code{omp_get_device_num}, see
\specref{subsec:omp_get_device_num}.

\item \code{target} construct, see
\specref{subsec:target Construct}

\end{itemize}



\subsection{\hcode{omp_get_device_num}}
\index{omp_get_device_num@{\code{omp_get_device_num}}}
\label{subsec:omp_get_device_num}
\summary
The \code{omp_get_device_num} routine returns the device number of the device on which
the calling thread is executing.

\format
\begin{ccppspecific}
\begin{ompcFunction}
int omp_get_device_num(void);
\end{ompcFunction}
\end{ccppspecific}


\begin{fortranspecific}
\begin{ompfFunction}
integer function omp_get_device_num()
\end{ompfFunction}
\end{fortranspecific}

\binding
The binding task set for an \code{omp_get_device_num} region is the generating task.

\effect
The \code{omp_get_device_num} routine returns the device number of the device on which
the calling thread is executing. When called on the host device, it will return the same
value as the \code{omp_get_initial_device} routine.

\crossreferences
\begin{itemize}

\item \code{omp_get_initial_device} routine, see
\specref{subsec:omp_get_initial_device}.

\item \code{omp_get_default_device}, see
\specref{subsec:omp_get_default_device}.


\item \code{omp_get_num_devices}, see
\specref{subsec:omp_get_num_devices}.

\item \code{target} construct, see
\specref{subsec:target Construct}

\end{itemize}










\subsection{\hcode{omp_get_num_teams}}
\index{omp_get_num_teams@{\code{omp_get_num_teams}}}
\label{subsec:omp_get_num_teams}
\summary
The \code{omp_get_num_teams} routine returns the number of initial teams in the current \code{teams}
region.

\format
\begin{ccppspecific}
\begin{ompcFunction}
int omp_get_num_teams(void);
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfFunction}
integer function omp_get_num_teams()
\end{ompfFunction}
\end{fortranspecific}

\binding
The binding task set for an \code{omp_get_num_teams} region is the generating task

\effect
The effect of this routine is to return the number of initial teams in the current \code{teams} region.
The routine returns 1 if it is called from outside of a \code{teams} region.

\crossreferences
\begin{itemize}

\item \code{teams} construct, see
\specref{sec:teams Construct}.

\item \code{omp_get_team_num} routin


\item \code{target} construct, see
\specref{subsec:target Construct}
\end{itemize}











\subsection{\hcode{omp_get_team_num}}
\index{omp_get_team_num@{\code{omp_get_team_num}}}
\label{subsec:omp_get_team_num}
\summary
The \code{omp_get_team_num} routine returns the initial team number of the calling thread.

\format
\begin{ccppspecific}
\begin{ompcFunction}
int omp_get_team_num(void);
\end{ompcFunction}
\end{ccppspecific}

\begin{fortranspecific}
\begin{ompfFunction}
integer function omp_get_team_num()
\end{ompfFunction}
\end{fortranspecific}

\binding
The binding task set for an \code{omp_get_team_num} region is the generating task.

\effect
The \code{omp_get_team_num} routine returns the initial team number of the calling thread. The
initial team number is an integer between 0 and one less than the value returned by
\code{omp_get_num_teams()}, inclusive. The routine returns 0 if it is called outside of a
\code{teams} region.

\crossreferences
\begin{itemize}

\item \code{teams} construct, see
\specref{sec:teams Construct}.

\item \code{omp_get_num_teams} routine, see
\specref{subsec:omp_get_num_teams}.

\item \code{target} construct, see
\specref{subsec:target Construct}

\end{itemize}









\subsection{\hcode{omp_is_initial_device}}
\index{omp_is_initial_device@{\code{omp_is_initial_device}}}
\label{subsec:omp_is_initial_device}
\summary
The \code{omp_is_initial_device} routine returns \plc{true} if the current task is executing
on the host device; otherwise, it returns \plc{false}.

\begin{samepage}
\format
\begin{ccppspecific}
\begin{ompcFunction}
int omp_is_initial_device(void);
\end{ompcFunction}
\end{ccppspecific}
\end{samepage}

\begin{fortranspecific}
\begin{ompfFunction}
logical function omp_is_initial_device()
\end{ompfFunction}
\end{fortranspecific}

\binding
The binding task set for an \code{omp_is_initial_device} region is the generating task.

\effect
The effect of this routine is to return \plc{true} if the current task is executing on the host
device; otherwise, it returns \plc{false}.

\crossreferences
\begin{itemize}


\item \code{omp_get_get_initial_device} routine, see
\specref{subsec:omp_get_initial_device}.

\item Device memory routines, see \specref{sec:Device Memory Routines}.
\end{itemize}





\subsection{\hcode{omp_get_initial_device}}
\index{omp_get_initial_device@{\code{omp_get_initial_device}}}
\label{subsec:omp_get_initial_device}
\summary
The \code{omp_get_initial_device} routine returns a device number representing
the host device.

\begin{samepage}
\format
\begin{ccppspecific}
\begin{ompcFunction}
int omp_get_initial_device(void);
\end{ompcFunction}
\end{ccppspecific}
\end{samepage}

\begin{fortranspecific}
\begin{ompfFunction}
integer function omp_get_initial_device()
\end{ompfFunction}
\end{fortranspecific}

\binding
The binding task set for an \code{omp_get_initial_device} region is the generating task.

\effect
The effect of this routine is to return the device number of the host device.
The value of the device number is implementation defined. If it is between 0
and one less than \code{omp_get_num_devices()} then it is valid for use
with all device constructs and routines; if it is outside that range, then
it is only valid for use with the device memory routines and not in the
\code{device} clause. When called from within a \code{target} region
the effect of this routine is unspecified.

\crossreferences
\begin{itemize}

\item \code{omp_is_initial_device} routine, see
\specref{subsec:omp_is_initial_device}.

\item Device memory routines, see \specref{sec:Device Memory Routines}.
\end{itemize}




\subsection{\hcode{omp_get_max_task_priority}}
\index{omp_get_max_task_priority@{\code{omp_get_max_task_priority}}}
\label{subsec:omp_get_max_task_priority}
\summary

The \code{omp_get_max_task_priority} routine returns the maximum value that can be
specified in the \code{priority} clause.

\begin{samepage}
\format
\begin{ccppspecific}
\begin{ompcFunction}
int omp_get_max_task_priority(void);
\end{ompcFunction}
\end{ccppspecific}
\end{samepage}

\begin{fortranspecific}
\begin{ompfFunction}
integer function omp_get_max_task_priority()
\end{ompfFunction}
\end{fortranspecific}

\binding

The binding thread set for an \code{omp_get_max_task_priority} region is all threads
on the device. The effect of executing this routine is not related to any specific region
corresponding to any construct or API routine.

\effect

The \code{omp_get_max_task_priority} routine returns the value of the \plc{max-task-priority-var}
ICV, which determines the maximum value that can be specified in the \code{priority} clause.

\crossreferences

\begin{itemize}
\item \plc{max-task-priority-var}, see
\specref{sec:Internal Control Variables}.

\item \code{task} construct, see
\specref{subsec:task Construct}.
\end{itemize}




\subsection{\hcode{omp_pause_resource}}
\index{omp_pause_resource@{\code{omp_pause_resource}}}
\label{subsec:omp_pause_resource}
\summary

The \code{omp_pause_resource} routine allows the runtime to 
relinquish resources used by OpenMP on the specified device.

\begin{samepage}
\format
\begin{ccppspecific}
\begin{ompcFunction}
int omp_pause_resource(
  omp_pause_resource_t kind,
  int device_num
);
\end{ompcFunction}
\end{ccppspecific}
\end{samepage}

\begin{fortranspecific}
\begin{ompfFunction}
integer function omp_pause_resource(kind, device_num)
integer (kind=omp_pause_resource_kind) kind
integer device_num
\end{ompfFunction}
\end{fortranspecific}

\constraints

The first argument passed to this routine can be one of the valid OpenMP pause kind, 
or any implementation specific pause kind. The C/C++ header file
(\code{omp.h}) and the Fortran include file (\code{omp_lib.h}) and/or Fortran~90 module file
(\code{omp_lib}) define the valid constants. 
The valid constants must include the following, which can be extended with implementation 
specific values:

\begin{samepage}
\format
\begin{ccppspecific}
\begin{ompcFunction}
typedef enum omp_pause_resource_t {
  omp_pause_soft = 1,
  omp_pause_hard = 2
} omp_pause_resource_t;
\end{ompcFunction}
\end{ccppspecific}
\end{samepage}

\begin{fortranspecific}
\begin{ompfFunction}
integer (kind=omp_pause_resource_kind), parameter :: &
  omp_pause_soft = 1
integer (kind=omp_pause_resource_kind), parameter :: &
  omp_pause_hard = 2
\end{ompfFunction}
\end{fortranspecific}

The second argument passed to this routine indicates which device is paused. 
The \code{device_num} parameter must be greater than or equal to zero and 
less than the result of \code{omp_get_num_devices()}
or equal to the result of a call to \code{omp_get_initial_device()}.

\binding

The binding task set for an \code{omp_pause_resource} region is the whole program.

\effect

The \code{omp_pause_resource} routine allows the runtime to relinquish resources 
used by OpenMP on the specified device.

If successful, the \code{omp_pause_hard} value results in a hard pause for which the OpenMP state is not guaranteed to 
persist across the \code{omp_pause_resource} call. Hard pause may relinquish any 
data allocated by OpenMP on a given device, including data allocated by memory routines 
for that device as well as data present on the device as a result of a \code{declare target} or \code{target data} construct.
Hard pause may also relinquish any data associated with a \code{threadprivate} directive.
When relinquished and when applicable, base language appropriate deallocation/finalization is performed. 
When relinquished and when applicable, mapped data on a device will not be copied back from the device to the host.

If successful, the \code{omp_pause_soft} value results in a soft pause for which the OpenMP state 
is guaranteed to persist across the call, with the exception of any data associated with a
 \code{threadprivate} directive which may be relinquished across the call. 
When relinquished and when applicable, base language appropriate deallocation/finalization is performed. 

\begin{note}
Hard pause may relinquish more resources, but may resume processing OpenMP regions more slowly. 
Soft pause allows OpenMP regions to restart more quickly, but may relinquish fewer resources. 
An OpenMP implementation will reclaim resources as needed for OpenMP regions encountered after the pause region. 
Since  a hard pause may unmap data on the specified device, appropriate data mapping is required before 
using data on the specified device after the pause region.
 \end{note}
 
The routine returns zero in case of success, and nonzero otherwise.

\tools

If the tool is not allowed to interact with the specified device after encountering this call, then the runtime must call
the tool finalizer for that device.

\restrictions
The \code{omp_pause_resource} routine has the following restriction:

\begin{itemize}
\item The routine may only be called in the sequential part and when there are no pending 
task waiting for execution. Calling in any other circumstances may result in unspecified behavior.
\end{itemize}

\crossreferences

\begin{itemize}

\item \code{target} construct, see
\specref{subsec:target Construct}

\item \code{declare target} directive, see
\specref{subsec:declare target Directive}

\item \code{omp_get_num_devices}, see
\specref{subsec:omp_get_num_devices}.

\item \code{omp_get_get_initial_device} routine, see
\specref{subsec:omp_get_initial_device}.

\item \code{threadprivate} directives, see
\specref{subsec:threadprivate Directive}.

\item To pause resources on all devices at once, see
\specref{subsec:omp_pause_resource_all}.
\end{itemize}

\subsection{\hcode{omp_pause_resource_all}}
\index{omp_pause_resource_all@{\code{omp_pause_resource_all}}}
\label{subsec:omp_pause_resource_all}
\summary

The \code{omp_pause_resource_all} routine allows the runtime to 
relinquish resources used by OpenMP on all devices.

\begin{samepage}
\format
\begin{ccppspecific}
\begin{ompcFunction}
int omp_pause_resource_all(omp_pause_resource_t kind);
\end{ompcFunction}
\end{ccppspecific}
\end{samepage}

\begin{fortranspecific}
\begin{ompfFunction}
integer function omp_pause_resource_all(kind)
integer (kind=omp_pause_resource_kind) kind
\end{ompfFunction}
\end{fortranspecific}

\binding

The binding task set for an \code{omp_pause_resource_all} region is the whole program.

\effect

The \code{omp_pause_resource_all} routine allows the runtime to relinquish resources 
used by OpenMP on all devices. It is equivalent to repetitively 
calling the \code{omp_pause_resource} for all of the available devices, including the host device.

The argument \code{kind} passed to this routine can be one of the valid OpenMP pause kind 
as defined in \specref{subsec:omp_pause_resource}, or any implementation specific pause kind.

\tools

If the tool is not allowed to interact with a given device after encountering this call, then the runtime must call
the tool finalizer for that device.

\restrictions
The \code{omp_pause_resource_all}  routine has the following restriction:

\begin{itemize}
\item The routine may only be called in the sequential part and there are no pending task waiting for execution. Calling in any other circumstances may result in unspecified behavior.
\end{itemize}

\crossreferences

\begin{itemize}

\item \code{target} construct, see
\specref{subsec:target Construct}

\item \code{declare target} directive, see
\specref{subsec:declare target Directive}

\item \code{omp_get_num_devices}, see
\specref{subsec:omp_get_num_devices}.

\item \code{omp_get_get_initial_device} routine, see
\specref{subsec:omp_get_initial_device}.

\item To pause resources on a specific device only, see
\specref{subsec:omp_pause_resource}.
\end{itemize}



