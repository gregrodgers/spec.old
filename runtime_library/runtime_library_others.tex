% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. There are environments that provide special formatting, e.g. language bars.
%       Please use them whereever appropriate.  Examples are:
%
%         \begin{fortranspecific}
%         This is text that appears enclosed in blue language bars for Fortran.
%         \end{fortranspecific}
%
%         \begin{note}
%         This is a note.  The "Note -- " header appears automatically.
%         \end{note}
%
%    6. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of 
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%


\section{Lock Routines}
\index{lock routines}
\label{sec:Lock Routines}

\vspace{-8pt}

The OpenMP runtime library includes a set of general-purpose lock routines that can be 
used for synchronization. These general-purpose lock routines operate on OpenMP locks 
that are represented by OpenMP lock variables. OpenMP lock variables must be 
accessed only through the routines described in this section; programs that otherwise 
access OpenMP lock variables are non-conforming.

An OpenMP lock can be in one of the following states: \emph{uninitialized}, \emph{unlocked}, or 
\emph{locked}. If a lock is in the \emph{unlocked} state, a task can \emph{set} the lock, which changes its state 
to \emph{locked}. The task that sets the lock is then said to \emph{own} the lock. A task that owns a 
lock can \emph{unset} that lock, returning it to the \emph{unlocked} state. A program in which a task 
unsets a lock that is owned by another task is non-conforming.

Two types of locks are supported: \emph{simple locks} and \emph{nestable locks}. A \emph{nestable lock} can 
be set multiple times by the same task before being unset; a \emph{simple lock} cannot be set if 
it is already owned by the task trying to set it. \emph{Simple lock} variables are associated with 
\emph{simple locks} and can only be passed to \emph{simple lock} routines. \emph{Nestable lock} variables are 
associated with \emph{nestable locks} and can only be passed to \emph{nestable lock} routines.

Each type of lock can also have a \emph{synchronization hint} that contains information about the intended usage 
of the lock by the application code.  The effect of the hint is
implementation defined.  An OpenMP implementation can use this hint to select a
usage-specific lock, but hints do not change the mutual exclusion semantics of locks. 
A conforming implementation can safely ignore the hint.

Constraints on the state and ownership of the lock accessed by each of the lock routines 
are described with the routine. If these constraints are not met, the behavior of the 
routine is unspecified. 

The OpenMP lock routines access a lock variable such that they always read 
and update the most current value of the lock variable. It is not necessary for an 
OpenMP program to include explicit \code{flush} directives to ensure that the lock variable's 
value is consistent among different tasks. 

\vspace{-8pt}

\binding
The binding thread set for all lock routine regions is all threads in the contention group. 
As a consequence, for each OpenMP lock, the lock routine effects relate to all tasks that 
call the routines, without regard to which teams the threads in the contention group 
executing the tasks belong.


\vspace{-8pt}

\littleheader{Simple Lock Routines}
\index{Simple Lock Routines}
\begin{ccppspecific}
The type \code{omp\_lock\_t} represents a simple lock. For the 
following routines, a simple lock variable must be of \code{omp\_lock\_t} type. All simple 
lock routines require an argument that is a pointer to a variable of type \code{omp\_lock\_t}.
\end{ccppspecific}

\begin{fortranspecific}
For the following routines, a simple lock variable must be an integer variable of 
\code{kind=omp\_lock\_kind}.
\end{fortranspecific}

The simple lock routines are as follows:

\begin{itemize}
\item The \code{omp\_init\_lock} routine initializes a simple lock.

\item The \code{omp\_init\_lock\_with\_hint} routine initializes a simple lock and attaches a hint to it.

\item The \code{omp\_destroy\_lock} routine uninitializes a simple lock.

\item The \code{omp\_set\_lock} routine waits until a simple lock is available, and then sets it.

\item The \code{omp\_unset\_lock} routine unsets a simple lock.

\item The \code{omp\_test\_lock} routine tests a simple lock, and sets it if it is available.
\end{itemize}

\littleheader{Nestable Lock Routines}
\begin{ccppspecific}
The type \code{omp\_nest\_lock\_t} represents a nestable lock. 
For the following routines, a nestable lock variable must be of \code{omp\_nest\_lock\_t} type. 
All nestable lock routines require an argument that is a pointer to a variable of type 
\code{omp\_nest\_lock\_t}.
\end{ccppspecific}

\begin{fortranspecific}
For the following routines, a nestable lock variable must be an integer variable of 
\code{kind=omp\_nest\_lock\_kind}.
\end{fortranspecific}

The nestable lock routines are as follows:

\begin{itemize}
\item The \code{omp\_init\_nest\_lock} routine initializes a nestable lock.

\item The \code{omp\_init\_nest\_lock\_with\_hint} routine initializes a nestable lock and attaches a hint to it.

\item The \code{omp\_destroy\_nest\_lock} routine uninitializes a nestable lock.

\item The \code{omp\_set\_nest\_lock} routine waits until a nestable lock is available, and then 
sets it.

\item The \code{omp\_unset\_nest\_lock} routine unsets a nestable lock.

\item The \code{omp\_test\_nest\_lock} routine tests a nestable lock, and sets it if it is 
available
\end{itemize}

\restrictions
OpenMP lock routines have the following restrictions:

\begin{itemize}
\item The use of the same OpenMP lock in different contention groups results in 
unspecified behavior. 
\end{itemize}










\subsection{\code{omp\_init\_lock} and \code{omp\_init\_nest\_lock}}
\label{subsec:omp_init_lock and omp_init_nest_lock}
\index{omp\_init\_lock@{\code{omp\_init\_lock}}}
\index{omp\_init\_nest\_lock@{\code{omp\_init\_nest\_lock}}}
\summary
These routines initialize an OpenMP lock without a hint.

\format
\begin{ccppspecific}
\begin{boxedcode}
void omp\_init\_lock(omp\_lock\_t *\plc{lock});
void omp\_init\_nest\_lock(omp\_nest\_lock\_t *\plc{lock});
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
subroutine omp\_init\_lock(\plc{svar})
integer (kind=omp\_lock\_kind) \plc{svar}

subroutine omp\_init\_nest\_lock(\plc{nvar})
integer (kind=omp\_nest\_lock\_kind) \plc{nvar}
\end{boxedcode}
\end{fortranspecific}

\constraints
A program that accesses a lock that is not in the uninitialized state through either routine 
is non-conforming.

\effect
The effect of these routines is to initialize the lock to the unlocked state; that is, no task 
owns the lock. In addition, the nesting count for a nestable lock is set to zero.

\events

The \plc{lock-init} or \plc{nest-lock-init} event occurs in the thread 
executing a \code{omp\_init\_lock} or \code{omp\_init\_nest\_lock} region
after initialization of the lock, but before finishing the region.

\tools

A thread dispatches a registered \code{ompt\_callback\_lock\_init}
callback for each occurrence of a \plc{lock-init} or \plc{nest-lock-init} event 
in that thread.  This callback has the type signature \code{ompt\_callback\_mutex\_acquire\_t}.
The callbacks occur in the task encountering the routine.
The callback receives \code{omp\_sync\_hint\_none} as
\plc{hint} argument and
\code{ompt\_mutex\_lock} or 
 \code{ompt\_mutex\_nest\_lock} as \plc{kind} argument as appropriate.

\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_mutex\_acquire\_t}, see
\specref{sec:ompt_callback_mutex_acquire_t}.
\end{itemize}











\subsection[\code{omp\_init\_lock\_with\_hint} and \\
\code{omp\_init\_nest\_lock\_with\_hint}]{\code{omp\_init\_lock\_with\_hint} and \\
\code{omp\_init\_nest\_lock\_with\_hint}}
\label{subsec:omp_init_lock_with_hint and omp_init_nest_lock_with_hint}
\index{omp\_init\_lock@{\code{omp\_init\_lock}}}
\index{omp\_init\_nest\_lock@{\code{omp\_init\_nest\_lock}}}
\summary
These routines initialize an OpenMP lock with a hint.  
The effect of the hint is implementation-defined. The OpenMP implementation
can ignore the hint without changing program semantics.


\format
\begin{ccppspecific}
\begin{boxedcode}
void omp\_init\_lock\_with\_hint(omp\_lock\_t *\plc{lock}, 
                             omp\_sync\_hint\_t \plc{hint});
void omp\_init\_nest\_lock\_with\_hint(omp\_nest\_lock\_t *\plc{lock}, 
                                  omp\_sync\_hint\_t \plc{hint});
\end{boxedcode}
\end{ccppspecific}

\newpage %% HACK
\begin{fortranspecific}
\begin{boxedcode}
subroutine omp\_init\_lock\_with\_hint(\plc{svar}, \plc{hint})
integer (kind=omp\_lock\_kind) \plc{svar}
integer (kind=omp\_sync\_hint\_kind) \plc{hint}

subroutine omp\_init\_nest\_lock\_with\_hint(\plc{nvar}, \plc{hint})
integer (kind=omp\_nest\_lock\_kind) \plc{nvar}
integer (kind=omp\_sync\_hint\_kind) \plc{hint}
\end{boxedcode}
\end{fortranspecific}

\constraints
A program that accesses a lock that is not in the uninitialized state through either routine 
is non-conforming.

The second argument passed to these routines (\plc{hint}) is a hint 
as described in \specref{subsec:Synchronization Hints}.

\effect
The effect of these routines is to initialize the lock to the unlocked state and, optionally, to choose a specific lock implementation based on the hint. 
After initialization no task owns the lock. In addition, the nesting count for a nestable lock is set to zero.

\events

The \plc{lock-init} or \plc{nest-lock-init} event occurs in the thread 
executing a \code{omp\_init\_lock\_with\_hint} or \code{omp\_init\_nest\_lock\_with\_hint} region
after initialization of the lock, but before finishing the region.

\tools

A thread dispatches a registered \code{ompt\_callback\_lock\_init}
callback for each occurrence of a \plc{lock-init} or \plc{nest-lock-init} event 
in that thread.  This callback has the type signature \code{ompt\_callback\_mutex\_acquire\_t}.
The callbacks occur in the task encountering the routine. 
The callback receives the function's \plc{hint} argument as
\plc{hint} argument and
\code{ompt\_mutex\_lock} or 
 \code{ompt\_mutex\_nest\_lock} as \plc{kind} argument as appropriate.

\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_mutex\_acquire\_t}, see
\specref{sec:ompt_callback_mutex_acquire_t}.
\item Synchronization Hints, see \specref{subsec:Synchronization Hints}.
\end{itemize}



\subsection[\code{omp\_destroy\_lock} and \code{omp\_destroy\_nest\_lock}]{\code{omp\_destroy\_lock} and\\ \code{omp\_destroy\_nest\_lock}}
\label{subsec:omp_destroy_lock and omp_destroy_nest_lock}
\index{omp\_destroy\_lock@{\code{omp\_destroy\_lock}}}
\index{omp\_destroy\_nest\_lock@{\code{omp\_destroy\_nest\_lock}}}
\summary
These routines ensure that the OpenMP lock is uninitialized.

\format
\begin{ccppspecific}
\begin{boxedcode}
void omp\_destroy\_lock(omp\_lock\_t *\plc{lock});
void omp\_destroy\_nest\_lock(omp\_nest\_lock\_t *\plc{lock});
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
subroutine omp\_destroy\_lock(\plc{svar})
integer (kind=omp\_lock\_kind) \plc{svar}

subroutine omp\_destroy\_nest\_lock(\plc{nvar})
integer (kind=omp\_nest\_lock\_kind) \plc{nvar}
\end{boxedcode}
\end{fortranspecific}

\constraints
A program that accesses a lock that is not in the unlocked state through either routine is 
non-conforming.

\effect
The effect of these routines is to change the state of the lock to uninitialized.

\events

The \plc{lock-destroy} or \plc{nest-lock-destroy} event occurs in the thread 
executing a \code{omp\_destroy\_lock} or \code{omp\_destroy\_nest\_lock} region
before finishing the region.

\tools

A thread dispatches a registered \code{ompt\_callback\_lock\_destroy}
callback for each occurrence of a \plc{lock-destroy} or \plc{nest-lock-destroy} event 
in that thread.  This callback has the type signature \code{ompt\_callback\_mutex\_t}.
The callbacks occur in the task encountering the routine.
The callbacks receive \code{ompt\_mutex\_lock} or 
 \code{ompt\_mutex\_nest\_lock} as their \plc{kind} argument as appropriate.


\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_mutex\_t}, see 
\specref{sec:ompt_callback_mutex_t}.
\end{itemize}









\subsection{\code{omp\_set\_lock} and \code{omp\_set\_nest\_lock}}
\label{subsec:omp_set_lock and omp_set_nest_lock}
\index{omp\_set\_lock@{\code{omp\_set\_lock}}}
\index{omp\_set\_nest\_lock@{\code{omp\_set\_nest\_lock}}}
\summary
These routines provide a means of setting an OpenMP lock. The calling
task region behaves as if it was suspended until the lock can be set
by this task.

\format
\begin{ccppspecific}
\begin{boxedcode}
void omp\_set\_lock(omp\_lock\_t *\plc{lock});
void omp\_set\_nest\_lock(omp\_nest\_lock\_t *\plc{lock});
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
subroutine omp\_set\_lock(\plc{svar})
integer (kind=omp\_lock\_kind) \plc{svar}

subroutine omp\_set\_nest\_lock(\plc{nvar})
integer (kind=omp\_nest\_lock\_kind) \plc{nvar}
\end{boxedcode}
\end{fortranspecific}

\constraints
A program that accesses a lock that is in the uninitialized state through either routine is 
non-conforming. A simple lock accessed by \code{omp\_set\_lock} that is in the locked state 
must not be owned by the task that contains the call or deadlock will result.

\effect
Each of these routines has an effect equivalent to suspension of the task
executing the routine until the specified lock is available. 

% However, the
% task region may continue to execute speculatively, provided that the 
% implementation ensures that execution is as if the lock were owned
% exclusively by one thread. 

% A note because it's only explanatory. The as-ifness already allows
% this via the ``equivalent to''
\begin{note} The semantics of these routines is specified
\emph{as if} they serialize execution of the region guarded by the
lock. However, implementations may implement them in other ways
provided that the isolation properties are respected so that the
actual execution delivers a result that could arise from some
serialization. 
\end{note}

A simple lock is available if it is unlocked. Ownership of the lock is 
granted to the task executing the routine.

A nestable lock is available if it is unlocked or if it is already owned by 
the task executing the routine. The task executing the routine is granted, 
or retains, ownership of the lock, and the nesting count for the lock is 
incremented.

\events

The \plc{lock-acquire} or \plc{nest-lock-acquire} event occurs in the thread 
executing a \code{omp\_set\_lock} or \code{omp\_set\_nest\_lock} region
before the associated lock is requested.

The \plc{lock-acquired} or \plc{nest-lock-acquired} event occurs in the thread 
executing a \code{omp\_set\_lock} or \code{omp\_set\_nest\_lock} region
after acquiring the associated lock, if the thread did not already own the lock, 
but before finishing the region.

The \plc{nest-lock-owned} event occurs in the thread 
executing a \code{omp\_set\_nest\_lock} region
when the thread already owned the lock, 
before finishing the region.


\tools

A thread dispatches a registered \code{ompt\_callback\_mutex\_acquire}
callback for each occurrence of a \plc{lock-acquire} or \plc{nest-lock-acquire} event 
in that thread.  This callback has the type signature \code{ompt\_callback\_mutex\_acquire\_t}.

A thread dispatches a registered \code{ompt\_callback\_mutex\_acquired}
callback for each occurrence of a \plc{lock-acquired} or \plc{nest-lock-acquired} event 
in that thread.  This callback has the type signature \code{ompt\_callback\_mutex\_t}.

A thread dispatches a registered \code{ompt\_callback\_nest\_lock}
callback for each occurrence of a \plc{nest-lock-owned} event 
in that thread. This callback has the type signature \code{ompt\_callback\_nest\_lock\_t}.
The callback receives \code{ompt\_scope\_begin} as its \plc{endpoint} argument.

The callbacks occur in the task encountering
the lock function.  The callbacks receive \code{ompt\_mutex\_lock} or 
 \code{ompt\_mutex\_nest\_lock} as their \plc{kind} argument, as appropriate.


\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_mutex\_acquire\_t}, see 
\specref{sec:ompt_callback_mutex_acquire_t}.
\item \code{ompt\_callback\_mutex\_t}, see 
\specref{sec:ompt_callback_mutex_t}.
\item \code{ompt\_callback\_nest\_lock\_t}, see
\specref{sec:ompt_callback_nest_lock_t}.
\end{itemize}




\subsection{\code{omp\_unset\_lock} and \code{omp\_unset\_nest\_lock}}
\label{subsec:omp_unset_lock and omp_unset_nest_lock}
\index{omp\_unset\_lock@{\code{omp\_unset\_lock}}}
\index{omp\_unset\_nest\_lock@{\code{omp\_unset\_nest\_lock}}}
\summary
These routines provide the means of unsetting an OpenMP lock.

\format
\begin{ccppspecific}
\begin{boxedcode}
void omp\_unset\_lock(omp\_lock\_t *\plc{lock});
void omp\_unset\_nest\_lock(omp\_nest\_lock\_t *\plc{lock});
\end{boxedcode}
\end{ccppspecific}

\newpage %% HACK
\begin{fortranspecific}
\begin{boxedcode}
subroutine omp\_unset\_lock(\plc{svar})
integer (kind=omp\_lock\_kind) \plc{svar}

subroutine omp\_unset\_nest\_lock(\plc{nvar})
integer (kind=omp\_nest\_lock\_kind) \plc{nvar}
\end{boxedcode}
\end{fortranspecific}

\constraints
A program that accesses a lock that is not in the locked state or that is 
not owned by the task that contains the call through either routine is 
non-conforming.

% Jim Cownie: I don't believe we need anything more about speculation
% here. It has to behave ``as-if'' it held the lock, and released it
% here, and that's what we say happens.

\effect
For a simple lock, the \code{omp\_unset\_lock} routine causes the lock to become unlocked.

For a nestable lock, the \code{omp\_unset\_nest\_lock} routine decrements the nesting 
count, and causes the lock to become unlocked if the resulting nesting count is zero.

For either routine, if the lock becomes unlocked, and if one or more task 
regions were effectively suspended because the lock was unavailable, the 
effect is that one task is chosen and given ownership of the lock. 

\events

The \plc{lock-release} or \plc{nest-lock-release} event occurs in the thread 
executing a \code{omp\_unset\_lock} or \code{omp\_unset\_nest\_lock} region
after releasing the associated lock, but before finishing the region.

The \plc{nest-lock-held} event occurs in the thread 
executing a \code{omp\_unset\_nest\_lock} region
when the thread still owns the lock, 
before finishing the region.


\tools

A thread dispatches a registered \code{ompt\_callback\_mutex\_released}
callback for each occurrence of a \plc{lock-release} or \plc{nest-lock-release} event 
in that thread.  This callback has the type signature \code{ompt\_callback\_mutex\_t}.
The callback occurs in the task encountering
the routine. The callback receives \code{ompt\_mutex\_lock} or 
 \code{ompt\_mutex\_nest\_lock} as \plc{kind} argument as appropriate.

A thread dispatches a registered \code{ompt\_callback\_nest\_lock}
callback for each occurrence of a \plc{nest-lock-held} event 
in that thread. This callback has the type signature \code{ompt\_callback\_nest\_lock\_t}.
The callback receives \code{ompt\_scope\_end} as its \plc{endpoint} argument.

\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_mutex\_t}, see
\specref{sec:ompt_callback_mutex_t}.
\item \code{ompt\_callback\_nest\_lock\_t}, see
\specref{sec:ompt_callback_nest_lock_t}.
\end{itemize}








\subsection{\code{omp\_test\_lock} and \code{omp\_test\_nest\_lock}}
\label{subsec:omp_test_lock and omp_test_nest_lock}
\index{omp\_test\_lock@{\code{omp\_test\_lock}}}
\index{omp\_test\_nest\_lock@{\code{omp\_test\_nest\_lock}}}
\summary
These routines attempt to set an OpenMP lock but do not suspend execution of the task 
executing the routine.

\format
\begin{ccppspecific}
\begin{boxedcode}
int omp\_test\_lock(omp\_lock\_t *\plc{lock});
int omp\_test\_nest\_lock(omp\_nest\_lock\_t *\plc{lock});
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
logical function omp\_test\_lock(\plc{svar})
integer (kind=omp\_lock\_kind) \plc{svar}
integer function omp\_test\_nest\_lock(\plc{nvar})
integer (kind=omp\_nest\_lock\_kind) \plc{nvar}
\end{boxedcode}
\end{fortranspecific}

\constraints
A program that accesses a lock that is in the uninitialized state through either routine is 
non-conforming. The behavior is unspecified if a simple lock accessed by 
\code{omp\_test\_lock} is in the locked state and is owned by the task that contains the call.

\effect 
These routines attempt to set a lock in the same manner as \code{omp\_set\_lock} and 
\code{omp\_set\_nest\_lock}, except that they do not suspend execution of the task 
executing the routine.

For a simple lock, the \code{omp\_test\_lock} routine returns \plc{true} if the lock is successfully 
set; otherwise, it returns \plc{false}.

For a nestable lock, the \code{omp\_test\_nest\_lock} routine returns the new nesting count 
if the lock is successfully set; otherwise, it returns zero.

\events

The \plc{lock-test} or \plc{nest-lock-test} event occurs in the thread 
executing a \code{omp\_test\_lock} or \code{omp\_test\_nest\_lock} region
before the associated lock is tested.

The \plc{lock-test-acquired} or \plc{nest-lock-test-acquired} event occurs in the thread 
executing a \code{omp\_test\_lock} or \code{omp\_test\_nest\_lock} region
before finishing the region if the associated lock was acquired and the thread did not already own the lock. 

The \plc{nest-lock-owned} event occurs in the thread 
executing a \code{omp\_test\_nest\_lock} region
if the thread already owned the lock, 
before finishing the region.


\tools

A thread dispatches a registered \code{ompt\_callback\_mutex\_acquire}
callback for each occurrence of a \plc{lock-test} or \plc{nest-lock-test} event 
in that thread.  This callback has the type signature \code{ompt\_callback\_mutex\_acquire\_t}.

A thread dispatches a registered \code{ompt\_callback\_mutex\_acquired}
callback for each occurrence of a \plc{lock-test-acquired} or \plc{nest-lock-test-acquired} event 
in that thread.  This callback has the type signature \code{ompt\_callback\_mutex\_t}.

A thread dispatches a registered \code{ompt\_callback\_nest\_lock}
callback for each occurrence of a \plc{nest-lock-owned} event 
in that thread. This callback has the type signature \code{ompt\_callback\_nest\_lock\_t}.
The callback receives \code{ompt\_scope\_begin} as its \plc{endpoint} argument.

The callbacks occur in the task encountering
the lock function.  The callbacks receive \code{ompt\_mutex\_lock} or 
 \code{ompt\_mutex\_nest\_lock} as their \plc{kind} argument, as appropriate.


\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_mutex\_acquire\_t}, see 
\specref{sec:ompt_callback_mutex_acquire_t}.
\item \code{ompt\_callback\_mutex\_t}, see 
\specref{sec:ompt_callback_mutex_t}.
\item \code{ompt\_callback\_nest\_lock\_t}, see
\specref{sec:ompt_callback_nest_lock_t}.
\end{itemize}









\section{Timing Routines}
\index{timing routines}
\index{timer}
\index{wall clock timer}
\label{sec:Timing Routines}
This section describes routines that support a portable wall clock timer.

\vspace{-12pt}









\subsection{\code{omp\_get\_wtime}}
\index{omp\_get\_wtime@{\code{omp\_get\_wtime}}}
\label{subsec:omp_get_wtime}
\summary
The \code{omp\_get\_wtime} routine returns elapsed wall clock time in seconds.

\format
\begin{ccppspecific}
\begin{boxedcode}
double omp\_get\_wtime(void);
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
double precision function omp\_get\_wtime()
\end{boxedcode}
\end{fortranspecific}

\binding
The binding thread set for an \code{omp\_get\_wtime} region is the encountering thread. The 
routine's return value is not guaranteed to be consistent across any set of threads.

\effect
The \code{omp\_get\_wtime} routine returns a value equal to the elapsed wall clock time in 
seconds since some ``time in the past''. The actual ``time in the past'' is arbitrary, but it is 
guaranteed not to change during the execution of the application program. The time 
returned is a ``per-thread time'', so it is not required to be globally consistent across all 
threads participating in an application.

\begin{note}
It is anticipated that the routine will be used to measure elapsed times as shown 
in the following example:

\begin{ccppspecific}
\begin{boxedcode}
double start;
double end;
start = omp\_get\_wtime();
\plc{... work to be timed ...}
end = omp\_get\_wtime();
printf("Work took \%f seconds{\textbackslash}n", end - start);
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
DOUBLE PRECISION START, END
START = omp\_get\_wtime()
\plc{... work to be timed ...}
END = omp\_get\_wtime()
PRINT *, "Work took", END - START, "seconds"
\end{boxedcode}
\end{fortranspecific}
\end{note}









\subsection{\code{omp\_get\_wtick}}
\index{omp\_get\_wtick@{\code{omp\_get\_wtick}}}
\label{subsec:omp_get_wtick}
\summary
The \code{omp\_get\_wtick} routine returns the precision of the timer used by 
\code{omp\_get\_wtime}.

\newpage %% HACK
\format
\begin{ccppspecific}
\begin{boxedcode}
double omp\_get\_wtick(void);
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
double precision function omp\_get\_wtick()
\end{boxedcode}
\end{fortranspecific}

\binding
The binding thread set for an \code{omp\_get\_wtick} region is the encountering thread. The 
routine's return value is not guaranteed to be consistent across any set of threads.

\effect
The \code{omp\_get\_wtick} routine returns a value equal to the number of seconds between 
successive clock ticks of the timer used by \code{omp\_get\_wtime}.

