% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. There are environments that provide special formatting, e.g. language bars.
%       Please use them whereever appropriate.  Examples are:
%
%         \begin{fortranspecific}
%         This is text that appears enclosed in blue language bars for Fortran.
%         \end{fortranspecific}
%
%         \begin{note}
%         This is a note.  The "Note -- " header appears automatically.
%         \end{note}
%
%    6. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of 
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%


\section{Lock Routines}
\index{lock routines}
\label{sec:Lock Routines}

\vspace{-8pt}

The OpenMP runtime library includes a set of general-purpose lock routines that can be 
used for synchronization. These general-purpose lock routines operate on OpenMP locks 
that are represented by OpenMP lock variables. OpenMP lock variables must be 
accessed only through the routines described in this section; programs that otherwise 
access OpenMP lock variables are non-conforming.

An OpenMP lock can be in one of the following states: \emph{uninitialized}, \emph{unlocked}, or 
\emph{locked}. If a lock is in the \emph{unlocked} state, a task can \emph{set} the lock, which changes its state 
to \emph{locked}. The task that sets the lock is then said to \emph{own} the lock. A task that owns a 
lock can \emph{unset} that lock, returning it to the \emph{unlocked} state. A program in which a task 
unsets a lock that is owned by another task is non-conforming.

Two types of locks are supported: \emph{simple locks} and \emph{nestable locks}. A \emph{nestable lock} can 
be set multiple times by the same task before being unset; a \emph{simple lock} cannot be set if 
it is already owned by the task trying to set it. \emph{Simple lock} variables are associated with 
\emph{simple locks} and can only be passed to \emph{simple lock} routines. \emph{Nestable lock} variables are 
associated with \emph{nestable locks} and can only be passed to \emph{nestable lock} routines.

Each type of lock can also have a \emph{lock hint} that contains information about the intended usage 
of the lock by the application code.  The effect of the lock hint is
implementation defined.  An OpenMP implementation can use this hint to select a
usage-specific lock, but lock hints do not change the mutual exclusion semantics of locks. 
A conforming implementation can safely ignore the lock hint.

Constraints on the state and ownership of the lock accessed by each of the lock routines 
are described with the routine. If these constraints are not met, the behavior of the 
routine is unspecified. 

The OpenMP lock routines access a lock variable such that they always read 
and update the most current value of the lock variable. It is not necessary for an 
OpenMP program to include explicit \code{flush} directives to ensure that the lock variable's 
value is consistent among different tasks. 

\vspace{-8pt}

\binding
The binding thread set for all lock routine regions is all threads in the contention group. 
As a consequence, for each OpenMP lock, the lock routine effects relate to all tasks that 
call the routines, without regard to which teams the threads in the contention group 
executing the tasks belong.


\vspace{-8pt}

\littleheader{Simple Lock Routines}
\index{Simple Lock Routines}
\begin{ccppspecific}
The type \code{omp\_lock\_t} represents a simple lock. For the 
following routines, a simple lock variable must be of \code{omp\_lock\_t} type. All simple 
lock routines require an argument that is a pointer to a variable of type \code{omp\_lock\_t}.
\end{ccppspecific}

\begin{fortranspecific}
For the following routines, a simple lock variable must be an integer variable of 
\code{kind=omp\_lock\_kind}.
\end{fortranspecific}

The simple lock routines are as follows:

\begin{itemize}
\item The \code{omp\_init\_lock} routine initializes a simple lock.

\item The \code{omp\_init\_lock\_with\_hint} routine initializes a simple lock and attaches a hint to it.

\item The \code{omp\_destroy\_lock} routine uninitializes a simple lock.

\item The \code{omp\_set\_lock} routine waits until a simple lock is available, and then sets it.

\item The \code{omp\_unset\_lock} routine unsets a simple lock.

\item The \code{omp\_test\_lock} routine tests a simple lock, and sets it if it is available.
\end{itemize}

\littleheader{Nestable Lock Routines}
\begin{ccppspecific}
The type \code{omp\_nest\_lock\_t} represents a nestable lock. 
For the following routines, a nestable lock variable must be of \code{omp\_nest\_lock\_t} type. 
All nestable lock routines require an argument that is a pointer to a variable of type 
\code{omp\_nest\_lock\_t}.
\end{ccppspecific}

\begin{fortranspecific}
For the following routines, a nestable lock variable must be an integer variable of 
\code{kind=omp\_nest\_lock\_kind}.
\end{fortranspecific}

The nestable lock routines are as follows:

\begin{itemize}
\item The \code{omp\_init\_nest\_lock} routine initializes a nestable lock.

\item The \code{omp\_init\_nest\_lock\_with\_hint} routine initializes a nestable lock and attaches a hint to it.

\item The \code{omp\_destroy\_nest\_lock} routine uninitializes a nestable lock.

\item The \code{omp\_set\_nest\_lock} routine waits until a nestable lock is available, and then 
sets it.

\item The \code{omp\_unset\_nest\_lock} routine unsets a nestable lock.

\item The \code{omp\_test\_nest\_lock} routine tests a nestable lock, and sets it if it is 
available
\end{itemize}

\restrictions
OpenMP lock routines have the following restrictions:

\begin{itemize}
\item The use of the same OpenMP lock in different contention groups results in 
unspecified behavior. 
\end{itemize}










\subsection{\code{omp\_init\_lock} and \code{omp\_init\_nest\_lock}}
\label{subsec:omp_init_lock and omp_init_nest_lock}
\index{omp\_init\_lock@{\code{omp\_init\_lock}}}
\index{omp\_init\_nest\_lock@{\code{omp\_init\_nest\_lock}}}
\summary
These routines initialize an OpenMP lock without a hint.

\format
\begin{ccppspecific}
\begin{boxedcode}
void omp\_init\_lock(omp\_lock\_t *\plc{lock});
void omp\_init\_nest\_lock(omp\_nest\_lock\_t *\plc{lock});
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
subroutine omp\_init\_lock(\plc{svar})
integer (kind=omp\_lock\_kind) \plc{svar}

subroutine omp\_init\_nest\_lock(\plc{nvar})
integer (kind=omp\_nest\_lock\_kind) \plc{nvar}
\end{boxedcode}
\end{fortranspecific}

\constraints
A program that accesses a lock that is not in the uninitialized state through either routine 
is non-conforming.

\effect
The effect of these routines is to initialize the lock to the unlocked state; that is, no task 
owns the lock. In addition, the nesting count for a nestable lock is set to zero.

\events

The \plc{lock-init} or \plc{nest-lock-init} event occurs in the thread 
executing a \code{omp\_init\_lock} or \code{omp\_init\_nest\_lock} region
after initialization of the lock, but before finishing the region.

\tools

A thread dispatches a registered \code{ompt\_callback\_lock\_init}
callback for each occurrence of a \plc{lock-init} or \plc{nest-lock-init} event 
in that thread.  This callback has the type signature \code{ompt\_callback\_mutex\_acquire\_t}.
The callbacks occur in the task encountering the routine.
The callback receives \code{omp\_lock\_hint\_none} as
\plc{hint} argument and
\code{ompt\_mutex\_lock} or 
 \code{ompt\_mutex\_nest\_lock} as \plc{kind} argument as appropriate.

\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_mutex\_acquire\_t}, see
\specref{sec:ompt_callback_mutex_acquire_t}.
\end{itemize}











\subsection[\code{omp\_init\_lock\_with\_hint} and \\\code{omp\_init\_nest\_lock\_with\_hint}]{\code{omp\_init\_lock\_with\_hint} and \\\code{omp\_init\_nest\_lock\_with\_hint}}
\label{subsec:omp_init_lock_with_hint and omp_init_nest_lock_with_hint}
\index{omp\_init\_lock@{\code{omp\_init\_lock}}}
\index{omp\_init\_nest\_lock@{\code{omp\_init\_nest\_lock}}}
\summary
These routines initialize an OpenMP lock with a hint.  
The effect of the hint is implementation-defined. The OpenMP implementation
can ignore the hint without changing program semantics.


\format
\begin{ccppspecific}
\begin{boxedcode}
void omp\_init\_lock\_with\_hint(omp\_lock\_t *\plc{lock}, 
                             omp\_lock\_hint\_t \plc{hint});
void omp\_init\_nest\_lock\_with\_hint(omp\_nest\_lock\_t *\plc{lock}, 
                                  omp\_lock\_hint\_t \plc{hint});
\end{boxedcode}
\end{ccppspecific}

\newpage %% HACK

\begin{fortranspecific}
\begin{boxedcode}
subroutine omp\_init\_lock\_with\_hint(\plc{svar}, \plc{hint})
integer (kind=omp\_lock\_kind) \plc{svar}
integer (kind=omp\_lock\_hint\_kind) \plc{hint}

subroutine omp\_init\_nest\_lock\_with\_hint(\plc{nvar}, \plc{hint})
integer (kind=omp\_nest\_lock\_kind) \plc{nvar}
integer (kind=omp\_lock\_hint\_kind) \plc{hint}
\end{boxedcode}
\end{fortranspecific}

\constraints
A program that accesses a lock that is not in the uninitialized state through either routine 
is non-conforming.

The second argument passed to this routine (\plc{hint}) can be one of the valid OpenMP lock hints below or any implementation-defined hint. 
The C/C++ header file (\code{omp.h}) and the Fortran include file (\code{omp\_lib.h}) and/or Fortran~90 module file (\code{omp\_lib}) define the valid lock hint constants.  
The valid constants must include the following, which can be extended with implementation-defined values:

\begin{ccppspecific}
\begin{codepar}
typedef enum omp\_lock\_hint\_t \{
  omp\_lock\_hint\_none = 0,
  omp\_lock\_hint\_uncontended = 1,
  omp\_lock\_hint\_contended = 2,
  omp\_lock\_hint\_nonspeculative = 4,
  omp\_lock\_hint\_speculative = 8
\} omp\_lock\_hint\_t;
\end{codepar}
\end{ccppspecific}

\newpage %% HACK 

\begin{fortranspecific}
\begin{codepar}
integer (kind=omp\_lock\_hint\_kind), &
        parameter :: omp\_lock\_hint\_none = 0
integer (kind=omp\_lock\_hint\_kind), &
        parameter :: omp\_lock\_hint\_uncontended = 1
integer (kind=omp\_lock\_hint\_kind), &
        parameter :: omp\_lock\_hint\_contended = 2
integer (kind=omp\_lock\_hint\_kind), &
        parameter :: omp\_lock\_hint\_nonspeculative = 4 
integer (kind=omp\_lock\_hint\_kind), &
        parameter :: omp\_lock\_hint\_speculative = 8
\end{codepar}
\end{fortranspecific}

The hints can be combined by using the \code{+} or \code{|} operators in C/C++ or the \code{+} operator in Fortran.  
The effect of the combined hint is implementation defined and can be ignored by the implementation.
Combining \code{omp\_lock\_hint\_none} with any other hint is equivalent to specifying the other hint.
The following restrictions apply to combined hints; violating these 
restrictions results in unspecified behavior:
\begin{itemize}
%\item \code{omp\_lock\_hint\_none} cannot be combined with any other hint,
\item the hints \code{omp\_lock\_hint\_uncontended} and \code{omp\_lock\_hint\_contended} cannot be combined,
\item the hints \code{omp\_lock\_hint\_nonspeculative} and \code{omp\_lock\_hint\_speculative} cannot be combined.
\end{itemize}


\begin{note}
Future OpenMP specifications may add additional hints to the 
\code{omp\_lock\_hint\_t} type and the \code{omp\_lock\_hint\_kind} kind.  
Implementers are advised to add implementation-defined hints starting from 
the most significant bit of the \code{omp\_lock\_hint\_t} type and
\code{omp\_lock\_hint\_kind} kind and to include the name of the 
implementation in the name of the added hint to avoid name conflicts 
with other OpenMP implementations.
\end{note}


\effect
The effect of these routines is to initialize the lock to the unlocked state and, optionally, to choose a specific lock implementation based on the hint. 
After initialization no task owns the lock. In addition, the nesting count for a nestable lock is set to zero.

\events

The \plc{lock-init} or \plc{nest-lock-init} event occurs in the thread 
executing a \code{omp\_init\_lock\_with\_hint} or \code{omp\_init\_nest\_lock\_with\_hint} region
after initialization of the lock, but before finishing the region.

\tools

A thread dispatches a registered \code{ompt\_callback\_lock\_init}
callback for each occurrence of a \plc{lock-init} or \plc{nest-lock-init} event 
in that thread.  This callback has the type signature \code{ompt\_callback\_mutex\_acquire\_t}.
The callbacks occur in the task encountering the routine. 
The callback receives the function's \plc{hint} argument as
\plc{hint} argument and
\code{ompt\_mutex\_lock} or 
 \code{ompt\_mutex\_nest\_lock} as \plc{kind} argument as appropriate.

\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_mutex\_acquire\_t}, see
\specref{sec:ompt_callback_mutex_acquire_t}.
\end{itemize}



\subsection[\code{omp\_destroy\_lock} and \code{omp\_destroy\_nest\_lock}]{\code{omp\_destroy\_lock} and\\ \code{omp\_destroy\_nest\_lock}}
\label{subsec:omp_destroy_lock and omp_destroy_nest_lock}
\index{omp\_destroy\_lock@{\code{omp\_destroy\_lock}}}
\index{omp\_destroy\_nest\_lock@{\code{omp\_destroy\_nest\_lock}}}
\summary
These routines ensure that the OpenMP lock is uninitialized.

\format
\begin{ccppspecific}
\begin{boxedcode}
void omp\_destroy\_lock(omp\_lock\_t *\plc{lock});
void omp\_destroy\_nest\_lock(omp\_nest\_lock\_t *\plc{lock});
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
subroutine omp\_destroy\_lock(\plc{svar})
integer (kind=omp\_lock\_kind) \plc{svar}

subroutine omp\_destroy\_nest\_lock(\plc{nvar})
integer (kind=omp\_nest\_lock\_kind) \plc{nvar}
\end{boxedcode}
\end{fortranspecific}

\constraints
A program that accesses a lock that is not in the unlocked state through either routine is 
non-conforming.

\effect
The effect of these routines is to change the state of the lock to uninitialized.

\events

The \plc{lock-destroy} or \plc{nest-lock-destroy} event occurs in the thread 
executing a \code{omp\_destroy\_lock} or \code{omp\_destroy\_nest\_lock} region
before finishing the region.

\tools

A thread dispatches a registered \code{ompt\_callback\_lock\_destroy}
callback for each occurrence of a \plc{lock-destroy} or \plc{nest-lock-destroy} event 
in that thread.  This callback has the type signature \code{ompt\_callback\_mutex\_t}.
The callbacks occur in the task encountering the routine.
The callbacks receive \code{ompt\_mutex\_lock} or 
 \code{ompt\_mutex\_nest\_lock} as their \plc{kind} argument as appropriate.


\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_mutex\_t}, see 
\specref{sec:ompt_callback_mutex_t}.
\end{itemize}









\subsection{\code{omp\_set\_lock} and \code{omp\_set\_nest\_lock}}
\label{subsec:omp_set_lock and omp_set_nest_lock}
\index{omp\_set\_lock@{\code{omp\_set\_lock}}}
\index{omp\_set\_nest\_lock@{\code{omp\_set\_nest\_lock}}}
\summary
These routines provide a means of setting an OpenMP lock. The calling
task region behaves as if it was suspended until the lock can be set
by this task.

\format
\begin{ccppspecific}
\begin{boxedcode}
void omp\_set\_lock(omp\_lock\_t *\plc{lock});
void omp\_set\_nest\_lock(omp\_nest\_lock\_t *\plc{lock});
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
subroutine omp\_set\_lock(\plc{svar})
integer (kind=omp\_lock\_kind) \plc{svar}

subroutine omp\_set\_nest\_lock(\plc{nvar})
integer (kind=omp\_nest\_lock\_kind) \plc{nvar}
\end{boxedcode}
\end{fortranspecific}

\constraints
A program that accesses a lock that is in the uninitialized state through either routine is 
non-conforming. A simple lock accessed by \code{omp\_set\_lock} that is in the locked state 
must not be owned by the task that contains the call or deadlock will result.

\effect
Each of these routines has an effect equivalent to suspension of the task
executing the routine until the specified lock is available. 

% However, the
% task region may continue to execute speculatively, provided that the 
% implementation ensures that execution is as if the lock were owned
% exclusively by one thread. 

% A note because it's only explanatory. The as-ifness already allows
% this via the ``equivalent to''
\begin{note} The semantics of these routines is specified
\emph{as if} they serialize execution of the region guarded by the
lock. However, implementations may implement them in other ways
provided that the isolation properties are respected so that the
actual execution delivers a result that could arise from some
serialization. 
\end{note}

A simple lock is available if it is unlocked. Ownership of the lock is 
granted to the task executing the routine.

A nestable lock is available if it is unlocked or if it is already owned by 
the task executing the routine. The task executing the routine is granted, 
or retains, ownership of the lock, and the nesting count for the lock is 
incremented.

\events

The \plc{lock-acquire} or \plc{nest-lock-acquire} event occurs in the thread 
executing a \code{omp\_set\_lock} or \code{omp\_set\_nest\_lock} region
before the associated lock is requested.

The \plc{lock-acquired} or \plc{nest-lock-acquired} event occurs in the thread 
executing a \code{omp\_set\_lock} or \code{omp\_set\_nest\_lock} region
after acquiring the associated lock, if the thread did not already own the lock, 
but before finishing the region.

The \plc{nest-lock-owned} event occurs in the thread 
executing a \code{omp\_set\_nest\_lock} region
when the thread already owned the lock, 
before finishing the region.


\tools

A thread dispatches a registered \code{ompt\_callback\_mutex\_acquire}
callback for each occurrence of a \plc{lock-acquire} or \plc{nest-lock-acquire} event 
in that thread.  This callback has the type signature \code{ompt\_callback\_mutex\_acquire\_t}.

A thread dispatches a registered \code{ompt\_callback\_mutex\_acquired}
callback for each occurrence of a \plc{lock-acquired} or \plc{nest-lock-acquired} event 
in that thread.  This callback has the type signature \code{ompt\_callback\_mutex\_t}.

A thread dispatches a registered \code{ompt\_callback\_nest\_lock}
callback for each occurrence of a \plc{nest-lock-owned} event 
in that thread. This callback has the type signature \code{ompt\_callback\_nest\_lock\_t}.
The callback receives \code{ompt\_scope\_begin} as its \plc{endpoint} argument.

The callbacks occur in the task encountering
the lock function.  The callbacks receive \code{ompt\_mutex\_lock} or 
 \code{ompt\_mutex\_nest\_lock} as their \plc{kind} argument, as appropriate.


\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_mutex\_acquire\_t}, see 
\specref{sec:ompt_callback_mutex_acquire_t}.
\item \code{ompt\_callback\_mutex\_t}, see 
\specref{sec:ompt_callback_mutex_t}.
\item \code{ompt\_callback\_nest\_lock\_t}, see
\specref{sec:ompt_callback_nest_lock_t}.
\end{itemize}




\subsection{\code{omp\_unset\_lock} and \code{omp\_unset\_nest\_lock}}
\label{subsec:omp_unset_lock and omp_unset_nest_lock}
\index{omp\_unset\_lock@{\code{omp\_unset\_lock}}}
\index{omp\_unset\_nest\_lock@{\code{omp\_unset\_nest\_lock}}}
\summary
These routines provide the means of unsetting an OpenMP lock.

\format
\begin{ccppspecific}
\begin{boxedcode}
void omp\_unset\_lock(omp\_lock\_t *\plc{lock});
void omp\_unset\_nest\_lock(omp\_nest\_lock\_t *\plc{lock});
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
subroutine omp\_unset\_lock(\plc{svar})
integer (kind=omp\_lock\_kind) \plc{svar}

subroutine omp\_unset\_nest\_lock(\plc{nvar})
integer (kind=omp\_nest\_lock\_kind) \plc{nvar}
\end{boxedcode}
\end{fortranspecific}

\constraints
A program that accesses a lock that is not in the locked state or that is 
not owned by the task that contains the call through either routine is 
non-conforming.

% Jim Cownie: I don't believe we need anything more about speculation
% here. It has to behave ``as-if'' it held the lock, and released it
% here, and that's what we say happens.

\effect
For a simple lock, the \code{omp\_unset\_lock} routine causes the lock to become unlocked.

For a nestable lock, the \code{omp\_unset\_nest\_lock} routine decrements the nesting 
count, and causes the lock to become unlocked if the resulting nesting count is zero.

For either routine, if the lock becomes unlocked, and if one or more task 
regions were effectively suspended because the lock was unavailable, the 
effect is that one task is chosen and given ownership of the lock. 

\events

The \plc{lock-release} or \plc{nest-lock-release} event occurs in the thread 
executing a \code{omp\_unset\_lock} or \code{omp\_unset\_nest\_lock} region
after releasing the associated lock, but before finishing the region.

The \plc{nest-lock-held} event occurs in the thread 
executing a \code{omp\_unset\_nest\_lock} region
when the thread still owns the lock, 
before finishing the region.


\tools

A thread dispatches a registered \code{ompt\_callback\_mutex\_released}
callback for each occurrence of a \plc{lock-release} or \plc{nest-lock-release} event 
in that thread.  This callback has the type signature \code{ompt\_callback\_mutex\_t}.
The callback occurs in the task encountering
the routine. The callback receives \code{ompt\_mutex\_lock} or 
 \code{ompt\_mutex\_nest\_lock} as \plc{kind} argument as appropriate.

A thread dispatches a registered \code{ompt\_callback\_nest\_lock}
callback for each occurrence of a \plc{nest-lock-held} event 
in that thread. This callback has the type signature \code{ompt\_callback\_nest\_lock\_t}.
The callback receives \code{ompt\_scope\_end} as its \plc{endpoint} argument.

\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_mutex\_t}, see
\specref{sec:ompt_callback_mutex_t}.
\item \code{ompt\_callback\_nest\_lock\_t}, see
\specref{sec:ompt_callback_nest_lock_t}.
\end{itemize}








\subsection{\code{omp\_test\_lock} and \code{omp\_test\_nest\_lock}}
\label{subsec:omp_test_lock and omp_test_nest_lock}
\index{omp\_test\_lock@{\code{omp\_test\_lock}}}
\index{omp\_test\_nest\_lock@{\code{omp\_test\_nest\_lock}}}
\summary
These routines attempt to set an OpenMP lock but do not suspend execution of the task 
executing the routine.

\format
\begin{ccppspecific}
\begin{boxedcode}
int omp\_test\_lock(omp\_lock\_t *\plc{lock});
int omp\_test\_nest\_lock(omp\_nest\_lock\_t *\plc{lock});
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
logical function omp\_test\_lock(\plc{svar})
integer (kind=omp\_lock\_kind) \plc{svar}
integer function omp\_test\_nest\_lock(\plc{nvar})
integer (kind=omp\_nest\_lock\_kind) \plc{nvar}
\end{boxedcode}
\end{fortranspecific}

\constraints
A program that accesses a lock that is in the uninitialized state through either routine is 
non-conforming. The behavior is unspecified if a simple lock accessed by 
\code{omp\_test\_lock} is in the locked state and is owned by the task that contains the call.

\effect 
These routines attempt to set a lock in the same manner as \code{omp\_set\_lock} and 
\code{omp\_set\_nest\_lock}, except that they do not suspend execution of the task 
executing the routine.

For a simple lock, the \code{omp\_test\_lock} routine returns \plc{true} if the lock is successfully 
set; otherwise, it returns \plc{false}.

For a nestable lock, the \code{omp\_test\_nest\_lock} routine returns the new nesting count 
if the lock is successfully set; otherwise, it returns zero.

\events

The \plc{lock-test} or \plc{nest-lock-test} event occurs in the thread 
executing a \code{omp\_test\_lock} or \code{omp\_test\_nest\_lock} region
before the associated lock is tested.

The \plc{lock-test-acquired} or \plc{nest-lock-test-acquired} event occurs in the thread 
executing a \code{omp\_test\_lock} or \code{omp\_test\_nest\_lock} region
before finishing the region if the associated lock was acquired and the thread did not already own the lock. 

The \plc{nest-lock-owned} event occurs in the thread 
executing a \code{omp\_test\_nest\_lock} region
if the thread already owned the lock, 
before finishing the region.


\tools

A thread dispatches a registered \code{ompt\_callback\_mutex\_acquire}
callback for each occurrence of a \plc{lock-test} or \plc{nest-lock-test} event 
in that thread.  This callback has the type signature \code{ompt\_callback\_mutex\_acquire\_t}.

A thread dispatches a registered \code{ompt\_callback\_mutex\_acquired}
callback for each occurrence of a \plc{lock-test-acquired} or \plc{nest-lock-test-acquired} event 
in that thread.  This callback has the type signature \code{ompt\_callback\_mutex\_t}.

A thread dispatches a registered \code{ompt\_callback\_nest\_lock}
callback for each occurrence of a \plc{nest-lock-owned} event 
in that thread. This callback has the type signature \code{ompt\_callback\_nest\_lock\_t}.
The callback receives \code{ompt\_scope\_begin} as its \plc{endpoint} argument.

The callbacks occur in the task encountering
the lock function.  The callbacks receive \code{ompt\_mutex\_lock} or 
 \code{ompt\_mutex\_nest\_lock} as their \plc{kind} argument, as appropriate.


\crossreferences
\begin{itemize}
\item \code{ompt\_callback\_mutex\_acquire\_t}, see 
\specref{sec:ompt_callback_mutex_acquire_t}.
\item \code{ompt\_callback\_mutex\_t}, see 
\specref{sec:ompt_callback_mutex_t}.
\item \code{ompt\_callback\_nest\_lock\_t}, see
\specref{sec:ompt_callback_nest_lock_t}.
\end{itemize}








\vspace{-24pt}


\section{Timing Routines}
\index{timing routines}
\index{timer}
\index{wall clock timer}
\label{sec:Timing Routines}
This section describes routines that support a portable wall clock timer.

\vspace{-12pt}









\subsection{\code{omp\_get\_wtime}}
\index{omp\_get\_wtime@{\code{omp\_get\_wtime}}}
\label{subsec:omp_get_wtime}
\summary
The \code{omp\_get\_wtime} routine returns elapsed wall clock time in seconds.

\format
\begin{ccppspecific}
\begin{boxedcode}
double omp\_get\_wtime(void);
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
double precision function omp\_get\_wtime()
\end{boxedcode}
\end{fortranspecific}

\binding
The binding thread set for an \code{omp\_get\_wtime} region is the encountering thread. The 
routine’s return value is not guaranteed to be consistent across any set of threads.

\effect
The \code{omp\_get\_wtime} routine returns a value equal to the elapsed wall clock time in 
seconds since some ``time in the past''. The actual ``time in the past'' is arbitrary, but it is 
guaranteed not to change during the execution of the application program. The time 
returned is a ``per-thread time'', so it is not required to be globally consistent across all 
threads participating in an application.

\begin{note}
It is anticipated that the routine will be used to measure elapsed times as shown 
in the following example:

\begin{ccppspecific}
\begin{boxedcode}
double start;
double end;
start = omp\_get\_wtime();
\plc{... work to be timed ...}
end = omp\_get\_wtime();
printf("Work took \%f seconds{\textbackslash}n", end - start);
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
DOUBLE PRECISION START, END
START = omp\_get\_wtime()
\plc{... work to be timed ...}
END = omp\_get\_wtime()
PRINT *, "Work took", END - START, "seconds"
\end{boxedcode}
\end{fortranspecific}
\end{note}










\pagebreak
\subsection{\code{omp\_get\_wtick}}
\index{omp\_get\_wtick@{\code{omp\_get\_wtick}}}
\label{subsec:omp_get_wtick}
\summary
The \code{omp\_get\_wtick} routine returns the precision of the timer used by 
\code{omp\_get\_wtime}.

\format
\begin{ccppspecific}
\begin{boxedcode}
double omp\_get\_wtick(void);
\end{boxedcode}
\end{ccppspecific}

\begin{fortranspecific}
\begin{boxedcode}
double precision function omp\_get\_wtick()
\end{boxedcode}
\end{fortranspecific}

\binding
The binding thread set for an \code{omp\_get\_wtick} region is the encountering thread. The 
routine’s return value is not guaranteed to be consistent across any set of threads.

\effect
The \code{omp\_get\_wtick} routine returns a value equal to the number of seconds between 
successive clock ticks of the timer used by \code{omp\_get\_wtime}.







\pagebreak
\begin{ccppspecific}
\vspace{-3\baselineskip}
\section{Device Memory Routines}
\index{device memory routines}
\index{target memory routines}
\label{sec:Device Memory Routines}
This section describes routines that support allocation of memory and 
management of pointers in the data environments of target devices.


\subsection{\code{omp\_target\_alloc}}
\index{omp\_target\_alloc@{\code{omp\_target\_alloc}}}
\label{subsec:omp_target_alloc}
\summary
The \code{omp\_target\_alloc} routine allocates memory in a device data
environment.

\format
\begin{boxedcode}
void* omp\_target\_alloc(size\_t \plc{size}, int \plc{device\_num});
\end{boxedcode}

\effect

The \code{omp\_target\_alloc} routine returns the device address of a storage
location of \plc{size} bytes. The storage location is dynamically allocated in
the device data environment of the device specified by \plc{device\_num}, which
must be greater than or equal to zero and less than the result of
\code{omp\_get\_num\_devices()} or the result of a call to
\code{omp\_get\_initial\_device()}. When called from within a \code{target} region 
the effect of this routine is unspecified.

The \code{omp\_target\_alloc} routine returns \code{NULL} if it cannot dynamically
allocate the memory in the device data environment. 

The device address returned by \code{omp\_target\_alloc} can be used in an 
\code{is\_device\_ptr} clause, \specref{subsec:target Construct}.

Pointer arithmetic is not supported on the device address returned by
\code{omp\_target\_alloc}.

Freeing the storage returned by \code{omp\_target\_alloc} with any routine
other than \code{omp\_target\_free} results in unspecified behavior.

\pagebreak
\linewitharrows{-1}{dashed}{C/C++ (cont.)}{8em}
\events
The \plc{target-data-allocation} event occurs when a thread allocates data on a target device.

\tools

A thread invokes a registered \code{ompt\_callback\_target\_data\_op}
callback for each occurrence of a \plc{target-data-allocation} event in that thread. 
The callback occurs in the context of the target task.  The callback has type signature
\code{ompt\_callback\_target\_data\_op\_t}. 


\crossreferences
\begin{itemize}
\item \code{target} construct, see 
\specref{subsec:target Construct}

\item \code{omp\_get\_num\_devices} routine, see 
\specref{subsec:omp_get_num_devices}

\item \code{omp\_get\_initial\_device} routine, see 
\specref{subsec:omp_get_initial_device}

\item \code{omp\_target\_free} routine, see 
\specref{subsec:omp_target_free}

\item \code{ompt\_callback\_target\_data\_op\_t}, see 
\specref{sec:ompt_callback_target_data_op_t}.

\end{itemize}



\subsection{\code{omp\_target\_free}}
\index{omp\_target\_free@{\code{omp\_target\_free}}}
\label{subsec:omp_target_free}
\summary
The \code{omp\_target\_free} routine frees the device memory allocated by the \code{omp\_target\_alloc} routine.

\format
\begin{boxedcode}
void omp\_target\_free(void * \plc{device\_ptr}, int \plc{device\_num});
\end{boxedcode}

\constraints

A program that calls \code{omp\_target\_free} with a non-\code{NULL} pointer 
that does not have a value returned from \code{omp\_target\_alloc} is
non-conforming.  The \plc{device\_num} must be greater than or equal to 
zero and less than the result of \code{omp\_get\_num\_devices()} or the
 result of a call to \code{omp\_get\_initial\_device()}.

\pagebreak
\linewitharrows{-1}{dashed}{C/C++ (cont.)}{8em}
\effect

The \code{omp\_target\_free} routine frees the memory in the device data
environment associated with \plc{device\_ptr}.  If \plc{device\_ptr} is
\code{NULL}, the operation is ignored.

Synchronization must be inserted to ensure that all accesses to 
\plc{device\_ptr} are completed before the call to \code{omp\_target\_free}.

When called from within a \code{target} region the effect of this routine
is unspecified.

\events
The \plc{target-data-free} event occurs when a thread frees data on a target device.

\tools

A thread invokes a registered \code{ompt\_callback\_target\_data\_op}
callback for each occurrence of a \plc{target-data-free} event in that thread. 
The callback occurs in the context of the target task.  The callback has type signature
\code{ompt\_callback\_target\_data\_op\_t}. 


\crossreferences
\begin{itemize}
\item \code{target} construct, see 
\specref{subsec:target Construct}

\item \code{omp\_get\_num\_devices} routine, see 
\specref{subsec:omp_get_num_devices}

\item \code{omp\_get\_initial\_device} routine, see 
\specref{subsec:omp_get_initial_device}

\item \code{omp\_target\_alloc} routine, see 
\specref{subsec:omp_target_alloc}

\item \code{ompt\_callback\_target\_data\_op\_t}, see 
\specref{sec:ompt_callback_target_data_op_t}.

\end{itemize}



\pagebreak
\linewitharrows{-1}{dashed}{C/C++ (cont.)}{8em}
\subsection{\code{omp\_target\_is\_present}}
\index{omp\_target\_is\_present@{\code{omp\_target\_is\_present}}}
\label{subsec:omp_target_is_present}
\summary

The \code{omp\_target\_is\_present} routine tests whether a host pointer
has corresponding storage on a given device.

\format
\begin{boxedcode}
int omp\_target\_is\_present(const void * \plc{ptr}, int \plc{device\_num});
\end{boxedcode}

\constraints

The value of \plc{ptr} must be a valid host pointer or \code{NULL}.
The \plc{device\_num}
must be greater than or equal to zero and less than the result of
\code{omp\_get\_num\_devices()} or the result of a call to
\code{omp\_get\_initial\_device()}.

\effect

This routine returns non-zero if the specified pointer
would be found present on device \plc{device\_num} by a \code{map}
clause; otherwise, it returns zero.

When called from within a \code{target} region 
the effect of this routine is unspecified.

\crossreferences
\begin{itemize}
\item \code{target} construct, see \specref{subsec:target Construct}

\item \code{map} clause, see \specref{subsec:map Clause}.

\item \code{omp\_get\_num\_devices} routine, see 
\specref{subsec:omp_get_num_devices}

\item \code{omp\_get\_initial\_device} routine, see 
\specref{subsec:omp_get_initial_device}
\end{itemize}


\pagebreak
\linewitharrows{-1}{dashed}{C/C++ (cont.)}{8em}
\subsection{\code{omp\_target\_memcpy}}
\index{omp\_target\_memcpy@{\code{omp\_target\_memcpy}}}
\label{subsec:omp_target_memcpy}
\summary

The \code{omp\_target\_memcpy} routine copies memory between any combination
of host and device pointers.

\format
\begin{boxedcode}
int omp\_target\_memcpy(void * \plc{dst}, const void * \plc{src},
                        size\_t \plc{length}, size\_t \plc{dst\_offset},
                        size\_t \plc{src\_offset}, int \plc{dst\_device\_num},
                        int \plc{src\_device\_num});
\end{boxedcode}

\constraints
Each device must
be compatible with the device pointer specified on the same side of the copy.
The \plc{dst\_device\_num} and \plc{src\_device\_num}
must be greater than or equal to zero and less than the result of
\code{omp\_get\_num\_devices()} or equal to the result of a call to
\code{omp\_get\_initial\_device()}.

\effect


\plc{length} bytes of memory at offset \plc{src\_offset} from  \plc{src}
in the device data environment of device \plc{src\_device\_num} are
copied to \plc{dst} starting at offset \plc{dst\_offset} in the device data
environment of device \plc{dst\_device\_num}.  
The return value is zero on success and non-zero on failure.  The host device
and host device data environment can be referenced with the device number
returned by \code{omp\_get\_initial\_device}. This routine contains a task
scheduling point.

When called from within a \code{target} region 
the effect of this routine is unspecified.

\events
The \plc{target-data-transfer} event occurs when a thread transfers data on a target device.

\pagebreak
\linewitharrows{-1}{dashed}{C/C++ (cont.)}{8em}
\tools
A thread invokes a registered \code{ompt\_callback\_target\_data\_op}
callback for each occurrence of a \plc{target-data-transfer} event in that thread. 
The callback occurs in the context of the target task.  The callback has type signature
\code{ompt\_callback\_target\_data\_op\_t}. 


\crossreferences
\begin{itemize}
\item \code{target} construct, see \specref{subsec:target Construct}

\item \code{omp\_get\_initial\_device} routine, see 
\specref{subsec:omp_get_initial_device}

\item \code{omp\_target\_alloc} routine, see \specref{subsec:omp_target_alloc}


\item \code{ompt\_callback\_target\_data\_op\_t}, see 
\specref{sec:ompt_callback_target_data_op_t}.
\end{itemize}


\vspace{-1\baselineskip}
\subsection{\code{omp\_target\_memcpy\_rect}}
\index{omp\_target\_memcpy\_rect@{\code{omp\_target\_memcpy\_rect}}}
\label{subsec:omp_target_memcpy_rect}
\summary

The \code{omp\_target\_memcpy\_rect} routine copies a rectangular subvolume from
a multi-dimensional array to another multi-dimensional array. The copies can
use any combination of host and device pointers.

\format
\begin{samepage}
\begin{boxedcode}
int omp\_target\_memcpy\_rect(
               void * \plc{dst}, const void * \plc{src},
               size\_t \plc{element\_size},
               int \plc{num\_dims},
               const size\_t* \plc{volume},
               const size\_t* \plc{dst\_offsets},
               const size\_t* \plc{src\_offsets},
               const size\_t* \plc{dst\_dimensions},
               const size\_t* \plc{src\_dimensions},
               int \plc{dst\_device\_num}, int \plc{src\_device\_num});
\end{boxedcode}
\end{samepage}

\newpage
\linewitharrows{-1}{dashed}{C/C++ (cont.)}{8em}
\constraints
The length of the offset and dimension arrays must be at least the
value of \plc{num\_dims}.
The \code{dst\_device\_num} and \code{src\_device\_num}
must be greater than or equal to zero and less than the result of
\code{omp\_get\_num\_devices()} or equal to the result of a call to
\code{omp\_get\_initial\_device()}.

The value of \plc{num\_dims} must be between 1 and the implementation-defined
limit, which must be at least three.


\effect

This routine copies a rectangular subvolume of \plc{src},
in the device data environment of device \plc{src\_device\_num},
to \plc{dst}, in the device data environment of device \plc{dst\_device\_num}.
The volume is specified in terms of the size of an element, 
number of dimensions, and constant arrays of length \plc{num\_dims}.  The 
maximum number of dimensions supported is at least three, support for higher 
dimensionality is implementation defined. The volume array specifies the 
length, in number of elements, to copy in each dimension from \plc{src} 
to \plc{dst}. The \plc{dst\_offsets} (\plc{src\_offsets}) parameter specifies
number of elements from the origin of \plc{dst} (\plc{src}) in elements.  
The \plc{dst\_dimensions} (\plc{src\_dimensions}) parameter specifies the 
length of each dimension of \plc{dst} (\plc{src})

The routine returns zero if successful. If both \plc{dst} and \plc{src} are
\code{NULL} pointers, the routine returns the number of dimensions supported
by the implementation for the specified device numbers. The host device and
host device data environment can be referenced with the device number returned
by \code{omp\_get\_initial\_device}.  Otherwise, it returns a non-zero value. The
routine contains a task scheduling point.

When called from within a \code{target} region 
the effect of this routine is unspecified.

%% As an example, this routine could be used to copy a $3\times3\times3$ cube 
%% from the center of a $9\times9\times9$ cube in \code{src} to a \code{dst} 
%% matrix of size $3\times3\times3$ on the host as follows:
%%\begin{samepage}
%%\begin{boxedcode}
%%int src[9][9][9], dst[3][3][3];
%%size_t volume[]    = \{3, 3, 3\},
%%       dst_offset[]= \{0, 0, 0\},
%%       src_offset[]= \{3, 3, 3\},
%%       dst_dims[]  = \{3, 3, 3\},
%%       src_dims[]  = \{9, 9, 9\};
%%omp_target_memcpy_rect(
%%          dst, src,
%%          sizeof(int), //elem_size
%%          3, //num_dims
%%          volume,
%%          dst_offset,
%%          src_offset,
%%          dst_dims,
%%          src_dims,
%%          0, 0);
%%\end{boxedcode}
%%\end{samepage}

\events
The \plc{target-data-transfer} event occurs when a thread transfers data on a target device.

\tools

A thread invokes a registered \code{ompt\_callback\_target\_data\_op}
callback for each occurrence of a \plc{target-data-transfer} event in that thread. 
The callback occurs in the context of the target task.  The callback has type signature
\code{ompt\_callback\_target\_data\_op\_t}. 


\newpage
\linewitharrows{-1}{dashed}{C/C++ (cont.)}{8em}
\crossreferences
\begin{itemize}
\item \code{target} construct, see \specref{subsec:target Construct}

\item \code{omp\_get\_initial\_device} routine, see 
\specref{subsec:omp_get_initial_device}

\item \code{omp\_target\_alloc} routine, see \specref{subsec:omp_target_alloc}


\item \code{ompt\_callback\_target\_data\_op\_t}, see 
\specref{sec:ompt_callback_target_data_op_t}.

\end{itemize}

\subsection{\code{omp\_target\_associate\_ptr}}
\index{omp\_target\_associate\_ptr@{\code{omp\_target\_associate\_ptr}}}
\label{subsec:omp_target_associate_ptr}
\summary

The \code{omp\_target\_associate\_ptr} routine maps a device pointer, which may
be returned from \code{omp\_target\_alloc} or implementation-defined runtime 
routines, to a host pointer.

\format
\begin{boxedcode}
int omp\_target\_associate\_ptr(const void * \plc{host\_ptr},
                                const void * \plc{device\_ptr},
                                size\_t \plc{size}, size\_t \plc{device\_offset},
                                int \plc{device\_num});
\end{boxedcode}

\constraints

The value of \plc{device\_ptr} value must be a valid pointer to device 
memory for the device denoted by the value of \plc{device\_num}.
The \plc{device\_num} argument
must be greater than or equal to zero and less than the result of
\code{omp\_get\_num\_devices()} or equal to the result of a call to
\code{omp\_get\_initial\_device()}.

\pagebreak
\linewitharrows{-1}{dashed}{C/C++ (cont.)}{8em}
\effect

The \code{omp\_target\_associate\_ptr} routine associates a device pointer
in the device data environment of device \plc{device\_num}
with a host pointer such that when the host pointer appears in a subsequent
\code{map} clause, the associated device pointer is used as the target for
data motion associated with that host pointer.  The \plc{device\_offset}
parameter specifies what offset into \plc{device\_ptr} will be used as the
base address for the device side of the mapping.  The reference count of the
resulting mapping will be infinite.  After being successfully associated, the
buffer pointed to by the device pointer is invalidated and accessing data
directly through the device pointer results in unspecified behavior.  The
pointer can be retrieved for other uses by disassociating it.
When called from within a \code{target} region 
the effect of this routine is unspecified.

The routine returns zero if successful. Otherwise it returns a non-zero value.

Only one device buffer can be associated with a given host pointer value and
device number pair. Attempting to associate a second buffer will return
non-zero. Associating the same pair of pointers on the same device with the
same offset has no effect and returns zero.  Associating pointers that share
underlying storage will result in unspecified behavior. The
\code{omp\_target\_is\_present} region can be used to test whether a given
host pointer has a corresponding variable in the device data environment.

\events
The \plc{target-data-associate} event occurs when a thread associates data on a target device.

\tools

A thread invokes a registered \code{ompt\_callback\_target\_data\_op}
callback for each occurrence of a \plc{target-data-associate} event in that thread. 
The callback occurs in the context of the target task.  The callback has type signature
\code{ompt\_callback\_target\_data\_op\_t}. 

\crossreferences
\begin{itemize}
\item \code{target} construct, see \specref{subsec:target Construct}

\item \code{map} clause, see \specref{subsec:map Clause}.

\item \code{omp\_target\_alloc} routine, see \specref{subsec:omp_target_alloc}

\item \code{omp\_target\_disassociate\_ptr} routine, see 
\specref{subsec:omp_target_associate_ptr}

\item \code{ompt\_callback\_target\_data\_op\_t}, see 
\specref{sec:ompt_callback_target_data_op_t}.

\end{itemize}

\pagebreak
\linewitharrows{-1}{dashed}{C/C++ (cont.)}{8em}
\subsection{\code{omp\_target\_disassociate\_ptr}}
\index{omp\_target\_disassociate\_ptr@{\code{omp\_target\_disassociate\_ptr}}}
\label{subsec:omp_target_disassociate_ptr}
\summary

The \code{omp\_target\_disassociate\_ptr} removes the associated pointer for a
given device from a host pointer.

\format
\begin{boxedcode}
int omp\_target\_disassociate\_ptr(const void * \plc{ptr}, int \plc{device\_num});
\end{boxedcode}

\constraints


The \plc{device\_num}
must be greater than or equal to zero and less than the result of
\code{omp\_get\_num\_devices()} or equal to the result of a call to
\code{omp\_get\_initial\_device()}.

\effect

The \code{omp\_target\_disassociate\_ptr} removes the associated device data
on device \plc{device\_num} from the presence table for host pointer
\plc{ptr}. A call to this routine on a pointer that is not 
\code{NULL} and does not have associated data on the given device results
in unspecified behavior.  The reference count of the mapping is reduced to 
zero, regardless of its current value.

When called from within a \code{target} region 
the effect of this routine is unspecified.

After a call to \code{omp\_target\_disassociate\_ptr}, the contents of the device
buffer are invalidated.

\events
The \plc{target-data-disassociate} event occurs when a thread disassociates data on a target device.

\tools

A thread invokes a registered \code{ompt\_callback\_target\_data\_op}
callback for each occurrence of a \plc{target-data-disassociate} event in that thread. 
The callback occurs in the context of the target task.  The callback has type signature
\code{ompt\_callback\_target\_data\_op\_t}. 

\pagebreak
\linewitharrows{-1}{dashed}{C/C++ (cont.)}{8em}
\crossreferences
\begin{itemize}
\item \code{target} construct, see 
\specref{subsec:target Construct}
\item \code{omp\_target\_associate\_ptr} routine, see 
\specref{subsec:omp_target_associate_ptr}
\item \code{ompt\_callback\_target\_data\_op\_t}, see 
\specref{sec:ompt_callback_target_data_op_t}.

\end{itemize}

\end{ccppspecific}

\section{Tool Control Routines}
\index{tool control}
\label{sec:control_tool}

\summary
The \code{omp\_control\_tool} routine enables a program to 
pass commands to an active tool.

\format

\vbox{
\begin{ccppspecific}
\begin{boxedcode}
int omp\_control\_tool(int \plc{command}, int \plc{modifier}, void *\plc{arg});
\end{boxedcode}
\end{ccppspecific}
}

\begin{fortranspecific}
\begin{boxedcode}
integer function omp\_control\_tool(\plc{command}, \plc{modifier})
integer (kind=omp\_control\_tool\_kind) \plc{command}
integer (kind=omp\_control\_tool\_kind) \plc{modifier}
\end{boxedcode}
\end{fortranspecific}

\descr

An OpenMP program may use \code{omp\_control\_tool} to pass commands to 
a tool. 
Using \code{omp\_control\_tool}, an application can request that
a tool start or restart data collection when a code
region of interest is encountered, pause data collection when 
leaving the region of interest, 
flush any data that it has collected so far, or
end data collection. 
Additionally, \code{omp\_control\_tool} can be used to pass 
tool-specific commands to a particular tool.


\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef enum omp_control_tool_result_t \{
  omp_control_tool_notool = -2,
  omp_control_tool_nocallback = -1,
  omp_control_tool_success = 0,
  omp_control_tool_ignored = 1
\} omp_control_tool_result_t;
\end{boxedcode}
\end{ccppspecific}
}

\vbox{
\begin{fortranspecific}
\begin{boxedcode}
integer (kind=omp\_control\_tool\_result\_kind), &
        parameter :: omp\_control\_tool\_notool = -2 
integer (kind=omp\_control\_tool\_result\_kind), &
        parameter :: omp\_control\_tool\_nocallback = -1
integer (kind=omp\_control\_tool\_result\_kind), &
        parameter :: omp\_control\_tool\_success = 0
integer (kind=omp\_control\_tool\_result\_kind), &
        parameter :: omp\_control\_tool\_ignored = 1
\end{boxedcode}
\end{fortranspecific}
}

If no tool is active, the OpenMP implementation will return
\code{omp\_control\_tool\_notool}. If a tool is active, but it has not
registered a callback for the \plc{tool-control} event, the OpenMP
implementation will return \code{omp\_control\_tool\_nocallback}.  
An OpenMP implementation may return other implementation-defined negative
values $< -64$; an application may assume that any negative return value
indicates that a tool has not received the command.  A return value of
\code{omp\_control\_tool\_success} indicates that the tool has performed the
specified command.  A return value of \code{omp\_control\_tool\_ignored}
indicates that the tool has ignored the specified command.
A tool may return other positive values $> 64$ that are tool-defined. 

\constraints

The following enumeration type defines four standard commands.
Table~\ref{table:std-tool-cmds} describes the 
actions that these commands request from a tool.

\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef enum omp_control_tool_t \{
  omp_control_tool_start = 1,
  omp_control_tool_pause = 2,
  omp_control_tool_flush = 3,
  omp_control_tool_end = 4
\} omp_control_tool_t;
\end{boxedcode}
\end{ccppspecific}
}

\vbox{
\begin{fortranspecific}
\begin{boxedcode}
integer (kind=omp\_control\_tool\_kind), &
          parameter :: omp\_control\_tool\_start = 1
integer (kind=omp\_control\_tool\_kind), &
          parameter :: omp\_control\_tool\_pause = 2
integer (kind=omp\_control\_tool\_kind), &
          parameter :: omp\_control\_tool\_flush = 3
integer (kind=omp\_control\_tool\_kind), &
          parameter :: omp\_control\_tool\_end = 4
\end{boxedcode}
\end{fortranspecific}
}

Tool-specific values for \plc{command} must be $\geq$ 64.
Tools must ignore \plc{command} values that they are not
explicitly designed to handle.
Other values accepted by a tool for \plc{command}, 
and any values for \plc{modifier} and \plc{arg} are tool-defined.


\begin{table}
\begin{center}
\begin{tabular}{|l|p{3.5in}|}\hline
Command & Action\\\hline\hline
\code{omp\_control\_tool\_start} & Start or 
restart monitoring if it is off. If monitoring is already on, this 
command is idempotent. If monitoring has already been turned off 
permanently, this command will have no effect.\\\hline
\code{omp\_control\_tool\_pause} & Temporarily
turn monitoring off. If monitoring is already off, it is idempotent.\\\hline
\code{omp\_control\_tool\_flush} & Flush any data buffered by a tool.
This command may be applied whether monitoring is on or off.\\\hline
\code{omp\_control\_tool\_end} & Turn monitoring off permanently; 
the tool finalizes itself and flushes all output.\\\hline
\end{tabular}
\vskip 1ex
\caption{Standard tool control commands.}
\label{table:std-tool-cmds}
\end{center}
\end{table}

\events

The \plc{tool-control} event occurs in the thread encountering a call
to \code{omp\_control\_tool} at a point inside its associated OpenMP region.

\tools

An OpenMP implementation dispatches a registered
\code{ompt\_callback\_control\_tool} callback for each occurrence of a
\plc{tool-control} event.  The callback executes in the context of the
call that occurs in the user program.  This callback has type
signature \code{ompt\_callback\_control\_tool\_t}.The callback may return
any non-negative value, which will be returned to the application by
the OpenMP implementation as the return value of the
\code{omp\_control\_tool} call that triggered the callback.


Arguments passed to the callback are those passed by the user to
\code{omp\_control\_tool}. If the call is made in Fortran, the tool
will be passed a \code{NULL} as the third argument to the callback. If
any of the four standard commands is presented to a tool, the tool
will ignore the \plc{modifier} and \plc{arg} argument values.



\crossreferences
\begin{itemize}
\item Tool Interface, see
\specchapterref{chap:ToolsSupport}
\item \code{ompt\_callback\_control\_tool\_t}, see 
\specref{sec:ompt_callback_control_tool_t}
\end{itemize}

