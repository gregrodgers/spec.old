
In this section, we define the types, structures, and functions for the OMPD API.

\ompdsubsection{Basic Types}
%\label{ompd:ompd_addr_t}
%\label{ompd:ompd_word_t}
%\label{ompd:ompd_wait_id_t}
%\label{ompd:ompd_address_t}
The following describes the basic OMPD API types.

\subsubsubsection{Size type}
\label{ompd:ompd_size_t}

This type is used to specify the number of bytes in opaque data objects passed across the OMPD API.

\format
\vbox{
	\ccppspecificstart
	\begin{boxedcode}
  typedef uint64_t ompd_size_t;  
	\end{boxedcode}
	\ccppspecificend
}

\subsubsubsection{Wait id type}
\label{ompd:ompd_wait_id_t}

This type identifies what a thread is waiting for.

\format
\vbox{
	\ccppspecificstart
	\begin{boxedcode}
  typedef uint64_t ompd_wait_id_t;  
	\end{boxedcode}
	\ccppspecificend
}

\subsubsubsection{Basic value types}
\label{ompd:ompd_addr_t}
\label{ompd:ompd_word_t}
\label{ompd:ompd_seg_t}

These definitions represent a word, address, and segment value types.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
  typedef uint64_t ompd_addr_t;
  typedef int64_t  ompd_word_t;
  typedef uint64_t ompd_seg_t;
\end{boxedcode}
\ccppspecificend
}

The \plc{ompd\_addr\_t} type represents an unsigned integer large enough to hold an address in an 
OpenMP process.
The \plc{ompd\_word\_t} type represents a signed version of  \plc{ompd\_addr\_t} to hold a signed 
integer of the OpenMP process.
The \plc{ompd\_seg\_t} type represents an unsigned integer large enough to hold a segment value.

\subsubsubsection{Address type}
\label{ompd:ompd_address_t}

This type is a structure that OMPD uses to specify device addresses, 
which may or may not be segmented.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct \{
 ompd_seg_t \plc{segment};
 ompd_addr_t \plc{address};
\} ompd_address_t;

#define OMPD_SEGMENT_UNSPECIFIED 0
\end{boxedcode}
\ccppspecificend
}

For non segmented architectures, use OMPD\_SEGMENT\_UNSPECIFIED in the \plc{segment} 
field of \code{ompd\_address\_t}.

%\format
%\vbox{
%\ccppspecificstart
%\begin{boxedcode}
%/* unsigned integer large enough to hold a target device */
%/* address or a target device segment value */
%typedef uint64_t ompd_addr_t;
%/* signed version of ompd_addr_t */
%typedef int64_t  ompd_word_t;
%/* identifies what a thread is waiting for */
%typedef uint64_t ompd_wait_id_t;
%typedef struct \{
%  /* target device specific segment value */
%  ompd_addr_t segment;
%  /* target device address in the segment */ 
%  ompd_addr_t address;
%\} ompd_address_t;
%\end{boxedcode}
%\ccppspecificend
%}

%The \code{ompd\_address\_t} is a structure that OMPD uses to specify target device addresses, 
%which 
%may or may not be segmented.  
  
\ompdsubsection{System Device Identifiers}

Different OpenMP runtimes may utilize different underlying devices.
The type used to hold an device identifier can vary in size and format, and 
therefore is not explicitly represented in the OMPD API. Device identifiers are 
passed across the interface using a device-identifier `kind', a pointer to where
the device identifier is stored, and the size of the device identifier in bytes.
The OMPD library and tool using it must agree on the format
of what is being passed.
Each different kind of device identifier uses a unique
unsigned 64-bit integer value.

Recommended values of \code{ompd\_device\_kind\_t} are defined in the \code{ompd\_types.h} 
header file, which is available on \url{http://www.openmp.org/}. 

\label{ompd:ompd_device_kind_t}
\format
\vbox{
	\ccppspecificstart
	\begin{boxedcode}
  typedef uint64_t ompd_device_kind_t;
	\end{boxedcode}
	\ccppspecificend
}

\ompdsubsection{Thread Identifiers}

Different OpenMP runtimes may use different underlying native
thread implementations.
The type used to hold a thread identifier can vary in size and format, and 
therefore is not explicitly represented in the OMPD API. Thread identifiers are 
passed across the interface using a thread-identifier `kind', a pointer to where
the thread identifier is stored, and the size of the thread identifier in bytes.
The OMPD library and tool using it must agree on the format
of what is being passed.
Each different kind of thread identifier uses a unique
unsigned 64-bit integer value.

Recommended values of \code{ompd\_thread\_id\_kind\_t} are defined in the \code{ompd\_types.h} 
header file, which is available on \url{http://www.openmp.org/}. 

\label{ompd:ompd_thread_id_kind_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef uint64_t ompd_thread_id_kind_t;
\end{boxedcode}
\ccppspecificend
}

\ompdsubsection{OMPD Handle Types}
\label{ompd:ompd_address_space_handle_t}
\label{ompd:ompd_thread_handle_t}
\label{ompd:ompd_parallel_handle_t}
\label{ompd:ompd_task_handle_t}

Each operation of the OMPD interface that applies to a particular address space, thread, parallel 
region, or task must explicitly specify
% ilaguna: device can be confused by a GPU device
%the device for the operation using a \emph{handle}.
a \emph{handle} for the operation.
OMPD employs handles for address spaces (for a host or target device), threads, parallel regions, 
and tasks. A handle for an entity is constant while the entity itself is alive. Handles are defined by 
the OMPD plugin, and are opaque to the tool. The following defines the OMPD 
handle types:

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct _ompd_aspace_handle_s ompd_address_space_handle_t;
typedef struct _ompd_thread_handle_s ompd_thread_handle_t;
typedef struct _ompd_parallel_handle_s ompd_parallel_handle_t;
typedef struct _ompd_task_handle_s ompd_task_handle_t;
\end{boxedcode}
\ccppspecificend
}

Defining externally visible type names in this way introduces type safety to the interface, and helps 
to catch instances where incorrect handles are passed by the tool to the OMPD 
library. The \code{struct}s do not need to be defined at all. The OMPD library 
must cast incoming (pointers to) handles to the appropriate internal, private types.

\ompdsubsection{Tool Context Types}

A third-party tool uses contexts to uniquely  identifies abstractions. These contexts are opaque to 
the OMPD library and are defined as follows:
%The debugger uses The debugger contexts are opaque to the OMPD and are defined as follows:

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct _ompd_aspace_cont_s ompd_address_space_context_t;
typedef struct _ompd_thread_cont_s ompd_thread_context_t;
\end{boxedcode}
\ccppspecificend
}

\ompdsubsection{Return Code Types}
\label{ompd:ompd_rc_t}

Each OMPD operation has a return code. The return code types and their semantics are defined as 
follows:

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum \{
  ompd_rc_ok = 0,
  ompd_rc_unavailable = 1, 
  ompd_rc_stale_handle = 2,
  ompd_rc_bad_input = 3,
  ompd_rc_error = 4,
  ompd_rc_unsupported = 5,
  ompd_rc_needs_state_tracking = 6,
  ompd_rc_incompatible = 7,
  ompd_rc_device_read_error = 8,
  ompd_rc_device_write_error = 9,
  ompd_rc_nomem = 10, 
\} ompd_rc_t;	
\end{boxedcode}
\ccppspecificend
}

\descr
\label{ompd:ompd_rc_ok}
\textbf{ompd\_rc\_ok} is returned when the operation is successful.

\label{ompd:ompd_rc_unavailable}
\textbf{ompd\_rc\_unavailable} is returned when 
information is not available for the specified context.

\label{ompd:ompd_rc_stale_handle}
\textbf{ompd\_rc\_stale\_handle} is returned when
the specified handle is no longer valid.

\label{ompd:ompd_rc_bad_input}
\textbf{ompd\_rc\_bad\_input} is returned when
the input parameters (other than handle) are invalid. 

\label{ompd:ompd_rc_error}
\textbf{ompd\_rc\_error} is returned when
a fatal error occurred.

\label{ompd:ompd_rc_unsupported}
\textbf{ompd\_rc\_unsupported} is returned when
the requested operation is not supported.

\label{ompd:ompd_rc_needs_state_tracking}
\textbf{ompd\_rc\_needs\_state\_tracking} is returned when
the state tracking operation failed because state tracking is not currently enabled.

\label{ompd:ompd_rc_incompatible}
\textbf{ompd\_rc\_incompatible} is returned when
this OMPD is incompatible with the OpenMP program.

\label{ompd:ompd_rc_device_read_error}
\textbf{ompd\_rc\_device\_read\_error} is returned when
a read operation failed on the device

\label{ompd:ompd_rc_device_write_error}
\textbf{ompd\_rc\_device\_write\_error} is returned when
a write operation failed to the device.

\label{ompd:ompd_rc_nomem}
\textbf{ompd\_rc\_nomem} is returned when
unable to allocate memory.

\ompdsubsection{OpenMP Scheduling Types}
\label{ompd:ompd_sched_t}

The following enumeration defines \code{ompd\_sched\_t}, which is the OMPD API definition 
corresponding to the OpenMP enumeration type \code{omp\_sched\_t} (see 

\specref{subsec:omp_set_schedule}).
\code{ompd\_sched\_t} also defines \code{ompd\_sched\_vendor\_lo} and
\code{ompd\_sched\_vendor\_hi} to define the range of implementation-specific 
\code{omp\_sched\_t} values than can be handle by the OMPD API.

\begin{quote}
	\begin{lstlisting}

	\end{lstlisting}
\end{quote}

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum \{
  ompd_sched_static = 1,
  ompd_sched_dynamic = 2,
  ompd_sched_guided = 3,
  ompd_sched_auto = 4,
  ompd_sched_vendor_lo = 5,
  ompd_sched_vendor_hi = 0x7fffffff
\} ompd_sched_t;
\end{boxedcode}
\ccppspecificend
}

\ompdsubsection{OpenMP Proc Binding Types}
\label{ompd:ompd_proc_bind_t}

The following enumeration defines \code{ompd\_proc\_bind\_t}, which is the OMPD
API definition corresponding to the OpenMP enumeration type
\code{omp\_proc\_bind\_t} (\specref{subsec:omp_get_proc_bind}).

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum \{
  ompd_proc_bind_false = 0,
  ompd_proc_bind_true = 1,
  ompd_proc_bind_master = 2,
  ompd_proc_bind_close = 3,
  ompd_proc_bind_spread = 4
\} ompd_proc_bind_t;
\end{boxedcode}
\ccppspecificend
}

\ompdsubsection{Primitive Types}
\label{ompd:ompd_device_type_sizes_t}
The following structure contains members that the OMPD library can use
to interrogate the tool about the ``sizeof'' of primitive types in the OpenMP architecture 
address space.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct \{
  int \plc{sizeof_char};
  int \plc{sizeof_short};
  int \plc{sizeof_int};
  int \plc{sizeof_long};
  int \plc{sizeof_long_long};
  int \plc{sizeof_pointer};
\} ompd_device_type_sizes_t;
\end{boxedcode}
\ccppspecificend
}

\descr
The fields of \code{ompd\_device\_type\_sizes\_t} give the sizes of
the eponymous basic types used by the OpenMP runtime.
As the tool and the OMPD plugin, by definition, have the same
architecture and programming model, the size of the fields can be given
as \code{int}.

\crossreferences
\begin{itemize}
	\item
	\code{ompd\_sizeof\_fn\_t}, \specref{ompd:ompd_sizeof_fn_t}
\end{itemize}

The following enumeration of primitive types are used by OMPD to express the primitive
type of data for OpenMP device to OMPD host conversion.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum \{
  ompd_type_char = 0,
  ompd_type_short = 1,
  ompd_type_int = 2,
  ompd_type_long = 3,
  ompd_type_long_long = 4,
  ompd_type_pointer = 5
\} ompd_device_prim_types_t;
\end{boxedcode}
\ccppspecificend
}

\ompdsubsection{Runtime State Types}

The OMPD runtime states mirror those in OMPT (\specref{sec:ompt_get_state_t}). Note that there is no guarantee that 
the numeric values of the corresponding members of the enumerations are identical.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum \{
  ompd_state_work_serial = 0x00,
  ompd_state_work_parallel = 0x01,
  ompd_state_work_reduction = 0x02,
  ompd_state_idle = 0x10,
  ompd_state_overhead = 0x20,
  ompd_state_wait_barrier = 0x40,
  ompd_state_wait_barrier_implicit = 0x41,
  ompd_state_wait_barrier_explicit = 0x42,
  ompd_state_wait_taskwait = 0x50,
  ompd_state_wait_taskgroup = 0x51,
  ompd_state_wait_mutex = 0x60,
  ompd_state_wait_lock = 0x61,  
  ompd_state_wait_critical = 0x62,
  ompd_state_wait_atomic = 0x63,
  ompd_state_wait_ordered = 0x64,
  ompd_state_undefined = 0x70,
  ompd_state_first = 0x71,
\} ompd_state_t;
\end{boxedcode}
\ccppspecificend
}

\descr
\label{ompd_state_work_serial}
\textbf{ompd\_state\_work\_serial} - 
working outside parallel
 
\label{ompd_state_work_parallel}
\textbf{ompd\_state\_work\_parallel} - 
working within parallel

\label{ompd_state_work_reduction}
\textbf{ompd\_state\_work\_reduction} - 
performing a reduction

\label{ompd_state_idle}
\textbf{ompd\_state\_idle} - 
waiting for work
 
\label{ompd_state_overhead}
\textbf{ompd\_state\_overhead} - 
non-wait overhead

\label{ompd_state_wait_barrier}
\textbf{ompd\_state\_wait\_barrier} - 
generic barrier

\label{ompd_state_wait_barrier_implicit}
\textbf{ompd\_state\_wait\_barrier\_implicit} - 
implicit barrier

\label{ompd_state_wait_barrier_explicit}
\textbf{ompd\_state\_wait\_barrier\_explicit} - 
explicit barrier

\label{ompd_state_wait_taskwait}
\textbf{ompd\_state\_wait\_taskwait} - 
waiting at a taskwait

\label{ompd_state_wait_taskgroup}
\textbf{ompd\_state\_wait\_taskgroup} - 
waiting at a taskgroup

\label{ompd_state_wait_mutex}
\textbf{ompd\_state\_wait\_mutex} - 
waiting for any mutex kind

\label{ompd_state_wait_lock}
\textbf{ompd\_state\_wait\_lock} - 
waiting for lock

\label{ompd_state_wait_critical}
\textbf{ompd\_state\_wait\_critical} - 
waiting for critical

\label{ompd_state_wait_atomic}
\textbf{ompd\_state\_wait\_atomic} - 
waiting for atomic

\label{ompd_state_wait_ordered}
\textbf{ompd\_state\_wait\_ordered} - 
waiting for ordered

\label{ompd_state_undefined}
\textbf{ompd\_state\_undefined} - 
undefined thread state

\label{ompd_state_first}
\textbf{ompd\_state\_first} - 
initial enumeration state
