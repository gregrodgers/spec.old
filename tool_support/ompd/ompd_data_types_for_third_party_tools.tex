
In this section, we define the types, structures, and functions for the OMPD API.

\ompdsubsection{Basic Types}
%\label{ompd:ompd_addr_t}
%\label{ompd:ompd_word_t}
%\label{ompd:ompd_wait_id_t}
%\label{ompd:ompd_address_t}
The following describes the basic OMPD API types.

\subsubsubsection{Segment value type}
\label{ompd:ompd_addr_t}
\label{ompd:ompd_word_t}

This type represents an address or a target device segment value. We define a signed integer 
version of the type and an unsigned integer version, which is large enough to hold a target device.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
  typedef int64_t  ompd_word_t;
  typedef uint64_t ompd_addr_t;   
\end{boxedcode}
\ccppspecificend
}

\subsubsubsection{Wait id type}
\label{ompd:ompd_wait_id_t}

This type identifies what a thread is waiting for.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
  typedef uint64_t ompd_wait_id_t;  
\end{boxedcode}
\ccppspecificend
}

\subsubsubsection{Address type}
\label{ompd:ompd_address_t}

This type is a structure that OMPD uses to specify target device addresses, 
which may or may not be segmented.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct \{
 ompd_addr_t segment;
 ompd_addr_t address;
\} ompd_address_t; 
\end{boxedcode}
\ccppspecificend
}

%\format
%\vbox{
%\ccppspecificstart
%\begin{boxedcode}
%/* unsigned integer large enough to hold a target device */
%/* address or a target device segment value */
%typedef uint64_t ompd_addr_t;
%/* signed version of ompd_addr_t */
%typedef int64_t  ompd_word_t;
%/* identifies what a thread is waiting for */
%typedef uint64_t ompd_wait_id_t;
%typedef struct \{
%  /* target device specific segment value */
%  ompd_addr_t segment;
%  /* target device address in the segment */ 
%  ompd_addr_t address;
%\} ompd_address_t;
%\end{boxedcode}
%\ccppspecificend
%}

%The \code{ompd\_address\_t} is a structure that OMPD uses to specify target device addresses, 
%which 
%may or may not be segmented.  
  
\ompdsubsection{Operating System Identifiers}
\subsubsection{System Device Identifiers}

Different OpenMP runtimes may utilize different underlying devices.
The type used to hold an device identifier can vary in size and format, and 
therefore is not explicitly represented in the OMPD API. Device identifiers are 
passed across the interface using a device-identifier `kind', a pointer to where
the device identifier is stored, and the size of the device identifier in bytes.
The OMPD library and tool using it must agree on the format
of what is being passed.
Each different kind of device identifier uses a unique
unsigned 64-bit integer value.

\label{ompd:ompd_device_kind_t}
\format
\vbox{
	\ccppspecificstart
	\begin{boxedcode}
		typedef uint64_t ompd_device_kind_t;
	\end{boxedcode}
	\ccppspecificend
}

\subsubsection{Operating System Thread Identifiers}

Different OpenMP runtimes may use different underlying (operating system)
thread implementations.
The type used to hold an operating system thread identifier can vary in size and format, and 
therefore is not explicitly represented in the OMPD API. Operating system thread identifiers are 
passed across the interface using a thread-identifier `kind', a pointer to where
the thread identifier is stored, and the size of the thread identifier in bytes.
The OMPD library and tool using it must agree on the format
of what is being passed.
Each different kind of thread identifier uses a unique
unsigned 64-bit integer value.

\label{ompd:ompd_osthread_kind_t}
\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef uint64_t ompd_osthread_kind_t;
\end{boxedcode}
\ccppspecificend
}

\ompdsubsection{OMPD Handle Types}

Each operation of the OMPD interface that applies to a particular address space, thread, parallel 
region, or task must explicitly specify
% ilaguna: device can be confused by a GPU device
%the device for the operation using a \emph{handle}.
a \emph{handle} for the operation.
OMPD employs handles for address spaces (for a host or target device), threads, parallel regions, 
and tasks. A handle for an entity is constant while the entity itself is alive. Handles are defined by 
the OMPD plugin, and are opaque to the tool. The following defines the OMPD 
handle types:

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct _ompd_aspace_handle_s ompd_address_space_handle_t;
typedef struct _ompd_thread_handle_s ompd_thread_handle_t;
typedef struct _ompd_parallel_handle_s ompd_parallel_handle_t;
typedef struct _ompd_task_handle_s ompd_task_handle_t;
\end{boxedcode}
\ccppspecificend
}

Defining externally visible type names in this way introduces type safety to the interface, and helps 
to catch instances where incorrect handles are passed by the debugger to the OMPD 
library. The \code{struct}s do not need to be defined at all. The OMPD library 
must cast incoming (pointers to) handles to the appropriate internal, private types.

\ompdsubsection{Tool Context Types}

A third-party tool uses contexts to uniquely  identifies abstractions. These contexts are opaque to 
the OMPD library and are defined as follows:
%The debugger uses The debugger contexts are opaque to the OMPD and are defined as follows:

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct _ompd_aspace_cont_s ompd_address_space_context_t;
typedef struct _ompd_thread_cont_s ompd_thread_context_t;
\end{boxedcode}
\ccppspecificend
}

\ompdsubsection{Return Code Types}
\label{ompd:ompd_rc_t}

Each OMPD operation has a return code. The return code types and their semantics are defined as 
follows:

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum \{
  /* Operation was successful */
  ompd_rc_ok = 0,
  /* Information is not available (in this context) */
  ompd_rc_unavailable = 1, 
  /* Handle is no longer valid */
  ompd_rc_stale_handle = 2,
  /* Bad input parameters (other than handle) */ 
  ompd_rc_bad_input = 3,
  /* Error */
  ompd_rc_error = 4,
  /* Operation is not supported */ 
  ompd_rc_unsupported = 5,
  /* Needs runtime state tracking enabled */ 
  ompd_rc_needs_state_tracking = 6,
  /* Not compatible with this OMPD */ 
  ompd_rc_incompatible = 7,
  /* Read error  */ 
  ompd_rc_device_read_error = 8,
  /* Write error */ 
  ompd_rc_device_write_error = 9,
  /* Unable to allocate memory */
  ompd_rc_nomem = 10, 
\} ompd_rc_t;	
\end{boxedcode}
\ccppspecificend
}

\ompdsubsection{OpenMP Scheduling Types}

The following enumeration defines \code{ompd\_sched\_t}, which is the OMPD API definition 
corresponding to the OpenMP enumeration type \code{omp\_sched\_t} (see 
\specref{subsec:omp_set_schedule}).
\code{ompd\_sched\_t} also defines \code{ompd\_sched\_vendor\_lo} and
\code{ompd\_sched\_vendor\_hi} to define the range of implementation-specific 
\code{omp\_sched\_t} values than can be handle by the OMPD API.

\begin{quote}
	\begin{lstlisting}

	\end{lstlisting}
\end{quote}

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum \{
  ompd_sched_static = 1,
  ompd_sched_dynamic = 2,
  ompd_sched_guided = 3,
  ompd_sched_auto = 4,
  ompd_sched_vendor_lo = 5,
  ompd_sched_vendor_hi = 0x7fffffff
\} ompd_sched_t;
\end{boxedcode}
\ccppspecificend
}

\ompdsubsection{OpenMP Proc Binding Types}

The following enumeration defines \code{ompd\_proc\_bind\_t}, which is the OMPD
API definition corresponding to the OpenMP enumeration type
\code{omp\_proc\_bind\_t} (XXX).

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum \{
  ompd_proc_bind_false = 0,
  ompd_proc_bind_true = 1,
  ompd_proc_bind_master = 2,
  ompd_proc_bind_close = 3,
  ompd_proc_bind_spread = 4
\} ompd_proc_bind_t;
\end{boxedcode}
\ccppspecificend
}

\ompdsubsection{Primitive Types}

The following structure contains members that the OMPD library can use
to interrogate the debugger about the ``sizeof'' of primitive types in the OpenMP architecture 
address space.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef struct \{
  int sizeof_char;
  int sizeof_short;
  int sizeof_int;
  int sizeof_long;
  int sizeof_long_long;
  int sizeof_pointer;
\} ompd_device_type_sizes_t;
\end{boxedcode}
\ccppspecificend
}

The following enumeration of primitive types are used by OMPD to express the primitive
type of data for OpenMP device to OMPD host conversion.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum \{
  ompd_type_char = 0,
  ompd_type_short = 1,
  ompd_type_int = 2,
  ompd_type_long = 3,
  ompd_type_long_long = 4,
  ompd_type_pointer = 5
\} ompd_device_prim_types_t;
\end{boxedcode}
\ccppspecificend
}

\ompdsubsection{Runtime State Types}

The OMPD runtime states mirror those in OMPT (see XXX). Note that there is no guarantee that 
the numeric values of the corresponding members of the enumerations are identical.

\format
\vbox{
\ccppspecificstart
\begin{boxedcode}
typedef enum \{
  /* work states (0..15) */
  ompd_state_work_serial = 0x00, /* working outside parallel */
  ompd_state_work_parallel = 0x01, /* working within parallel  */
  ompd_state_work_reduction = 0x02, /* performing a reduction */

  /* idle (16..31) */
  ompd_state_idle = 0x10, /* waiting for work */

  /* overhead states (32..63) */
  ompd_state_overhead = 0x20, /* non-wait overhead */

  /* barrier wait states (64..79) */
  ompd_state_wait_barrier = 0x40, /* generic barrier */
  ompd_state_wait_barrier_implicit = 0x41, /* implicit barrier */
  ompd_state_wait_barrier_explicit = 0x42, /* explicit barrier */

  /* task wait states (80..95) */
  ompd_state_wait_taskwait = 0x50, /* waiting at a taskwait */
  ompd_state_wait_taskgroup = 0x51, /* waiting at a taskgroup */

  /* mutex wait states (96..111) */
  ompd_state_wait_mutex = 0x60, /* waiting for any mutex kind */
  ompd_state_wait_lock = 0x61, /* waiting for lock */  
  ompd_state_wait_critical = 0x62, /* waiting for critical */
  ompd_state_wait_atomic = 0x63, /* waiting for atomic */
  ompd_state_wait_ordered = 0x64, /* waiting for ordered */

  /* misc (112..127) */
  ompd_state_undefined = 0x70, /* undefined thread state */
  ompd_state_first = 0x71, /* initial enumeration state */
\} ompd_state_t;
\end{boxedcode}
\ccppspecificend
}
