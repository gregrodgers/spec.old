\section{OMPD}
\label{sec:ompd-overview}
\label{sec:third-party-tool-callback-interface}

OMPD allows \emph{third-party tools} such as a debuggers to inspect the 
OpenMP state of a live program or core file in an implementation-agnostic 
manner. That is, a tool that uses OMPD should work with any conforming 
OpenMP implementation. An OpenMP implementor provides a library for OMPD 
that a third-party tool can dynamically load. Using the interface exported 
by the OMPD library, the external tool can inspect the OpenMP state of a 
program. In order to satisfy requests from the third-party tool, the OMPD 
library may need to read data from, or to find the addresses of symbols in 
the OpenMP program. The OMPD library provides this functionality through a 
callback interface that the third-party tool must instantiate for the OMPD library.

To use OMPD, the third-party tool loads the OMPD library. The OMPD library exports 
the API that is defined throughout this section and that the tool uses to 
determine OpenMP information about the OpenMP program. The OMPD library must
look up the symbols and read data out of the program. It does not perform
these operations directly, but instead it use the callback interface that the
tool exports to cause the tool to perform them.

This architectural layout insulates the tool from the details
of the internal structure of the OpenMP runtime.
Similarly, the OMPD library does not need to be concerned about
how to access the OpenMP program.
Decoupling the library and tool in this way allows for
great flexibility in how the OpenMP program and tool are deployed,
so that, for example, there is no requirement that tool
and OpenMP program execute on the same machine.

Generally the tool does not interact directly with the OpenMP
runtime in the OpenMP program, and instead uses the OMPD library
for this purpose.
However, there are a few instances where the tool does need
to access the OpenMP runtime directly.
These cases fall into two broad categories.
The first is during initialization, where the tool needs
to be able to look up symbols and read variables in OpenMP runtime
in order to identify the OMPD library it should use.
This is discussed in Sections~\ref{subsubsec:ompd_dll_locations}
and~\ref{subsubsec:ompd_dll_locations_valid}.
The second category relates to arranging for the tool to be notified
when certain events occur during the execution of the OpenMP program.
The model used for this purpose is that the OpenMP implementation
is required to define certain symbols in the runtime code.
This is discussed in Section~\ref{subsec:runtime-entry-points-for-ompd}.
Each of these symbols corresponds to an event type.
The runtime must ensure that control passes through the appropriate
named location when events occur.
If the tool wants to get notification of an event, it can plant
a breakpoint at the matching location.

The code locations can, but do not need to, be functions.
They can, for example, simply be labels.
However, the names must have external \texttt{C} linkage.

