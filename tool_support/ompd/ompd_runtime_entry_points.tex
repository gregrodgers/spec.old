\subsection{Runtime Entry Points for OMPD}
\label{ompd:runtime-entry-points-for-ompd}

Most of the tool's OpenMP-related activity on an OpenMP
program will be performed through the OMPD interface.
However, supporting OMPD introduced some requirements of the OpenMP
runtime.
These fall into three categories: entrypoints the user's code in
OpenMP program can call; locations in the OpenMP runtime through
which control must pass when specific events occur; and data that must
be accessible to the tool.

\subsubsection{Identifying the Matching OMPD}
\label{ompd:ompd_dll_locations}
\index{ompd\_dll\_locations@{\code{ompd\_dll\_locations}}}

\summary
Names the OMPD plugin(s) that are compatible with the runtime.

\vbox{
\cspecificstart
\begin{boxedcode}
const char **ompd\_dll\_locations;
\end{boxedcode}
\cspecificend
}

\descr
\code{ompd\_dll\_locations} is an \code{argv}-style vector of filename
strings that provide the names of any OMPD plugin implementations
that are compatible with the OpenMP runtime.
The vector is NULL-terminated.

The programming model or architecture of the tool, and
hence that of the required OMPD plugin, might not match that of
the OpenMP program to be examined.
On platforms that support multiple programming models (\textit{e.g.},
32- v. 64-bit), or in heterogenous  environments where the architectures
of the OpenMP program and tool may be be different,
OpenMP implementors are encourgaed to provide OMPD plugins for all models.
The vector, therefore, may name plugins that are not compatible
with the tool.
This is legal, and it is up to the tool to check that
a plugin is compatible.
(Typically, a tool might iterate over the vector until a compatible
plugin is found.)

\restrictions
\code{ompd\_dll\_locations} has external \code{C} linkage,
no demangling or other transformations are required by a 
tool before looking up its address in the OpenMP program.

The vector and its members must be fully initialized before
\code{ompd\_dll\_locations} is set to a non-NULL value.
That is, if \code{ompd\_dll\_locations} is not NULL, the vector
and its contents are valid.

\crossreferences
\begin{itemize}
\item
  \code{ompd\_dll\_locations\_valid}, \specref{ompd:ompd_dll_locations_valid}
\item
  Finding the OMPD plugin, \specref{ompd:finding-the-ompd}
\end{itemize}

\subsubsection{Indicating that \code{ompd\_dll\_locations} is Valid}
\label{ompd:ompd_dll_locations_valid}
\index{ompd\_dll\_locations\_valid@{\code{ompd\_dll\_locations}}}

\summary
The OpenMP indicates that the vector of names of matching OMPD plugins
is valid by allowing execution to pass through the location
identified by \code{ompd\_dll\_locations\_valid}.

\vbox{
\cspecificstart
\begin{boxedcode}
void ompd\_dll\_locations\_valid ( void );
\end{boxedcode}
\cspecificend
}

\descr
In some implementations of the OpenMP runtime the vector of names
of matching OMPD plugins may need to be constructed at runtime.
Before the vector is valid, \code{ompd\_dll\_locations} must be NULL.
To avoid the tool having to poll \code{ompd\_dll\_locations}
to become non-NULL, the OpenMP runtime must arrange for execution
to pass through the location named by \code{ompd\_dll\_locations\_valid}
once the vector has been initialized.
By planting a breakpoint at \code{ompd\_dll\_locations\_valid},
the tool can be notified when the vector of names is
ready to be read.

If \code{ompd\_dll\_locations} vector is statically allocated
and initialized, the tool should not need to use
\code{ompd\_dll\_locations\_valid} since \code{ompd\_dll\_locations}
will be non-NULL.

\restrictions

\code{ompd\_dll\_locations\_valid} has external \code{C} linkage,
and no demangling or other transformations are required by a 
tool before looking up its address in the OpenMP program.

Conceptually \code{ompd\_dll\_locations\_valid} has the signature
given above.
However, it does not need to be a function, but can be a labeled
location in the runtime code.

\crossreferences
\begin{itemize}
\item
  \code{ompd\_dll\_locations}, \specref{ompd:ompd_dll_locations}
\item
  Finding the OMPD plugin, \specref{ompd:finding-the-ompd}
\end{itemize}

\subsubsection{Event notification}
\label{ompd:event-notification}

Neither a tool nor an OpenMP runtime system know what
application code a program will launch as parallel regions
or tasks until the program invokes the runtime system and
provides a code address as an argument.
To help a tool control the execution of an OpenMP program
launching parallel regions or tasks,
the OpenMP runtime must define a number of symbols
through which execution must pass when particular events occur
\emph{and} data collection for OMPD is enabled.
These locations may, but do not have to, be subroutines,
They may, for example, be labeled locations.
The symbols must all have external, \code{C}, linkage.

A tool can gain notification of the event by planting a breakpoint
at the corresponding named location.

\subsubsubsection{Beginning Parallel Regions}
\label{ompd:ompd_bp_parallel_begin}
\index{ompd\_bp\_parallel\_begin@{\code{ompd\_bp\_parallel\_begin}}}

\summary
The OpenMP runtime must execute through
\code{ompd\_bp\_parallel\_begin} when a new parallel region is launched.

\vbox{
\cspecificstart
\begin{boxedcode}
void ompd\_bp\_parallel\_begin ( void );
\end{boxedcode}
\cspecificend
}

\descr

When starting a new parallel region, the runtime must allow execution
to flow through \code{ompd\_bp\_parallel\_begin}.
This should occur after a task encounters a parallel construct,
but before any implicit task starts to execute the parallel
region's work.

Control passes through \code{ompd\_bp\_parallel\_begin}
once per region, and not once for each thread per region.

At the point where the runtime reaches \code{ompd\_bp\_parallel\_begin},
a tool can map the encountering native thread to an OpenMP
thread handle using
\code{ompd\_get\_thread\_handle}.
At this point the handle returned by \code{ompd\_get\_current\_parallel\_handle}
is that of the new parallel region.
The tool can find the entry point of the user code that
the new parallel region will execute by passing the parallel handle region
to \code{ompd\_get\_parallel\_function}.

The actual number of threads, rather than the requested number of threads,
in the team is returned by
\code{ompd\_get\_num\_threads}.

The task handle returned by
\code{ompd\_get\_current\_task\_handle}
will be that of the task encountering the parallel construct.

The `reenter runtime' address in the information returned by
\code{ompd\_get\_task\_frame}
will be that of the stack frame where the thread called the OpenMP
runtime to handle the parallel construct.
The `exit runtime' address will be for the stack frame where the thread
left the OpenMP runtime to execute the user code that encountered
the parallel construct.

\restrictions

\code{ompd\_bp\_parallel\_begin} has external \code{C} linkage, and no
demangling or other transformations are required by a tool
to look up its address in the OpenMP program.

Conceptually \code{ompd\_bp\_parallel\_begin} has the type signature
given above.
However, it does not need to be a function, but can be a labeled location
in the runtime code.

\crossreferences

\begin{itemize}
\item
  \code{ompd\_get\_thread\_handle}, \specref{ompd:ompd_get_thread_handle}
\item
  \code{ompd\_get\_current\_parallel\_handle}, \specref{ompd:ompd_get_current_parallel_handle}
\item
  \code{ompd\_get\_parallel\_function}, \specref{ompd:ompd_get_parallel_function}
\item
  \code{ompd\_get\_num\_threads}, \specref{ompd:ompd_get_num_threads}
\item
  \code{ompd\_get\_current\_task\_handle}, \specref{ompd:ompd_get_current_task_handle}
\item
  \code{ompd\_get\_task\_frame}, \specref{ompd:ompd_get_task_frame}
\end{itemize}

\subsubsubsection{Ending Parallel Regions}
\label{ompd:ompd_bp_parallel_end}
\index{ompd\_bp\_parallel\_end@{\code{ompd\_bp\_parallel\_end}}}

The OpenMP runtime must execute through \code{ompd\_bp\_parallel\_end}
when a parallel region ends.

\vbox{
\cspecificstart
\begin{boxedcode}
void ompd\_bp\_parallel\_end ( void );
\end{boxedcode}
\cspecificend
}

\descr

When a parallel region finishes, the OpenMP runtime must allow execution
to flow through \code{ompd\_bp\_parallel\_end}.

Control passes through \code{ompd\_bp\_parallel\_end}
once per region, and not once for each thread per region.

At the point the runtime reaches \code{ompd\_bp\_parallel\_end}
the tool can map the encountering native thread
to an OpenMP thread handle using \code{ompd\_get\_thread\_handle}.
\code{ompd\_get\_current\_parallel\_handle}
returns the handle of the terminating parallel region.

\code{ompd\_get\_current\_task\_handle}
returns the handle of the task that encountered the
parallel construct that initiated the parallel region just
terminating.
The `reenter runtime' address in the frame information returned by
\code{ompd\_get\_task\_frame}
will be that for the stack frame in which the thread called the
OpenMP runtime to start the parallel construct just terminating.
The `exit runtime' address will refer to the stack frame where the
thread left the OpenMP runtime to execute the user code that
invoked the parallel construct just terminating.

\restrictions

\code{ompd\_bp\_parallel\_end} has external \code{C} linkage, and no
demangling or other transformations are required by a tool
to look up its address in the OpenMP program.

Conceptually \code{ompd\_bp\_parallel\_end} has the type signature
given above.
However, it does not need to be a function, but can be a labeled location
in the runtime code.

\crossreferences
\begin{itemize}
\item
  \code{ompd\_get\_thread\_handle}, \specref{ompd:ompd_get_thread_handle}
\item
  \code{ompd\_get\_current\_parallel\_handle}, \specref{ompd:ompd_get_current_parallel_handle}
\item
  \code{ompd\_get\_current\_task\_handle}, \specref{ompd:ompd_get_current_task_handle}
\item
  \code{ompd\_get\_task\_frame}, \specref{ompd:ompd_get_task_frame}
\end{itemize}


\subsubsubsection{Beginning Task Regions}
\label{ompd:ompd_bp_task_begin}
\index{ompd\_bp\_task\_begin@{\code{ompd\_bp\_task\_begin}}}

The OpenMP runtime must execute through \code{ompd\_bp\_task\_begin}
when a new task is started.

\vbox{
\cspecificstart
\begin{boxedcode}
void ompd\_bp\_task\_begin ( void );
\end{boxedcode}
\cspecificend
}

\descr

When starting a new task region, the OpenMP runtime system
must allow control to pass through \code{ompd\_bp\_task\_begin}.

The OpenMP runtime system will execute through this location after the task
construct is encountered, but before the new explicit task starts.
At the point where the runtime reaches \code{ompd\_bp\_task\_begin}
the tool can map the native thread to an OpenMP handle using
\code{ompd\_get\_thread\_handle}.

\code{ompd\_get\_current\_task\_handle} returns the handle of the new task region.
The entry point of the user code to be executed by the new task
is returned from
\code{ompd\_get\_task\_function}.

\restrictions

\code{ompd\_bp\_task\_begin} has external \code{C} linkage, and no
demangling or other transformations are required by a tool
to look up its address in the OpenMP program.

Conceptually \code{ompd\_bp\_task\_begin} has the type signature
given above.
However, it does not need to be a function, but can be a labeled location
in the runtime code.

\crossreferences
\begin{itemize}
\item
  \code{ompd\_get\_thread\_handle}, \specref{ompd:ompd_get_thread_handle}
\item
  \code{ompd\_get\_current\_task\_handle}, \specref{ompd:ompd_get_current_task_handle}
\item
  \code{ompd\_get\_task\_function}, \specref{ompd:ompd_get_task_function}
\end{itemize}

\subsubsubsection{Ending Task Regions}
\label{ompd:ompd_bp_task_end}
\index{ompd\_bp\_task\_end@{\code{ompd\_bp\_task\_end}}}

\summary
The OpenMP runtime must execute through \code{ompd\_bp\_task\_end}
when a task region ends.

\vbox{
\cspecificstart
\begin{boxedcode}
void ompd\_bp\_task\_end ( void );
\end{boxedcode}
\cspecificend
}

\descr

When a task region completes, the OpenMP runtime system
must allow execution to flow through the location \code{ompd\_bp\_task\_end}.

At the point where the runtime reaches \code{ompd\_bp\_task\_end}
the tool can use
\code{ompd\_get\_thread\_handle}
to map the encountering native thread to the corresponding
OpenMP thread handle.
At this point \code{ompd\_get\_current\_task\_handle}
returns the handle for the terminating task.

\restrictions

\code{ompd\_bp\_task\_end} has external \code{C} linkage, and no
demangling or other transformations are required by a tool
to look up its address in the OpenMP program.

Conceptually \code{ompd\_bp\_task\_end} has the type signature
given above.
However, it does not need to be a function, but can be a labeled location
in the runtime code.

\crossreferences
\begin{itemize}
\item
  \code{ompd\_get\_thread\_handle}, \specref{ompd:ompd_get_thread_handle}
\item
  \code{ompd\_get\_current\_task\_handle}, \specref{ompd:ompd_get_current_task_handle}
\end{itemize}


\subsection{Entry Points for OMPD defined in the OpenMP program}
%REDEFINITION \label{ompd:runtime-entry-points-for-ompd}

There is a small group of OpenMP entrypoints that are defined in
OpenMP program, rather than in the OpenMP runtime.
Unless otherwise stated, these entrypoints need not be defined
in a program, in which case default behavior will apply.

\subsubsection{Enabling Support for OMPD at Runtime}
\label{ompd:ompd_enable}
\index{ompd\_enable@{\code{ompd\_enable}}}

\summary
Instructs the OpenMP runtime to collect whatever information
is necessary for supporting access by tools using OMPD.

\vbox{
\cspecificstart
\begin{boxedcode}
int ompd_enable ( void );
\end{boxedcode}
\cspecificend
}

\descr

In some cases it may not be possible to control an OpenMP program's
environment to set the \code{OMPD\_ENABLED} variable so as to enable
data collection by the runtime for OMPD.
\code{ompd\_enable} allows an OpenMP process itself to turn on data collection.
Upon starting, the OpenMP runtime will check to see if the function
\code{ompd\_enable} is defined in the OpenMP program or any of
its dynamically-linked libraries.
If it is defined, the OpenMP runtime will call the function,
and if logical true (non-zero) is returned, it will enable data
collection to support external tools.
The function may be positioned in an otherwise empty DLL that the
programmer can link with the OpenMP program, thereby leaving
the program code unmodified.

\crossreferences
\begin{itemize}
\item
  \code{OMPD\_ENABLED}, \specref{sec:OMPD_ENABLED}
\item
  Enabling the Runtime for OMPD, \specref{ompd:enabling-ompd}
\end{itemize}
