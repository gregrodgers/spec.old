
\subsection{OMPD Tool Interface Routines}
\label{subsec:ompd-api}

\subsubsection{Per OMPD Library Initialization and Finalization}

The OMPD library must be initialized exactly once after it is loaded, and finalized exactly once
before it is unloaded. Per OpenMP process or core file initialization and finalization are also required. 
A tool starts the initialization by calling \code{ompd_initialize}. Once loaded, the 
tool can determine the version of the OMPD API supported by the plugin by 
calling \code{ompd_get_version}.

\subsubsubsection{\hcode{ompd_initialize}}
\label{subsubsubsec:ompd_initialize}

\summary
The \code{ompd_initialize} function initializes the OMPD library.

\format

\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_initialize(const ompd_callbacks_t *\plc{callbacks});
\end{ompSyntax}
\end{cspecific}

\descr
The above initialization is performed for each OMPD library that is loaded by an OMPD using tool. 
There may be more than one library present in a thid-party tool, such as a debugger, because the tool 
may be controlling a number of devices that may be using different runtime systems which require 
different OMPD libraries. This initialization must be performed exactly once before the tool
can begin operating on a OpenMP process or core file.
\argdesc
The tool provides the OMPD plugin with a set of callback functions in the \plc{callbacks} input argument
which enables the OMPD plugin to allocate and deallocate memory in the tool's address space, to lookup the 
sizes of basic primitive types in the device, to lookup symbols in the device, as well as to read and 
write memory in the device.

\crossreferences
\begin{itemize}
	\item
	\code{ompd_rc_t}, \specref{subsubsec:ompd_rc_t}
	\item
	\code{ompd_callbacks_t}, \specref{subsubsec:ompd_callbacks_t}
\end{itemize}

\subsubsubsection{\hcode{ompd_get_version}}
\label{subsubsubsec:ompd_get_version}

\summary
The \code{ompd_get_version} function returns the OMPD API version.

\format

\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_version(int *\plc{version});
\end{ompSyntax}
\end{cspecific}


\descr
The tool may call this function to obtain the version number of the OMPD plugin.

\argdesc
The version number is returned in to the location pointed to by the \plc{version} output argument 

\subsubsubsection{\hcode{ompd_get_version_string}}
\label{subsubsubsec:ompd_get_version_string}

\summary
The \code{ompd_get_version_string} function returns a descriptive string for the OMPD API version.

\format

\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_version_string(const char **\plc{string});
\end{ompSyntax}
\end{cspecific}


\descr
The tool may call this function to obtain a pointer to a descriptive version string of the OMPD plugin.

\argdesc
A pointer to a descriptive version string will be placed into the *\plc{string} output argument.
The string returned by the 
OMPD library is `owned' by the library, and it must not be modified or released by the tool.
It is guaranteed to remain valid for as long as the library is loaded. 
\code{ompd_get_version_string} 
may be called before \code{ompd_initialize}. Accordingly, the OMPD library must not use heap or 
stack memory for the string it returns to the tool.

The signatures of \code{ompd_get_version} and \code{ompd_get_version_string} are 
guaranteed not to change in future versions of the API. In contrast, the type definitions and 
prototypes in the rest of the API do not carry the same guarantee. Therefore an OMPD using tool 
should check the version of the API of a loaded OMPD library before calling any other function of 
the API.

\subsubsubsection{\hcode{ompd_finalize}}
\label{subsubsubsec:ompd_finalize}

\summary
When the tool is finished with the OMPD library it should call \code{ompd_finalize} before 
unloading the library.

\format

\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_finalize(void);
\end{ompSyntax}
\end{cspecific}


\descr
This must be the last call the tool makes to the library before
unloading it. The call to \code{ompd_finalize} gives the OMPD library a chance to
free up any remaining resources it may be holding.

The OMPD library may implement a \emph{finalizer} section. This will execute as the library is 
unloaded, and therefore after the tool's call to \code{ompd_finalize}. The OMPD library is allowed 
to use the callbacks (provided to it earlier by the tool after the call to 
\code{ompd_initialize}) during finalization.

\crossreferences
\begin{itemize}
	\item
	\code{ompd_rc_t}, \specref{subsubsec:ompd_rc_t}
\end{itemize}

\subsubsection{Per OpenMP Process Initialization and Finalization}

\subsubsubsection{\hcode{ompd_process_initialize}}
\label{subsubsubsec:ompd_process_initialize}
\summary
A tool obtains an address space handle when it initializes
a session on a live process or core file by calling \code{ompd_process_initialize}.

\format

\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_process_initialize(
  ompd_address_space_context_t *\plc{context},
  ompd_address_space_handle_t **\plc{handle}
);
\end{ompSyntax}
\end{cspecific}


\descr
On return from \code{ompd_process_initialize} the address
space handle is owned by the tool. This function must be called before any OMPD operations 
are performed on the OpenMP process. \code{ompd_process_initialize} gives the OMPD library an 
opportunity to confirm that it is capable of handling the OpenMP process or core file identified by 
the \code{context}. Incompatibility is signaled by a return value of \code{ompd_rc_incompatible}. 
On return, the handle is owned by the tool, which must release it using 
\code{ompd_release_address_space_handle}.

\argdesc
The input argument \plc{context} is an opaque handle provided by the tool
to address an address space.
On return the output argument \plc{handle} provides an opaque handle to the
tool for this address space, which the tool is responsible for 
releasing when it is no longer needed

\crossreferences
\begin{itemize}
	\item \code{ompd_address_space_context_t} type, see 
	\specref{subsubsec:ompd_address_space_context_t}.
	\item \code{ompd_address_space_handle_t} type, see 
	\specref{subsubsec:ompd_address_space_handle_t}.
\end{itemize}


\subsubsubsection{\hcode{ompd_device_initialize}}
\label{subsubsubsec:ompd_device_initialize}
\summary
A tool obtains an address space handle for a device that has
at least one active target region by calling
\code{ompd_device_initialize}.

\format

\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_device_initialize(
  ompd_address_space_handle_t *\plc{process_handle},
  ompd_address_space_context_t *\plc{device_context},
  omp_device_kind_t \plc{kind},
  ompd_size_t \plc{sizeof_id},
  void *\plc{id},
  ompd_address_space_handle_t **\plc{device_handle}
);
\end{ompSyntax}
\end{cspecific}


\descr
On return from \code{ompd_device_initialize} the address
space handle is owned by the tool.

\argdesc

The input argument \plc{process_handle} is an opaque handle provided by the tool
to reference the address space of the OpenMP process.
The input argument \plc{device_context} is an opaque handle provided by the tool
to reference a device address space.
The input arguments \plc{kind},  \plc{sizeof_id}, and \plc{id} represent a device identifier. 
On return the output argument \plc{device_handle} provides an opaque handle to the
tool for this address space.

\crossreferences
\begin{itemize}
	\item \code{ompd_address_space_context_t} type, see 
	\specref{subsubsec:ompd_address_space_context_t}.
	\item \code{omp_device_kind_t} type, see \specref{ompd:omp_device_kind_t}.
	\item \code{ompd_size_t} type, see \specref{subsubsubsec:ompd_size_t}.
	\item \code{ompd_address_space_handle_t} type, see 
	\specref{subsubsec:ompd_address_space_handle_t}.
\end{itemize}


\subsubsubsection{\hcode{ompd_release_address_space_handle}}
\label{subsubsubsec:ompd_release_address_space_handle}
\summary
A tool calls \code{ompd_release_address_space_handle} to release an address space 
handle.

\format

\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_release_address_space_handle(
  ompd_address_space_handle_t *\plc{handle}
);
\end{ompSyntax}
\end{cspecific}


\descr
When the tool is finished with the OpenMP process address space handle it
should call \code{ompd_release_address_space_handle} to release
the handle and give the OMPD library the opportunity to release
any resources it may have related to the address space.

\argdesc
The input argument \plc{handle} is an opaque handle for an address space
to be released.

\crossreferences	
\begin{itemize}
	\item \code{ompd_address_space_handle_t} type, see 
	\specref{subsubsec:ompd_address_space_handle_t}.
\end{itemize}

\subsubsection{Thread and Signal Safety}

The OMPD library does not need to be reentrant. It is the responsibility 
of the tool to ensure that only one thread enters the OMPD library at a time. The OMPD 
implementation must not install signal handlers or otherwise interfere with the tool's signal 
configuration.


\subsubsection{Available Processors and Threads}

\subsubsubsection{\hcode{ompd_get_num_procs}}
\label{subsubsubsec:ompd_get_num_procs}
\summary
The \code{ompd_get_num_procs} routine returns the number of processors
available on the entity identified by an address space handle.

\format

\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_num_procs (
  ompd_address_space_handle_t *\plc{handle},
  ompd_word_t *\plc{num_processors}
);
\end{ompSyntax}
\end{cspecific}


\descr
The \code{ompd_get_num_procs} routine returns the number of processors
available on the entity identified by an address space handle, and corresponds to the
\code{omp_get_num_procs} OpenMP runtime library routine.

\argdesc
The input argument \plc{handle} is an opaque handle for an address space;
the number of processors on the entity identified by the address space
handle is returned through the output argument \plc{num_processors}.
This operation corresponds to the OpenMP runtime function
\code{omp_get_num_procs} that an OpenMP program can call.

\crossreferences	
\begin{itemize}
	\item \code{ompd_address_space_handle_t} type, see \specref{subsubsec:ompd_address_space_handle_t}.
	\item \code{omp_get_num_procs}, see \specref{subsec:omp_get_num_procs}.
\end{itemize}

\subsubsubsection{\hcode{ompd_get_thread_limit}}
\label{subsubsubsec:ompd_get_thread_limit}
\summary
The \code{ompd_get_thread_limit} routine returns the maximum
number of OpenMP threads available on the entity identified by
an address space handle.

\format

\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_thread_limit (
  ompd_address_space_handle_t *\plc{handle},
  ompd_word_t *\plc{num_threads}
);
\end{ompSyntax}
\end{cspecific}


\descr
The \code{ompd_get_thread_limit} routine returns the maximum
number of OpenMP threads available on the entity identified by
an address space handle, and corresponds to the \code{omp_get_thread_limit} OpenMP
runtime library routine.

\argdesc
The input argument \plc{handle} is an opaque handle for an address space;
the maximum number of OpenMP threads on the entity identified by the
address space handle is returned through the output argument \plc{num_threads}.
This operation corresponds to the OpenMP runtime function
\code{omp_get_thread_limit} that an OpenMP program can call.

\crossreferences	
\begin{itemize}
	\item \code{ompd_address_space_handle_t} type, see \specref{subsubsec:ompd_address_space_handle_t}.
	\item \code{omp_get_thread_limit}, see \specref{subsec:omp_get_thread_limit}.
\end{itemize}


\subsubsection{Thread Handles}

\subsubsubsection{\hcode{ompd_get_thread_in_parallel}}
\label{subsubsubsec:ompd_get_thread_in_parallel}
\summary
The  \code{ompd_get_thread_in_parallel} operation enables a tool to obtain handles for 
OpenMP threads associated with a parallel region.

\format

\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_thread_in_parallel(
  ompd_parallel_handle_t *\plc{parallel_handle},
  int \plc{nth_handle},
  ompd_thread_handle_t **\plc{thread_handle}
);
\end{ompSyntax}
\end{cspecific}


\descr
A successful invocation of  \code{ompd_get_thread_in_parallel} returns a pointer to 
a thread handle in \code{*thread_handle}. 
This call yields meaningful results only if all OpenMP threads in the parallel 
region are stopped.

\argdesc
The input argument \plc{parallel_handle} is an opaque handle for a parallel region
 and selects the parallel region to operate on.
The input argument \code{nth_handles} selects the thread of the team to be returned. 
On return the output argument \plc{thread_handle} is an opaque handle for the selected thread.

\restrictions
The value of \code{nth_handles} must be a non-negative integer smaller than the
team size returned by a call to \code{ompd_get_num_threads}.

\crossreferences
\begin{itemize}
	\item \code{ompd_parallel_handle_t} type, see \specref{subsubsec:ompd_parallel_handle_t}.
	\item \code{ompd_thread_handle_t} type, see \specref{subsubsec:ompd_thread_handle_t}.
\end{itemize}

% SUBSUMED by  ompd_get_thread_in_parallel
%
%
%\subsubsubsection{\hcode{ompd_get_master_thread_in_parallel}}
\label{subsubsubsec:ompd_get_master_thread_in_parallel}
%\summary
%The  \code{ompd_get_master_thread_in_parallel} operation
%enables a tool to obtain a handle for the OpenMP master thread in a parallel region. 
%
%\format
%
%\begin{ccppspecific}
%\begin{ompSyntax}
%ompd_rc_t ompd_get_master_thread_in_parallel(
%  ompd_parallel_handle_t *\plc{parallel_handle},
%  ompd_thread_handle_t **\plc{thread_handle}   
%);
%\end{ompSyntax}
%\end{ccppspecific}
%
%
%\descr
%A successful invocation of \code{ompd_get_master_thread_in_parallel} returns a handle
%for the thread that encountered the parallel construct. This call yields meaningful results only if an 
%OpenMP thread in the parallel region is stopped; otherwise, the parallel region is not guaranteed to 
%be alive. 
%
%On success \code{ompd_get_master_thread_in_parallel} returns \code{ompd_rc_ok}.
%A pointer to the thread handle is returned in \code{*thread_handle}. After the call the thread 
%handle is owned by the tool, which must release it when it is no longer required by calling
%\code{ompd_release_thread_handle}.
%
%\argdesc
%The input argument \plc{parallel_handle} is an opaque handle for the parallel team.
%The input argument \code{nth_handles} selects the thread of the team to be returned. 
%On return the output argument \plc{thread_handle} is an opaque handle for the selected thread.
%
%\crossreferences
%\begin{itemize}
%	\item \code{ompd_parallel_handle_t} type, see \specref{subsubsec:ompd_parallel_handle_t}.
%	\item \code{ompd_thread_handle_t} type, see \specref{subsubsec:ompd_thread_handle_t}.
%\end{itemize}


\subsubsubsection{\hcode{ompd_get_thread_handle}}
\label{subsubsubsec:ompd_get_thread_handle}
\summary
Mapping a native thread to an OMPD thread handle.
\format
\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_thread_handle(
  ompd_address_space_handle_t *\plc{handle},
  ompd_thread_id_kind_t \plc{kind},
  ompd_size_t \plc{sizeof_thread_id},
  const void *\plc{thread_id},
  ompd_thread_handle_t **\plc{thread_handle}
);
\end{ompSyntax}
\end{cspecific}

\descr
OMPD provides the function \code{ompd_get_thread_handle}
to inquire whether a native thread is an OpenMP
thread or not.
%If the function returns \code{ompd_rc_ok},
On success, the thread identifier is an OpenMP thread and \code{*thread_handle}
is initialized to a pointer to the thread handle for the OpenMP thread.

\argdesc


The input argument \plc{handle} is an opaque handle provided by the tool
to reference to an address space.
The input arguments \plc{kind},  \plc{sizeof_thread_id}, and \plc{thread_id} represent a
thread identifier. 
On return the output argument \plc{thread_handle} provides an opaque handle to the
tool for thread within the provided address space.

The thread identifier \plc{*thread_id} is guaranteed to be valid for the duration of the call. If the 
OMPD library needs to retain the thread identifier it must copy it.

%\The thread handle \plc{*thread_handle} returned by the OMP implementation
%is `owned' by the debugger, which must release it by calling
%\code{ompd_release_thread_handle}.
%If \plc{os_thread} does not refer to an OpenMP thread,
%\code{ompd_get_thread_handle} returns \code{ompd_rc_bad_input}
%and \plc{*thread_handle} is also set to NULL.




\crossreferences
\begin{itemize}
	\item \code{ompd_address_space_handle_t} type, see \specref{subsubsec:ompd_address_space_handle_t}.
	\item \code{ompd_thread_id_kind_t} type, see \specref{ompd:ompd_thread_id_kind_t}.
	\item \code{ompd_size_t} type, see \specref{subsubsubsec:ompd_size_t}.
	\item \code{ompd_thread_handle_t} type, see \specref{subsubsec:ompd_thread_handle_t}.
\end{itemize}

\subsubsubsection{\hcode{ompd_release_thread_handle}}
\label{subsubsubsec:ompd_release_thread_handle}
\summary
This operation releases a thread handle.

\format

\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_release_thread_handle(
  ompd_thread_handle_t *\plc{thread_handle}
);
\end{ompSyntax}
\end{cspecific}


\descr
Thread handles are opaque to tools, which therefore cannot release them directly.
Instead, when the tool is finished with a thread handle it must pass it to the OMPD 
\code{ompd_release_thread_handle} routine for disposal.

\argdesc
The input argument \plc{thread_handle} is an opaque handle for a thread
to be released.

\crossreferences
\begin{itemize}
	\item \code{ompd_thread_handle_t} type, see \specref{subsubsec:ompd_thread_handle_t}.
\end{itemize}


\subsubsubsection{\hcode{ompd_thread_handle_compare}}
\label{subsubsubsec:ompd_thread_handle_compare}
\summary
The \code{ompd_thread_handle_compare} operation allows tools to compare 
two thread handles.

\format

\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_thread_handle_compare(
  ompd_thread_handle_t *\plc{thread_handle_1},
  ompd_thread_handle_t *\plc{thread_handle_2},
  int *\plc{cmp_value}
);
\end{ompSyntax}
\end{cspecific}


\descr
The internal structure of thread handles is opaque to a tool. While the tool can easily compare 
pointers to thread handles, it cannot determine whether handles of two different addresses
refer to the same underlying thread. This function can be used to compare thread handles.

On success, \code{ompd_thread_handle_compare} returns in \code{*cmp_value} a signed 
integer value that indicates how the underlying threads compare: a value less than, equal to, or 
greater than 0 indicates that the thread corresponding to \code{thread_handle_1} is, respectively, 
less than, equal to, or greater than that corresponding to \code{thread_handle_2}.

%\begin{notes}
%	ilaguna: do we need to give intuition about what we mean by thread1 < thread2 
%	(or vice versa)? Will the OMPD DLL maintain a total order or a partial order of 
%	thread handles? If thread1 < thread2, and thread2 < thread3, is thread1 < 
%	thread3 or can thread1 > thread3?
%\end{notes}

% JP: rationale, so dropped
%For OMPD libraries that always have a single, unique, underlying thread handle for a given 
%thread, this operation reduces to a simple comparison of the pointers. However, other 
%implementations may take a different approach, and therefore the only reliable way of determining 
%whether two different pointers to thread handles refer the same or distinct threads is to use
%\code{ompd_thread_handle_compare}.
%
%Allowing thread handles to be compared allows the tool to hold them in ordered collections.
%The means by which thread handles are ordered is implementation-defined.

\argdesc
The input arguments \plc{thread_handle_1} and \plc{thread_handle_2} are opaque handles for threads.
On return the output argument \plc{cmp_value} is set to a signed integer value.

\crossreferences
\begin{itemize}
	\item \code{ompd_thread_handle_t} type, see \specref{subsubsec:ompd_thread_handle_t}.
\end{itemize}

\subsubsubsection{\hcode{ompd_get_thread_handle_string_id}}
\label{subsubsubsec:ompd_get_thread_handle_string_id}
\summary
The \code{ompd_get_thread_handle_string_id} function returns a string
that contains a unique printable value that identifies the thread.

\format

\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_thread_handle_string_id(
  ompd_thread_handle_t *\plc{thread_handle},
  char **\plc{string_id}
);
\end{ompSyntax}
\end{cspecific}


\descr
The string that is returned by the function should be a single sequence of alphanumeric or 
underscore characters, and NULL terminated.
%\begin{notes}
%	ilaguna: Why allowing only alphanumeric or underscore characters? As an 
%	implementer I may want to use colon or slash characters for more structured 
%	names.
%\end{notes}

The OMPD library allocates the string returned in \code{*string_id} using the allocation 
routine in the callbacks passed to it during initialization. On return the string is owned by the 
tool, which is responsible for deallocating it. The contents of the strings returned for thread 
handles which compare as equal with \code{ompd_thread_handle_compare} must be the same.

\argdesc
The input argument \plc{thread_handle} is an opaque handle for a thread  and selects the thread to operate on.
On return the output argument \plc{string_id} is set to a string representation of the thread.


\crossreferences
\begin{itemize}
	\item \code{ompd_thread_handle_t} type, see \specref{subsubsec:ompd_thread_handle_t}.
\end{itemize}

\subsubsubsection{\hcode{ompd_get_thread_id}}
\label{subsubsubsec:ompd_get_thread_id}
\summary
Mapping an OMPD thread handle to a native thread.

\newpage %% HACK
\format
\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_thread_id(
  ompd_thread_handle_t *\plc{thread_handle},
  ompd_thread_id_kind_t \plc{kind},
  ompd_size_t \plc{sizeof_thread_id},
  void *\plc{thread_id}
);
\end{ompSyntax}
\end{cspecific}

\descr
\code{ompd_get_thread_id} performs the mapping between an OMPD
thread handle and a thread identifier.

\argdesc

The input argument \plc{thread_handle} is an opaque thread handle.
The input argument  \plc{kind} represents the thread
identifier. The input argument \plc{sizeof_thread_id} represents the size of the 
thread identifier. The output argument \plc{thread_id} is a buffer that represents a thread identifier.

%It also passes a pointer to the buffer into which the OMPD
%implementation writes the operating system-specific thread identifier,
%and the size of the buffer, to the OMPD library.
%The buffer is owned by the debugger.

%On success \code{ompd_get_thread_id} returns \code{rc_ok},
%and returns the operating system-specific thread identifier in
%\plc{*thread_id}.
%If the operation fails, the OMPD library returns
%the appropriate value from \code{ompd_rc_t}.
%Note that the operation should fail if the OMPD library is
%unable to return an operating system-specific identifier of the
%requested `kind' or size.

\crossreferences
\begin{itemize}
	\item \code{ompd_thread_handle_t} type, see \specref{subsubsec:ompd_thread_handle_t}.
	\item \code{ompd_thread_id_kind_t} type, see \specref{ompd:ompd_thread_id_kind_t}.
	\item \code{ompd_size_t} type, see \specref{subsubsubsec:ompd_size_t}.
\end{itemize}

\subsubsection{Parallel Region Handles}

\subsubsubsection{\hcode{ompd_get_current_parallel_handle}}
\label{subsubsubsec:ompd_get_current_parallel_handle}
\summary
The  \code{ompd_get_current_parallel_handle} operation enables the tool to obtain a pointer to 
the parallel handle for the current parallel region associated with an OpenMP thread.

\format

\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_current_parallel_handle(
  ompd_thread_handle_t *\plc{thread_handle},
  ompd_parallel_handle_t **\plc{parallel_handle}
);
\end{ompSyntax}
\end{cspecific}


\descr
This call is meaningful only if the thread whose handle is provided is stopped. The parallel handle 
must be released by calling \code{ompd_release_parallel_handle}.

\argdesc
The input argument \plc{thread_handle} is an opaque handle for a thread and selects the thread to operate on.
On return the output argument \plc{parallel_handle} is set to a handle for the parallel region
currently executing on this thread if there is any.

\crossreferences
\begin{itemize}
	\item \code{ompd_thread_handle_t} type, see \specref{subsubsec:ompd_thread_handle_t}.
	\item \code{ompd_parallel_handle_t} type, see \specref{subsubsec:ompd_parallel_handle_t}.
\end{itemize}

\subsubsubsection{\hcode{ompd_get_enclosing_parallel_handle}}
\label{subsubsubsec:ompd_get_enclosing_parallel_handle}
\summary
The  \code{ompd_get_enclosing_parallel_handle}  operation enables a tool to obtain a 
pointer to the parallel handle for the parallel region enclosing the parallel region specified by 
\code{parallel_handle}.

\format

\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_enclosing_parallel_handle(
  ompd_parallel_handle_t *\plc{parallel_handle},
  ompd_parallel_handle_t **\plc{enclosing_parallel_handle}
);
\end{ompSyntax}
\end{cspecific}


\descr
This call is meaningful only if at least one thread in the parallel region is stopped.
%On success 
%\code{ompd_get_enclosing_parallel_handle} returns \code{ompd_rc_ok}.
A pointer to the parallel handle for the enclosing region is returned in 
\code{*enclosing_parallel_handle}. After the call the handle is owned by the tool, which must 
release it when it is no longer required by calling \code{ompd_release_parallel_handle}.

\argdesc
The input argument \plc{parallel_handle} is an opaque handle for a parallel region and selects the parallel region to operate on.
On return the output argument \plc{parallel_handle} is set to a handle for the parallel region
enclosing the selected parallel region.

\crossreferences
\begin{itemize}
	\item \code{ompd_parallel_handle_t} type, see \specref{subsubsec:ompd_parallel_handle_t}.
\end{itemize}

\subsubsubsection{\hcode{ompd_get_task_parallel_handle}}
\label{subsubsubsec:ompd_get_task_parallel_handle}
\summary
The  \code{ompd_get_task_parallel_handle}  operation enables a tool to obtain a 
pointer to the parallel handle for the parallel region enclosing the task region specified by 
\code{task_handle}.

\format

\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_task_parallel_handle(
  ompd_task_handle_t *\plc{task_handle},
  ompd_parallel_handle_t **\plc{task_parallel_handle}
);
\end{ompSyntax}
\end{cspecific}


\descr
This call is meaningful only if at least one thread in the parallel region is stopped.
%On success 
%\code{ompd_get_task_parallel_handle} returns \code{ompd_rc_ok}.
A pointer to the parallel regions handle is returned in \code{*task_parallel_handle}.
The parallel handle is owned by the 
tool, which must release it by calling \code{ompd_release_parallel_handle}.

\argdesc
The input argument \plc{task_handle} is an opaque handle for a task and selects the task to operate on.
On return the output argument \plc{parallel_handle} is set to a handle for the parallel region
enclosing the selected task.

\crossreferences
\begin{itemize}
	\item \code{ompd_task_handle_t} type, see \specref{subsubsec:ompd_task_handle_t}.
	\item \code{ompd_parallel_handle_t} type, see \specref{subsubsec:ompd_parallel_handle_t}.
\end{itemize}

\subsubsubsection{\hcode{ompd_release_parallel_handle}}
\label{subsubsubsec:ompd_release_parallel_handle}
\summary
This operation allows releasing a parallel region handle.

\format

\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_release_parallel_handle(
  ompd_parallel_handle_t *\plc{parallel_handle}
);
\end{ompSyntax}
\end{cspecific}


\descr
Parallel region handles are opaque to the tool, which therefore
cannot release them directly. Instead, when the tool is finished with a parallel region handle
it must must pass it to the OMPD \code{ompd_release_parallel_handle}
routine for disposal.

\argdesc
The input argument \plc{parallel_handle} is an opaque handle for a parallel region
to be released.

\crossreferences
\begin{itemize}
	\item \code{ompd_parallel_handle_t} type, see \specref{subsubsec:ompd_parallel_handle_t}.
\end{itemize}

\subsubsubsection{\hcode{ompd_parallel_handle_compare}}
\label{subsubsubsec:ompd_parallel_handle_compare}
\summary
The \code{ompd_parallel_handle_compare} operation allows a tool to compare two 
parallel region handles.

\format

\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_parallel_handle_compare(
  ompd_parallel_handle_t *\plc{parallel_handle_1},
  ompd_parallel_handle_t *\plc{parallel_handle_2},
  int *\plc{cmp_value}
);
\end{ompSyntax}
\end{cspecific}


\descr
The internal structure of parallel region handles is opaque to the tool. While the tool can easily 
compare pointers to parallel region handles, it cannot determine whether handles at two different 
addresses refer to the same underlying parallel region.

On success, \code{ompd_parallel_handle_compare} returns in \code{*cmp_value} a signed 
integer value that indicates how the underlying parallel regions compare: a value less than, equal 
to, or greater than 0 indicates that the region corresponding to \code{parallel_handle_1} is,
respectively, less than, equal to, or greater than that corresponding to \code{parallel_handle_2}.

For OMPD libraries that always have a single, unique, underlying parallel region handle for 
a given parallel region, this operation reduces to a simple comparison of the pointers. However, 
other implementations may take a different approach, and therefore the only reliable way of 
determining whether two different pointers to parallel regions handles refer the same or distinct
parallel regions is to use \code{ompd_parallel_handle_compare}.

Allowing parallel region handles to be compared allows the tool to hold them in ordered 
collections. The means by which parallel region handles are ordered is implementation-defined.

\argdesc

The input arguments \plc{parallel_handle_1} and \plc{parallel_handle_2} are opaque handles 
corresponding to parallel regions.
On return the output argument \plc{cmp_value}  returns a signed 
integer value that indicates how the underlying parallel regions compare.

\crossreferences
\begin{itemize}
	\item \code{ompd_parallel_handle_t} type, see \specref{subsubsec:ompd_parallel_handle_t}.
\end{itemize}

\subsubsubsection{\hcode{ompd_get_parallel_handle_string_id}}
\label{subsubsubsec:ompd_get_parallel_handle_string_id}
\summary
The \code{ompd_get_parallel_handle_string_id} function returns a string that contains a unique 
printable value that identifies the parallel region.

\format

\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_parallel_handle_string_id(
  ompd_parallel_handle_t *\plc{parallel_handle},
  char **\plc{string_id}
);
\end{ompSyntax}
\end{cspecific}


\descr
The returned string should be a single sequence of alphanumeric or underscore characters, and 
NULL terminated. The OMPD library allocates the string returned in \code{*string_id}
using the allocation routine in the callbacks passed to it during initialization. On return the string is 
owned by the tool, which is responsible for deallocating it.

The contents of the strings returned for parallel regions handles which compare as equal with
\code{ompd_parallel_handle_compare} must be the same.

\argdesc
The input argument \plc{parallel_handle} is an opaque handle for a parallel region and selects the parallel region to operate on.
On return the output argument \plc{string_id} is set to a string representation of the parallel region.

\crossreferences
\begin{itemize}
	\item \code{ompd_parallel_handle_t} type, see \specref{subsubsec:ompd_parallel_handle_t}.
\end{itemize}

\subsubsection{Task Handles}

\subsubsubsection{\hcode{ompd_get_current_task_handle}}
\label{subsubsubsec:ompd_get_current_task_handle}
\summary
A tool uses the \code{ompd_get_current_task_handle} operation to obtain a pointer to the 
task handle for the current task region associated with an OpenMP thread.

\format

\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_current_task_handle(
  ompd_thread_handle_t *\plc{thread_handle},
  ompd_task_handle_t **\plc{task_handle}
);
\end{ompSyntax}
\end{cspecific}


\descr
This call is meaningful only if the thread whose handle is provided is stopped.
The task handle must be released by calling \code{ompd_release_task_handle}.

\argdesc
The input argument \plc{thread_handle} is an opaque handle for a thread and selects the thread to operate on.
On return the output argument \plc{task_handle} is set to a handle for the task
currently executing on the thread.

\crossreferences
\begin{itemize}
	\item \code{ompd_thread_handle_t} type, see \specref{subsubsec:ompd_thread_handle_t}.
	\item \code{ompd_task_handle_t} type, see \specref{subsubsec:ompd_task_handle_t}.
\end{itemize}

% ilaguna: I'm not sure where to place this text.
\littleheader{Retrieve the handle for an enclosing task.}
The OMPD API includes operations to obtain the handle of the parent of a task represented by a 
given task handle. There are two notions of parenthood. The \emph{scheduling} parent task is the 
task that was active when the child task was scheduled to run. The \emph{generating} is the task 
that encountered the OpenMP that caused the child task to be created.

The generating and scheduling parents need not be the same. This might happen if the thread 
executing a task encounters an OpenMP construct. When this happens, the thread will enter the 
runtime. The runtime will set up the tasks to implement the OpenMP program construct, and then 
call its schedular to choose a task to execute. If the scheduler chooses a task other than one of 
these newly created tasks to run, the scheduling parent of the selected task will not be the same 
as its generating parent. The former is the task that the thread was executing most recently,
and from which it entered the runtime. The later is the task which encountered the OpenMP 
construct it is executing.

\subsubsubsection{\hcode{ompd_get_generating_ancestor_task_handle}}
\label{subsubsubsec:ompd_get_generating_ancestor_task_handle}
\summary
A tool uses \code{ompd_get_generating_ancestor_task_handle} to obtain
a pointer to the task handle for the task that encountered the OpenMP construct which caused the 
task represented by \code{task_handle} to be created.

\format

\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_generating_ancestor_task_handle(
  ompd_task_handle_t *\plc{task_handle},
  ompd_task_handle_t **\plc{parent_task_handle}
);
\end{ompSyntax}
\end{cspecific}


\descr
This call is meaningful only if the thread executing the task specified by
\verb|task_handle|  is stopped.

\argdesc
The input argument \plc{task_handle} is an opaque handle for a task and selects the task to operate on.
On return the output argument \plc{task_handle} is set to a handle for the task
that created the selected task.

\crossreferences
\begin{itemize}
	\item \code{ompd_task_handle_t} type, see \specref{subsubsec:ompd_task_handle_t}.
\end{itemize}


\subsubsubsection{\hcode{ompd_get_scheduling_ancestor_task_handle}}
\label{subsubsubsec:ompd_get_scheduling_ancestor_task_handle}
\summary
The \code{ompd_get_scheduling_ancestor_task_handle} returns the
scheduling parent of the task represented \code{task_handle}.

\format

\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_scheduling_ancestor_task_handle(
  ompd_task_handle_t *\plc{task_handle},
  ompd_task_handle_t **\plc{parent_task_handle}
);
\end{ompSyntax}
\end{cspecific}


\descr
In this operation, the scheduling parent task is the OpenMP task that was active when
the child task was scheduled. This call is meaningful only if the thread executing the task specified 
by \code{task_handle}  is stopped. The parent task handle must be released by calling 
\code{ompd_release_task_handle}.

\argdesc
The input argument \plc{task_handle} is an opaque handle for a task and selects the task to operate on.
On return the output argument \plc{parent_task_handle} is set to a handle for the task that is 
still on the stack of execution on the same thread and was deferred in favor of executing the selected task.

\crossreferences
\begin{itemize}
	\item \code{ompd_task_handle_t} type, see \specref{subsubsec:ompd_task_handle_t}.
\end{itemize}

\subsubsubsection{\hcode{ompd_get_implicit_task_in_parallel}}
\label{subsubsubsec:ompd_get_implicit_task_in_parallel}
\summary
The \code{ompd_get_implicit_task_in_parallel}  operation enables a tool to obtain a 
vector of pointers to task handles for all implicit tasks associated with a parallel region.

\format

\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_implicit_task_in_parallel(
  ompd_parallel_handle_t *\plc{parallel_handle},
  ompd_task_handle_t ***\plc{task_handle_vector},
  int *\plc{num_handles}
);
\end{ompSyntax}
\end{cspecific}


\descr
This call is meaningful only if all threads associated with the parallel region are stopped.
The OMPD library must use the memory allocation callback to obtain the memory for the vector of 
pointers to task handles returned by the operation. If the OMPD library needs to allocate 
heap memory for the task handles it returns, it must use the callbacks to acquire this memory.
After the call the vector and the task handles are `owned' by the tool, which is responsible for 
deallocating them. The task handles must be released calling \code{ompd_release_task_handle}.
The vector was allocated by the OMPD library using the
allocation routine passed to it during the call to \code{ompd_initialize}.
The tool itself must deallocate the vector in a compatible manner.

\argdesc
The input argument \plc{parallel_handle} is an opaque handle for a parallel region and selects the parallel region to operate on.
On return the output argument \plc{task_handle} is set to a handle for the implicit task
executing on \plc{nth} thread of the parallel region.

\crossreferences
\begin{itemize}
	\item \code{ompd_parallel_handle_t} type, see \specref{subsubsec:ompd_parallel_handle_t}.
	\item \code{ompd_task_handle_t} type, see \specref{subsubsec:ompd_task_handle_t}.
\end{itemize}

\subsubsubsection{\hcode{ompd_release_task_handle}}
\label{subsubsubsec:ompd_release_task_handle}
\summary
This operation releases a task handle.

\format

\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_release_task_handle(
  ompd_task_handle_t *\plc{task_handle}
);
\end{ompSyntax}
\end{cspecific}


\descr
Task handles are opaque to the tool, which therefore cannot release
them directly. Instead, when the tool is finished with a task handle it must
pass it to the OMPD \code{ompd_release_task_handle} routine
for disposal.

\argdesc
The input argument \plc{task_handle} is an opaque handle for a task
to be released.

\crossreferences
\begin{itemize}
	\item \code{ompd_task_handle_t} type, see \specref{subsubsec:ompd_task_handle_t}.
\end{itemize}


\subsubsubsection{\hcode{ompd_task_handle_compare}}
\label{subsubsubsec:ompd_task_handle_compare}
\summary
The \code{ompd_task_handle_compare} operations allows a tool to compare task 
handles.

\format

\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_task_handle_compare(
  ompd_task_handle_t *\plc{task_handle_1},
  ompd_task_handle_t *\plc{task_handle_2},
  int *\plc{cmp_value}
);
\end{ompSyntax}
\end{cspecific}


\descr
The internal structure of task handles is opaque to the tool. While the tool can easily compare 
pointers to task handles, it cannot determine whether handles at two different addresses refer
to the same underlying task.

On success, \code{ompd_task_handle_compare} returns in \code{*cmp_value} a signed integer 
value that indicates how the underlying tasks compare: a value less than, equal to, or greater than 
0 indicates that the task corresponding to \plc{task_handle_1} is, respectively, less than, equal 
to, or greater than that corresponding to \plc{task_handle_2}.

For OMPD libraries that always have a single, unique, underlying task handle for a given 
task, this operation reduces to a simple comparison of the pointers. However, other 
implementations may take a different approach, and therefore the only reliable way of determining 
whether two different pointers to task handles refer the same or distinct task is to use 
\code{ompd_task_handle_compare}.

Allowing task handles to be compared allows the tool to hold them in ordered collections.
The means by which task handles are ordered is implementation-defined.

\argdesc
The input arguments \plc{task_handle_1} and \plc{task_handle_2} are opaque handles 
corresponding to tasks.
On return the output argument \plc{cmp_value}  returns a signed 
integer value that indicates how the underlying tasks compare.

\crossreferences
\begin{itemize}
	\item \code{ompd_task_handle_t} type, see \specref{subsubsec:ompd_task_handle_t}.
\end{itemize}

\subsubsubsection{\hcode{ompd_get_task_handle_string_id}}
\label{subsubsubsec:ompd_get_task_handle_string_id}
\summary
The \code{ompd_get_task_handle_string_id} function returns a string that contains a unique 
printable value that identifies the task.

\format

\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_task_handle_string_id (
  ompd_task_handle_t *\plc{task_handle},
  char **\plc{string_id}
);
\end{ompSyntax}
\end{cspecific}


\descr
The returned string should be a single sequence of alphanumeric or underscore characters, and 
NULL terminated. The OMPD library allocates the string returned in \code{*string_id}
using the allocation routine in the callbacks passed to it during initialization. On return the string is 
owned by the tool, which is responsible for deallocating it.

The contents of the strings returned for task handles which compare as equal with
\code{ompd_task_handle_compare} must be the same.

\argdesc
The input argument \plc{thread_handle} is an opaque handle for a task and selects the task to operate on.
On return the output argument \plc{string_id} is set to a string representation of the task.

\crossreferences
\begin{itemize}
	\item \code{ompd_task_handle_t} type, see \specref{subsubsec:ompd_task_handle_t}.
\end{itemize}



\subsubsubsection{\hcode{ompd_get_num_threads}}
\label{subsubsubsec:ompd_get_num_threads}
\summary
Determine the number of threads associated with a parallel region.

\format
\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_num_threads(
  ompd_parallel_handle_t *\plc{parallel_handle},
  ompd_word_t *\plc{val}
);
\end{ompSyntax}
\end{cspecific}

\descr

\argdesc
The input argument \plc{parallel_handle} is an opaque handle for a parallel region and selects the parallel region to operate on.
On return the output argument \plc{val} is set to the value that \code{omp_get_num_threads} would return when
executed in this parallel region.

\crossreferences
\begin{itemize}
	\item \code{ompd_parallel_handle_t} type, see \specref{subsubsec:ompd_parallel_handle_t}.
	\item \code{ompd_word_t} type, see \specref{subsubsubsec:ompd_word_t}.
\end{itemize}

\subsubsubsection{\hcode{ompd_get_parallel_function}}
\label{subsubsubsec:ompd_get_parallel_function}
\summary
Returns the entry point of a parallel region.

\format
\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_parallel_function (
  ompd_parallel_handle_t *\plc{parallel_handle},
  ompd_address_t *\plc{entry_point}
);
\end{ompSyntax}
\end{cspecific}

\descr

\argdesc
The input argument \plc{parallel_handle} is an opaque handle for a
parallel region, and selects the parallel region to operate on.
On return,  the output argument \plc{entry_point} is set to the
entry point of the code that corresponds to the body of the parallel
construct.

\crossreferences
\begin{itemize}
	\item \code{ompd_parallel_handle_t} type, see \specref{subsubsec:ompd_parallel_handle_t}.
	\item \code{ompd_address_t} type, see \specref{subsubsubsec:ompd_address_t}.
\end{itemize}


\subsubsubsection{\hcode{ompd_get_level}}
\label{subsubsubsec:ompd_get_level}
\summary
Determine the nesting depth of a particular parallel region.

\format
\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_level (
  ompd_task_handle_t *\plc{task_handle},
  ompd_word_t *\plc{val}
);
\end{ompSyntax}
\end{cspecific}

\descr
\code{ompd_get_level} returns the number of nested
parallel regions enclosing the parallel region specified by its handle.

\argdesc
The input argument \plc{task_handle} is an opaque handle for a task and selects the task to operate on.
On return the output argument \plc{val} is set to the value that \code{omp_get_level} would return 
when executed in this task.


\crossreferences
\begin{itemize}
	\item \code{ompd_task_handle_t} type, see \specref{subsubsec:ompd_task_handle_t}.
	\item \code{ompd_word_t} type, see \specref{subsubsubsec:ompd_word_t}.
\end{itemize}


\subsubsubsection{\hcode{ompd_get_active_level}}
\label{subsubsubsec:ompd_get_active_level}
\summary
Determine the number of enclosing  parallel regions.

\format
\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_active_level(
  ompd_task_handle_t *\plc{task_handle},
  ompd_word_t *\plc{val}
);
\end{ompSyntax}
\end{cspecific}

\descr
\code{ompd_get_active_level} returns the number of nested, active
parallel regions enclosing the parallel region specified by its handle.

\argdesc
The input argument \plc{task_handle} is an opaque handle for a task and selects the task to operate on.
On return the output argument \plc{val} is set to the value that \code{omp_get_active_level} would return when
executed in this task.

\crossreferences
\begin{itemize}
	\item \code{ompd_task_handle_t} type, see \specref{subsubsec:ompd_task_handle_t}.
	\item \code{ompd_word_t} type, see \specref{subsubsubsec:ompd_word_t}.
\end{itemize}

%JP: Basically, there isn't the parallel function, look for the task function of the implicit task.
%
%\subsubsubsection{\hcode{ompd_get_parallel_function}}
%\summary
%Parallel Function Entry Point
%\format
%\begin{cspecific}
%\begin{ompSyntax}
%ompd_rd_t ompd_get_parallel_function(
%  ompd_parallel_handle_t *\plc{parallel_handle},
%  ompd_address_t *\plc{entry_point}                             
%);
%\end{ompSyntax}
%\end{cspecific}
%
%\descr
%The \code{ompd_get_parallel_function} returns the
%entry point of the code that corresponds to the body of
%the parallel construct.
%\argdesc
%The input argument \plc{task_handle} is an opaque handle for a task and selects the task to operate on.
%On return the output argument \plc{val} is set to the value that \code{omp_get_level} would return when
%executed in this task.
%
%\crossreferences
%\begin{itemize}
%	\item \code{ompd_parallel_handle_t} type, see \specref{subsubsec:ompd_parallel_handle_t}.
%	\item \code{ompd_word_t} type, see \specref{subsubsubsec:ompd_word_t}.
%\end{itemize}


\subsubsubsection{\hcode{ompd_get_task_function}}
\label{subsubsubsec:ompd_get_task_function}
\summary
Task Function Entry Point
\format
\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_task_function (
  ompd_task_handle_t *\plc{task_handle},
  ompd_address_t *\plc{entry_point}
);
\end{ompSyntax}
\end{cspecific}

\descr
The \code{ompd_get_task_function} returns the entry point of the code
that corresponds to the body of code executed by the task:

\argdesc
The input argument \plc{task_handle} is an opaque handle for a task and selects the task to operate on.
On return the output argument \plc{entry_point} is set an address that describes the begin of application
code which executes the task region.

\crossreferences
\begin{itemize}
	\item \code{ompd_task_handle_t} type, see \specref{subsubsec:ompd_task_handle_t}.
	\item \code{ompd_address_t} type, see \specref{subsubsubsec:ompd_address_t}.
\end{itemize}


\subsubsubsection{\hcode{ompd_get_max_threads}}
\label{subsubsubsec:ompd_get_max_threads}
\summary
The \code{ompd_get_max_threads} function returns the first value of the \plc{nthreads-var} ICV.

\format
\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_max_threads (
  const ompd_task_handle_t *\plc{task_handle},
  ompd_word_t *\plc{val}
);
\end{ompSyntax}
\end{cspecific}

\descr
The \code{ompd_get_max_threads} function returns the first value of the
 \emph{nthreads-var} ICV,
and corresponds to the \code{omp_get_max_threads} function
in the OpenMP runtime API.
This returns an upper bound on the number threads that could be used
to form a new team if a \code{parallel} construct without a
\code{num_threads} clause were encountered.

\argdesc
The input argument \plc{task_handle} is an opaque handle for a task and selects the task to operate on.
On return the output argument \plc{val} is set to the value that \code{omp_get_max_threads} would return when
executed in this task.

\crossreferences
\begin{itemize}
	\item \code{ompd_task_handle_t} type, see \specref{subsubsec:ompd_task_handle_t}.
	\item \code{ompd_word_t} type, see \specref{subsubsubsec:ompd_word_t}.
	\item \plc{nthreads-var} ICV, see \specref{sec:Internal Control Variables}.
\end{itemize}

\subsubsubsection{\hcode{ompd_get_thread_num}}
\label{subsubsubsec:ompd_get_thread_num}
\summary
The \code{ompd_get_thread_num} function returns the logical thread number of the thread in the team of the OpenMP process.

\format
\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_thread_num (
  const ompd_thread_handle_t *\plc{task_handle},
  ompd_word_t *\plc{val}
);
\end{ompSyntax}
\end{cspecific}

\descr
The \code{ompd_get_thread_num} function returns the logical thread number of the thread in the team of the OpenMP process, and
corresponds to the \code{omp_get_thread_num} function in the OpenMP runtime API.


\argdesc
The input argument \plc{task_handle} is an opaque handle for a task and selects the task to operate on.
On return the output argument \plc{val} is set to the value that \code{omp_get_thread_num} would return when
executed in this task.

\crossreferences
\begin{itemize}
	\item \code{ompd_thread_handle_t} type, see \specref{subsubsec:ompd_thread_handle_t}.
	\item \code{ompd_word_t} type, see \specref{subsubsubsec:ompd_word_t}.
\end{itemize}


\subsubsubsection{\hcode{ompd_in_parallel}}
\label{subsubsubsec:ompd_in_parallel}
\summary
The \code{ompd_in_parallel} function returns \plc{true} if \plc{active-levels-var} is greater than~0, and \plc{false} otherwise.

\format
\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_in_parallel (
  const ompd_task_handle_t *\plc{task_handle},
  ompd_word_t *\plc{val}
);
\end{ompSyntax}
\end{cspecific}

\descr
\code{ompd_in_parallel} returns logical true (\textit{i.e.}, \code{*val != 0})
if \emph{active-levels-var}
ICV is greater than~0, and false (0) otherwise.
The routine corresponds to \code{omp_in_parallel} in the OpenMP runtime.

\argdesc
The input argument \plc{task_handle} is an opaque handle for a task and selects the task to operate on.
On return the output argument \plc{val} is set to the value that \code{omp_in_parallel} would return when
executed in this task.

\crossreferences
\begin{itemize}
	\item \code{ompd_task_handle_t} type, see \specref{subsubsec:ompd_task_handle_t}.
	\item \code{ompd_word_t} type, see \specref{subsubsubsec:ompd_word_t}.
	\item \plc{active-levels-var} ICV, see \specref{sec:Internal Control Variables}.
\end{itemize}


\subsubsubsection{\hcode{ompd_in_final}}
\label{subsubsubsec:ompd_in_final}
\summary
The \code{ompd_in_final} function returns \plc{true} if the task is a final task.

\format
\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_in_final (
  const ompd_task_handle_t *\plc{task_handle},
  ompd_word_t *\plc{val}
);
\end{ompSyntax}
\end{cspecific}

\descr
\code{ompd_in_final} corresponds to \code{omp_in_final} and returns
logical true if the task is a final task.

\argdesc
The input argument \plc{task_handle} is an opaque handle for a task and selects the task to operate on.
On return the output argument \plc{val} is set to the value that \code{omp_in_final} would return when
executed in this task.

\crossreferences
\begin{itemize}
	\item \code{ompd_task_handle_t} type, see \specref{subsubsec:ompd_task_handle_t}.
	\item \code{ompd_word_t} type, see \specref{subsubsubsec:ompd_word_t}.
\end{itemize}


\subsubsubsection{\hcode{ompd_get_dynamic}}
\label{subsubsubsec:ompd_get_dynamic}
\summary
The \code{ompd_get_dynamic} function returns the value of the \plc{dyn-var} ICV.

\format
\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_dynamic (
  const ompd_task_handle_t *\plc{task_handle},
  ompd_word_t *\plc{val}
);
\end{ompSyntax}
\end{cspecific}

\descr
\code{ompd_get_dynamic} returns the value of the
\plc{dyn-var} ICV,
and corresponds to the \code{omp_get_dynamic} member of the OpenMPI API.

\argdesc
The input argument \plc{task_handle} is an opaque handle for a task and selects the task to operate on.
On return the output argument \plc{val} is set to the value that \code{omp_get_dynamic} would return when
executed in this task.

\crossreferences
\begin{itemize}
	\item \code{ompd_task_handle_t} type, see \specref{subsubsec:ompd_task_handle_t}.
	\item \code{ompd_word_t} type, see \specref{subsubsubsec:ompd_word_t}.
	\item \plc{dyn-var} ICV, see \specref{sec:Internal Control Variables}.
\end{itemize}


\subsubsubsection{\hcode{ompd_get_nested}}
\label{subsubsubsec:ompd_get_nested}
\summary
The \code{ompd_get_nested} function returns the value of the \plc{nest-var} ICV.

\format
\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_nested (
  const ompd_task_handle_t *\plc{task_handle},
  ompd_word_t *\plc{val}
);
\end{ompSyntax}
\end{cspecific}

\descr
\code{ompd_get_nested} corresponds to \code{omp_get_nested},
and returns the value of the \emph{nest-var} ICV.

\argdesc
The input argument \plc{task_handle} is an opaque handle for a task and selects the task to operate on.
On return the output argument \plc{val} is set to the value that \code{omp_get_nested} would return when
executed in this task.

\crossreferences
\begin{itemize}
	\item \code{ompd_task_handle_t} type, see \specref{subsubsec:ompd_task_handle_t}.
	\item \code{ompd_word_t} type, see \specref{subsubsubsec:ompd_word_t}.
	\item \plc{nest-var} ICV, see \specref{sec:Internal Control Variables}.
\end{itemize}


\subsubsubsection{\hcode{ompd_get_max_active_levels}}
\label{subsubsubsec:ompd_get_max_active_levels}
\summary
The \code{ompd_get_max_active_levels} function returns the value of the \plc{max-active-levels-var} ICV.

\format
\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_max_active_levels (
  const ompd_thread_handle_t *\plc{thread_handle},
  ompd_word_t *\plc{val}
);
\end{ompSyntax}
\end{cspecific}

\descr
The maximum number of nested levels parallelism is returned by
\code{get_max_active_levels}.
This operation corresponds to the OpenMP routine
\code{omp_get_max_active_levels}
and the ICV \emph{max-active-levels-var}.%

\argdesc
The input argument \plc{task_handle} is an opaque handle for a task and selects the task to operate on.
On return the output argument \plc{val} is set to the value that \code{omp_get_max_active_levels} would return when
executed in this task.

\crossreferences
\begin{itemize}
	\item \code{ompd_thread_handle_t} type, see \specref{subsubsec:ompd_thread_handle_t}.
	\item \code{ompd_word_t} type, see \specref{subsubsubsec:ompd_word_t}.
	\item \plc{max-active-levels-var} ICV, see \specref{sec:Internal Control Variables}.
\end{itemize}

\subsubsubsection{\hcode{ompd_get_schedule}}
\label{subsubsubsec:ompd_get_schedule}
\summary
The \code{ompd_get_schedule} function returns information about the schedule when \code{runtime} scheduling is used.

\format
\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_schedule (
  ompd_task_handle_t *\plc{task_handle},
  ompd_sched_t *\plc{kind},
  ompd_word_t *\plc{modifier}
);
\end{ompSyntax}
\end{cspecific}

\descr

\code{ompd_get_schedule} returns information about the schedule that is
applied when \code{runtime} scheduling is used.
%
This information is represented in the device by the
\emph{run-sched-var}.

\argdesc
The input argument \plc{task_handle} is an opaque handle for a task and selects the task to operate on.
On return the output argument \plc{kind} is set to the schedule that \code{omp_get_schedule} would return when
executed in this task; the output argument \plc{modifier} is set to the \plc{chunk_size} that 
\code{omp_get_schedule} would return.


\crossreferences
\begin{itemize}
	\item \code{ompd_task_handle_t} type, see \specref{subsubsec:ompd_task_handle_t}.
	\item \code{ompd_sched_t} type, see \specref{subsubsec:ompd_sched_t}.
	\item \code{ompd_word_t} type, see \specref{subsubsubsec:ompd_word_t}.
	\item \plc{run-sched-var} ICV, see \specref{sec:Internal Control Variables}.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\subsubsubsection{\hcode{ompd_get_proc_bind}}
\label{subsubsubsec:ompd_get_proc_bind}
\summary
The \code{ompd_get_proc_bind} function returns the value of the task's \plc{bind-var} ICV.

\format
\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_proc_bind (
  ompd_task_handle_t *\plc{task_handle},
  ompd_proc_bind_t *\plc{bind}
);
\end{ompSyntax}
\end{cspecific}

\descr
\code{ompd_get_proc_bind} returns the value of the task's
\emph{bind-var} ICV (\specref{sec:Internal Control Variables}), which ``controls the
binding of the OpenMP threads to places,'' or ``default thread
affinity policies.''
%
The OMPD API defines
\code{ompd_proc_bind_t}, which
contains the corresponding OpenMP enumeration values.
%

\argdesc
The input argument \plc{task_handle} is an opaque handle for a task and selects the task to operate on.
On return the output argument \plc{bind} is set to the value that \code{omp_get_proc_bind} would return when
executed in this task.
%

\crossreferences
\begin{itemize}
	\item \code{ompd_task_handle_t} type, see \specref{subsubsec:ompd_task_handle_t}.
	\item \code{ompd_proc_bind_t} type, see \specref{subsubsec:ompd_proc_bind_t}.
	\item \plc{bind-var} ICV, see \specref{sec:Internal Control Variables}.
\end{itemize}

\subsubsubsection{\hcode{ompd_is_implicit}}
\label{subsubsubsec:ompd_is_implicit}
\summary
The \code{ompd_is_implicit} function returns \plc{true} if a task is implicit, and \plc{false} otherwise.

\format
\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_is_implicit (
  ompd_task_handle_t *\plc{task_handle},
  ompd_word_t *\plc{val}
);
\end{ompSyntax}
\end{cspecific}

\descr
\code{ompd_is_implicit} returns logical true (\textit{i.e.}, \code{*val != 0})
if a task is implicit, and false (0) otherwise.
The routine has no corresponding call in the OpenMP runtime.

\argdesc
The input argument \plc{task_handle} is an opaque handle for a task and selects the task to operate on.
On return the output argument \plc{val} is set to the value that \code{omp_get_dynamic} would return when
executed in this task.

\crossreferences
\begin{itemize}
	\item \code{ompd_task_handle_t} type, see \specref{subsubsec:ompd_task_handle_t}.
	\item \code{ompd_word_t} type, see \specref{subsubsubsec:ompd_word_t}.
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\subsubsubsection{\hcode{ompd_get_task_frame}}
\label{subsubsubsec:ompd_get_task_frame}
\summary
For the specified task, extract the task's frame pointers maintained by an OpenMP implementation.

\format
\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_task_frame (
  ompd_task_handle_t *\plc{task_handle},
  ompd_address_t *\plc{exit_frame},
  ompd_address_t *\plc{enter_frame}
);
\end{ompSyntax}
\end{cspecific}



\descr
An OpenMP implementation  maintains an \code{omp_frame_t} object for every implicit or explicit task. 
For the task identified by \plc{task_handle}, \code{ompd_get_task_frame} extracts 
the \plc{enter_frame} and \plc{exit_frame} fields of the task's \code{omp_frame_t} object.

\argdesc

The argument \plc{task_handle} specifies an OpenMP task.

The argument \plc{exit_frame} is a pointer to an \code{ompd_address_t} object that the OMPD plugin will 
modify to return the segment and address that represent the value of the \plc{exit_frame} 
field of the \code{omp_frame_t} object associated with the specified task.

The argument \plc{enter_frame} is a pointer to an \code{ompd_address_t} object that the OMPD plugin will 
modify to return the segment and address that represent the value of the \plc{enter_frame} 
field of the \code{omp_frame_t} object associated with the specified task.

\crossreferences
\begin{itemize}
	\item \code{ompd_task_handle_t} type, see \specref{subsubsec:ompd_task_handle_t}.
	\item \code{ompd_address_t} type, see \specref{subsubsubsec:ompd_address_t}.
	\item \code{omp_frame_t} type, see \specref{sec:omp_frame_t}.
\end{itemize}


\subsubsubsection{\hcode{ompd_get_state}}
\label{subsubsubsec:ompd_get_state}
\summary
This function allows a third party tool to interrogate the OMPD plugin about the state of a thread.

\format
\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_state (
  ompd_thread_handle_t *\plc{thread_handle},
  omp_state_t *\plc{state},
  omp_wait_id_t *\plc{wait_id}
);
\end{ompSyntax}
\end{cspecific}

\descr
The function \code{ompd_get_state} is the  OMPD version of
\code{ompt_get_state}. 
The only difference between the OMPD and OMPT counterparts
is that the OMPD version must supply a thread handle to provide
a context for this inquiry.

\argdesc

%ompd_thread_handle_t *\plc{thread_handle}, %/* IN */
%ompd_state_t *\plc{state}, %/* OUT */
%ompd_wait_id_t    *\plc{wait_id} % /* OUT */

The input argument \plc{thread_handle} is a thread handle. The output argument
\plc{state} represents the state of the thread that is represented by the thread handle.
The thread states are represented by values of the enumeration type
\code{omp_state_t}.

The output argument \plc{wait_id} is a pointer to an opaque handle available to receive the value 
of the thread's wait identifier. If the \plc{wait_id} pointer is not \code{NULL}, it will contain
the value of the thread's wait identifier \plc{*wait_id}. If the thread state is not one of the 
specified wait states, the value of \plc{*wait_id} is undefined.

%The symbolic names of the members of \code{ompd_state_t} should
%match those of the OMPT enumeration type \code{omp_state_e}.
%However, there is no guarantee that the numeric values of the corresponding
%symbolic constants are identical.

\crossreferences
\begin{itemize}
	\item \code{ompd_thread_handle_t} type, see \specref{subsubsec:ompd_thread_handle_t}.
	\item \code{omp_state_t} type, see \specref{sec:thread-states}.
	\item \code{ompd_wait_id_t} type, see \specref{subsubsubsec:ompd_wait_id_t}.
\end{itemize}



\subsubsection{Display Control variables}

\subsubsubsection{\hcode{ompd_get_display_control_vars}}
\label{subsubsubsec:ompd_get_display_control_vars}
\summary
Returns a list of name/value pairs for the OpenMP control variables
that are user-controllable and important to the operation or
performance of OpenMP programs.
\format
\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_get_display_control_vars (
  ompd_address_space_handle_t *\plc{address_space_handle},
  const char * const * *\plc{control_vars}
);
\end{ompSyntax}
\end{cspecific}

\descr
The function \code{ompd_get_display_control_vars} returns a
NULL-terminated vactor of strings of name/value pairs of control
variables whose settings are (a) user controllable,
and (b) importannt to the operation or performance of an OpenMP
runtime system.
The control variables exposed through this interface include all
of the OpenMP environment variables, settings that may come from
vendor or platform-specific environment variables, and other
settings that affect the operation or functioning of an OpenMP
runtime.

The format of the strings is:
\begin{center}
\code{name=a string}
\end{center}

The third-party tool must not modify the vector or the strings
(i.e., they are both \code{const}).
The strings are NULL terminated.
The vector is NULL terminated.

After returning from the call, the vector and strings are `owned'
by the third third-party tool.
Providing the termination constraints are satisfied, the OMPD
implementation is free to use static or dynamic memory for the
vector and/or the strings, and to arrange them in memory
as it pleases.
If dynamic memory is used, then the OMPD implementation must use
the allocate callback it received in the call to \code{ompd_initialize}.
As the third-party tool cannot make any assumptions about the origin or
layout of the memory used for the vector or strings, it cannot release
the display control variables directly when they are no longer
needed; instead it must use \code{ompd_release_display_control_vars~()}.

\argdesc
The address space is identified by the input argument \plc{address_space_handle}.
The vector of display control variables is returned through
the output argument \plc{control_vars}.

\crossreferences
\begin{itemize}
	\item \code{ompd_address_space_handle_t} type, see \specref{subsubsec:ompd_address_space_handle_t}.
	\item \code{ompd_release_display_control_vars} type, see \specref{subsubsubsec:ompd_release_display_control_vars}.
\end{itemize}


\subsubsubsection{\hcode{ompd_release_display_control_vars}}
\label{subsubsubsec:ompd_release_display_control_vars}
\summary

Releases a list of name/value pairs of OpenMP control variables
previously acquired using \code{ompd_get_display_control_vars}.
\format
\begin{cspecific}
\begin{ompSyntax}
ompd_rc_t ompd_release_display_control_vars (
  const char * const **\plc{control_vars}
);
\end{ompSyntax}
\end{cspecific}

\descr
The vector and strings returned from \code{ompd_get_display_control_vars}
are `owned' by the thrid-party, but allocated by the OMPD.
Because the third-party tool doesn't know how the memory for the vector
and strings was alloacted, it cannot deallocate the memory itself.
Instead, the third-party tool must call
\code{ompd_release_display_control_vars} to release the vector
and strings.

\argdesc
The input parameter \plc{control_vars} is the vector of display control variables to be released.

\crossreferences
\begin{itemize}
	\item \code{ompd_get_display_control_vars} type, see \specref{subsubsubsec:ompd_get_display_control_vars}.
\end{itemize}
