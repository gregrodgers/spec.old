\subsubsection{\hcode{ompd_dll_locations}}
\label{subsubsec:ompd_dll_locations}
\index{ompd_dll_locations@{\code{ompd_dll_locations}}}

\summary
The \code{ompd_dll_locations} global variable indicates the location
of OMPD libraries that are compatible with the OpenMP implementation.

\format
\begin{cspecific}
\begin{ompSyntax}
const char **ompd_dll_locations;
\end{ompSyntax}
\end{cspecific}

\descr
An OpenMP runtime may have more than one OMPD libary. The tool must be able 
to locate the right library to use for the OpenMP program that it is examining.
The OpenMP runtime system must provide a public variable \code{ompd_dll_locations},
which is an \code{argv}-style vector of filename string pointers that provides 
the name(s) of any compatible OMPD library. This variable must have \code{C} 
linkage. The tool uses the name of the variable verbatim and, in particular, 
does not apply any name mangling before performing the look up.

The programming model or architecture of the tool and, thus, that of OMPD does 
not have to match that of the OpenMP program that is being examined. The tool
must interpret the contents of \code{ompd_dll_locations} to find a suitable OMPD 
that matches its own architectural characteristics. On platforms that support 
different programming models (for example, 32-bit vs 64-bit), OpenMP 
implementations are encouraged to provide OMPD libraries for all models, and 
that can handle OpenMP programs of any model. Thus, for example, a 32-bit 
debugger that uses OMPD should be able to debug a 64-bit OpenMP program by 
loading a 32-bit OMPD implementation that can manage a 64-bit OpenMP runtime.

\code{ompd_dll_locations} points to a NULL-terminated vector of zero or more 
NULL-terminated pathname strings that do not have any filename conventions. 
This vector must be fully initialized \emph{before} \code{ompd_dll_locations} 
is set to a non-null value, such that if a tool, such as a debugger, stops 
execution of the OpenMP program at any point at which \code{ompd_dll_locations} 
is non-null, then the vector of strings to which it points is valid and complete.

\crossreferences
\begin{itemize}
\item   \code{ompd_dll_locations_valid}, 
see \specref{subsubsec:ompd_dll_locations_valid}
\end{itemize}



\subsubsection{\hcode{ompd_dll_locations_valid}}
\label{subsubsec:ompd_dll_locations_valid}
\index{ompd_dll_locations@{\code{ompd_dll_locations_valid}}}

\summary
The OpenMP runtime notifies third-party tools that \code{ompd_dll_locations}
is valid by allowing execution to pass through a location identified
by the symbol \code{ompd_dll_locations_valid}.


\begin{cspecific}
\begin{ompSyntax}
void ompd_dll_locations_valid(void);
\end{ompSyntax}
\end{cspecific}


\descr
Depending on how the OpenMP runtime is
implemented, \code{ompd_dll_locations} might not be a static
variable, and therefore needs to be initialized at runtime.  The
OpenMP runtime notifies third-party tools
that \code{ompd_dll_locations} is valid by having execution pass
through a location identified by the
symbol \code{ompd_dll_locations_valid}.
If \code{ompd_dll_locations} is NULL, a third-party tool, e.g., a
debugger can place a breakpoint at \code{ompd_dll_locations_valid}
to be notified when \code{ompd_dll_locations} has been initialized.
In practice, the symbol \code{ompd_dll_locations_valid} need not be
a function; instead, it may be a labeled machine instruction through
which execution passes once the vector is valid.

