% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. There are environments that provide special formatting, e.g. language bars.
%       Please use them whereever appropriate.  Examples are:
%
%         \begin{fortranspecific}
%         This is text that appears enclosed in blue language bars for Fortran.
%         \end{fortranspecific}
%
%         \begin{note}
%         This is a note.  The "Note -- " header appears automatically.
%         \end{note}
%
%    6. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%


\subsection{OMPT Tool Callback Signatures and Trace Records}
\label{sec:ompt-tool-callbacks}

\restrictions
\begin{itemize}
\item Tool callbacks may not use OpenMP directives or call any runtime library routines
described in Section~\ref{chap:Runtime Library Routines}.
\end{itemize}

\subsubsection{Initialization and Finalization Callback Signature}

\subsubsubsection{\hcode{ompt_initialize_t}}
\label{sec:ompt_initialize_t}

\summary
A tool implements an initializer with the type signature
\code{ompt_initialize_t} to initialize the tool's use of
the OMPT interface.

\format

\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_initialize_t) (
  ompt_function_lookup_t \plc{lookup},
  ompt_data_t *\plc{tool_data}
);
\end{omptInquiry}
\end{ccppspecific}


\descr
For a tool to use the OMPT interface of an OpenMP implementation,
the tool's implementation of \code{ompt_start_tool} must return a
non-\code{NULL} pointer to an
\code{ompt_start_tool_result_t} structure that contains a
non-\code{NULL} pointer to a tool initializer with
type signature \code{ompt_initialize_t}.
An OpenMP implementation will call the tool initializer
after fully initializing itself but before
beginning execution of any OpenMP construct
or completing execution of any environment routine invocation.

The initializer returns a non-zero value if it succeeds.

\argdesc
The argument \plc{lookup} is a callback
to an OpenMP runtime routine that a tool must use to
obtain a pointer to each runtime entry point in the OMPT interface.
The argument \plc{tool_data} is a pointer to the
\plc{tool_data} field in the \code{ompt_start_tool_result_t}
structure returned by \code{ompt_start_tool}.
The expected actions of a tool initializer are described in
\specref{sec:tool-initialize}.

\crossreferences
\begin{itemize}
\item \code{ompt_start_tool_result_t}, see
  \specref{sec:ompt_start_tool_result_t}.
\item \code{ompt_data_t}, see \specref{sec:ompt_data_t}.
\item \code{ompt_function_lookup_t}, see
  \specref{sec:ompt_function_lookup_t}.
\item \code{ompt_start_tool}, see \specref{sec:ompt_start_tool}.
\end{itemize}


\subsubsubsection{\hcode{ompt_finalize_t}}
\label{sec:ompt_finalize_t}

\summary
A tool implements a finalizer with the type signature
\code{ompt_finalize_t} to finalize the tool's use of
the OMPT interface.

\format

\begin{ccppspecific}
\begin{omptInquiry}
typedef void (*ompt_finalize_t) (
  ompt_data_t *\plc{tool_data}
);
\end{omptInquiry}
\end{ccppspecific}


\descr
For a tool to use the OMPT interface of an OpenMP implementation,
the tool's implementation of \code{ompt_start_tool} must return a
non-\code{NULL} pointer to an
\code{ompt_start_tool_result_t} structure that contains a
non-\code{NULL} pointer to a tool finalizer with
type signature \code{ompt_finalize_t}.
An OpenMP implementation will call the tool finalizer
after the last OMPT \plc{event} as the OpenMP implementation shuts down.

\argdesc
The argument \plc{tool_data} is a pointer to the
\plc{tool_data} field in the \code{ompt_start_tool_result_t}
structure returned by \code{ompt_start_tool}.

\crossreferences
\begin{itemize}
\item \code{ompt_start_tool_result_t}, see
  \specref{sec:ompt_start_tool_result_t}.
\item \code{ompt_data_t}, see \specref{sec:ompt_data_t}.
\item \code{ompt_start_tool}, see \specref{sec:ompt_start_tool}.
\end{itemize}


\subsubsection{Event Callback Signatures and Trace Records}
\index{event callback signatures}
\label{sec:ToolsSupport_callback_signatures}

This section describes the signatures of tool callback functions that an OMPT
tool might register and that are called during runtime of an OpenMP program.

\subsubsubsection{\hcode{ompt_callback_thread_begin_t}}
\index{ompt_callback_thread_begin_t@{\code{ompt_callback_thread_begin_t}}}
\label{sec:ompt_callback_thread_begin_t}
\format

\begin{ccppspecific}
\begin{omptCallback}
typedef void (*ompt_callback_thread_begin_t) (
  ompt_thread_t \plc{thread_type},
  ompt_data_t *\plc{thread_data}
);
\end{omptCallback}
\end{ccppspecific}


\record

\begin{ccppspecific}
\begin{omptRecord}
typedef struct ompt_record_thread_begin_t {
  ompt_thread_t \plc{thread_type};
} ompt_record_thread_begin_t;
\end{omptRecord}
\end{ccppspecific}


\argdesc

The argument \plc{thread_type}
indicates the type of the new thread: initial, worker, or other.

The binding of argument \plc{thread_data} is the new thread.

\crossreferences
\begin{itemize}
\item \code{ompt_data_t} type, see
\specref{sec:ompt_data_t}.
\item \code{ompt_thread_t} type, see
\specref{sec:ompt_thread_t}.
\end{itemize}



\subsubsubsection{\hcode{ompt_callback_thread_end_t}}
\index{ompt_callback_thread_end_t@{\code{ompt_callback_thread_end_t}}}
\label{sec:ompt_callback_thread_end_t}
\format

\begin{ccppspecific}
\begin{omptCallback}
typedef void (*ompt_callback_thread_end_t) (
  ompt_data_t *\plc{thread_data}
);
\end{omptCallback}
\end{ccppspecific}


\argdesc

The binding of argument \plc{thread_data} is the thread that is
terminating.

\crossreferences
\begin{itemize}
\item \code{ompt_record_ompt_t} type, see
\specref{sec:ompt_record_ompt_t}.
\item \code{ompt_data_t} type, see
\specref{sec:ompt_data_t}.
\end{itemize}


\subsubsubsection{\hcode{ompt_callback_parallel_begin_t}}
\index{ompt_callback_parallel_begin_t@{\code{ompt_callback_parallel_begin_t}}}
\label{sec:ompt_callback_parallel_begin_t}
\format

\begin{ccppspecific}
\begin{omptCallback}
typedef void (*ompt_callback_parallel_begin_t) (
  ompt_data_t *\plc{encountering_task_data},
  const omp_frame_t *\plc{encountering_task_frame},
  ompt_data_t *\plc{parallel_data},
  unsigned int \plc{requested_parallelism},
  int \plc{flag},
  const void *\plc{codeptr_ra}
);
\end{omptCallback}
\end{ccppspecific}


\record

\begin{ccppspecific}
\begin{omptRecord}
typedef struct ompt_record_parallel_begin_t {
  ompt_id_t \plc{encountering_task_id};
  ompt_id_t \plc{parallel_id};
  unsigned int \plc{requested_parallelism};
  int \plc{flag};
  const void *\plc{codeptr_ra};
} ompt_record_parallel_begin_t;
\end{omptRecord}
\end{ccppspecific}


\argdesc

The binding of argument \plc{encountering_task_data} is the
encountering task.

The argument \plc{encountering_task_frame} points to the frame object
associated with the encountering task.

The binding of argument \plc{parallel_data} is the parallel or teams
region that is beginning.

The argument \plc{requested_parallelism}
indicates the number of threads or teams requested by the user.

The argument \plc{flag} indicates whether the code for the
parallel region is inlined into the application or invoked by the
runtime and also whether the region is a parallel or teams region.

\codeptrdesc

\crossreferences
\begin{itemize}
\item \code{ompt_data_t} type, see \specref{sec:ompt_data_t}.
\item \code{ompt_parallel_flag_t} type, see \specref{sec:ompt_parallel_flag_t}.
\item \code{omp_frame_t} type, see \specref{sec:omp_frame_t}.
\end{itemize}



\subsubsubsection{\hcode{ompt_callback_parallel_end_t}}
\index{ompt_callback_parallel_end_t@{\code{ompt_callback_parallel_end_t}}}
\label{sec:ompt_callback_parallel_end_t}
\format

\begin{ccppspecific}
\begin{omptCallback}
typedef void (*ompt_callback_parallel_end_t) (
  ompt_data_t *\plc{parallel_data},
  ompt_data_t *\plc{encountering_task_data},
  int \plc{flag},
  const void *\plc{codeptr_ra}
);
\end{omptCallback}
\end{ccppspecific}


\record

\begin{ccppspecific}
\begin{omptRecord}
typedef struct ompt_record_parallel_end_t {
  ompt_id_t \plc{parallel_id};
  ompt_id_t \plc{encountering_task_id};
  int \plc{flag};
  const void *\plc{codeptr_ra};
} ompt_record_parallel_end_t;
\end{omptRecord}
\end{ccppspecific}


\argdesc

The binding of argument \plc{parallel_data} is the parallel or teams
region that is ending.

The binding of argument \plc{encountering_task_data} is the encountering
task.

The argument \plc{flag} indicates whether the execution of the
parallel region is inlined into the application or invoked by the
runtime and also whether the region is a parallel or teams region.

\codeptrdesc

\crossreferences
\begin{itemize}
\item \code{ompt_data_t} type signature, see
\specref{sec:ompt_data_t}.
\item \code{ompt_parallel_flag_t} type signature, see
\specref{sec:ompt_parallel_flag_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_callback_master_t}}
\index{ompt_callback_master_t@{\code{ompt_callback_master_t}}}
\label{sec:ompt_callback_master_t}
\format

\begin{ccppspecific}
\begin{omptCallback}
typedef void (*ompt_callback_master_t) (
  ompt_scope_endpoint_t \plc{endpoint},
  ompt_data_t *\plc{parallel_data},
  ompt_data_t *\plc{task_data},
  const void *\plc{codeptr_ra}
);
\end{omptCallback}
\end{ccppspecific}


\record

\begin{ccppspecific}
\begin{omptRecord}
typedef struct ompt_record_master_t {
  ompt_scope_endpoint_t \plc{endpoint};
  ompt_id_t \plc{parallel_id};
  ompt_id_t \plc{task_id};
  const void *\plc{codeptr_ra};
} ompt_record_master_t;
\end{omptRecord}
\end{ccppspecific}


\argdesc

\epdesc

The binding of argument \plc{parallel_data} is the current parallel region.

The binding of argument \plc{task_data} is the encountering task.

\codeptrdesc

%\effect
% ompt events have no effect

\crossreferences
\begin{itemize}
\item \code{ompt_data_t} type signature, see \specref{sec:ompt_data_t}.
\item \code{ompt_scope_endpoint_t} type, see \specref{sec:ompt_scope_endpoint_t}.
\end{itemize}





\subsubsubsection{\hcode{ompt_callback_task_create_t}}
\index{ompt_callback_task_create_t@{\code{ompt_callback_task_create_t}}}
\label{sec:ompt_callback_task_create_t}
\format

\begin{ccppspecific}
\begin{omptCallback}
typedef void (*ompt_callback_task_create_t) (
  ompt_data_t *\plc{encountering_task_data},
  const omp_frame_t *\plc{encountering_task_frame},
  ompt_data_t *\plc{new_task_data},
  int \plc{flag},
  int \plc{has_dependences},
  const void *\plc{codeptr_ra}
);
\end{omptCallback}
\end{ccppspecific}


\record

\begin{ccppspecific}
\begin{omptRecord}
typedef struct ompt_record_task_create_t {
  ompt_id_t \plc{encountering_task_id};
  ompt_id_t \plc{new_task_id};
  int \plc{flag};
  int \plc{has_dependences};
  const void *\plc{codeptr_ra};
} ompt_record_task_create_t;
\end{omptRecord}
\end{ccppspecific}


\argdesc

The binding of argument \plc{encountering_task_data} is the
encountering task.
This parameter is \code{NULL} for an initial task.

The argument \plc{encountering_task_frame} points to the frame object
associated with the encountering task.
This parameter is \code{NULL} for an initial task.

The binding of argument \plc{new_task_data} is the created
task.

The argument \plc{flag} indicates the kind of the task: initial,
explicit or target.
Values for \plc{flag} are composed by or-ing elements of enum
\code{ompt_task_flag_t}.

The argument \plc{has_dependences} indicates whether created
task has dependences.

\codeptrdesc

\crossreferences
\begin{itemize}
\item \code{ompt_data_t} type, see
\specref{sec:ompt_data_t}.
\item \code{ompt_task_flag_t} type, see
\specref{sec:ompt_task_flag_t}.
\item \code{omp_frame_t} type, see
\specref{sec:omp_frame_t}.
\end{itemize}



\subsubsubsection{\hcode{ompt_callback_task_dependences_t}}
\index{ompt_callback_task_dependences_t@{\code{ompt_callback_task_dependences_t}}}
\label{sec:ompt_callback_task_dependences_t}
\format

\begin{ccppspecific}
\begin{omptCallback}
typedef void (*ompt_callback_task_dependences_t) (
  ompt_data_t *\plc{task_data},
  const ompt_task_dependence_t *\plc{deps},
  int \plc{ndeps}
);
\end{omptCallback}
\end{ccppspecific}


\record

\begin{ccppspecific}
\begin{omptRecord}
typedef struct ompt_record_task_dependences_t {
  ompt_id_t \plc{task_id};
  ompt_task_dependence_t \plc{dep};
  int \plc{ndeps};
} ompt_record_task_dependences_t;
\end{omptRecord}
\end{ccppspecific}



\argdesc

The binding of argument \plc{task_data} is the task being created.

The argument \plc{deps} lists all dependences of a new task.

The argument \plc{ndeps} specifies the length of the list.
The memory for \plc{deps} is owned by the caller; the tool cannot rely on
the data after the callback returns.

The performance monitor interface for tracing activity on target devices will provide one record per dependence.

\crossreferences
\begin{itemize}
\item \code{ompt_data_t} type, see
\specref{sec:ompt_data_t}.
\item \code{ompt_task_dependence_t} type, see
\specref{sec:ompt_task_dependence_t}.
\end{itemize}



\subsubsubsection{\hcode{ompt_callback_task_dependence_t}}
\index{ompt_callback_task_dependence_t@{\code{ompt_callback_task_dependence_t}}}
\label{sec:ompt_callback_task_dependence_t}
\format

\begin{ccppspecific}
\begin{omptCallback}
typedef void (*ompt_callback_task_dependence_t) (
  ompt_data_t *\plc{src_task_data},
  ompt_data_t *\plc{sink_task_data}
);
\end{omptCallback}
\end{ccppspecific}


\record

\begin{ccppspecific}
\begin{omptRecord}
typedef struct ompt_record_task_dependence_t {
  ompt_id_t \plc{src_task_id};
  ompt_id_t \plc{sink_task_id};
} ompt_record_task_dependence_t;
\end{omptRecord}
\end{ccppspecific}


\argdesc

The binding of argument \plc{src_task_data} is a running task
with an outgoing dependence.

The binding of argument \plc{sink_task_data} is a task with an
unsatisfied incoming dependence.


\crossreferences
\begin{itemize}
\item \code{ompt_data_t} type signature, see
\specref{sec:ompt_data_t}.
\end{itemize}



\subsubsubsection{\hcode{ompt_callback_task_schedule_t}}
\index{ompt_callback_task_schedule_t@{\code{ompt_callback_task_schedule_t}}}
\label{sec:ompt_callback_task_schedule_t}
\format

\begin{ccppspecific}
\begin{omptCallback}
typedef void (*ompt_callback_task_schedule_t) (
  ompt_data_t *\plc{prior_task_data},
  ompt_task_status_t \plc{prior_task_status},
  ompt_data_t *\plc{next_task_data}
);
\end{omptCallback}
\end{ccppspecific}


\record

\begin{ccppspecific}
\begin{omptRecord}
typedef struct ompt_record_task_schedule_t {
  ompt_id_t \plc{prior_task_id};
  ompt_task_status_t \plc{prior_task_status};
  ompt_id_t \plc{next_task_id};
} ompt_record_task_schedule_t;
\end{omptRecord}
\end{ccppspecific}


\argdesc

The argument \plc{prior_task_status} indicates the status of
the task that arrived at a task scheduling point.

The binding of argument \plc{prior_task_data} is the task that
arrived at the scheduling point.

The binding of argument \plc{next_task_data} is the task that
will resume at the scheduling point.

\crossreferences
\begin{itemize}
\item \code{ompt_data_t} type, see
\specref{sec:ompt_data_t}.

\item \code{ompt_task_status_t} type, see
\specref{sec:ompt_task_status_t}.
\end{itemize}



\subsubsubsection{\hcode{ompt_callback_implicit_task_t}}
\index{ompt_callback_implicit_task_t@{\code{ompt_callback_implicit_task_t}}}
\label{sec:ompt_callback_implicit_task_t}
\format

\begin{ccppspecific}
\begin{omptCallback}
typedef void (*ompt_callback_implicit_task_t) (
  ompt_scope_endpoint_t \plc{endpoint},
  ompt_data_t *\plc{parallel_data},
  ompt_data_t *\plc{task_data},
  unsigned int \plc{actual_parallelism},
  unsigned int \plc{index}
);
\end{omptCallback}
\end{ccppspecific}


\record

\begin{ccppspecific}
\begin{omptRecord}
typedef struct ompt_record_implicit_t {
  ompt_scope_endpoint_t \plc{endpoint};
  ompt_id_t \plc{parallel_id};
  ompt_id_t \plc{task_id};
  unsigned int \plc{actual_parallelism};
  unsigned int \plc{index};
} ompt_record_implicit_t;
\end{omptRecord}
\end{ccppspecific}


\argdesc

\epdesc

The binding of argument \plc{parallel_data} is the current
parallel region.
For the \plc{implicit-task-end} event, this argument is \code{NULL}.

The binding of argument \plc{task_data} is the implicit task
executing the parallel region's structured block.

The argument \plc{actual_parallelism} indicates the number of
threads in the \code{parallel} region, respectively the number of 
teams in the \code{teams} region.
For the \plc{implicit-task-end} and the \plc{initial-task-end} events, 
this argument is \code{0}.

The argument \plc{index} indicates the thread number or team number 
of the calling thread, within the team or league executing the 
parallel or teams region to which the implicit region binds.

\crossreferences
\begin{itemize}
\item \code{ompt_data_t} type, see
\specref{sec:ompt_data_t}.
\item \code{ompt_scope_endpoint_t} enumeration type, see
\specref{sec:ompt_scope_endpoint_t}.
\end{itemize}



\subsubsubsection{\hcode{ompt_callback_sync_region_t}}
\index{ompt_callback_sync_region_t@{\code{ompt_callback_sync_region_t}}}
\label{sec:ompt_callback_sync_region_t}
\format

\begin{ccppspecific}
\begin{omptCallback}
typedef void (*ompt_callback_sync_region_t) (
  ompt_sync_region_t \plc{kind},
  ompt_scope_endpoint_t \plc{endpoint},
  ompt_data_t *\plc{parallel_data},
  ompt_data_t *\plc{task_data},
  const void *\plc{codeptr_ra}
);
\end{omptCallback}
\end{ccppspecific}


\record

\begin{ccppspecific}
\begin{omptRecord}
typedef struct ompt_record_sync_region_t {
  ompt_sync_region_t \plc{kind};
  ompt_scope_endpoint_t \plc{endpoint};
  ompt_id_t \plc{parallel_id};
  ompt_id_t \plc{task_id};
  const void *\plc{codeptr_ra};
} ompt_record_sync_region_t;
\end{omptRecord}
\end{ccppspecific}


% \descr
% A tool executes a callback with type signature
% \code{ompt_callback_sync_region_t} to receive notification of
% event \code{ompt_callback_sync_region_t} when an OpenMP
% implementation starts and stops waiting in a barrier region, taskwait
% region, or taskgroup region.

\argdesc

The argument \plc{kind} indicates the kind of 
synchronization.

\epdesc

The binding of argument \plc{parallel_data} is the current
parallel region.
For the \plc{barrier-end} event at the end of a parallel region,
this argument is \code{NULL}.

The binding of argument \plc{task_data} is the current task.

\codeptrdesc

\crossreferences
\begin{itemize}
\item \code{ompt_data_t} type, see
\specref{sec:ompt_data_t}.
\item \code{ompt_scope_endpoint_t} type, see
\specref{sec:ompt_scope_endpoint_t}.
\item \code{ompt_sync_region_t} type, see
\specref{sec:ompt_sync_region_t}.
\end{itemize}


\subsubsubsection{\hcode{ompt_callback_mutex_acquire_t}}
\index{ompt_callback_mutex_acquire_t@{\code{ompt_callback_mutex_acquire_t}}}
\label{sec:ompt_callback_mutex_acquire_t}
\format

\begin{ccppspecific}
\begin{omptCallback}
typedef void (*ompt_callback_mutex_acquire_t) (
  ompt_mutex_t \plc{kind},
  unsigned int \plc{hint},
  unsigned int \plc{impl},
  omp_wait_id_t \plc{wait_id},
  const void *\plc{codeptr_ra}
);
\end{omptCallback}
\end{ccppspecific}


\record

\begin{ccppspecific}
\begin{omptRecord}
typedef struct ompt_record_mutex_acquire_t {
  ompt_mutex_t \plc{kind};
  unsigned int \plc{hint};
  unsigned int \plc{impl};
  omp_wait_id_t \plc{wait_id};
  const void *\plc{codeptr_ra};
} ompt_record_mutex_acquire_t;
\end{omptRecord}
\end{ccppspecific}


\argdesc

The argument \plc{kind} indicates the kind of the lock.

The argument \plc{hint} indicates the hint provided when initializing
an implementation of mutual exclusion.
If no hint is available when a thread initiates acquisition of mutual exclusion,
the runtime may supply \code{omp_sync_hint_none} as the value for \plc{hint}.

The argument \plc{impl} indicates the mechanism chosen by the
runtime to implement the mutual exclusion.

The argument \plc{wait_id} indicates the object being awaited.

\codeptrdesc

\crossreferences
\begin{itemize}
\item \code{ompt_mutex_t} type, see
\specref{sec:ompt_mutex_t}.
\item \code{omp_wait_id_t} type, see
\specref{sec:omp_wait_id_t}.
\end{itemize}



\subsubsubsection{\hcode{ompt_callback_mutex_t}}
\index{ompt_callback_mutex_t@{\code{ompt_callback_mutex_t}}}
\label{sec:ompt_callback_mutex_t}
\format

\begin{ccppspecific}
\begin{omptCallback}
typedef void (*ompt_callback_mutex_t) (
  ompt_mutex_t \plc{kind},
  omp_wait_id_t \plc{wait_id},
  const void *\plc{codeptr_ra}
);
\end{omptCallback}
\end{ccppspecific}


\record

\begin{ccppspecific}
\begin{omptRecord}
typedef struct ompt_record_mutex_t {
  ompt_mutex_t \plc{kind};
  omp_wait_id_t \plc{wait_id};
  const void *\plc{codeptr_ra};
} ompt_record_mutex_t;
\end{omptRecord}
\end{ccppspecific}


\argdesc

The argument \plc{kind} indicates the kind of mutual exclusion event.

The argument \plc{wait_id} indicates the object being awaited.

\codeptrdesc

\crossreferences
\begin{itemize}
\item \code{ompt_mutex_t} type signature, see
\specref{sec:ompt_mutex_t}.
\item \code{omp_wait_id_t} type signature, see
\specref{sec:omp_wait_id_t}.
\end{itemize}



\subsubsubsection{\hcode{ompt_callback_nest_lock_t}}
\index{ompt_callback_nest_lock_t@{\code{ompt_callback_nest_lock_t}}}
\label{sec:ompt_callback_nest_lock_t}
\format

\begin{ccppspecific}
\begin{omptCallback}
typedef void (*ompt_callback_nest_lock_t) (
  ompt_scope_endpoint_t \plc{endpoint},
  omp_wait_id_t \plc{wait_id},
  const void *\plc{codeptr_ra}
);
\end{omptCallback}
\end{ccppspecific}


\record

\begin{ccppspecific}
\begin{omptRecord}
typedef struct ompt_record_nest_lock_t {
  ompt_scope_endpoint_t \plc{endpoint};
  omp_wait_id_t \plc{wait_id};
  const void *\plc{codeptr_ra};
} ompt_record_nest_lock_t;
\end{omptRecord}
\end{ccppspecific}


\argdesc

\epdesc

The argument \plc{wait_id} indicates the object being awaited.

\codeptrdesc

\crossreferences
\begin{itemize}
\item \code{ompt_scope_endpoint_t} type signature, see
\specref{sec:ompt_scope_endpoint_t}.
\item \code{omp_wait_id_t} type signature, see
\specref{sec:omp_wait_id_t}.
\end{itemize}



\subsubsubsection{\hcode{ompt_callback_work_t}}
\index{ompt_callback_work_t@{\code{ompt_callback_work_t}}}
\label{sec:ompt_callback_work_t}
\format

\begin{ccppspecific}
\begin{omptCallback}
typedef void (*ompt_callback_work_t) (
  ompt_work_t \plc{wstype},
  ompt_scope_endpoint_t \plc{endpoint},
  ompt_data_t *\plc{parallel_data},
  ompt_data_t *\plc{task_data},
  uint64_t \plc{count},
  const void *\plc{codeptr_ra}
);
\end{omptCallback}
\end{ccppspecific}


\record

\begin{ccppspecific}
\begin{omptRecord}
typedef struct ompt_record_work_t {
  ompt_work_t \plc{wstype};
  ompt_scope_endpoint_t \plc{endpoint};
  ompt_id_t \plc{parallel_id};
  ompt_id_t \plc{task_id};
  uint64_t \plc{count};
  const void *\plc{codeptr_ra};
} ompt_record_work_t;
\end{omptRecord}
\end{ccppspecific}


\argdesc

The argument \plc{wstype} indicates the kind of worksharing
region.

\epdesc

The binding of argument \plc{parallel_data} is the current
parallel region.

The binding of argument \plc{task_data} is the current task.

The argument \plc{count} is a measure of the quantity of work involved in the worksharing construct.
For a worksharing-loop construct, \plc{count} represents the number of iterations of the loop.
For a \code{taskloop} construct, \plc{count} represents the number of iterations in the iteration space,
which may be the result of collapsing several associated loops.
For a \code{sections} construct, \plc{count} represents the number of sections.
For a \code{workshare} construct, \plc{count} represents the units of work, as defined by the \code{workshare} construct.
For a \code{single} construct, \plc{count} is always 1.
When the \plc{endpoint} argument is signaling the end of a scope, a \plc{count} value of 0 indicates that the actual \plc{count} value is not available.

\codeptrdesc


\crossreferences
\begin{itemize}
\item worksharing constructs, see \specref{sec:Worksharing Constructs} and \specref{subsec:Worksharing-Loop Construct}.
\item \code{ompt_data_t} type signature, see
\specref{sec:ompt_data_t}.
\item \code{ompt_scope_endpoint_t} type signature, see
\specref{sec:ompt_scope_endpoint_t}.
\item \code{ompt_work_t} type signature, see
\specref{sec:ompt_work_t}.
\end{itemize}



\subsubsubsection{\hcode{ompt_callback_flush_t}}
\index{ompt_callback_flush_t@{\code{ompt_callback_flush_t}}}
\label{sec:ompt_callback_flush_t}
\format

\begin{ccppspecific}
\begin{omptCallback}
typedef void (*ompt_callback_flush_t) (
  ompt_data_t *\plc{thread_data},
  const void *\plc{codeptr_ra}
);
\end{omptCallback}
\end{ccppspecific}


\record

\begin{ccppspecific}
\begin{omptRecord}
typedef struct ompt_record_flush_t {
  const void *\plc{codeptr_ra};
} ompt_record_flush_t;
\end{omptRecord}
\end{ccppspecific}


\argdesc

\codeptrdesc

\crossreferences
\begin{itemize}
\item \code{ompt_data_t} type signature, see
\specref{sec:ompt_data_t}.
\end{itemize}



\subsubsubsection{\hcode{ompt_callback_dispatch_t}}
\index{ompt_callback_flush_t@{\code{ompt_callback_dispatch_t}}}
\label{sec:ompt_callback_dispatch_t}
\format

\begin{ccppspecific}
\begin{omptCallback}
typedef void (*ompt_callback_dispatch_t) (
  ompt_data_t *\plc{parallel_data},
  ompt_data_t *\plc{task_data},
  ompt_dispatch_t \plc{kind},
  ompt_data_t \plc{instance} 
);
\end{omptCallback}
\end{ccppspecific}


\record

\begin{ccppspecific}
\begin{omptRecord}
typedef struct ompt_record_dispatch_t {
  ompt_id_t \plc{parallel_id};
  ompt_id_t \plc{task_id};
  ompt_dispatch_t \plc{kind};
  ompt_data_t \plc{instance}; 
} ompt_record_dispatch_t;
\end{omptRecord}
\end{ccppspecific}


\argdesc

The argument \plc{kind} indicates whether a loop iteration or a
section is being dispatched.

For a loop iteration, the argument \plc{instance.value} contains
the iteration variable value.  
For a structured block in the \code{sections} construct, \plc{instance.ptr}
contains a code address identifying the structured block.  In cases where a
runtime routine implements the structured block associated with this callback,
\plc{instance.ptr} is expected to contain the return address of the
call to the runtime routine.  In cases where the implementation of
the structured block is inlined, \plc{instance.ptr} is expected to contain
the return address of the invocation of this callback.

\crossreferences
\begin{itemize}
\item \code{ompt_data_t} type signature, see
  \specref{sec:ompt_data_t}.
\item \code{ompt_dispatch_t} type, see
  \specref{sec:ompt_dispatch_t}.
\end{itemize}



\subsubsubsection{\hcode{ompt_callback_target_t}}
\index{ompt_callback_target_t@{\code{ompt_callback_target_t}}}
\label{sec:ompt_callback_target_t}
\format

\begin{ccppspecific}
\begin{omptCallback}
typedef void (*ompt_callback_target_t) (
  ompt_target_t \plc{kind},
  ompt_scope_endpoint_t \plc{endpoint},
  uint64_t \plc{device_num},
  ompt_data_t *\plc{task_data},
  ompt_id_t \plc{target_id},
  const void *\plc{codeptr_ra}
);
\end{omptCallback}
\end{ccppspecific}


\record

\begin{ccppspecific}
\begin{omptRecord}
typedef struct ompt_record_target_t {
  ompt_target_t \plc{kind};
  ompt_scope_endpoint_t \plc{endpoint};
  uint64_t \plc{device_num};
  ompt_data_t *\plc{task_data};
  ompt_id_t \plc{target_id};
  const void *\plc{codeptr_ra};
} ompt_record_target_t;
\end{omptRecord}
\end{ccppspecific}


\argdesc

The argument \plc{kind} indicates the kind of target region.

\epdesc

The argument \plc{device_num} indicates the id of the device
which will execute the target region.

The binding of argument \plc{task_data} is the generating task.

The binding of argument \plc{target_id} is the target region.

\codeptrdesc

\crossreferences
\begin{itemize}
\item \code{ompt_id_t} type, see
\specref{sec:ompt_id_t}.
\item \code{ompt_data_t} type signature, see
\specref{sec:ompt_data_t}.
\item \code{ompt_scope_endpoint_t} type signature, see
\specref{sec:ompt_scope_endpoint_t}.
\item \code{ompt_target_t} type signature, see
\specref{sec:ompt_target_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_callback_device_load_t}}
\index{ompt_callback_target_code_t@{\code{ompt_callback_device_load_t}}}
\label{sec:ompt_callback_device_load_t}

\summary
The OpenMP runtime invokes this callback to notify a tool immediately after loading code onto the specified device.

\format


\begin{ccppspecific}
\begin{omptCallback}
typedef void (*ompt_callback_device_load_t) (
  uint64_t \plc{device_num},
  const char *\plc{filename},
  int64_t \plc{offset_in_file},
  void *\plc{vma_in_file},
  size_t \plc{bytes}
  void *\plc{host_addr},
  void *\plc{device_addr},
  uint64_t \plc{module_id}
);
\end{omptCallback}

\end{ccppspecific}
\code{ompt_addr_none} is defined as a pointer with the value \textasciitilde 0.


\argdesc
The argument \plc{device_num} specifies the device.

The argument \plc{filename} indicates the name of a file in which the device code can be found. A NULL \plc{filename} indicates that the code is not available in a file in the file system.

The argument \plc{offset_in_file} indicates an offset into \plc{filename} at which the code can be found. A value of -1 indicates that
no offset is provided.

The argument \plc{vma_in_file} indicates an virtual address in \plc{filename} at which the code can be found.
A value of \plc{ompt_addr_none} indicates that a virtual address in the file is not 
available.

The argument \plc{bytes} indicates the size of the device code object in bytes.

The argument \plc{host_addr} indicates where a copy of the device code is available in host memory.
A value of \plc{ompt_addr_none} indicates that a host code address is not available.

The argument \plc{device_addr} indicates where the device code has been loaded in device memory.
A value of \plc{ompt_addr_none} indicates that a device code address is not available.

The argument \plc{module_id} is an identifier that is associated with the device code object.


\subsubsubsection{\hcode{ompt_callback_device_unload_t}}
\index{ompt_callback_target_code_t@{\code{ompt_callback_device_unload_t}}}
\label{sec:ompt_callback_device_unload_t}

\summary
The OpenMP runtime invokes this callback to notify a tool immediately prior to unloading code from the specified device.

\format


\begin{ccppspecific}
\begin{omptCallback}
typedef void (*ompt_callback_device_unload_t) (
  uint64_t \plc{device_num},
  uint64_t \plc{module_id}
);
\end{omptCallback}

\end{ccppspecific}


\argdesc

The argument \plc{device_num} specifies the device.

The argument \plc{module_id} is an identifier that is associated with the device code object.


\subsubsubsection{\hcode{ompt_callback_target_data_op_t}}
\index{ompt_callback_target_data_op_t@{\code{ompt_callback_target_data_op_t}}}
\label{sec:ompt_callback_target_data_op_t}
\format


\begin{ccppspecific}
\begin{omptCallback}
typedef void (*ompt_callback_target_data_op_t) (
  ompt_id_t \plc{target_id},
  ompt_id_t \plc{host_op_id},
  ompt_target_data_op_t \plc{optype},
  void *\plc{src_addr},
  int \plc{src_device_num},
  void *\plc{dest_addr},
  int \plc{dest_device_num},
  size_t \plc{bytes},
  const void *\plc{codeptr_ra}
);
\end{omptCallback}
\end{ccppspecific}


\record

\begin{ccppspecific}
\begin{omptRecord}
typedef struct ompt_record_target_data_op_t {
  ompt_id_t \plc{host_op_id};
  ompt_target_data_op_t \plc{optype};
  void *\plc{src_addr};
  int \plc{src_device_num};
  void *\plc{dest_addr};
  int \plc{dest_device_num};
  size_t \plc{bytes};
  ompt_device_time_t \plc{end_time};
  const void *\plc{codeptr_ra};
} ompt_record_target_data_op_t;
\end{omptRecord}
\end{ccppspecific}


\descr
An OpenMP implementation will dispatch a registered \code{ompt_callback_target_data_op} callback
when device memory is allocated or freed, as well as when data is copied to or from a device.

\begin{note}
An OpenMP implementation may aggregate program variables and data
operations upon them.  For instance, an OpenMP implementation may
synthesize a composite to represent multiple scalars and then
allocate, free, or copy this composite as a whole rather than
performing data operations on each scalar individually.  For that
reason, a tool should not expect to see separate data operations
on each variable.
\end{note}

\argdesc

The argument \plc{host_op_id} is a unique identifer for a data
operations on a target device.

The argument \plc{optype} indicates the kind of data mapping.

The argument \plc{src_addr} indicates the address of data
before the operation, where applicable.

The argument \plc{src_device_num} indicates the source device number
for the data operation, where applicable.

The argument \plc{dest_addr} indicates the address of data
after the operation.

The argument \plc{dest_device_num} indicates the destination device
number for the data operation.

It is implementation defined whether in some operations \plc{src_addr}
or \plc{dest_addr} might point to an intermediate buffer.

The argument \plc{bytes} indicates the size of data.

\codeptrdesc

\crossreferences
\begin{itemize}
\item \code{ompt_id_t} type, see
\specref{sec:ompt_id_t}.
\item \code{ompt_target_data_op_t} type signature, see
\specref{sec:ompt_target_data_op_t}.
\end{itemize}




\subsubsubsection{\hcode{ompt_callback_target_map_t}}
\index{ompt_callback_target_map_t@{\code{ompt_callback_target_map_t}}}
\label{sec:ompt_callback_target_map_t}
\format

\begin{ccppspecific}
\begin{omptCallback}
typedef void (*ompt_callback_target_map_t) (
  ompt_id_t \plc{target_id},
  unsigned int \plc{nitems},
  void **\plc{host_addr},
  void **\plc{device_addr},
  size_t *\plc{bytes},
  unsigned int *\plc{mapping_flags},
  const void *\plc{codeptr_ra}
);
\end{omptCallback}
\end{ccppspecific}


\record

\begin{ccppspecific}
\begin{omptRecord}
typedef struct ompt_record_target_map_t {
  ompt_id_t \plc{target_id};
  unsigned int \plc{nitems};
  void **\plc{host_addr};
  void **\plc{device_addr};
  size_t *\plc{bytes};
  unsigned int *\plc{mapping_flags};
  const void *\plc{codeptr_ra};
} ompt_record_target_map_t;
\end{omptRecord}
\end{ccppspecific}


\descr
An instance of a \code{target}, \code{target data}, or \code{target enter data} construct may contain one or more \code{map} clauses.
An OpenMP implementation may report the set of mappings associated with \code{map} clauses for a construct
with a single \code{ompt_callback_target_map} callback to report the effect of all mappings or multiple
\code{ompt_callback_target_map} callbacks with each reporting a subset of the mappings.
Furthermore, an OpenMP implementation may omit mappings that it determines are unnecessary.
If an OpenMP implementation issues multiple \code{ompt_callback_target_map}
callbacks, these callbacks may be interleaved with \code{ompt_callback_target_data_op} callbacks
used to report data operations associated with the mappings.

\argdesc

The binding of argument \plc{target_id} is the target region.

The argument \plc{nitems} indicates the number of data mappings being reported by this callback.

The argument \plc{host_addr} indicates an array of addresses of
data on host side.

The argument \plc{device_addr} indicates an array of addresses
of data on device side.

The argument \plc{bytes} indicates an array of size of data.

The argument \plc{mapping_flags} indicates the kind of data
mapping. Flags for a mapping include one or more values specified by the type
\code{ompt_target_map_flag_t}.

\codeptrdesc


\crossreferences
\begin{itemize}
\item \code{ompt_id_t} type, see
\specref{sec:ompt_id_t}.
\item \code{ompt_target_map_flag_t} type, see
\specref{sec:ompt_target_map_flag_t}.
\item \code{ompt_callback_target_data_op_t},
see \specref{sec:ompt_callback_target_data_op_t}.
\end{itemize}


\subsubsubsection{\hcode{ompt_callback_target_submit_t}}
\index{ompt_callback_target_submit_t@{\code{ompt_callback_target_submit_t}}}
\label{sec:ompt_callback_target_submit_t}
\format

\begin{ccppspecific}
\begin{omptCallback}
typedef void (*ompt_callback_target_submit_t) (
  ompt_id_t \plc{target_id},
  ompt_id_t \plc{host_op_id},
  unsigned int \plc{requested_num_teams}
);
\end{omptCallback}
\end{ccppspecific}


\descr
A thread dispatches a registered \code{ompt_callback_target_submit} callback on the host when
a target task creates an initial task on a target device.

\argdesc

The argument \plc{target_id} is a unique identifier for the
associated target region.

The argument \plc{host_op_id} is a unique identifer for the
initial task on the target device.

The argument \plc{requested_num_teams} is the number of teams that the host is requesting to
execute the kernel. The actual number of teams that execute the kernel may be smaller and generally won't be
known until the kernel begins to execute on the device.

\constraints

The argument \plc{target_id} indicates the instance of the
target construct to which the computation belongs.

The argument \plc{host_op_id} provides a unique host-side
identifier that represents the computation on the device.

\record

\begin{ccppspecific}
\begin{omptRecord}
typedef struct ompt_record_target_kernel_t {
  ompt_id_t \plc{host_op_id};
  unsigned int \plc{requested_num_teams};
  unsigned int \plc{granted_num_teams};
  ompt_device_time_t \plc{end_time};
} ompt_record_target_kernel_t;
\end{omptRecord}
\end{ccppspecific}



If a tool has configured a device to trace kernel execution using \code{ompt_set_trace_ompt},
the device will log a \code{ompt_record_target_kernel_t} record in a trace. The fields in the record
are as follows:

\begin{itemize}
\item The \plc{host_op_id} field contains a unique identifier that a tool can use to correlate a
\code{ompt_record_target_kernel_t} record with its associated \code{ompt_callback_target_submit} callback
on the host.

\item The \plc{requested_num_teams} field contains the number of teams that the host requested to execute the kernel.

\item The \plc{granted_num_teams} field contains the number of teams that the device actually used to execute the kernel.

\item The time when the initial task began execution on the device is recorded in the \plc{time} field of an enclosing
\code{ompt_record_t} structure; the time when the initial task completed execution on the device is recorded in the \plc{end_time} field.
\end{itemize}

\crossreferences
\begin{itemize}
\item \code{ompt_id_t} type, see
\specref{sec:ompt_id_t}.
\end{itemize}


\subsubsubsection{\hcode{ompt_callback_buffer_request_t}}
\index{ompt_callback_buffer_request_t@{\code{ompt_callback_buffer_request_t}}}
\label{sec:ompt_callback_buffer_request_t}

\summary
The OpenMP runtime will invoke a callback with type signature
\code{ompt_callback_buffer_request_t} to request a
buffer to store event records for a device.

\format

\begin{ccppspecific}
\begin{omptCallback}
typedef void (*ompt_callback_buffer_request_t) (
  uint64_t \plc{device_num},
  ompt_buffer_t **\plc{buffer},
  size_t *\plc{bytes}
);
\end{omptCallback}
\end{ccppspecific}


\descr
This callback requests a buffer to store trace records for the
specified device.

A buffer request callback may set \plc{*bytes} to 0 if it does not
want to provide a buffer for any reason. If a callback sets
\plc{*bytes} to 0, further recording of events for the device will be
disabled until the next invocation of \code{ompt_start_trace}.  This
will cause the device to drop future trace records until recording is
restarted.

The buffer request callback is not required to be \emph{async signal safe}.

\argdesc

The argument \plc{device_num} specifies the device.

A tool should set \plc{*buffer} to point to a buffer where device events
may be recorded and \plc{*bytes} to the length of that buffer.

\crossreferences
\begin{itemize}
\item \code{ompt_buffer_t} type, see
\specref{sec:ompt_buffer_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_callback_buffer_complete_t}}
\index{ompt_callback_buffer_complete_t@{\code{ompt_callback_buffer_complete_t}}}
\label{sec:ompt_callback_buffer_complete_t}
\summary
A device triggers a call to \code{ompt_callback_buffer_complete_t} when no further records will be recorded in an event buffer and all records written to the buffer are valid.

\format

\begin{ccppspecific}
\begin{omptCallback}
typedef void (*ompt_callback_buffer_complete_t) (
  uint64_t \plc{device_num},
  ompt_buffer_t *\plc{buffer},
  size_t \plc{bytes},
  ompt_buffer_cursor_t \plc{begin},
  int \plc{buffer_owned}
);
\end{omptCallback}
\end{ccppspecific}


\descr
This callback provides a tool with a buffer containing trace records for the
specified device. Typically, a tool will iterate through the records
in the buffer and process them.

The OpenMP implementation will make these callbacks
on a thread that is not an OpenMP master or worker.

The callee may delete the buffer if the argument
\plc{buffer_owned}=0.

The buffer completion callback is not
required to be \emph{async signal safe}.

\argdesc

The argument \plc{device_num} indicates the device whose events
the buffer contains.

The argument \plc{buffer} is the address of a buffer previously
allocated by a \emph{buffer request} callback.

The argument \plc{bytes} indicates the full size of the buffer.

The argument \plc{begin} is an opaque cursor that indicates the
position at the beginning of the first record in the buffer.

The argument \plc{buffer_owned} is 1 if the data pointed to by
buffer can be deleted by the callback and 0 otherwise. If multiple
devices accumulate trace events into a single buffer, this callback
might be invoked with a pointer to one or more trace records in a
shared buffer with \plc{buffer_owned} = 0. In this case, the callback
may not delete the buffer.

\crossreferences
\begin{itemize}
\item \code{ompt_buffer_t} type, see
\specref{sec:ompt_buffer_t}.
\item \code{ompt_buffer_cursor_t} type, see
\specref{sec:ompt_buffer_cursor_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_callback_control_tool_t}}
\index{ompt_callback_control_tool_t@{\code{ompt_callback_control_tool_t}}}
\label{sec:ompt_callback_control_tool_t}
\format

\begin{ccppspecific}
\begin{omptCallback}
typedef int (*ompt_callback_control_tool_t) (
  uint64_t \plc{command},
  uint64_t \plc{modifier},
  void *\plc{arg},
  const void *\plc{codeptr_ra}
);
\end{omptCallback}
\end{ccppspecific}


\descr

The tool control callback may return any non-negative value, which will be returned to the
application by the OpenMP implementation as the return value of the
\code{omp_control_tool} call that triggered the callback.

\argdesc

The argument \plc{command} passes a command from an application
to a tool.  Standard values for \plc{command} are defined by
\code{omp_control_tool_t}.  defined in \specref{sec:control_tool}.

The argument \plc{modifier} passes a command modifier from an
application to a tool.

This callback allows tool-specific values for \plc{command} and
\plc{modifier}.  Tools must ignore \plc{command} values that they are
not explicitly designed to handle.

The argument \plc{arg} is a void pointer that enables a tool and
an application to pass arbitrary state back and forth.
The argument \plc{arg} may be \code{NULL}.

\codeptrdesc


\constraints
Tool-specific values for \plc{command} must be $\geq$ 64.

\crossreferences
\begin{itemize}
\item \code{omp_control_tool_t} enumeration type, see \specref{sec:control_tool}.
\end{itemize}

\subsubsubsection{\hcode{ompt_callback_cancel_t}}
\index{ompt_callback_cancel_t@{\code{ompt_callback_cancel_t}}}
\label{sec:ompt_callback_cancel_t}
\format

\begin{ccppspecific}
\begin{omptCallback}
typedef void (*ompt_callback_cancel_t) (
  ompt_data_t *\plc{task_data},
  int \plc{flags},
  const void *\plc{codeptr_ra}
);
\end{omptCallback}
\end{ccppspecific}


\argdesc

The argument \plc{task_data} corresponds to the task
encountering a \code{cancel} construct, a \code{cancellation point}
construct, or a construct defined as having an implicit cancellation
point.

The argument \plc{flags}, defined by the enumeration
\code{ompt_cancel_flag_t}, indicates whether the cancel is
activated by the current task, or detected as being activated by
another task.  The construct being canceled is also described in the
\plc{flags}. When several constructs are detected as being
concurrently canceled, each corresponding bit in the flags will be
set.

\codeptrdesc

\crossreferences
\begin{itemize}
\item \code{omp_cancel_flag_t} enumeration type, see \specref{sec:ompt_cancel_flag_t}.
\end{itemize}


\subsubsubsection{\hcode{ompt_callback_device_initialize_t}}
\index{ompt_callback_flush_t@{\code{ompt_callback_device_initialize_t}}}
\label{sec:ompt_callback_device_initialize_t}

\summary The tool callback with type signature
\code{ompt_callback_device_initialize_t} initializes a
tool's tracing interface for a device.

\format

\begin{ccppspecific}
\begin{omptCallback}
typedef void (*ompt_callback_device_initialize_t) (
  uint64_t \plc{device_num},
  const char *\plc{type},
  ompt_device_t *\plc{device},
  ompt_function_lookup_t \plc{lookup},
  const char *\plc{documentation}
);
\end{omptCallback}
\end{ccppspecific}


\descr

A tool that wants to asynchronously collect a trace of
activities on a device should register a callback with type signature
\code{ompt_callback_device_initialize_t} for the
\code{ompt_callback_device_initialize} OpenMP event. An OpenMP
implementation will invoke this callback for a device after OpenMP is
initialized for the device but before beginning execution of any
OpenMP construct on the device.

\argdesc

The argument \plc{device_num} identifies the logical device
being initialized.

The argument \plc{type} is a character string indicating the
type of the device. A device type string is a semicolon separated
character string that includes at a minimum the vendor and model name
of the device. This may be followed by a semicolon-separated sequence
of properties that describe a device's hardware or software.

\devicedesc

The argument \plc{lookup} is a pointer to a runtime callback
that a tool must use to obtain pointers to runtime entry points in the
device's OMPT tracing interface. If a device does not support tracing,
it should provide \code{NULL} for \plc{lookup}.

The argument \plc{documentation} is a string that describes
how to use any device-specific runtime
entry points that can be obtained using \plc{lookup}. This
documentation string could simply be a pointer to external
documentation, or it could be inline descriptions
that includes names and type signatures for any
device-specific interfaces that are available through \plc{lookup}
along with descriptions of how to use these interface functions to
control monitoring and analysis of device traces.

\constraints
The arguments \plc{type} and \plc{documentation} must be
immutable strings that are defined for the lifetime of a program
execution.

\effect

A tool's device initializer has several duties.  First, it should use
\plc{type} to determine whether the tool has any special knowledge
about a device's hardware and/or software.  Second, it should use
\plc{lookup} to look up pointers to runtime entry points in the OMPT tracing
interface for the device.  Finally, using these runtime entry points, it can
then set up tracing for a device.

Initializing tracing for a target device is described in section
\specref{sec:tracing-device-activity}.

\crossreferences
\begin{itemize}
\item \code{ompt_function_lookup_t}, see
  \specref{sec:ompt_function_lookup_t}.
\end{itemize}


\subsubsubsection{\hcode{ompt_callback_device_finalize_t}}
\index{ompt_callback_flush_t@{\code{ompt_callback_device_finalize_t}}}
\label{sec:ompt_callback_device_finalize_t}

\summary The tool callback with type signature
\code{ompt_callback_device_finalize_t} finalizes a
tool's tracing interface for a device.

\format

\begin{ccppspecific}
\begin{omptCallback}
typedef void (*ompt_callback_device_finalize_t) (
  uint64_t \plc{device_num}
);
\end{omptCallback}
\end{ccppspecific}


\argdesc

The argument \plc{device_num} identifies the logical device
being finalized.

\descr

An OpenMP implementation dispatches a finalization callback for a
device immediately prior to finalizing the device. Prior to dispatching
a finalization callback for a device on which tracing is active,
the OpenMP implementation will stop tracing on the device and
synchronously flush all trace records for the device 
that have not yet been reported to the tool. 
If any trace records for the device need to be flushed,
the OpenMP implementation will issue one or more
buffer completion callbacks with type signature 
\code{ompt_callback_buffer_complete_t}
as needed.

\crossreferences
\begin{itemize}
\item \code{ompt_callback_buffer_complete_t}, see
  \specref{sec:ompt_callback_buffer_complete_t}.
\end{itemize}
