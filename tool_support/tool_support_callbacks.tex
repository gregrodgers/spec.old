% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. There are environments that provide special formatting, e.g. language bars.
%       Please use them whereever appropriate.  Examples are:
%
%         \begin{fortranspecific}
%         This is text that appears enclosed in blue language bars for Fortran.
%         \end{fortranspecific}
%
%         \begin{note}
%         This is a note.  The "Note -- " header appears automatically.
%         \end{note}
%
%    6. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of 
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%


\section{Tool Callback Signatures and Trace Records}
\label{sec:ompt-tool-callbacks}

\restrictions
Tool callbacks may not use OpenMP directives or call any runtime library routines
described in Section~\ref{chap:Runtime Library Routines}.

\subsection{Initialization and Finalization Callback Signature}

\omptcallbacksignature{\code{ompt\_initialize\_t}}
\label{sec:ompt_initialize_t}

\summary
A tool implements an initializer with the type signature
\code{ompt\_initialize\_t} to initialize the tool's use of
the OMPT interace.

\format
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef int (*ompt_initialize_t) (
  ompt_function_lookup_t \plc{lookup},
  struct ompt_fns_t *\plc{fns}
);
\end{boxedcode}
\end{ccppspecific}
}

\descr
For a tool to initialize the OMPT interface of an OpenMP implementation,
the tool's implementation of \code{ompt\_start\_tool} must return a 
pointer to a tool initializer with type signature \code{ompt\_initialize\_t}.
An OpenMP implementation will call the tool initializer returned by
\code{ompt\_start\_tool} after fully initializing itself but before 
beginning execution of any OpenMP construct
or completing execution of any environment routine invocation.  

The initializer returns a non-zero value if it succeeds.

\argdesc
The \callbackarg{} \plc{lookup} is a callback 
to an OpenMP runtime routine that a tool must use to 
obtain a pointer to each runtime entry point in the OMPT interface.
The \callbackarg{} \plc{fns} is the value returned by \code{ompt\_start\_tool}.
The actions of a tool initializer are described in \specref{sec:tool-initialize}.

\crossreferences
\begin{itemize}
\item \code{ompt\_function\_lookup\_t}, see
  \specref{sec:ompt_function_lookup_t}.
\end{itemize}


\omptcallbacksignature{\code{ompt\_finalize\_t}}
\label{sec:ompt_finalize_t}

\summary
A tool implements an finalizer with the type signature
\code{ompt\_finalize\_t} to finalize the tool's use of
the OMPT interface.

\format
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef void (*ompt_finalize_t) (
  struct ompt_fns_t *\plc{fns}
);
\end{boxedcode}
\end{ccppspecific}
}

\descr
The finalizer for an OpenMP implementation is invoked by an OpenMP
implementation as it shuts down.

\argdesc
The \callbackarg{} \plc{fns} is the value returned by \code{ompt\_start\_tool}.

\crossreferences
\begin{itemize}
\item \code{ompt\_fns\_t}, see
  \specref{sec:ompt_fns_t}.
\end{itemize}


\subsection{Event Callback Signatures and Trace Records}
\index{event callback signatures}
\label{sec:ToolsSupport_callback_signatures}

This section describes the signatures of tool callback functions that an OMPT
tool might register and that are called during runtime of an OpenMP program.

\omptcallbacksignature{\code{ompt\_callback\_thread\_begin\_t}}
\index{ompt\_callback\_thread\_begin\_t@{\code{ompt\_callback\_thread\_begin\_t}}}
\label{sec:ompt_callback_thread_begin_t}
\format
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef void (*ompt_callback_thread_begin_t) (
  ompt_thread_type_t \plc{thread_type},
  ompt_data_t *\plc{thread_data}
);
\end{boxedcode}
\end{ccppspecific}
}

\record
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef struct ompt_record_thread_begin_s \{
  ompt_thread_type_t \plc{thread_type};
\} ompt_record_thread_begin_t;
\end{boxedcode}
\end{ccppspecific}
}

\argdesc

The \callbackarg{} \plc{thread\_type}
indicates the type of the new thread: initial, worker, or other.

The binding of \callbackarg{} \plc{thread\_data} is the new thread.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_thread\_type\_t} type, see
\specref{sec:ompt_thread_type_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_thread\_end\_t}}
\index{ompt\_callback\_thread\_end\_t@{\code{ompt\_callback\_thread\_end\_t}}}
\label{sec:ompt_callback_thread_end_t}
\format
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef void (*ompt_callback_thread_end_t) (
  ompt_data_t *\plc{thread_data}
);
\end{boxedcode}
\end{ccppspecific}
}

\argdesc

The binding of \callbackarg{} \plc{thread\_data} is the thread that is
terminating.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\end{itemize}


\omptcallbacksignature{\code{ompt\_callback\_idle\_t}}
\index{ompt\_callback\_idle\_t@{\code{ompt\_callback\_idle\_t}}}
\label{sec:ompt_callback_idle_t}
\format
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef void (*ompt_callback\_idle_t) (
  ompt_scope_endpoint_t \plc{endpoint}
);
\end{boxedcode}
\end{ccppspecific}
}

\record
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef struct ompt_record_idle_s \{
  ompt_scope_endpoint_t \plc{endpoint};
\} ompt_record_idle_t;
\end{boxedcode}
\end{ccppspecific}
}

\argdesc

The \callbackarg{} \plc{endpoint} indicates whether the callback is
signalling the beginning or end of an idle interval.

\crossreferences
\begin{itemize}
\item \code{ompt\_scope\_endpoint\_t} type, see
\specref{sec:ompt_scope_endpoint_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_parallel\_begin\_t}}
\index{ompt\_callback\_parallel\_begin\_t@{\code{ompt\_callback\_parallel\_begin\_t}}}
\label{sec:ompt_callback_parallel_begin_t}
\format
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef void (*ompt_callback_parallel_begin_t) (
  ompt_data_t *\plc{parent_task_data},
  const ompt_frame_t *\plc{parent_frame},
  ompt_data_t *\plc{parallel_data},
  unsigned int \plc{requested_team_size},
  ompt_invoker_t \plc{invoker},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\end{ccppspecific}
}

\record
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef struct ompt_record_parallel_begin_s \{
  ompt_id_t \plc{parent_task_id};
  ompt_id_t \plc{parallel_id};
  unsigned int \plc{requested_team_size};
  ompt_invoker_t \plc{invoker};
  const void *\plc{codeptr_ra};
\} ompt_record_parallel_begin_t;
\end{boxedcode}
\end{ccppspecific}
}

\argdesc

The binding of \callbackarg{} \plc{parent\_task\_data} is the
encountering task.

The \callbackarg{} \plc{parent\_frame} points to the frame object
associated with the encountering task.

The binding of \callbackarg{} \plc{parallel\_data} is the parallel
region that is beginning.

The \callbackarg{} \plc{requested\_team\_size}
indicates the number of threads requested by the user. 

The \callbackarg{} \plc{invoker} indicates whether the code for the
parallel region is inlined into the application or invoked by the
runtime.

\codeptrdesc

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see \specref{sec:ompt_data_t}.
\item \code{ompt\_frame\_t} type, see \specref{sec:ompt_frame_t}.
\item \code{ompt\_invoker\_t} type, see \specref{sec:ompt_invoker_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_parallel\_end\_t}}
\index{ompt\_callback\_parallel\_end\_t@{\code{ompt\_callback\_parallel\_end\_t}}}
\label{sec:ompt_callback_parallel_end_t}
\format
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef void (*ompt_callback_parallel_end_t) (
  ompt_data_t *\plc{parallel_data},
  ompt_data_t *\plc{task_data},
  ompt_invoker_t \plc{invoker},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\end{ccppspecific}
}

\record
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef struct ompt_record_parallel_end_s \{
  ompt_id_t \plc{parallel_id}; 
  ompt_id_t \plc{task_id};
  ompt_invoker_t \plc{invoker};
  const void *\plc{codeptr_ra};
\} ompt_record_parallel_end_t;
\end{boxedcode}
\end{ccppspecific}
}

\argdesc

The binding of \callbackarg{} \plc{parallel\_data} is the parallel
region that is ending.

The binding of \callbackarg{} \plc{task\_data} is the encountering
task.

The \callbackarg{} \plc{invoker} explains whether the execution of the
parallel region code is inlined into the application code or started
by the runtime.

\codeptrdesc

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type signature, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_invoker\_t} type signature, see
\specref{sec:ompt_invoker_t}.
\end{itemize}

\omptcallbacksignature{\code{ompt\_callback\_master\_t}}
\index{ompt\_callback\_master\_t@{\code{ompt\_callback\_master\_t}}}
\label{sec:ompt_callback_master_t}
\format
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef void (*ompt_callback_master_t) (
  ompt_scope_endpoint_t \plc{endpoint},
  ompt_data_t *\plc{parallel_data},
  ompt_data_t *\plc{task_data},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\end{ccppspecific}
}

\record
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef struct ompt_record_master_s \{
  ompt_scope_endpoint_t \plc{endpoint};
  ompt_id_t \plc{parallel_id};
  ompt_id_t \plc{task_id};
  const void *\plc{codeptr_ra};
\} ompt_record_master_t;
\end{boxedcode}
\end{ccppspecific}
}

\argdesc

\epdesc

The binding of \callbackarg{} \plc{parallel\_data} is the current parallel region.

The binding of \callbackarg{} \plc{task\_data} is the encountering task.

\codeptrdesc

%\effect
% ompt events have no effect

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type signature, see \specref{sec:ompt_data_t}.
\item \code{ompt\_scope\_endpoint\_t} type, see \specref{sec:ompt_scope_endpoint_t}.
\end{itemize}





\omptcallbacksignature{\code{ompt\_callback\_task\_create\_t}}
\index{ompt\_callback\_task\_create\_t@{\code{ompt\_callback\_task\_create\_t}}}
\label{sec:ompt_callback_task_create_t}
\format
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef void (*ompt_callback_task_create_t) (
  ompt_data_t *\plc{parent_task_data},
  const ompt_frame_t *\plc{parent_frame},
  ompt_data_t *\plc{new_task_data},
  ompt_task_type_t \plc{type},
  int \plc{has_dependences},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\end{ccppspecific}
}

\record
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef struct ompt_record_task_create_s \{
  ompt_id_t \plc{parent_task_id};
  ompt_id_t \plc{new_task_id};
  ompt_task_type_t \plc{type};
  int \plc{has_dependences};
  const void *\plc{codeptr_ra};
\} ompt_record_task_create_t;
\end{boxedcode}
\end{ccppspecific}
}

\argdesc

The binding of \callbackarg{} \plc{parent\_task\_data} is the
encountering task.  
This parameter is \code{NULL} for an initial task.

The \callbackarg{} \plc{parent\_frame} points to the frame object
associated with the encountering task. 
This parameter is \code{NULL} for an initial task.

The binding of \callbackarg{} \plc{new\_task\_data} is the created
task.

The \callbackarg{} \plc{type} indicates the kind of the task: initial,
explicit or target.

The \callbackarg{} \plc{has\_dependences} indicates whether created
task has dependences.

\codeptrdesc

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_frame\_t} type, see
\specref{sec:ompt_frame_t}.
\item \code{ompt\_task\_type\_t} type, see
\specref{sec:ompt_task_type_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_task\_dependences\_t}}
\index{ompt\_callback\_task\_dependences\_t@{\code{ompt\_callback\_task\_dependences\_t}}}
\label{sec:ompt_callback_task_dependences_t}
\format
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef void (*ompt_callback_task_dependences_t) (
  ompt_data_t *\plc{task_data},
  const ompt_task_dependence_t *\plc{deps},
  int \plc{ndeps}
);
\end{boxedcode}
\end{ccppspecific}
}

\argdesc

The binding of \callbackarg{} \plc{task\_data} is the task being created.

The \callbackarg{} \plc{deps} lists all dependences of a new task.

The \callbackarg{} \plc{ndeps} specifies the length of the list.
The memory for \plc{deps} is owned by the caller; the tool cannot rely on
the data after the callback returns.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_task\_dependence\_t} type, see
\specref{sec:ompt_task_dependence_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_task\_dependence\_t}}
\index{ompt\_callback\_task\_dependence\_t@{\code{ompt\_callback\_task\_dependence\_t}}}
\label{sec:ompt_callback_task_dependence_t}
\format
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef void (*ompt_callback_task_dependence_t) (
  ompt_data_t *\plc{src_task_data},
  ompt_data_t *\plc{sink_task_data}
);
\end{boxedcode}
\end{ccppspecific}
}

\record
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef struct ompt_record_task_dependence_s \{
  ompt_id_t \plc{src_task_id};
  ompt_id_t \plc{sink_task_id};
\} ompt_record_task_dependence_t;
\end{boxedcode}
\end{ccppspecific}
}

\argdesc

The binding of \callbackarg{} \plc{src\_task\_data} is a running task
with an outgoing dependence.

The binding of \callbackarg{} \plc{sink\_task\_data} is a task with an
unsatisfied incoming dependence.


\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type signature, see
\specref{sec:ompt_data_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_task\_schedule\_t}}
\index{ompt\_callback\_task\_schedule\_t@{\code{ompt\_callback\_task\_schedule\_t}}}
\label{sec:ompt_callback_task_schedule_t}
\format
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef void (*ompt_callback_task_schedule_t) (
  ompt_data_t *\plc{prior_task_data},
  ompt_task_status_t \plc{prior_task_status},
  ompt_data_t *\plc{next_task_data}
);
\end{boxedcode}
\end{ccppspecific}
}

\record
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef struct ompt_record_task_schedule_s \{
  ompt_id_t \plc{prior_task_id};
  ompt_task_status_t \plc{prior_task_status},
  ompt_id_t \plc{next_task_id};
\} ompt_record_task_schedule_t;
\end{boxedcode}
\end{ccppspecific}
}

\argdesc

The \callbackarg{} \plc{prior\_task\_status} indicates the status of
the task that arrived at a task scheduling point.

The binding of \callbackarg{} \plc{prior\_task\_data} is the task that
arrived at the scheduling point.

The binding of \callbackarg{} \plc{next\_task\_data} is the task that
will resume at the scheduling point.

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.

\item \code{ompt\_task\_status\_t} type, see
\specref{sec:ompt_task_status_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_implicit\_task\_t}}
\index{ompt\_callback\_implicit\_task\_t@{\code{ompt\_callback\_implicit\_task\_t}}}
\label{sec:ompt_callback_implicit_task_t}
\format
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef void (*ompt_callback_implicit_task_t) (
  ompt_scope_endpoint_t \plc{endpoint},
  ompt_data_t *\plc{parallel_data},
  ompt_data_t *\plc{task_data},
  unsigned int \plc{team_size},
  unsigned int \plc{thread_num}
);
\end{boxedcode}
\end{ccppspecific}
}

\record
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef struct ompt_record_implicit_s \{
  ompt_scope_endpoint_t \plc{endpoint};
  ompt_id_t \plc{parallel_id};
  ompt_id_t \plc{task_id};
  unsigned int \plc{team_size},
  unsigned int \plc{thread_num};
\} ompt_record_implicit_t;
\end{boxedcode}
\end{ccppspecific}
}

\argdesc

\epdesc

The binding of \callbackarg{} \plc{parallel\_data} is the current
parallel region.

The binding of \callbackarg{} \plc{task\_data} is the implicit task
executing the parallel region's structured block.

The \callbackarg{} \plc{team\_size} indicates the number of
threads in the team.

The \callbackarg{} \plc{thread\_num} indicates
the thread number of the calling thread, within the team executing the parallel
region to which the implicit region binds.


\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_scope\_endpoint\_t} enumeration type, see
\specref{sec:ompt_scope_endpoint_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_sync\_region\_t}}
\index{ompt\_callback\_sync\_region\_t@{\code{ompt\_callback\_sync\_region\_t}}}
\label{sec:ompt_callback_sync_region_t}
\format
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef void (*ompt_callback_sync_region_t) (
  ompt_sync_region_kind_t \plc{kind},
  ompt_scope_endpoint_t \plc{endpoint},
  ompt_data_t *\plc{parallel_data},
  ompt_data_t *\plc{task_data},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\end{ccppspecific}
}

\record
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef struct ompt_record_sync_region_s \{
  ompt_sync_region_kind_t \plc{kind};
  ompt_scope_endpoint_t \plc{endpoint};
  ompt_id_t \plc{parallel_id};
  ompt_id_t \plc{task_id};
  const void *\plc{codeptr_ra};
\} ompt_record_sync_region_t;
\end{boxedcode}
\end{ccppspecific}
}

% \descr
% A tool executes a callback with type signature
% \code{ompt\_callback\_sync\_region\_t} to receive notification of
% event \code{ompt\_callback\_sync\_region\_t} when an OpenMP
% implementation starts and stops waiting in a barrier region, taskwait
% region, or taskgroup region.

\argdesc

The \callbackarg{} \plc{kind} indicates the kind of
synchronization region.

\epdesc

The binding of \callbackarg{} \plc{parallel\_data} is the current
parallel region.

The binding of \callbackarg{} \plc{task\_data} is the current task.

\codeptrdesc

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_sync\_region\_kind\_t} type, see
\specref{sec:ompt_sync_region_kind_t}.
\item \code{ompt\_scope\_endpoint\_t} type, see
\specref{sec:ompt_scope_endpoint_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_lock\_init\_t}}
\index{ompt\_callback\_lock\_init\_t@{\code{ompt\_callback\_lock\_init\_t}}}
\label{sec:ompt_callback_lock_init_t}
\format
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef void (*ompt_callback_lock_init_t) (
  ompt_mutex_kind_t \plc{kind},
  unsigned int \plc{hint},
  unsigned int \plc{impl},
  ompt_wait_id_t \plc{wait_id},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\end{ccppspecific}
}

\record
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef struct ompt_record_lock_init_s \{
  ompt_mutex_kind_t \plc{kind};
  unsigned int \plc{hint};
  unsigned int \plc{impl};
  ompt_wait_id_t \plc{wait_id};
  const void *\plc{codeptr_ra};
\} ompt_record_lock_init_t;
\end{boxedcode}
\end{ccppspecific}
}

\argdesc

The \callbackarg{} \plc{kind} indicates the kind of the lock.

The \callbackarg{} \plc{hint} indicates the hint provided when initializing
an implementation of mutual exclusion.

The \callbackarg{} \plc{impl} indicates the mechanism chosen by the
runtime to implement the mutual exclusion.

The \callbackarg{} \plc{wait\_id} indicates the object being awaited. 

\codeptrdesc


\crossreferences
\begin{itemize}
\item \code{ompt\_wait\_id\_t} type, see
\specref{sec:ompt_wait_id_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_lock\_destroy\_t}}
\index{ompt\_callback\_lock\_destroy\_t@{\code{ompt\_callback\_lock\_destroy\_t}}}
\label{sec:ompt_callback_lock_destroy_t}
\format
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef void (*ompt_callback_lock_destroy_t) (
  ompt_mutex_kind_t \plc{kind},
  ompt_wait_id_t \plc{wait_id},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\end{ccppspecific}
}

\record
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef struct ompt_record_lock_destroy_s \{
  ompt_mutex_kind_t \plc{kind};
  ompt_wait_id_t \plc{wait_id};
  const void *\plc{codeptr_ra};
\} ompt_record_lock_destroy_t;
\end{boxedcode}
\end{ccppspecific}
}

\argdesc

The \callbackarg{} \plc{kind} indicates the kind of the lock.

The \callbackarg{} \plc{wait\_id} identifies the lock.

\codeptrdesc


\crossreferences
\begin{itemize}
\item \code{ompt\_wait\_id\_t} type, see
\specref{sec:ompt_wait_id_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_mutex\_acquire\_t}}
\index{ompt\_callback\_mutex\_acquire\_t@{\code{ompt\_callback\_mutex\_acquire\_t}}}
\label{sec:ompt_callback_mutex_acquire_t}
\format
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef void (*ompt_callback_mutex_acquire_t) (
  ompt_mutex_kind_t \plc{kind},
  unsigned int \plc{hint},
  unsigned int \plc{impl},
  ompt_wait_id_t \plc{wait_id},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\end{ccppspecific}
}

\record
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef struct ompt_record_mutex_acquire_s \{
  ompt_mutex_kind_t \plc{kind};
  unsigned int \plc{hint};
  unsigned int \plc{impl};
  ompt_wait_id_t \plc{wait_id};
  const void *\plc{codeptr_ra};
\} ompt_record_mutex_acquire_t;
\end{boxedcode}
\end{ccppspecific}
}

\argdesc

The \callbackarg{} \plc{kind} indicates the kind of the lock.

The \callbackarg{} \plc{hint} indicates the hint provided when initializing
an implementation of mutual exclusion.
If no hint is available when a thread initiates acquisition of mutual exclusion,
the runtime may supply \code{omp\_lock\_hint\_none} as the value for \plc{hint}.

The \callbackarg{} \plc{impl} indicates the mechanism chosen by the
runtime to implement the mutual exclusion.  

The \callbackarg{} \plc{wait\_id} indicates the object being awaited. 

\codeptrdesc

\crossreferences
\begin{itemize}
\item \code{ompt\_wait\_id\_t} type, see
\specref{sec:ompt_wait_id_t}.
\item \code{ompt\_mutex\_kind\_t} type, see
\specref{sec:ompt_mutex_kind_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_mutex\_t}}
\index{ompt\_callback\_mutex\_t@{\code{ompt\_callback\_mutex\_t}}}
\label{sec:ompt_callback_mutex_t}
\format
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef void (*ompt_callback_mutex_t) (
  ompt_mutex_kind_t \plc{kind},
  ompt_wait_id_t \plc{wait_id},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\end{ccppspecific}
}

\record
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef struct ompt_record_mutex_s \{
  ompt_mutex_kind_t \plc{kind};
  ompt_wait_id_t \plc{wait_id};
  const void *\plc{codeptr_ra};
\} ompt_record_mutex_t;
\end{boxedcode}
\end{ccppspecific}
}

\argdesc

The \callbackarg{} \plc{kind} indicates the kind of mutual exclusion event.

The \callbackarg{} \plc{wait\_id} indicates the object being awaited. 

\codeptrdesc

\crossreferences
\begin{itemize}
\item \code{ompt\_wait\_id\_t} type signature, see
\specref{sec:ompt_wait_id_t}.
\item \code{ompt\_mutex\_kind\_t} type signature, see
\specref{sec:ompt_mutex_kind_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_nest\_lock\_t}}
\index{ompt\_callback\_nest\_lock\_t@{\code{ompt\_callback\_nest\_lock\_t}}}
\label{sec:ompt_callback_nest_lock_t}
\format
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef void (*ompt_callback_nest_lock_t) (
  ompt_scope_endpoint_t \plc{endpoint},
  ompt_wait_id_t \plc{wait_id},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\end{ccppspecific}
}

\record
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef struct ompt_record_nest_lock_s \{
  ompt_scope_endpoint_t \plc{endpoint};
  ompt_wait_id_t \plc{wait_id};
  const void *\plc{codeptr_ra};
\} ompt_record_nest_lock_t;
\end{boxedcode}
\end{ccppspecific}
}

\argdesc

\epdesc

The \callbackarg{} \plc{wait\_id} indicates the object being awaited. 

\codeptrdesc

\crossreferences
\begin{itemize}
\item \code{ompt\_wait\_id\_t} type signature, see
\specref{sec:ompt_wait_id_t}.
\item \code{ompt\_scope\_endpoint\_t} type signature, see
\specref{sec:ompt_scope_endpoint_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_work\_t}}
\index{ompt\_callback\_work\_t@{\code{ompt\_callback\_work\_t}}}
\label{sec:ompt_callback_work_t}
\format
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef void (*ompt_callback_work_t) (
  ompt_work_type_t \plc{wstype},
  ompt_scope_endpoint_t \plc{endpoint},
  ompt_data_t *\plc{parallel_data},
  ompt_data_t *\plc{task_data},
  \longlongint{} \plc{count},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\end{ccppspecific}
}

\record
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef struct ompt_record_work_s \{
  ompt_work_type_t \plc{wstype};
  ompt_scope_endpoint_t \plc{endpoint};
  ompt_id_t \plc{parallel_id};
  ompt_id_t \plc{task_id};
  \longlongint{} \plc{count};
  const void *\plc{codeptr_ra};
\} ompt_record_work_t;
\end{boxedcode}
\end{ccppspecific}
}

\argdesc

The \callbackarg{} \plc{wstype} indicates the kind of worksharing
region.

\epdesc

The binding of \callbackarg{} \plc{parallel\_data} is the current
parallel region.

The binding of \callbackarg{} \plc{task\_data} is the current task.

The \callbackarg{} \plc{count} is a measure of the quantity of work involved in the worksharing construct. 
For a loop construct, \plc{count} represents the number of iterations of the loop.
For a \code{taskloop} construct, \plc{count} represents the number of iterations in the iteration space, 
which may be the result of collapsing several associated loops.
For a \code{sections} construct, \plc{count} represents the number of sections. 
For a \code{workshare} construct, \plc{count} represents the units of work, as defined by the \code{workshare} construct.
For a \code{single} construct, \plc{count} is always 1.

\codeptrdesc


\crossreferences
\begin{itemize}
\item worksharing constructs, see \specref{sec:Worksharing Constructs}.
\item \code{ompt\_data\_t} type signature, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_scope\_endpoint\_t} type signature, see
\specref{sec:ompt_scope_endpoint_t}.
\item \code{ompt\_work\_type\_t} type signature, see
\specref{sec:ompt_work_type_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_flush\_t}}
\index{ompt\_callback\_flush\_t@{\code{ompt\_callback\_flush\_t}}}
\label{sec:ompt_callback_flush_t}
\format
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef void (*ompt_callback_flush_t) (
  ompt_data_t *\plc{thread_data},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\end{ccppspecific}
}

\record
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef struct ompt_record_flush_s \{
  void *\plc{codeptr_ra};
\} ompt_record_flush_t;
\end{boxedcode}
\end{ccppspecific}
}

\argdesc

\codeptrdesc

\crossreferences
\begin{itemize}
\item \code{ompt\_data\_t} type signature, see
\specref{sec:ompt_data_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_target\_t}}
\index{ompt\_callback\_target\_t@{\code{ompt\_callback\_target\_t}}}
\label{sec:ompt_callback_target_t}
\format
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef void (*ompt_callback_target_t) (
  ompt_target_type_t \plc{kind},
  ompt_scope_endpoint_t \plc{endpoint},
  uint64_t \plc{device_num},
  ompt_data_t *\plc{task_data},
  ompt_id_t \plc{target_id},
  const void *\plc{codeptr_ra}
);
\end{boxedcode}
\end{ccppspecific}
}

\record
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef struct ompt_record_target_s \{
  ompt_target_type_t \plc{kind};
  ompt_scope_endpoint_t \plc{endpoint};
  uint64_t \plc{device_num};
  ompt_data_t *\plc{task_data};
  ompt_id_t \plc{target_id};
  const void *\plc{codeptr_ra};
\} ompt_record_target_t;
\end{boxedcode}
\end{ccppspecific}
}

\argdesc

The \callbackarg{} \plc{kind} indicates the kind of target region.

\epdesc

The \callbackarg{} \plc{device\_num} indicates the id of the device
which will execute the target region.

The binding of \callbackarg{} \plc{task\_data} is the target task.

The binding of \callbackarg{} \plc{target\_id} is the target region.

\codeptrdesc

\crossreferences
\begin{itemize}
\item \code{ompt\_id\_t} type, see
\specref{sec:ompt_id_t}.
\item \code{ompt\_data\_t} type signature, see
\specref{sec:ompt_data_t}.
\item \code{ompt\_scope\_endpoint\_t} type signature, see
\specref{sec:ompt_scope_endpoint_t}.
\item \code{ompt\_target\_type\_t} type signature, see
\specref{sec:ompt_target_type_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_target\_data\_op\_t}}
\index{ompt\_callback\_target\_data\_op\_t@{\code{ompt\_callback\_target\_data\_op\_t}}}
\label{sec:ompt_callback_target_data_op_t}
\format

\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef void (*ompt_callback_target_data_op_t) (
  ompt_id_t \plc{target_id},
  ompt_id_t \plc{host_op_id},
  ompt_target_data_op_t \plc{optype},
  void *\plc{host_addr},
  void *\plc{device_addr},
  size_t \plc{bytes}
);
\end{boxedcode}
\end{ccppspecific}
}

\record
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef struct ompt_record_target_data_op_s \{
  ompt_id_t \plc{host\_op\_id};
  ompt_target_data_op_t \plc{optype};
  void *\plc{host\_addr};
  void *\plc{device\_addr};
  size_t \plc{bytes};
  ompt_device_time_t \plc{end\_time};
\} ompt_record_target_data_op_t;
\end{boxedcode}
\end{ccppspecific}
}

\argdesc

The \callbackarg{} \plc{host\_op\_id} is a unique identifer for a data
operations on a target device.

The \callbackarg{} \plc{optype} indicates the kind of data mapping.

The \callbackarg{} \plc{host\_addr} indicates the address of data on
host side.

The \callbackarg{} \plc{device\_addr} indicates the address of data on
device side.

The \callbackarg{} \plc{bytes} indicates the size of data.

\crossreferences
\begin{itemize}
\item \code{ompt\_id\_t} type, see
\specref{sec:ompt_id_t}.
\item \code{ompt\_target\_data\_op\_t} type signature, see
\specref{sec:ompt_target_data_op_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_target\_map\_t}}
\index{ompt\_callback\_target\_map\_t@{\code{ompt\_callback\_target\_map\_t}}}
\label{sec:ompt_callback_target_map_t}
\format
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef void (*ompt_callback_target_map_t) (
  ompt_id_t \plc{target_id},
  unsigned int \plc{nitems},
  void **\plc{host_addr},
  void **\plc{device_addr},
  size_t *\plc{bytes},
  unsigned int *\plc{mapping_flags}
);
\end{boxedcode}
\end{ccppspecific}
}

\record
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef struct ompt_record_target_map_s \{
  ompt_id_t \plc{target_id};
  unsigned int \plc{nitems};
  void **\plc{host_addr};
  void **\plc{device_addr};
  size_t *\plc{bytes};
  unsigned int *\plc{mapping_flags};
\} ompt_record_target_map_t;
\end{boxedcode}
\end{ccppspecific}
}

\argdesc

The binding of \callbackarg{} \plc{target\_id} is the target region.

The \callbackarg{} \plc{nitems} indicates the number of data mappings.

The \callbackarg{} \plc{host\_addr} indicates an array of addresses of
data on host side.

The \callbackarg{} \plc{device\_addr} indicates an array of addresses
of data on device side.

The \callbackarg{} \plc{bytes} indicates an array of size of data.

The \callbackarg{} \plc{mapping\_flags} indicates the kind of data
mapping.


\crossreferences
\begin{itemize}
\item \code{ompt\_id\_t} type, see
\specref{sec:ompt_id_t}.
\end{itemize}



\omptcallbacksignature{\code{ompt\_callback\_target\_submit\_t}}
\index{ompt\_callback\_target\_submit\_t@{\code{ompt\_callback\_target\_submit\_t}}}
\label{sec:ompt_callback_target_submit_t}
\format
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef void (*ompt_callback_target_submit_t) (
  ompt_id_t \plc{target_id},
  ompt_id_t \plc{host_op_id}
);
\end{boxedcode}
\end{ccppspecific}
}

\descr
This callback is invoked when a target task creates an initial task on a
target device. 

\argdesc

The \callbackarg{} \plc{target\_id} is a unique identifier for the
associated target region.

The \callbackarg{} \plc{host\_op\_id} is a unique identifer for the
initial task on the target device.

\constraints

The \callbackarg{} \plc{target\_id} indicates the instance of the
target construct to which the computation belongs.

The \callbackarg{} \plc{host\_op\_id} provides a unique host-side
identifier that represents the computation on the device.

\record
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef struct ompt_record_target_kernel_s \{
  ompt_id_t \plc{host_op_id};
  unsigned int \plc{requested_num_teams};
  unsigned int \plc{granted_num_teams};
  ompt_device_time_t \plc{end_time};
\} ompt_record_target_kernel_t;
\end{boxedcode}
\end{ccppspecific}
}

\crossreferences
\begin{itemize}
\item \code{ompt\_id\_t} type, see
\specref{sec:ompt_id_t}.
\end{itemize}


\omptcallbacksignature{\code{ompt\_callback\_buffer\_request\_t}}
\index{ompt\_callback\_buffer\_request\_t@{\code{ompt\_callback\_buffer\_request\_t}}}
\label{sec:ompt_callback_buffer_request_t}

\summary
The OpenMP runtime will invoke a callback with type signature  
\code{ompt\_callback\_buffer\_request\_t} to request a
buffer to store event records for a device.

\format
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef void (*ompt_callback_buffer_request_t) (
  uint64_t \plc{device_num},
  ompt_buffer_t **\plc{buffer},
  size_t *\plc{bytes}
);
\end{boxedcode}
\end{ccppspecific}
}

\descr
The callback requests a buffer to store trace records for the
specified device.

A buffer request callback may set \plc{*bytes} to 0 if it does not
want to provide a buffer for any reason. If a callback sets
\plc{*bytes} to 0, further recording of events for the device will be
disabled until the next invocation of \code{ompt\_start\_trace}.  This
will cause the device to drop future trace records until recording is
restarted.

The buffer request callback is not required to be \emph{async signal safe}.

\argdesc

The \callbackarg{} \plc{device\_num} specifies the device. 

A tool should set \plc{*buffer} to point to a buffer where device events
may be recorded and \plc{*bytes} to the length of that buffer.  

\crossreferences
\begin{itemize}
\item \code{ompt\_buffer\_t} type, see
\specref{sec:ompt_buffer_t}.
\end{itemize}

\omptcallbacksignature{\code{ompt\_callback\_buffer\_complete\_t}}
\index{ompt\_callback\_buffer\_complete\_t@{\code{ompt\_callback\_buffer\_complete\_t}}}
\label{sec:ompt_callback_buffer_complete_t}
\summary
A device triggers a call to \code{ompt\_callback\_buffer\_complete\_t} when no further records will be recorded in an event buffer and all records written to the buffer are valid. 

\format
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef void (*ompt_callback_buffer_complete_t) (
  uint64_t \plc{device_num},
  const ompt_buffer_t *\plc{buf},
  size_t \plc{bytes},
  ompt_buffer_cursor_t \plc{begin},
  int \plc{buffer_owned}
);
\end{boxedcode}
\end{ccppspecific}
}

\descr 
The callback provides a tool with a buffer containing trace records for the
specified device. Typically, a tool will iterate through the records
in the buffer and process them.

The OpenMP implementation will make these callbacks
on a thread that is not an OpenMP master or worker. 

The callee may delete the buffer if the \callbackarg{}
\plc{buffer\_owned}=0.

The buffer completion callback is not 
required to be \emph{async signal safe}.

\argdesc

The \callbackarg{} \plc{device\_num} indicates the device whose events
the buffer contains.

The \callbackarg{} \plc{buffer} is the address of a buffer previously
allocated by a \emph{buffer request} callback.

The \callbackarg{} \plc{bytes} indicates the full size of the buffer.

The \callbackarg{} \plc{begin} is an opaque cursor that indicates the
position at the beginning of the first record in the buffer.

The \callbackarg{} \plc{buffer\_owned} is 1 if the data pointed to by
buffer can be deleted by the callback and 0 otherwise. If multiple
devices accumulate trace events into a single buffer, this callback
might be invoked with a pointer to one or more trace records in a
shared buffer with \plc{buffer\_owned} = 0. In this case, the callback
may not delete the buffer.

\crossreferences
\begin{itemize}
\item \code{ompt\_buffer\_t} type, see
\specref{sec:ompt_buffer_t}.
\item \code{ompt\_buffer\_cursor\_t} type, see
\specref{sec:ompt_buffer_cursor_t}.
\end{itemize}

\omptcallbacksignature{\code{ompt\_callback\_control\_tool\_t}}
\index{ompt\_callback\_control\_tool\_t@{\code{ompt\_callback\_control\_tool\_t}}}
\label{sec:ompt_callback_control_tool_t}
\format
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef int (*ompt_callback_control\_tool_t) (
  \longlongint{} \plc{command},
  \longlongint{} \plc{modifier},
  void *\plc{arg}
);
\end{boxedcode}
\end{ccppspecific}
}

\descr

The tool control callback may return any non-negative value, which will be returned to the 
application by the OpenMP implementation as the return value of the 
\code{omp\_control\_tool} call that triggered the callback.

\argdesc 

The \callbackarg{} \plc{command} passes a command from an application
to a tool.  Standard values for \plc{command} are defined by
\code{omp\_control\_tool\_t}.  defined in \specref{sec:control_tool}.

The \callbackarg{} \plc{modifier} passes a command modifier from an
application to a tool.

The callback allows tool-specific values for \plc{command} and
\plc{modifier}.  Tools must ignore \plc{command} values that they are
not explicitly designed to handle.

The \callbackarg{} \plc{arg} is a void pointer that enables a tool and
an application to pass arbitrary state back and forth. 
The \callbackarg{} \plc{arg} may be \code{NULL}.



\constraints
Tool-specific values for \plc{command} must be $\geq$ 64.

\crossreferences
\begin{itemize}
\item \code{omp\_control\_tool\_t} enumeration type, see \specref{sec:control_tool}.
\end{itemize}

\omptcallbacksignature{\code{ompt\_callback\_cancel\_t}}
\index{ompt\_callback\_cancel\_t@{\code{ompt\_callback\_cancel\_t}}}
\label{sec:ompt_callback_cancel_t}
\format
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef void (*ompt_callback_cancel_t) (
  ompt_data_t *\plc{task_data},
  int \plc{flags},
  const void *\plc{codeptr_ra}
  );
\end{boxedcode}
\end{ccppspecific}
}

\argdesc 

The \callbackarg{} \plc{task\_data} corresponds to the task
encountering a \code{cancel} construct, a \code{cancellation point}
construct, or a construct defined as having an implicit cancellation
point.

The \callbackarg{} \plc{flags}, defined by the enumeration
\code{ompt\_cancel\_flag\_t}, indicates whether the cancel is
activated by the current task, or detected as being activated by
another task.  The construct being canceled is also described in the
\plc{flags}. When several constructs are detected as being
concurrently canceled, each corresponding bit in the flags will be
set.

\codeptrdesc

\crossreferences
\begin{itemize}
\item \code{omp\_cancel\_flag\_t} enumeration type, see \specref{sec:ompt_cancel_flag_t}.
\end{itemize}


\omptcallbacksignature{\code{ompt\_callback\_device\_initialize\_t}}
\index{ompt\_callback\_flush\_t@{\code{ompt\_callback\_device\_initialize\_t}}}
\label{sec:ompt_callback_device_initialize_t}

\summary The tool callback with type signature
\code{ompt\_callback\_device\_initialize\_t} initializes a
tool's tracing interface for a device.

\format
\vbox{
\begin{ccppspecific}
\begin{boxedcode}
typedef void (*ompt_callback_device_initialize_t) (
  uint64_t \plc{device_num},
  const char *\plc{type},
  ompt_device_t *\plc{device},
  ompt_function_lookup_t *\plc{lookup},
  const char *\plc{documentation}
);
\end{boxedcode}
\end{ccppspecific}
}

\descr 

A tool that wants to asynchronously collect a trace of
activities on a device should register a callback with type signature
\code{ompt\_callback\_device\_initialize\_t} for the
\code{ompt\_callback\_device\_initialize} OpenMP event. An OpenMP
implementation will invoke this callback for a device after OpenMP is
initialized for the device but before beginning execution of any
OpenMP construct on the device.

\argdesc

The \callbackarg{} \plc{device\_num} identifies the logical device
being initialized.

The \callbackarg{} \plc{type} is a character string indicating the
type of the device. A device type string is a semicolon separated
character string that includes at a minimum the vendor and model name
of the device. This may be followed by a semicolon-separated sequence
of properties that describe a device's hardware or software.

\devicedesc

The \callbackarg{} \plc{lookup} is a pointer to a runtime callback
that a tool must use to obtain pointers to runtime entry points in the
device's OMPT tracing interface. If a device does not support tracing,
it should provide \code{NULL} for \plc{lookup}.

The \callbackarg{} \plc{documentation} is a string that describes
how to use any device-specific runtime
entry points that can be obtained using \plc{lookup}. This
documentation string could simply be a pointer to external
documentation, or it could be inline descriptions 
that includes names and type signatures for any
device-specific interfaces that are available through \plc{lookup}
along with descriptions of how to use these interface functions to
control monitoring and analysis of device traces.

\constraints
The \callbackarg{}s \plc{type} and \plc{documentation} must be
immutable strings that are defined for the lifetime of a program
execution.

\effect

A tool's device initializer has several duties.  First, it should use
\plc{type} to determine whether the tool has any special knowledge
about a device's hardware and/or software.  Second, it should use
\plc{lookup} to look up pointers to runtime entry points in the OMPT tracing
interface for the device.  Finally, using these runtime entry points, it can
then set up tracing for a device.

Initializing tracing for a target device is described in section
\specref{sec:tracing-device-activity}. 

\crossreferences
\begin{itemize}
\item \code{ompt\_function\_lookup\_t}, see
  \specref{sec:ompt_function_lookup_t}.
\end{itemize}

