% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. There are environments that provide special formatting, e.g. language bars.
%       Please use them whereever appropriate.  Examples are:
%
%         \begin{fortranspecific}
%         This is text that appears enclosed in blue language bars for Fortran.
%         \end{fortranspecific}
%
%         \begin{note}
%         This is a note.  The "Note -- " header appears automatically.
%         \end{note}
%
%    6. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%


\subsection{OMPT Runtime Entry Points for Tools}
\label{sec:entry-points}

OMPT supports two principal sets of runtime entry points for tools. One set of 
runtime entry points enables a tool to register callbacks for OpenMP events and 
to inspect the state of an OpenMP thread while executing in a tool callback or 
a signal handler. The second set of runtime entry points enables a tool to trace 
activities on a device. When directed by the tracing interface, an OpenMP 
implementation will trace activities on a device, collect buffers of trace 
records, and invoke callbacks on the host to process these records. OMPT runtime 
entry points should not be global symbols since tools cannot rely on the 
visibility of such symbols.

OMPT also supports runtime entry points for two classes of lookup routines. The 
first class of lookup routines contains a single member: a routine that returns 
runtime entry points in the OMPT callback interface. The second class of lookup 
routines includes a unique lookup routine for each kind of device that can return 
runtime entry points in a device's OMPT tracing interface.

The C/C++ header file (omp-tools.h) provides the definitions of
the types that are specified throughout this subsection.

\restrictions

OMPT runtime entry points have the following restrictions:

\begin{itemize}
\item OMPT runtime entry points must not be called from a signal handler
      on a native thread before a \plc{native-thread-begin} or after a 
      \plc{native-thread-end} event.
\item OMPT device runtime entry points must not be called after a 
      \plc{device-finalize} event for that device.
\end{itemize}



\subsubsection{Entry Points in the OMPT Callback Interface}
\label{sec:ompt-callback-entry-points}

Entry points in the OMPT callback interface enable a tool to register callbacks 
for OpenMP events and to inspect the state of an OpenMP thread while executing 
in a tool callback or a signal handler. Pointers to these runtime entry points 
are obtained through the lookup function that is provided through the OMPT initializer.

\subsubsubsection{\hcode{ompt_enumerate_states_t}}
\label{sec:ompt_enumerate_states_t}
\label{sec:ompt_enumerate_states}

\summary
The \code{ompt_enumerate_states_t} type is the type signature of 
the \code{ompt_enumerate_states} runtime entry point, which
enumerates the thread states that an OpenMP implementation supports.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_enumerate_states_t) (
  int \plc{current_state},
  int *\plc{next_state},
  const char **\plc{next_state_name}
);
\end{omptInquiry}
\end{ccppspecific}

\descr
An OpenMP implementation may support only a subset of the states defined by
the \code{omp_state_t} enumeration type. An OpenMP implementation may also
support implementation-specific states. The \code{ompt_enumerate_states}
runtime entry point, which has type signature \code{ompt_enumerate_states_t}, 
 enables a tool to enumerate the supported thread states.

When a supported thread state is passed as \plc{current_state}, the runtime 
entry point assigns the next thread state in the enumeration to the variable 
passed by reference in \plc{next_state} and assigns the name associated with 
that state to the character pointer passed by reference in \plc{next_state_name}.

Whenever one or more states are left in the enumeration, the 
\code{ompt_enumerate_states} runtime entry point returns $1$. When 
the last state in the enumeration is passed as \plc{current_state}, 
\code{ompt_enumerate_states} returns $0$, which indicates that the 
enumeration is complete.

\argdesc
The \plc{current_state} argument must be a thread state that the OpenMP 
implementation supports. To begin enumerating the supported states, a tool 
should pass \code{omp_state_undefined} as \plc{current_state}. Subsequent
invocations of \code{ompt_enumerate_states} should pass the value assigned 
to the variable passed by reference in \plc{next_state} to the previous call.

The value \code{ompt_state_undefined} is reserved to indicate an invalid thread 
state. \code{ompt_state_undefined} is defined as an integer with the value 0.

The \plc{next_state} argument is a pointer to an integer in which 
\code{ompt_enumerate_states} returns the value of the next state in the enumeration.

The \plc{next_state_name} argument is a pointer to a character string 
pointer through which \code{ompt_enumerate_states} returns a string 
that describes the next state.

\constraints
Any string returned through the \plc{next_state_name} argument must be 
immutable and defined for the lifetime of a program execution.

\crossreferences
\begin{itemize}
\item \code{omp_state_t}, see \specref{sec:thread-states}.
\end{itemize}



\subsubsubsection{\hcode{ompt_enumerate_mutex_impls_t}}
\label{sec:ompt_enumerate_mutex_impls_t}
\label{sec:ompt_enumerate_mutex_impls}
\label{sec:ompt_mutex_impl_none}

\summary
The \code{ompt_enumerate_mutex_impls_t} type is the type signature of 
the \code{ompt_enumerate_mutex_impls} runtime entry point, which
enumerates the kinds of mutual exclusion implementations that an OpenMP 
implementation employs.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_enumerate_mutex_impls_t) (
  int \plc{current_impl},
  int *\plc{next_impl},
  const char **\plc{next_impl_name}
);
\end{omptInquiry}
\end{ccppspecific}

\descr
Mutual exclusion for locks, \code{critical} sections, and \code{atomic} 
regions may be implemented in several ways. The \code{ompt_enumerate_mutex_impls} 
runtime entry point, which has type signature \code{ompt_enumerate_mutex_impls_t},
enables a tool to enumerate the supported mutual exclusion implementations.

When a supported mutex implementation is passed as \plc{current_impl}, the 
runtime entry point assigns the next mutex implementation in the enumeration 
to the variable passed by reference in \plc{next_impl} and assigns the name 
associated with that mutex implementation to the character pointer passed by 
reference in \plc{next_impl_name}.

Whenever one or more mutex implementations are left in the enumeration, the 
\code{ompt_enumerate_mutex_impls} runtime entry point returns $1$. When the 
last mutex implementation in the enumeration is passed as \plc{current_impl}, the 
runtime entry point returns $0$, which indicates that the enumeration is complete.

\argdesc
The \plc{current_impl} argument must be a mutex implementation that an OpenMP 
implementation supports. To begin enumerating the supported mutex implementations, 
a tool should pass \code{ompt_mutex_impl_none} as \plc{current_impl}. 
Subsequent invocations of \code{ompt_enumerate_mutex_impls} should pass the
value assigned to the variable passed in \plc{next_impl} to the previous call.

The value \code{ompt_mutex_impl_none} is reserved to indicate an invalid 
mutex implementation. \code{ompt_mutex_impl_none} is defined as an integer 
with the value 0.

The \plc{next_impl} argument is a pointer to an integer in which 
\code{ompt_enumerate_mutex_impls} returns the value of the next mutex 
implementation in the enumeration.

The \plc{next_impl_name} argument is a pointer to a character string pointer
in which \code{ompt_enumerate_mutex_impls} returns a string that describes
the next mutex implementation.

\constraints
Any string returned through the \plc{next_impl_name} argument must be 
immutable and defined for the lifetime of a program execution.

\crossreferences
\begin{itemize}
\item \code{ompt_mutex_t}, see \specref{sec:ompt_mutex_t}.
\end{itemize}



\subsubsubsection{\hcode{ompt_set_callback_t}}
\label{sec:ompt_set_callback_t}
\label{sec:ompt_set_callback}

\summary
The \code{ompt_set_callback_t} type is the type signature of the 
\code{ompt_set_callback} runtime entry point, which registers a
pointer to a tool callback that an OpenMP implementation invokes 
when a host OpenMP event occurs.

\format
\begin{ccppspecific}
\begin{omptCallback}
typedef int (*ompt_set_callback_t) (
  ompt_callbacks_t \plc{event},
  ompt_callback_t \plc{callback}
);
\end{omptCallback}
\end{ccppspecific}

\descr
OpenMP implementations can use callbacks to indicate the occurrence of events 
during the execution of an OpenMP program. The \code{ompt_set_callback} runtime
entry point, which has type signature \code{ompt_set_callback_t}, registers a 
callback for an OpenMP event on the current device,

The return value of \code{ompt_set_callback} may indicate several possible 
outcomes. Callback registration may fail if it is called outside the initializer 
for the callback interface,which is indicated by the \code{omp_set_error} return 
value. Otherwise, the return value indicates if \emph{dispatching} a callback 
event leads to the invocation of the callback. The \code{ompt_set_never} return 
value indicates that the callback will never be invoked at runtime. The 
\code{ompt_set_sometimes} return value indicates that the callback will be 
invoked at runtime for an implementation-defined subset of associated event 
occurrences. The \code{ompt_set_sometimes_paired} return value indicates the 
same result as \code{ompt_set_sometimes}, and, in addition, that a callback
with an \plc{endpoint} value of \code{ompt_scope_begin} will be invoked if 
and only if the same callback with an \plc{endpoint} value of \code{ompt_scope_end} 
will also be invoked sometime in the future. The \code{ompt_set_always} return 
value indicates that the callback will always be invoked when an associated 
event occurs.

\argdesc
The \plc{event} argument indicates the event for which the callback is 
being registered.

The \plc{callback} argument is a tool callback function. If \plc{callback}
is \code{NULL} then callbacks associated with \plc{event} are disabled. If
callbacks are successfully disabled then \code{ompt_set_always} is returned.

\constraints
When a tool registers a callback for an event, the type signature for the 
callback must match the type signature appropriate for the event.

\begin{table}
\caption{Return Codes for \code{ompt_set_callback} and
    \code{ompt_set_trace_ompt}\label{table:ToolsSupport_set_rc}}
\begin{omptEnum}
typedef enum ompt_set_result_t {
  ompt_set_error            = 0,
  ompt_set_never            = 1,
  ompt_set_sometimes        = 2,
  ompt_set_sometimes_paired = 3,
  ompt_set_always           = 4
} ompt_set_result_t;
\end{omptEnum}
\end{table}

\crossreferences
\begin{itemize}
\item \code{ompt_callbacks_t} enumeration type, see \specref{sec:ompt_callbacks_t}.

\item \code{ompt_callback_t} type, see \specref{sec:ompt_callback_t}.

\item \code{ompt_get_callback_t} host callback type signature,
see \specref{sec:ompt_get_callback_t}.
\end{itemize}



\subsubsubsection{\hcode{ompt_get_callback_t}}
\label{sec:ompt_get_callback_t}
\label{sec:ompt_get_callback}

\summary
The \code{ompt_get_callback_t} type is the type signature of the 
\code{ompt_get_callback} runtime entry point, which retrieves a
pointer to a registered tool callback routine (if any) that an 
OpenMP implementation invokes when a host OpenMP event occurs.

\format
\begin{ccppspecific}
\begin{omptCallback}
typedef int (*ompt_get_callback_t) (
  ompt_callbacks_t \plc{event},
  ompt_callback_t *\plc{callback}
);
\end{omptCallback}
\end{ccppspecific}

\descr
The \code{ompt_get_callback} runtime entry point, which has type signature 
\code{ompt_get_callback_t}, retrieves a pointer to the tool callback that
an OpenMP implementation may invoke when a host OpenMP event occurs. If a 
non-null tool callback is registered for the specified event, the pointer 
to the tool callback is assigned to the variable passed by reference in
\plc{callback} and \code{ompt_get_callback} returns 1; otherwise, it returns 0. 
If \code{ompt_get_callback} returns 0, the value of the variable passed by 
reference as \plc{callback} is undefined.

\argdesc
The \plc{event} argument indicates the event for which the callback would 
be invoked.

The \plc{callback} argument returns a pointer to the callback associated 
with \plc{event}.

\constraints
The \plc{callback} argument must be a reference to a variable of specified type.

\crossreferences
\begin{itemize}
\item \code{ompt_callbacks_t} enumeration type, see \specref{sec:ompt_callbacks_t}.

\item \code{ompt_callback_t} type, see \specref{sec:ompt_callback_t}.

\item \code{ompt_set_callback_t} type signature,
see \specref{sec:ompt_set_callback_t}.
\end{itemize}


\subsubsubsection{\hcode{ompt_get_thread_data_t}}
\label{sec:ompt_get_thread_data_t}
\label{sec:ompt_get_thread_data}

\summary
The \code{ompt_get_thread_data_t} type is the type signature of the 
\code{ompt_get_thread_data} runtime entry point, which returns the
address of the thread data object for the current thread.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef ompt_data_t *(*ompt_get_thread_data_t) (void);
\end{omptInquiry}
\end{ccppspecific}

\binding
The binding thread for the \code{ompt_get_thread_data} runtime entry 
point is the current thread.

\descr
Each OpenMP thread can have an associated thread data object of type 
\code{ompt_data_t}. The \code{ompt_get_thread_data} runtime entry point, 
which has type signature \code{ompt_get_thread_data_t}, retrieves a pointer 
to the thread data object, if any, that is associated with the current thread. 
A tool may use a pointer to an OpenMP thread's data object that 
\code{ompt_get_thread_data} retrieves to inspect or to modify the value of 
the data object. When an OpenMP thread is created, its data object is
initialized with value \code{ompt_data_none}.

This runtime entry point is \emph{async signal safe}.

\crossreferences
\begin{itemize}
\item \code{ompt_data_t} type, see \specref{sec:ompt_data_t}.
\end{itemize}



\subsubsubsection{\hcode{ompt_get_num_procs_t}}
\label{sec:ompt_get_num_procs_t}

\summary
The \code{ompt_get_num_procs_t} type is the type signature of the 
\code{ompt_get_num_procs} runtime entry point, which returns the
number of processors currently available to the execution environment 
on the host device.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_get_num_procs_t) (void);
\end{omptInquiry}
\end{ccppspecific}

\binding
The binding thread set for the \code{ompt_get_num_procs} runtime entry 
point is all threads on the host device.

\descr
The \code{ompt_get_num_procs} runtime entry point, which has type 
signature  \code{ompt_get_num_procs_t}, returns the number of processors 
that are available on the host device at the time the routine is called. 
This value may change between the time that it is determined and the 
time that it is read in the calling context due to system actions 
outside the control of the OpenMP implementation.

This runtime entry point is \emph{async signal safe}.



\subsubsubsection{\hcode{ompt_get_num_places_t}}
\label{sec:ompt_get_num_places_t}
\label{sec:ompt_get_num_places}

\summary
The \code{ompt_get_num_places_t} type is the type signature of the 
\code{ompt_get_num_places} runtime entry point, which returns the
number of places currently available to the execution environment 
in the place list.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_get_num_places_t) (void);
\end{omptInquiry}
\end{ccppspecific}

\binding
The binding thread set for the \code{ompt_get_num_places} runtime entry 
point is all threads on a device.

\descr
The \code{ompt_get_num_places} runtime entry point, which has type signature 
\code{ompt_get_num_places_t}, returns the number of places in the place list. 
This value is equivalent to the number of places in the \plc{place-partition-var} 
ICV in the execution environment of the initial task.

This runtime entry point is \emph{async signal safe}.

\crossreferences
\begin{itemize}
\item \plc{place-partition-var} ICV, see
\specref{sec:Internal Control Variables}.

\item \code{OMP_PLACES} environment variable, see
\specref{sec:OMP_PLACES}.
\end{itemize}




\subsubsubsection{\hcode{ompt_get_place_proc_ids_t}}
\label{sec:ompt_get_place_proc_ids_t}
\label{sec:ompt_get_place_proc_ids}

\summary
The \code{ompt_get_place_procs_ids_t} type is the type signature of the 
\code{ompt_get_num_place_procs_ids} runtime entry point, which returns the
the numerical identifiers of the processors that are available to the execution 
environment in the specified place.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_get_place_proc_ids_t) (
  int \plc{place_num},
  int \plc{ids_size},
  int *\plc{ids}
);
\end{omptInquiry}
\end{ccppspecific}

\binding
The binding thread set for the \code{ompt_get_place_proc_ids} runtime 
entry point is all threads on a device.

\descr
The \code{ompt_get_place_proc_ids} runtime entry point, which has type 
signature \code{ompt_get_place_proc_ids_t}, returns the numerical 
identifiers of each processor that is associated with the specified 
place. These numerical identifiers are non-negative and their meaning 
is implementation defined.

\argdesc
The \plc{place_num} argument specifies the place that is being queried.

The \plc{ids} argument is an array in which the routine can return
a vector of processor identifiers in the specified place.

The \plc{ids_size} argument indicates the size of the result array that
is specified by \plc{ids}.

\effect
If the \plc{ids} array of size \plc{ids_size} is large enough to contain 
all identifiers then they are returned in \plc{ids} and their order in the 
array is implementation defined. Otherwise, if the \plc{ids} array is too 
small the the values in \plc{ids} when the function returns are unspecified.
The routine always returns the number of numerical identifiers of the 
processors that are available to the execution environment in the specified place.



\subsubsubsection{\hcode{ompt_get_place_num_t}}
\label{sec:ompt_get_place_num_t}
\label{sec:ompt_get_place_num}

\summary
The \code{ompt_get_place_num_t} type is the type signature of the 
\code{ompt_get_place_num} runtime entry point, which returns the
place number of the place to which the current thread is bound.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_get_place_num_t) (void);
\end{omptInquiry}
\end{ccppspecific}

\binding
The binding thread set of the \code{ompt_get_place_num} runtime entry point
is the current thread.

\descr
When the current thread is bound to a place, \code{ompt_get_place_num}
returns the place number associated with the thread. The returned value 
is between 0 and one less than the value returned by \code{ompt_get_num_places}, 
inclusive. When the current thread is not bound to a place, the routine returns -1.

This runtime entry point is \emph{async signal safe}.



\subsubsubsection{\hcode{ompt_get_partition_place_nums_t}}
\label{sec:ompt_get_partition_place_nums_t}
\label{sec:ompt_get_partition_place_nums}

\summary
The \code{ompt_get_partition_place_nums_t} type is the type signature 
of the \code{ompt_get_partition_place_nums} runtime entry point, which 
returns a list of place numbers that correspond to the places in the 
\plc{place-partition-var} ICV of the innermost implicit task.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_get_partition_place_nums_t) (
  int \plc{place_nums_size},
  int *\plc{place_nums}
);
\end{omptInquiry}
\end{ccppspecific}

\binding
The binding task set for the \code{ompt_get_partition_place_nums} runtime 
entry point is the current implicit task.

\descr
The \code{ompt_get_partition_place_nums} runtime entry point, which has
type signature \code{ompt_get_partition_place_nums_t}, returns a list of 
place numbers that correspond to the places in the \plc{place-partition-var}
ICV of the innermost implicit task.

This runtime entry point is \emph{async signal safe}.

\argdesc
The \plc{place_nums} argument is an array in which the routine can 
return a vector of place identifiers.

The \plc{place_nums_size} argument indicates the size of the result
array that the \plc{place_nums} argument specifies.

\effect
If the \plc{place_nums} array of size \plc{place_nums_size} is large 
enough to contain all identifiers then they are returned in \plc{place_nums} 
and their order in the array is implementation defined. Otherwise, if the 
\plc{place_nums} array is too small, the values in \plc{place_nums} when 
the function returns are unspecified. The routine always returns the number 
of places in the \plc{place-partition-var} ICV of the innermost implicit task.

\crossreferences
\begin{itemize}
\item \plc{place-partition-var} ICV, see
\specref{sec:Internal Control Variables}.

\item \code{OMP_PLACES} environment variable, see
\specref{sec:OMP_PLACES}.
\end{itemize}



\subsubsubsection{\hcode{ompt_get_proc_id_t}}
\label{sec:ompt_get_proc_id_t}
\label{sec:ompt_get_proc_id}

\summary
The \code{ompt_get_proc_id_t} type is the type signature of the 
\code{ompt_get_proc_id} runtime entry point, which returns the
numerical identifier of the processor of the current thread.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_get_proc_id_t) (void);
\end{omptInquiry}
\end{ccppspecific}

\binding
The binding thread set for the \code{ompt_get_proc_id} runtime entry point
is the current thread.

\descr
The \code{ompt_get_proc_id} runtime entry point, which has type signature
\code{ompt_get_proc_id_t}, returns the numerical identifier of the processor 
of the current thread. A defined numerical identifier is non-negative and
its meaning is implementation defined. A negative number indicates a failure 
to retrieve the numerical identifier.

This runtime entry point is \emph{async signal safe}.



\subsubsubsection{\hcode{ompt_get_state_t}}
\label{sec:ompt_get_state_t}
\label{sec:ompt_get_state}

\summary
The \code{ompt_get_state_t} type is the type signature of the 
\code{ompt_get_state} runtime entry point, which returns the
the state and the wait identifier of the current thread.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_get_state_t) (
  omp_wait_id_t *\plc{wait_id}
);
\end{omptInquiry}
\end{ccppspecific}

\binding
The binding thread for the \code{ompt_get_state} runtime entry point 
is the current thread.

\descr
Each OpenMP thread has an associated state and a wait identifier. If
a thread's state indicates that the thread is waiting for mutual exclusion
then its wait identifier contains an opaque handle that indicates the 
data object upon which the thread is waiting. The \code{ompt_get_state} 
runtime entry point, which has type signature \code{ompt_get_state_t},
retrieves the state and wait identifier of the current thread.
The returned value may be any one of the states predefined by 
\code{omp_state_t} or a value that represents any implementation
specific state. The tool may obtain a string representation for each 
state with the \code{ompt_enumerate_states} function.

If the returned state indicates that the thread is waiting for a
lock, nest lock, critical section, atomic region, or ordered region
then the value of the thread's wait identifier is assigned to a
non-null wait identifier passed as the \plc{wait_id} argument.

This runtime entry point is \emph{async signal safe}.

\argdesc
The \plc{wait_id} argument is a pointer to an opaque handle that is
available to receive the value of the thread's wait identifier. If
\plc{wait_id} is not \code{NULL} then the entry point assigns the 
value of the thread's wait identifier to the object to which 
\plc{wait_id} points. If the returned state is not one of the specified
wait states then the value of opaque object to which \plc{wait_id} points
is undefined after the call.

\constraints
The argument passed to the entry point must be a reference
to a variable of the specified type or \code{NULL}.

\crossreferences
\begin{itemize}
\item \code{ompt_enumerate_states_t} type, see \specref{sec:ompt_enumerate_states_t}.

\item \code{omp_state_t} type, see \specref{sec:omp_state_t}.

\item \code{omp_wait_id_t} type, see \specref{sec:omp_wait_id_t}.
\end{itemize}



\subsubsubsection{\hcode{ompt_get_parallel_info_t}}
\label{sec:ompt_get_parallel_info_t}
\label{sec:ompt_get_parallel_info}

\summary
The \code{ompt_get_parallel_info_t} type is the type signature of the 
\code{ompt_get_parallel_info} runtime entry point, which returns information 
about the parallel region, if any, at the specified ancestor level for 
the current execution context.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_get_parallel_info_t) (
  int \plc{ancestor_level},
  ompt_data_t **\plc{parallel_data},
  int *\plc{team_size}
);
\end{omptInquiry}
\end{ccppspecific}

\descr
During execution, an OpenMP program may employ nested parallel regions.
The \code{ompt_get_parallel_info} runtime entry point known, which has
type signature \code{ompt_get_parallel_info_t}, retrieves information,
about the current parallel region and any enclosing parallel regions 
for the current execution context. The entry point returns 2 if there 
is a parallel region at the specified ancestor level and the information 
is available, 1 if there is a parallel region at the specified ancestor 
level but the information is currently unavailable, and 0 otherwise.

A tool may use the pointer to a parallel region's data object that it
obtains from this runtime entry point to inspect or to modify the value
of the data object. When a parallel region is created, its data
object will be initialized with the value \code{ompt_data_none}.

This runtime entry point is \emph{async signal safe}.

Between a \emph{parallel-begin} event and an \emph{implicit-task-begin} event, 
a call to \code{ompt_get_parallel_info(0,...)} may return information about 
the outer parallel team, the new parallel team or an inconsistent state.

If a thread is in the state \code{omp_state_wait_barrier_implicit_parallel}
then a call to \code{ompt_get_parallel_info} may return a pointer to a copy 
of the specified parallel region's \plc{parallel_data} rather than a pointer 
to the data word for the region itself. This convention enables the master 
thread for a parallel region to free storage for the region immediately after 
the region ends, yet avoid having some other thread in the region's team potentially 
reference the region's \plc{parallel_data} object after it has been freed.

\argdesc
The \plc{ancestor_level} argument specifies the parallel region of 
interest by its ancestor level. Ancestor level 0 refers to the innermost 
parallel region; information about enclosing parallel regions may be 
obtained using larger values for \plc{ancestor_level}.

The \plc{parallel_data} argument returns the parallel data if the 
argument is not \code{NULL}.

The \plc{team_size} argument returns the team size if the argument 
is not \code{NULL}.

\effect
If the runtime entry point returns 0 or 1, no argument is modified. 
Otherwise, \code{ompt_get_parallel_info} has the following effects:

\begin{itemize}
\item If a non-null value was passed for \plc{parallel_data}, the value 
      returned in \plc{parallel_data} is a pointer to a data word that is
      associated with the parallel region at the specified level; and
\item If a non-null value was passed for \plc{team_size}, the value
      returned in the integer to which \plc{team_size} point is the 
      number of threads in the team that is associated with the parallel region.
\end{itemize}

\constraints
While argument \plc{ancestor_level} is passed by value, all other arguments 
to the entry point must be pointers to variables of the specified types or \code{NULL}.

\crossreferences
\begin{itemize}
\item \code{ompt_data_t} type, see \specref{sec:ompt_data_t}.
\end{itemize}



\subsubsubsection{\hcode{ompt_get_task_info_t}}
\label{sec:ompt_get_task_info_t}
\label{sec:ompt_get_task_info}

\summary
The \code{ompt_get_task_info_t} type is the type signature of the 
\code{ompt_get_task_info} runtime entry point, which returns information 
about the task, if any, at the specified ancestor level in the current 
execution context.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_get_task_info_t) (
  int \plc{ancestor_level},
  int *\plc{flag},
  ompt_data_t **\plc{task_data},
  omp_frame_t **\plc{task_frame},
  ompt_data_t **\plc{parallel_data},
  int *\plc{thread_num}
);
\end{omptInquiry}
\end{ccppspecific}

\descr
During execution, an OpenMP thread may be executing an OpenMP task.
Additionally, the thread's stack may contain procedure frames that 
are associated with suspended OpenMP tasks or OpenMP runtime system 
routines. To obtain information about any task on the current thread's 
stack, a tool uses the \code{ompt_get_task_info} runtime entry point,
which has type signature \code{ompt_get_task_info_t}.

Ancestor level 0 refers to the active task; information about other 
tasks with associated frames present on the stack in the current execution 
context may be queried at higher ancestor levels.

The \code{ompt_get_task_info} runtime entry point returns 2 if there 
is a task region at the specified ancestor level and the information 
is available, 1 if there is a task region at the specified ancestor 
level but the information is currently unavailable, and 0 otherwise.

If a task exists at the specified ancestor level and the information is 
available then information is returned in the variables passed by reference 
to the entry point. If no task region exists at the specified ancestor level 
or the information is unavailable then the values of variables passed by 
reference to the entry point are undefined when \code{ompt_get_task_info} returns.

A tool may use a pointer to a data object for a task or parallel region 
that it obtains from \code{ompt_get_task_info} to inspect or to modify the
value of the data object. When either a parallel region or a task region 
is created, its data object will be initialized with the value \code{ompt_data_none}.

This runtime entry point is \emph{async signal safe}.

\argdesc
The \plc{ancestor_level} argument specifies the task region of interest by 
its ancestor level. Ancestor level 0 refers to the active task; information 
about ancestor tasks found in the current execution context may be queried 
at higher ancestor levels.

The \plc{flag} argument returns the task type if the argument is not \code{NULL}.

The \plc{task_data} argument returns the task data if the argument is not \code{NULL}.

The \plc{task_frame} argument returns the task frame pointer
if the argument is not \code{NULL}.

The \plc{parallel_data} argument returns the parallel data
if the argument is not \code{NULL}.

The \plc{thread_num} argument returns the thread number
if the argument is not \code{NULL}.

\effect
If the runtime entry point returns 0 or 1, no argument is modified.
Otherwise, \code{ompt_get_task_info} has the following effects:

\begin{itemize}
\item If a non-null value was passed for \plc{flag} then the value 
      returned in the integer to which \plc{flag} points represents 
      the type of the task at the specified level; possible task types 
      include initial, implicit, explicit, and target tasks;
\item If a non-null value was passed for \plc{task_data} then the value that
      is returned in the object to which it points is a pointer to a data word
      that is associated with the task at the specified level;
\item If a non-null value was passed for \plc{task_frame} then the value that
      is returned in the object to which \plc{task_frame} points is a pointer 
      to the \code{omp_frame_t} structure that is associated with the task at 
      the specified level;
\item If a non-null value was passed for \plc{parallel_data} then the value that
      is returned in the object to which \plc{parallel_data} points is a pointer 
      to a data word that is associated with the parallel region that contains 
      the task at the specified level or, if the task at the specified level is 
      an initial task, \code{NULL}; and
\item If a non-null value was passed for \plc{thread_num} then the value that 
      is returned in the object to which \plc{thread_num} points indicates the 
      number of the thread in the parallel region that is executing the task
      at the specified level.
\end{itemize}

\constraints
While argument \plc{ancestor_level} is passed by value, all other arguments to 
\code{ompt_get_task_info} must be pointers to variables of the specified types 
or \code{NULL}.

\crossreferences
\begin{itemize}
\item \code{ompt_data_t} type, see \specref{sec:ompt_data_t}.

\item \code{ompt_task_flag_t} type, see \specref{sec:ompt_task_flag_t}.

\item \code{omp_frame_t} type, see \specref{sec:omp_frame_t}.

\item Example of the use of \code{omp_frame_t} structures with multiple
      threads and nested parallelism, see Appendix~\ref{chap:frames}.
\end{itemize}



\subsubsubsection{\hcode{ompt_get_task_memory_t}}
\label{sec:ompt_get_task_memory_t}
\label{sec:ompt_get_task_memory}

\summary
The \code{ompt_get_task_memory_t} type is the type signature of the 
\code{ompt_get_task_memory} runtime entry point, which returns information 
about memory ranges that are associated with the task.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_get_task_memory_t)(
  void **\plc{addr},
  size_t *\plc{size},
  int \plc{block}
);
\end{omptInquiry}
\end{ccppspecific}

\descr
During execution, an OpenMP thread may be executing an OpenMP task. The 
OpenMP implementation must preserve the data environment from the creation 
of the task for the execution of the task. The \code{ompt_get_task_memory} 
runtime entry point, which has type signature \code{ompt_get_task_memory_t},
provides information about the  memory ranges used to store the data 
environment for the current task.

Multiple memory ranges may be used to store these data. The \plc{block} 
argument supports iteration over these memory ranges.

The \code{ompt_get_task_memory} runtime entry point returns 1 if there 
are more memory ranges available, and 0 otherwise. If no memory is used 
for a task, \plc{size} is set to 0. In this case, addr is unspecified.

This runtime entry point is \emph{async signal safe}.

\argdesc
The \plc{addr} argument is a pointer to a void pointer return value
to provide the start address of a memory block.  

The \plc{size} argument is a pointer to a size type return
value to provide the size of the memory block.

The \plc{block} argument is an integer value to specify the
memory block of interest.



\subsubsubsection{\hcode{ompt_get_target_info_t}}
\label{sec:ompt_get_target_info_t}
\label{sec:ompt_get_target_info}

\summary
The \code{ompt_get_target_info_t} type is the type signature of the 
\code{ompt_get_target_info} runtime entry point, which returns identifiers 
that specify a thread's current \code{target} region and target operation ID, if any.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_get_target_info_t) (
  uint64_t *\plc{device_num},
  ompt_id_t *\plc{target_id},
  ompt_id_t *\plc{host_op_id}
);
\end{omptInquiry}
\end{ccppspecific}

\descr
The \code{ompt_get_target_info} entry point, which has type signature 
\code{ompt_get_target_info_t}, returns 1 if the current thread is in a 
\code{target} region and 0 otherwise. If the entry point returns 0 then
the values of the variables passed by reference as its arguments are undefined.

If the current thread is in a \code{target} region then \code{ompt_get_target_info}
returns information about the current device, active \code{target} region, and
active host operation, if any.

This runtime entry point is \emph{async signal safe}.

\argdesc
The \plc{device_num} argument returns the device number if the current 
thread is in a \code{target} region.

Th \plc{target_id} argument returns the \code{target} region identifier 
if the current thread is in a \code{target} region.

If the current thread is in the process of initiating an operation on a 
target device (for example, copying data to or from an accelerator or 
launching a kernel) then \plc{host_op_id} returns the identifier for the 
operation; otherwise, \plc{host_op_id} returns \code{ompt_id_none}.

\constraints
Arguments passed to the entry point must be valid references to variables 
of the specified types.

\crossreferences
\begin{itemize}
\item \code{ompt_id_t} type, see \specref{sec:ompt_id_t}.
\end{itemize}



\subsubsubsection{\hcode{ompt_get_num_devices_t}}
\label{sec:ompt_get_num_devices_t}
\label{sec:ompt_get_num_devices}

\summary
The \code{ompt_get_num_devices_t} type is the type signature of the 
\code{ompt_get_num_devices} runtime entry point, which returns the
number of available devices.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_get_num_devices_t) (void);
\end{omptInquiry}
\end{ccppspecific}

\descr
The \code{ompt_get_num_devices} runtime entry point, which has 
type signature \code{ompt_get_num_devices_t}, returns the number 
of devices available to an OpenMP program.

This runtime entry point is \emph{async signal safe}.



\subsubsubsection{\hcode{ompt_get_unique_id_t}}
\label{sec:ompt_get_unique_id_t}
\label{sec:ompt_get_unique_id}

\summary
The \code{ompt_get_unique_id_t} type is the type signature of the 
\code{ompt_get_unique_id} runtime entry point, which returns a unique number.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef uint64_t (*ompt_get_unique_id_t) (void);
\end{omptInquiry}
\end{ccppspecific}

\descr
The \code{ompt_get_unique_id} runtime entry point, which has type 
signature \code{ompt_get_unique_id_t}, returns a number that is unique 
for the duration of an OpenMP program. Successive invocations may not 
result in consecutive or even increasing numbers.

This runtime entry point is \emph{async signal safe}.



\subsubsubsection{\hcode{ompt_finalize_tool_t}}
\label{sec:ompt_finalize_tool_t}
\label{sec:ompt_finalize_tool}

\summary
The \code{ompt_finalize_tool_t} type is the type signature of the 
\code{ompt_finalize_tool} runtime entry point, which enables a tool 
to finalize itself.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef void (*ompt_finalize_tool_t) (void);
\end{omptInquiry}
\end{ccppspecific}

\descr
A tool may detect that the execution of an OpenMP program is ending 
before the OpenMP implementation does. To facilitate clean termination 
of the tool, the tool may invoke the \code{ompt_finalize_tool} runtime 
entry point, which has type signature \code{ompt_finalize_tool_t}. Upon 
completion of \code{ompt_finalize_tool}, no OMPT callbacks are dispatched.

\effect
The \code{ompt_finalize_tool} routine detaches the tool from the runtime, 
unregisters all callbacks and invalidates all OMPT entry points passed to 
the tool in the \plc{lookup-function}. Upon completion of \code{ompt_finalize_tool},
no further callbacks will be issued on any thread.

Before the callbacks are unregistered, the OpenMP runtime should attempt
to dispatch all outstanding registered callbacks as well as the callbacks 
that would be encountered during shutdown of the runtime, if possible in 
the current execution context.



\subsubsection{Entry Points in the OMPT Device Tracing Interface}
\label{sec:ompt-tracing-entry-points}

The runtime entry points with type signatures of the types that are 
specified in this section enable a tool to trace activities on a device.



\subsubsubsection{\hcode{ompt_get_device_num_procs_t}}
\label{sec:ompt_get_device_num_procs_t}

\summary
The \code{ompt_get_device_num_procs_t} type is the type signature of the 
\code{ompt_get_device_num_procs} runtime entry point, which returns the 
number of processors currently available to the execution environment on 
the specified device.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_get_device_num_procs_t) (
  ompt_device_t *\plc{device}
);
\end{omptInquiry}
\end{ccppspecific}

\descr
The \code{ompt_get_device_num_procs} runtime entry point, which has type 
signature \code{ompt_get_device_num_procs_t}, returns the number of processors 
that are available on the device at the time the routine is called. This value 
may change between the time that it is determined and the time that it is read 
in the calling context due to system actions outside the control of the OpenMP 
implementation.

\argdesc
The \plc{device} argument is a pointer to an opaque object that
represents the target device instance. The pointer to the device
instance object is used by functions in the device tracing interface
to identify the device being addressed.

\crossreferences
\begin{itemize}
\item \code{ompt_device_t}, see \specref{sec:ompt_device_t}.
\end{itemize}



\subsubsubsection{\hcode{ompt_get_device_time_t}}
\label{sec:ompt_get_device_time_t}

\summary
The \code{ompt_get_device_time_t} type is the type signature of the 
\code{ompt_get_device_time} runtime entry point, which returns the 
current time on the specified device.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef ompt_device_time_t (*ompt_get_device_time_t) (
  ompt_device_t *\plc{device}
);
\end{omptInquiry}
\end{ccppspecific}

\descr
Host and target devices are typically distinct and run independently.
If host and target devices are different hardware components, they
may use different clock generators. For this reason, a common time 
base for ordering host-side and device-side events may not be available.

The \code{ompt_get_device_time} runtime entry point, which has type 
signature \code{ompt_get_device_time_t}, returns the current time on 
the specified device. A tool can use this information to align time 
stamps from different devices.

\argdesc
The \plc{device} argument is a pointer to an opaque object that
represents the target device instance. The pointer to the device
instance object is used by functions in the device tracing interface
to identify the device being addressed.

\crossreferences
\begin{itemize}
\item \code{ompt_device_t}, see \specref{sec:ompt_device_t}.

\item \code{ompt_device_time_t}, see \specref{sec:ompt_device_time_t}.
\end{itemize}



\subsubsubsection{\hcode{ompt_translate_time_t}}
\label{sec:ompt_translate_time_t}

\summary
The \code{ompt_translate_time_t} type is the type signature of the 
\code{ompt_translate_time} runtime entry point, which translates a 
time value that is obtained from the specified device to a corresponding 
time value on the host device.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef double (*ompt_translate_time_t) (
  ompt_device_t *\plc{device},
  ompt_device_time_t \plc{time}
);
\end{omptInquiry}
\end{ccppspecific}

\descr
The \code{ompt_translate_time} runtime entry point, which has type signature 
\code{ompt_translate_time_t}, translates a time value obtained from the specified 
device to a corresponding time value on the host device. The returned value for 
the host time has the same meaning as the value returned from \code{omp_get_wtime}.

\begin{note}
The accuracy of time translations may degrade if they are not performed promptly 
after a device time value is received and if either the host or device vary their 
clock speeds. Prompt translation of device times to host times is recommended.
\end{note}

\argdesc
The \plc{device} argument is a pointer to an opaque object that
represents the target device instance. The pointer to the device
instance object is used by functions in the device tracing interface
to identify the device being addressed.

The \plc{time} argument is a time from the specified device.

\crossreferences
\begin{itemize}
\item \code{ompt_device_t}, see \specref{sec:ompt_device_t}.

\item \code{ompt_device_time_t}, see \specref{sec:ompt_device_time_t}.
\end{itemize}



\subsubsubsection{\hcode{ompt_set_trace_ompt_t}}
\label{sec:ompt_set_trace_ompt_t}

\summary
The \code{ompt_set_trace_ompt_t} type is the type signature of the 
\code{ompt_set_trace_ompt} runtime entry point, which enables or disables 
the recording of trace records for one or more types of OMPT events.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_set_trace_ompt_t) (
  ompt_device_t *\plc{device},
  unsigned int \plc{enable},
  unsigned int \plc{etype}
);
\end{omptInquiry}
\end{ccppspecific}

\argdesc
The \plc{device} argument points to an opaque object that represents
the target device instance. Functions in the device tracing interface
use this pointer to identify the device that is being addressed.

The \plc{enable} argument indicates whether tracing should be enabled 
or disabled for the event or events that the \plc{etype} argument specifies. 
A positive value for \plc{enable} indicates that recording of the one or 
more events that \plc{etype} specifies should be enabled; a value of 0 for 
\plc{enable} indicates that recording of events should be disabled by this invocation.

An \plc{etype} argument value of 0 indicates that traces for all event 
types will be enabled or disabled.  Passing a positive value for
\plc{etype} inidicates that recording should be enabled or disabled
for the event in \code{ompt_callbacks_t} that matches \plc{etype}.


\effect
Table~\ref{table:record_set} shows the possible return codes for 
\code{ompt_set_trace_ompt}. If a single invocation of \code{ompt_set_trace_ompt} 
is used to enable or disable more than one event, the return code is 3 if tracing 
is possible for one or more events but not for others.

\nolinenumbers
\renewcommand{\arraystretch}{1.5}
\tablefirsthead{%
\hline
\textsf{\textbf{Return Code}} & \textsf{\textbf{Meaning}}\\
\hline\\[-3ex]
}
\tablehead{%
\multicolumn{2}{l}{\small\slshape table continued from previous page}\\
\hline
\textsf{\textbf{Return Code}} & \textsf{\textbf{Meaning}}\\
\hline\\[-3ex]
}
\tabletail{%
\hline\\[-4ex]
\multicolumn{2}{l}{\small\slshape table continued on next page}\\
}
\tablelasttail{\hline}
\tablecaption{Return Codes for \code{ompt_set_trace_ompt} and
    \code{ompt_set_trace_native}\label{table:record_set}}
\begin{supertabular}{p{2.0in} p{3.0in}}
0 & error\\
1 & event will never occur\\
2 & event may occur but no tracing is possible\\
3 & event may occur and will be traced when convenient\\
4 & event may occur and will always be traced if event occurs\\
\end{supertabular}

\linenumbers

\crossreferences
\begin{itemize}
\item \code{ompt_callbacks_t},
see \specref{sec:ompt_callbacks_t}.
\item \code{ompt_device_t},
see \specref{sec:ompt_device_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_set_trace_native_t}}
\label{sec:ompt_set_trace_native_t}

\summary
A runtime entry point for a device known as \code{ompt_set_trace_native}
with type signature \code{ompt_set_trace_native_t}
enables or disables the recording of native trace records for a device.


\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_set_trace_native_t) (
  ompt_device_t *\plc{device},
  int \plc{enable},
  int \plc{flags}
);
\end{omptInquiry}
\end{ccppspecific}

\descr
This interface is designed for use by a tool with no knowledge about
an attached device. If a tool knows how to program a particular
attached device, it may opt to invoke native control functions
directly using pointers obtained through the \plc{lookup} function
associated with the device and described in the \plc{documentation}
string that is provided to the device initializer callback.

\argdesc
The \plc{device} argument points to an opaque object that represents
the target device instance. Functions in the device tracing interface
use this pointer to identify the device that is being addressed.

The argument \plc{enable} indicates whether recording of events
should be enabled or disabled by this invocation.

The argument \plc{flags} specifies the kinds of native device
monitoring to enable or disable.
Each kind of monitoring is specified by a flag bit.
Flags can be composed by using logical {\ttfamily or}  to combine enumeration
values from type \code{ompt_native_mon_flag_t}.
Table~\ref{table:record_set} shows the possible return codes for
\code{ompt_set_trace_native}.  If a single invocation of
\code{ompt_set_trace_native} is used to enable/disable more
than one kind of monitoring, the return code will be 3 if tracing
is possible for one or more kinds of monitoring but not for others.

To start, pause, flush, or stop tracing for a specific target device
associated with the handle \plc{device}, a tool invokes the 
\code{ompt_start_trace}, \code{ompt_pause_trace}, \code{ompt_flush_trace}, or
\code{ompt_stop_trace} runtime entry point for the device.


\crossreferences
\begin{itemize}
\item \code{ompt_device_t},
see \specref{sec:ompt_device_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_start_trace_t}}
\label{sec:ompt_start_trace_t}

\summary
A runtime entry point for a device known as \code{ompt_start_trace}
with type signature \code{ompt_start_trace_t}
starts tracing of activity on a specific device.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_start_trace_t) (
  ompt_device_t *\plc{device},
  ompt_callback_buffer_request_t \plc{request},
  ompt_callback_buffer_complete_t \plc{complete}
);
\end{omptInquiry}
\end{ccppspecific}

\descr
A tool may initiate tracing on a device by invoking the device's \code{ompt_start_trace}
runtime entry point.

Under normal operating conditions, every event buffer provided to
a device by a tool callback will be returned to the tool
before the OpenMP runtime shuts down.
If an exceptional condition terminates  execution of an OpenMP
program, the OpenMP runtime may not return buffers provided to the
device.

An invocation of \code{ompt_start_trace} returns 1 if the command
succeeds and 0 otherwise.

\argdesc
The \plc{device} argument points to an opaque object that represents
the target device instance. Functions in the device tracing interface
use this pointer to identify the device that is being addressed.

The argument \emph{buffer request} specifies a tool callback
that will supply a device with a buffer to deposit events.

The argument \emph{buffer complete} specifies a tool callback
that will be invoked by the OpenMP implementation to empty a buffer
containing event records.

\crossreferences
\begin{itemize}
\item \code{ompt_device_t},
see \specref{sec:ompt_device_t}.
\item \code{ompt_callback_buffer_request_t},
see \specref{sec:ompt_callback_buffer_request_t}.
\item \code{ompt_callback_buffer_complete_t},
see \specref{sec:ompt_callback_buffer_complete_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_pause_trace_t}}
\label{sec:ompt_pause_trace_t}

\summary
A runtime entry point for a device known as \code{ompt_pause_trace}
with type signature \code{ompt_pause_trace_t}
pauses or restarts activity tracing on a specific device.

\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_pause_trace_t) (
  ompt_device_t *\plc{device},
  int \plc{begin_pause}
);
\end{omptInquiry}
\end{ccppspecific}

\descr

A tool may pause or resume tracing on a device by invoking the device's
\code{ompt_pause_trace} runtime entry point.
An invocation of \code{ompt_pause_trace} returns 1 if the command
succeeds and 0 otherwise.

Redundant pause or resume commands are idempotent and will
return 1 indicating success.

\argdesc
The \plc{device} argument points to an opaque object that represents
the target device instance. Functions in the device tracing interface
use this pointer to identify the device that is being addressed.

The argument \plc{begin_pause} indicates whether to pause or
resume tracing.
To resume tracing, zero should be supplied for \plc{begin_pause}.

\crossreferences
\begin{itemize}
\item \code{ompt_device_t},
see \specref{sec:ompt_device_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_flush_trace_t}}
\label{sec:ompt_flush_trace_t}

\summary
A runtime entry point for a device known as \code{ompt_flush_trace}
with type signature \code{ompt_flush_trace_t} causes all pending trace 
records for the specified device to be delivered to the tool.

\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_flush_trace_t) (
  ompt_device_t *\plc{device}
);
\end{omptInquiry}
\end{ccppspecific}

\descr

A tool may request that a device flush any pending trace records
by invoking the \code{ompt_flush_trace} runtime entry point for the device.
Invoking \code{ompt_flush_trace} causes the OpenMP implementation to issue a sequence 
of zero or more buffer completion callbacks to deliver to the tool all trace records 
that have been collected prior to the flush.
An invocation of \code{ompt_flush_trace} returns 1 if the command
succeeds and 0 otherwise.

\argdesc
The \plc{device} argument points to an opaque object that represents
the target device instance. Functions in the device tracing interface
use this pointer to identify the device that is being addressed.

\crossreferences
\begin{itemize}
\item \code{ompt_device_t},
see \specref{sec:ompt_device_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_stop_trace_t}}
\label{sec:ompt_stop_trace_t}

\summary
A runtime entry point for a device known as \code{ompt_stop_trace}
with type signature \code{ompt_stop_trace_t}
stops tracing for a device.

\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_stop_trace_t) (
  ompt_device_t *\plc{device}
);
\end{omptInquiry}
\end{ccppspecific}

\descr

A tool may halt tracing on a device and request that the device flush any pending trace records
by invoking the \code{ompt_stop_trace} runtime entry point for the device.
An invocation of \code{ompt_stop_trace} returns 1 if the command
succeeds and 0 otherwise.

\argdesc
The \plc{device} argument points to an opaque object that represents
the target device instance. Functions in the device tracing interface
use this pointer to identify the device that is being addressed.


%%? johnmc says: we should export one more function from a target device: ompt_target_scope(begin/end, host_id)
%% this function will be used by the OpenMP runtime when a target device is being monitored to signal the target device when
%% (1) entering and leaving a target region
%% (2) before and after launching a kernel
%% (3) before and after performing a data operation: copy, allocation, release, ...
%% this function will enable the target device to associate device_activity_ids with some host_id that either represents a
%% target region, target data operation, or target kernel submission

\crossreferences
\begin{itemize}
\item \code{ompt_device_t},
see \specref{sec:ompt_device_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_advance_buffer_cursor_t}}
\label{sec:ompt_advance_buffer_cursor_t}

%There are several routines that need to be used together to process %target event records deposited in a buffer by a device.

\summary
A runtime entry point for a device known as \code{ompt_advance_buffer_cursor}
with type signature \code{ompt_advance_buffer_cursor_t}
advances a trace buffer cursor to the next record.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_advance_buffer_cursor_t) (
  ompt_buffer_t *\plc{buffer},
  size_t \plc{size},
  ompt_buffer_cursor_t \plc{current},
  ompt_buffer_cursor_t *\plc{next}
);
\end{omptInquiry}
\end{ccppspecific}

\descr
It returns \plc{true} if the advance is successful and the next
position in the buffer is valid.

\argdesc
The \plc{device} argument points to an opaque object that represents
the target device instance. Functions in the device tracing interface
use this pointer to identify the device that is being addressed.

The argument \plc{buffer} indicates a trace buffer associated
with the cursors.

The argument \plc{size} indicates the size of \plc{buffer} in
bytes.

The argument \plc{current} is an opaque buffer cursor.

The argument \plc{next} returns the next value of a opaque buffer cursor.


\crossreferences
\begin{itemize}
\item \code{ompt_device_t},
see \specref{sec:ompt_device_t}.
\item \code{ompt_buffer_cursor_t},
see \specref{sec:ompt_buffer_cursor_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_get_record_type_t}}
\label{sec:ompt_get_record_type_t}

\summary
A runtime entry point for a device known as
\code{ompt_get_record_type} with type signature
\code{ompt_get_record_type_t} inspects the type
of a trace record for a device.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef ompt_record_t (*ompt_get_record_type_t) (
  ompt_buffer_t *\plc{buffer},
  ompt_buffer_cursor_t \plc{current}
);
\end{omptInquiry}
\end{ccppspecific}

\descr

Trace records for a device may be in one of two forms: a
\emph{native} record format, which may be device-specific,
or an \emph{OMPT} record format, where each trace record
corresponds to an OpenMP \emph{event} and fields in the record
structure are mostly the arguments that would be passed to the
OMPT callback for the event.

A runtime entry point for a device known as
\code{ompt_get_record_type} with type signature
\code{ompt_get_record_type_t} inspects the type
of a trace record and indicates whether the record at the current
position in the provided trace buffer is an OMPT record,
a native record, or an invalid record. An invalid record type
is returned if the cursor is out of bounds.

\argdesc
The argument \plc{buffer} indicates a trace buffer.

The argument \plc{current} is an opaque buffer cursor.




\crossreferences
\begin{itemize}
\item \code{ompt_record_t},
see \specref{sec:ompt_record_t}.
\item \code{ompt_buffer_t},
see \specref{sec:ompt_buffer_t}.
\item \code{ompt_buffer_cursor_t},
see \specref{sec:ompt_buffer_cursor_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_get_record_ompt_t}}
\label{sec:ompt_get_record_ompt_t}

\summary
A runtime entry point for a device known as \code{ompt_get_record_ompt}
with type signature \code{ompt_get_record_ompt_t}
obtains a pointer to an OMPT trace record from a trace buffer associated with a device.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef ompt_record_ompt_t *(*ompt_get_record_ompt_t) (
  ompt_buffer_t *\plc{buffer},
  ompt_buffer_cursor_t \plc{current}
);
\end{omptInquiry}
\end{ccppspecific}

\descr

This function returns a pointer that may point to a record in the
trace buffer, or it may point to a record in thread local storage
where the information extracted from a record was assembled. The
information available for an event depends upon its type.

The return value of type \code{ompt_record_ompt_t}
includes a field of a union type that can represent
information for any OMPT event record type.
Another call to the runtime entry point may overwrite the
contents of the fields in a record returned by a prior invocation.

\argdesc
The argument \plc{buffer} indicates a trace buffer.

The argument \plc{current} is an opaque buffer cursor.

\crossreferences
\begin{itemize}
\item \code{ompt_record_ompt_t},
see \specref{sec:ompt_record_ompt_t}.
\item \code{ompt_device_t},
see \specref{sec:ompt_device_t}.
\item \code{ompt_buffer_cursor_t},
see \specref{sec:ompt_buffer_cursor_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_get_record_native_t}}
\label{sec:ompt_get_record_native_t}

\summary

A runtime entry point for a device known as
\code{ompt_get_record_native} with type signature
\code{ompt_get_record_native_t}
obtains a pointer to a native trace record from a trace buffer associated with a device.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef void *(*ompt_get_record_native_t) (
  ompt_buffer_t *\plc{buffer},
  ompt_buffer_cursor_t \plc{current},
  ompt_id_t *\plc{host_op_id}
);
\end{omptInquiry}
\end{ccppspecific}

\descr

The pointer returned  may point into the specified trace buffer, or into
thread local storage where the information extracted from a trace
record was assembled. The information available for a native event
depends upon its type. If the function returns a non-null result,
it will also set \code{*host_op_id} to identify host-side identifier
for the operation associated with the record.  A subsequent call
to \code{ompt_get_record_native} may overwrite the
contents of the fields in a record returned by a prior invocation.

\argdesc
The argument \plc{buffer} indicates a trace buffer.

The argument \plc{current} is an opaque buffer cursor.

The argument \plc{host_op_id} is a pointer to an identifier
that will be returned by the function. The entry point will set
*\plc{host_op_id} to the value of a host-side identifier for an operation on
a target device that was created when the operation was initiated by
the host.


\crossreferences
\begin{itemize}
\item \code{ompt_id_t},
see \specref{sec:ompt_id_t}.
\item \code{ompt_buffer_t},
see \specref{sec:ompt_buffer_t}.
\item \code{ompt_buffer_cursor_t},
see \specref{sec:ompt_buffer_cursor_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_get_record_abstract_t}}
\label{sec:ompt_get_record_abstract_t}

\summary
A runtime entry point for a device known as
\code{ompt_get_record_abstract}
with type signature
\code{ompt_get_record_abstract_t}
summarizes the context of a native (device-specific) trace record.

\format
\begin{ccppspecific}
\begin{omptOther}
typedef ompt_record_abstract_t *
(*ompt_get_record_abstract_t) (
  void *\plc{native_record}
);
\end{omptOther}
\end{ccppspecific}

\descr
An OpenMP implementation may execute on a device that logs
trace records in a native (device-specific) format unknown to a tool.
A tool can use the \code{ompt_get_record_abstract}
runtime entry point for the device with type signature
\code{ompt_get_record_abstract_t}
to decode a native trace record that it
does not understand into a standard form that it can interpret.

\argdesc

The argument \plc{native_record} is a pointer to a native trace
record.

\crossreferences
\begin{itemize}
\item \code{ompt_record_abstract_t},
see \specref{sec:ompt_record_abstract_t}.
\end{itemize}

\subsubsection{Lookup Entry Point}

\subsubsubsection{\hcode{ompt_function_lookup_t}}
\label{sec:ompt_function_lookup_t}
\label{sec:ompt_function_lookup}

\summary
A tool uses a lookup routine with type signature
\code{ompt_function_lookup_t}
to obtain pointers to runtime entry points that are
part of the OMPT interface.

\format

\begin{ccppspecific}
\begin{omptInquiry}
typedef void (*ompt_interface_fn_t) (void);

typedef ompt_interface_fn_t (*ompt_function_lookup_t) (
  const char *\plc{interface_function_name}
);
\end{omptInquiry}
\end{ccppspecific}


\descr

An OpenMP implementation provides a pointer to a lookup routine as an
argument to tool callbacks used to initialize tool support for
monitoring an OpenMP device using either tracing or callbacks.



When an OpenMP implementation invokes a tool initializer to configure
the OMPT callback interface, the OpenMP implementation will pass the
initializer a lookup function that the tool can use to obtain
pointers to runtime entry points that implement routines that are part of
the OMPT callback interface.

When an OpenMP implementation invokes a tool initializer to configure
the OMPT tracing interface for a device, the Open implementation will
pass the device tracing initializer a lookup function that the tool
can use to obtain pointers to runtime entry points that implement
tracing control routines appropriate for that device.

A tool can call the lookup function to obtain a pointer to a runtime
entry point.

\argdesc
The argument \plc{interface_function_name} is a C string
that represents the name of a runtime entry point.

\crossreferences
\begin{itemize}
\item Tool initializer for a device's OMPT tracing interface, 
\specref{sec:tracing-device-activity}.
\item Tool initializer for the OMPT callback interface, \specref{sec:ompt_initialize_t}
\item Entry points in the OMPT callback interface, see
  \tabref{table:ompt-callback-interface-functions} for a list and
  \specref{sec:ompt-callback-entry-points} for detailed definitions.
\item Entry points in the OMPT tracing interface, see
  \tabref{table:ompt-tracing-interface-functions} for a list and
  \specref{sec:ompt-tracing-entry-points} for detailed definitions.
\end{itemize}
% This is the end of ch4-toolsSupport.tex
