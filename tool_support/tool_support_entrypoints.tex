% This is an included file. See the master file for more information.
%
% When editing this file:
%
%    1. To change formatting, appearance, or style, please edit openmp.sty.
%
%    2. Custom commands and macros are defined in openmp.sty.
%
%    3. Be kind to other editors -- keep a consistent style by copying-and-pasting to
%       create new content.
%
%    4. We use semantic markup, e.g. (see openmp.sty for a full list):
%         \code{}     % for bold monospace keywords, code, operators, etc.
%         \plc{}      % for italic placeholder names, grammar, etc.
%
%    5. There are environments that provide special formatting, e.g. language bars.
%       Please use them whereever appropriate.  Examples are:
%
%         \begin{fortranspecific}
%         This is text that appears enclosed in blue language bars for Fortran.
%         \end{fortranspecific}
%
%         \begin{note}
%         This is a note.  The "Note -- " header appears automatically.
%         \end{note}
%
%    6. Other recommendations:
%         Use the convenience macros defined in openmp.sty for the minor headers
%         such as Comments, Syntax, etc.
%
%         To keep items together on the same page, prefer the use of
%         \begin{samepage}.... Avoid \parbox for text blocks as it interrupts line numbering.
%         When possible, avoid \filbreak, \pagebreak, \newpage, \clearpage unless that's
%         what you mean. Use \needspace{} cautiously for troublesome paragraphs.
%
%         Avoid absolute lengths and measures in this file; use relative units when possible.
%         Vertical space can be relative to \baselineskip or ex units. Horizontal space
%         can be relative to \linewidth or em units.
%
%         Prefer \emph{} to italicize terminology, e.g.:
%             This is a \emph{definition}, not a placeholder.
%             This is a \plc{var-name}.
%


\subsection{OMPT Runtime Entry Points for Tools}
\label{sec:entry-points}

OMPT supports two principal sets of runtime entry points for tools. One set of 
runtime entry points enables a tool to register callbacks for OpenMP events and 
to inspect the state of an OpenMP thread while executing in a tool callback or 
a signal handler. The second set of runtime entry points enables a tool to trace 
activities on a device. When directed by the tracing interface, an OpenMP 
implementation will trace activities on a device, collect buffers of trace 
records, and invoke callbacks on the host to process these records. OMPT runtime 
entry points should not be global symbols since tools cannot rely on the 
visibility of such symbols.

OMPT also supports runtime entry points for two classes of lookup routines. The 
first class of lookup routines contains a single member: a routine that returns 
runtime entry points in the OMPT callback interface. The second class of lookup 
routines includes a unique lookup routine for each kind of device that can return 
runtime entry points in a device's OMPT tracing interface.

\restrictions

OMPT runtime entry points have the following restrictions:

\begin{itemization}
\item Calling an OMPT runtime entry point from a signal handler before a
      \plc{native-thread-begin} or after a \plc{native-thread-end} event 
      on a native thread results in unspecified behavior.
\item Calling an OMPT device runtime entry point after a \plc{device-finalize} 
      event for that device results in unspecified behavior.
\end{itemization}



\subsubsection{Entry Points in the OMPT Callback Interface}
\label{sec:ompt-callback-entry-points}

Entry points in the OMPT callback interface enable a tool to register
callbacks for OpenMP events and to inspect the state of an OpenMP thread while
executing in a tool callback or a signal handler.
A tool obtains pointers to these runtime entry points
using the lookup function passed to the tool's initializer for the
callback interface.

\subsubsubsection{\hcode{ompt_enumerate_states_t}}
\label{sec:ompt_enumerate_states_t}
\label{sec:ompt_enumerate_states}

\summary
A runtime entry point known as \code{ompt_enumerate_states}
with type signature \code{ompt_enumerate_states_t}
enumerates the thread states supported by an OpenMP
implementation.

\format


\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_enumerate_states_t) (
  int \plc{current_state},
  int *\plc{next_state},
  const char **\plc{next_state_name}
);
\end{omptInquiry}
\end{ccppspecific}


\descr
An OpenMP implementation may support only a subset of the states defined by
the \code{omp_state_t} enumeration type. In addition, an
OpenMP implementation may support implementation-specific states.
The \code{ompt_enumerate_states} runtime entry point enables a tool to
enumerate the thread states supported by an OpenMP implementation.

When a thread state supported by an OpenMP implementation is passed
as the first argument to the runtime entry point,
the runtime entry point will assign the next thread state in the enumeration to
the variable passed by reference as the runtime entry point's second argument
and assign the name associated with the next thread state
to the character pointer passed by reference as the third argument.

Whenever one or more states are left in the enumeration,
the \code{ompt_enumerate_states} runtime entry point will return $1$.
When the last state in the enumeration is passed
as the first argument, the runtime entry point will return $0$
indicating that the enumeration is complete.



\argdesc

The argument \plc{current_state} must be a thread state
supported by the OpenMP implementation.  To begin enumerating the
states that an OpenMP implementation supports, a tool should pass
\code{omp_state_undefined} as \plc{current_state}.  Subsequent
invocations of the runtime entry point by the tool should pass the
value assigned to the variable passed by reference as the second
argument to the previous call.

The argument \plc{next_state} is a pointer to an integer where
the entry point will return the value of the next state in the
enumeration.

The argument \plc{next_state_name} is a pointer to a
character string pointer, where the entry point will return a string
describing the next state.

\constraints
Any string returned through the argument
\plc{next_state_name} must be immutable and defined
for the lifetime of a program execution.

\crossreferences
\begin{itemize}
\item \code{omp_state_t}, see \specref{sec:thread-states}.
\end{itemize}

\subsubsubsection{\hcode{ompt_enumerate_mutex_impls_t}}
\label{sec:ompt_enumerate_mutex_impls_t}
\label{sec:ompt_enumerate_mutex_impls}
\label{sec:ompt_mutex_impl_none}

\summary

A runtime entry point known as \code{ompt_enumerate_mutex_impls}
with type signature \code{ompt_enumerate_mutex_impls_t}
enumerates the kinds of mutual exclusion implementations that
an OpenMP implementation employs.


\format


\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_enumerate_mutex_impls_t) (
  int \plc{current_impl},
  int *\plc{next_impl},
  const char **\plc{next_impl_name}
);
\end{omptInquiry}
\end{ccppspecific}

\code{ompt_mutex_impl_none} is defined as an integer with the value 0.

\descr
An OpenMP implementation may implement mutual exclusion for locks,
nest locks, critical sections, and atomic regions in several different
ways.  The \code{ompt_enumerate_mutex_impls} runtime entry point
enables a tool to enumerate the
kinds of mutual exclusion implementations that an OpenMP implementation
employs.
The value \code{ompt_mutex_impl_none} is reserved to indicate an invalid
implementation.



When a mutex kind supported by an OpenMP implementation is passed
as the first argument to the runtime entry point,
the runtime entry point will assign the next mutex kind in the enumeration to
the variable passed by reference as the runtime entry point's second argument
and assign the name associated with the next mutex kind
to the character pointer passed by reference as the third argument.

Whenever one or more mutex kinds are left in the enumeration,
the runtime entry point to enumerate mutex implementations will return $1$.
When the last mutex kind in the enumeration is passed
as the first argument, the runtime entry point will return $0$
indicating that the enumeration is complete.

\argdesc

The argument \plc{current_impl} must be a mutex implementation
kind supported by an OpenMP implementation.  To begin enumerating the
mutex implementation kinds that an OpenMP implementation supports, a
tool should pass \code{ompt_mutex_impl_none} as the first
argument of the enumerate mutex kinds runtime entry point.  Subsequent
invocations of the runtime entry point by the tool should pass the
value assigned to the variable passed by reference as the second
argument to the previous call.

The argument \plc{next_impl} is a pointer to an integer where
the entry point will return the value of the next mutex implementation
in the enumeration.

The argument \plc{next_impl_name} is a pointer to a character
string pointer, where the entry point will return a string describing
the next mutex implementation.

\constraints
Any string returned through the argument
\plc{next_impl_name} must be immutable and defined
for the lifetime of a program execution.

\crossreferences
\begin{itemize}
\item \code{ompt_mutex_t}, see \specref{sec:ompt_mutex_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_set_callback_t}}
\label{sec:ompt_set_callback_t}
\label{sec:ompt_set_callback}

\summary

A runtime entry point known as \code{ompt_set_callback}
with type signature \code{ompt_set_callback_t} registers a
pointer to a tool callback that an OpenMP implementation will invoke when a host
OpenMP event occurs.

\format

\begin{ccppspecific}
\begin{omptCallback}
typedef int (*ompt_set_callback_t) (
  ompt_callbacks_t \plc{event},
  ompt_callback_t \plc{callback}
);
\end{omptCallback}
\end{ccppspecific}


\descr

OpenMP implementations can inform tools about events that occur during
the execution of an OpenMP program using callbacks.
To register a tool callback for an OpenMP event on the current device,
a tool uses the runtime entry point
known as \code{ompt_set_callback}
with type signature \code{ompt_set_callback_t}.

The return value of the \code{ompt_set_callback} runtime entry point may indicate several possible
outcomes. Callback registration may fail if it is called outside the initializer for the
callback interface, returning \code{omp_set_error}.
Otherwise, the return value of \code{ompt_set_callback}
indicates whether \emph{dispatching} a callback event leads to the invocation of the callback.
A return value of \code{ompt_set_never} indicates that the callback
will never be invoked at runtime.
A return value of \code{ompt_set_sometimes} indicates that the callback
will be invoked at runtime for an implementation-defined subset of
associated event occurrences.
A return value of \code{ompt_set_sometimes_paired} is similar to
\code{ompt_set_sometimes}, but provides an additional guarantee for
callbacks with an \plc{endpoint} parameter. Namely, it guarantees that a callback
with an \plc{endpoint} value of \code{ompt_scope_begin} is invoked if and only if
the same callback with \plc{endpoint} value of \code{ompt_scope_end} will
also be invoked sometime in the future.
A return value of \code{ompt_set_always} indicates that the callback
will be always invoked at runtime for associated event occurrences.

\argdesc

The argument \plc{event} indicates the event with which the callback 
is being registered.

The argument \plc{callback} is a tool callback function.

A tool may pass a \code{NULL} value for \plc{callback} to disable
any callback associated with \plc{event}. If disabling was successful,
\code{ompt_set_always} is returned.

\constraints
When a tool registers a callback for an event, the type
signature for the callback must match the type signature appropriate for the
event.

\begin{table}
\caption{Return Codes for \code{ompt_set_callback} and
    \code{ompt_set_trace_ompt}\label{table:ToolsSupport_set_rc}}
\begin{omptEnum}
typedef enum ompt_set_result_t {
  ompt_set_error            = 0,
  ompt_set_never            = 1,
  ompt_set_sometimes        = 2,
  ompt_set_sometimes_paired = 3,
  ompt_set_always           = 4
} ompt_set_result_t;
\end{omptEnum}

\end{table}

\crossreferences
\begin{itemize}
\item \code{ompt_callbacks_t} enumeration type, see \specref{sec:ompt_callbacks_t}.
\item \code{ompt_callback_t} type, see \specref{sec:ompt_callback_t}.
\item \code{ompt_get_callback_t} host callback type signature,
see \specref{sec:ompt_get_callback_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_get_callback_t}}
\label{sec:ompt_get_callback_t}
\label{sec:ompt_get_callback}

\summary

A runtime entry point known as \code{ompt_get_callback}
with type signature \code{ompt_get_callback_t} retrieves a pointer
to a tool callback routine (if any)
that an OpenMP implementation will invoke when an OpenMP event occurs.

\format

\begin{ccppspecific}
\begin{omptCallback}
typedef int (*ompt_get_callback_t) (
  ompt_callbacks_t \plc{event},
  ompt_callback_t *\plc{callback}
);
\end{omptCallback}
\end{ccppspecific}


\descr
A tool uses the runtime entry point known
as \code{ompt_get_callback}
with type signature \code{ompt_get_callback_t}
to obtain a pointer to the tool callback that
an OpenMP implementation may invoke when a host OpenMP event occurs.
If a non-null tool callback is registered for the specified event,
the pointer to the tool callback will be assigned to the variable
passed by reference as the second argument and the entry
point will return 1; otherwise, it will return 0. If the entry point
returns 0, the value of the variable passed by reference as the second
argument is undefined.

\argdesc

The argument \plc{event} indicates the event upon which the callback 
would be invoked.

The argument \plc{callback} returns a pointer to the callback being inspected.

\constraints
The second argument passed to the entry point must be a reference
to a variable of specified type.

\crossreferences
\begin{itemize}
\item \code{ompt_callbacks_t} enumeration type, see \specref{sec:ompt_callbacks_t}.
\item \code{ompt_callback_t} type, see \specref{sec:ompt_callback_t}.
\item \code{ompt_set_callback_t} type signature,
see \specref{sec:ompt_set_callback_t}.
\end{itemize}


\subsubsubsection{\hcode{ompt_get_thread_data_t}}
\label{sec:ompt_get_thread_data_t}
\label{sec:ompt_get_thread_data}

\summary
A runtime entry point known as \code{ompt_get_thread_data}
with type signature \code{ompt_get_thread_data_t}
returns the address of the thread data object for the current thread.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef ompt_data_t *(*ompt_get_thread_data_t) (void);
\end{omptInquiry}
\end{ccppspecific}

\binding

The binding thread for the runtime entry point known as
\code{ompt_get_thread_data} is the current thread.

\descr

Each OpenMP thread has an associated thread data object of type
\code{ompt_data_t}.
A tool uses the runtime entry point known as
\code{ompt_get_thread_data}
with type signature \code{ompt_get_thread_data_t}
to obtain a pointer to the thread data object, if any, associated with the
current thread. 

A tool may use a pointer to an OpenMP thread's data object
obtained from this runtime entry point to
inspect or modify the value of the data object.
When an OpenMP thread is created, its data object will be initialized
with value \code{ompt_data_none}.

This runtime entry point is \emph{async signal safe}.
\crossreferences
\begin{itemize}
\item \code{ompt_data_t} type, see \specref{sec:ompt_data_t}.
\end{itemize}


\subsubsubsection{\hcode{ompt_get_num_procs_t}}
\label{sec:ompt_get_num_procs_t}

\summary

A runtime entry point known as
\code{ompt_get_num_procs} with type signature
\code{ompt_get_num_procs_t}  returns
the number of processors currently available to the execution
environment on the host device.

\format

\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_get_num_procs_t) (void);
\end{omptInquiry}
\end{ccppspecific}

\binding

The binding thread set for the runtime entry point known as
\code{ompt_get_num_procs} is all threads on the host device.

\descr

The \code{ompt_get_num_procs} runtime entry point returns the
number of processors that are available on the host device at the time
the routine is called. This value may change between the time that
it is determined and the time that it is read in the calling context due to
system actions outside the control of the OpenMP implementation.

This runtime entry point is \emph{async signal safe}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Alex new proc_bind calls

\subsubsubsection{\hcode{ompt_get_num_places_t}}
\label{sec:ompt_get_num_places_t}
\label{sec:ompt_get_num_place}

\summary

A runtime entry point known as
\code{ompt_get_num_places} with type signature
\code{ompt_get_num_places_t}  returns
the number of places available to the execution
environment in the place list.

\format

\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_get_num_places_t) (void);
\end{omptInquiry}
\end{ccppspecific}

\binding

The binding thread set for
the runtime entry point known as \code{ompt_get_num_places}
is all threads on a device.

\descr

The runtime entry point known as  \code{ompt_get_num_places}
returns the number of places in the place list.
This value is equivalent to the number of places in
the  \plc{place-partition-var} ICV in the execution environment
of the initial task.

This runtime entry point is \emph{async signal safe}.

\crossreferences
\begin{itemize}
\item \plc{place-partition-var} ICV, see
\specref{sec:Internal Control Variables}.

\item \code{OMP_PLACES} environment variable, see
\specref{sec:OMP_PLACES}.
\end{itemize}




\subsubsubsection{\hcode{ompt_get_place_proc_ids_t}}
\label{sec:ompt_get_place_proc_ids_t}
\label{sec:ompt_get_place_proc_ids}

\summary

A runtime entry point known as
\code{ompt_get_place_proc_ids} with type signature
\code{ompt_get_place_proc_ids_t}
returns the numerical identifiers of the processors
available to the execution environment in the specified place.

\format

\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_get_place_proc_ids_t) (
  int \plc{place_num},
  int \plc{ids_size},
  int *\plc{ids}
);
\end{omptInquiry}
\end{ccppspecific}

\binding

The binding thread set for
the runtime entry point known as \code{ompt_get_place_proc_ids}
is all threads on a device.

\descr

The runtime entry point known as
\code{ompt_get_place_proc_ids} with type signature
\code{ompt_get_place_proc_ids_t} returns
the numerical identifiers of each processor
associated with the specified place.
The numerical identifiers returned are non-negative, and
their meaning is implementation defined.

\argdesc

The argument \plc{place_num} specifies the place being
queried.

The argument \plc{ids_size} indicates the size of the result
array specified by argument \plc{ids}.

The argument \plc{ids} is an array where the routine can return
a vector of processor identifiers in the specified place.

\effect

If the array \plc{ids} of size \plc{ids_size} is large enough to
contain all identifiers, they are returned in \plc{ids} and
their order in the array is implementation defined.

Otherwise, if the \plc{ids} array is too small, the values in \plc{ids} when the function returns are unspecified.

In both cases, the routine returns the number of numerical identifiers of the processors
available to the execution environment in the specified place.

% This runtime entry point is \emph{async signal safe}.


\subsubsubsection{\hcode{ompt_get_place_num_t}}
\label{sec:ompt_get_place_num_t}
\label{sec:ompt_get_place_num}

\summary

A runtime entry point known as
\code{ompt_get_place_num} with type signature
\code{ompt_get_place_num_t} returns
the place number of the place to which the current
thread is bound.

\format

\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_get_place_num_t) (void);
\end{omptInquiry}
\end{ccppspecific}

\binding

The binding thread set
for the runtime entry point known as \code{ompt_get_place_num}
is the current thread.

\descr

When the current thread is bound to a place,
the runtime entry point known as \code{ompt_get_place_num}
returns the place number associated with the thread.
The returned value is between 0 and one less than the value returned
by runtime entry point known as \code{ompt_get_num_places}, inclusive.
When the current thread is not bound to a place, the routine returns -1.

This runtime entry point is \emph{async signal safe}.


\subsubsubsection{\hcode{ompt_get_partition_place_nums_t}}
\label{sec:ompt_get_partition_place_nums_t}
\label{sec:ompt_get_partition_place_nums}

\summary

A runtime entry point known as
\code{ompt_get_partition_place_nums} with type signature
\code{ompt_get_partition_place_nums_t}
returns a list of place numbers corresponding to the places in the \plc{place-partition-var}
ICV of the innermost implicit task.

\format

\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_get_partition_place_nums_t) (
  int \plc{place_nums_size},
  int *\plc{place_nums}
);
\end{omptInquiry}
\end{ccppspecific}

\binding

The binding task set for
the runtime entry point known as \code{ompt_get_partition_place_nums}
is the current implicit task.

\descr

The runtime entry point known as
\code{ompt_get_partition_place_nums} with type signature
\code{ompt_get_partition_place_nums_t} returns a list of place
numbers corresponding to the places in the \plc{place-partition-var}
ICV of the innermost implicit task.

This runtime entry point is \emph{async signal safe}.

\argdesc

The argument \plc{place_nums_size} indicates the size of the result
array specified by argument \plc{place_nums}.

The argument \plc{place_nums} is an array where the routine can return
a vector of place identifiers.

\effect

If the array \plc{place_nums} of size \plc{place_nums_size} is
large enough to contain all identifiers, they are returned in
\plc{place_nums} and their order in the array is implementation
defined.

Otherwise, if the \plc{place_nums} array is too small, the values in \plc{place_nums} when the function returns are unspecified.

In both cases, the routine returns the number of places in the
\plc{place-partition-var} ICV of the innermost implicit task.

\crossreferences
\begin{itemize}
\item \plc{place-partition-var} ICV, see
\specref{sec:Internal Control Variables}.

\item \code{OMP_PLACES} environment variable, see
\specref{sec:OMP_PLACES}.

\end{itemize}





\subsubsubsection{\hcode{ompt_get_proc_id_t}}
\label{sec:ompt_get_proc_id_t}
\label{sec:ompt_get_proc_id}

\summary

A runtime entry point known as
\code{ompt_get_proc_id} with type signature
\code{ompt_get_proc_id_t} returns the numerical identifier
of the processor of the current thread.

\format

\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_get_proc_id_t) (void);
\end{omptInquiry}
\end{ccppspecific}

\binding

The binding thread set for
the runtime entry point known as \code{ompt_get_proc_id}
is the current thread.

\descr

The runtime entry point known as
\code{ompt_get_proc_id} returns the numerical identifier
of the processor of the current thread.
A defined numerical identifier is non-negative, and
its meaning is implementation defined.
A negative number indicates a failure to retrieve the numerical identifier.

This runtime entry point is \emph{async signal safe}.






\subsubsubsection{\hcode{ompt_get_state_t}}
\label{sec:ompt_get_state_t}
\label{sec:ompt_get_state}

\summary
A runtime entry point known as \code{ompt_get_state}
with type signature \code{ompt_get_state_t}
returns the state and the wait identifier of the
current thread.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_get_state_t) (
  omp_wait_id_t *\plc{wait_id}
);
\end{omptInquiry}
\end{ccppspecific}

\binding

The binding thread for runtime entry point known as
\code{ompt_get_state} is the current thread.

\descr

Each OpenMP thread has an associated state and a wait identifier.  If
a thread's state indicates that the thread is waiting for mutual
exclusion, the thread's wait identifier will contain an opaque handle
that indicates the data object upon which the thread is waiting.

To retrieve the state and wait identifier for the current thread,
a tool uses the runtime entry point known as
\code{ompt_get_state} with type signature \code{ompt_get_state_t}.

The returned value may be any one of the states predefined by
\code{omp_state_t} or a value that represents any implementation
specific state.
The tool may obtain a string representation for each state with the
function known as \code{ompt_enumerate_states}.

If the returned state indicates that the thread is waiting for a
lock, nest lock, critical section, atomic region, or ordered region
the value of the thread's wait identifier will be assigned to a
non-null wait identifier passed as an argument.

This runtime entry point is \emph{async signal safe}.

\argdesc

The argument \plc{wait_id} is a pointer to an opaque handle
available to receive the value of the thread's wait identifier.  If
the \plc{wait_id} pointer is not \code{NULL}, the entry point
will assign the value of the thread's wait identifier to
*\plc{wait_id}.  If the returned state is not one of the specified
wait states, the value of *\plc{wait_id} is undefined after the call.

\constraints
The argument passed to the entry point must be a reference
to a variable of the specified type or \code{NULL}.

\crossreferences
\begin{itemize}
\item \code{ompt_enumerate_states_t} type, see \specref{sec:ompt_enumerate_states_t}.
\item \code{omp_state_t} type, see \specref{sec:omp_state_t}.
\item \code{omp_wait_id_t} type, see \specref{sec:omp_wait_id_t}.
\end{itemize}


\subsubsubsection{\hcode{ompt_get_parallel_info_t}}
\label{sec:ompt_get_parallel_info_t}
\label{sec:ompt_get_parallel_info}

\summary

A runtime entry point known as \code{ompt_get_parallel_info}
with type signature \code{ompt_get_parallel_info_t}
returns information about
the parallel region, if any, at the specified ancestor level
for the current execution context.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_get_parallel_info_t) (
  int \plc{ancestor_level},
  ompt_data_t **\plc{parallel_data},
  int *\plc{team_size}
);
\end{omptInquiry}
\end{ccppspecific}

\descr
During execution, an OpenMP program may employ nested parallel
regions.
To obtain information about a parallel region,
a tool uses the runtime entry point known as
\code{ompt_get_parallel_info}
with type signature \code{ompt_get_parallel_info_t}.
This runtime entry point
can be used to obtain information about the current parallel region,
if any, and any enclosing parallel regions
for the current execution context.

The entry point returns 2 if there is a parallel region at the
specified ancestor level and the information is available,
1 if there is a parallel region at the specified ancestor level
but the information is currently unavailable, and 0 otherwise.

A tool may use the pointer to a parallel region's data object that it
obtains from this runtime entry point to inspect or modify the value
of the data object.  When a parallel region is created, its data
object will be initialized with the value \code{ompt_data_none}.

This runtime entry point is \emph{async signal safe}.

\argdesc

The argument \plc{ancestor_level} specifies the parallel region
of interest to a tool by its ancestor level.  Ancestor level 0 refers
to the innermost parallel region; information about enclosing parallel
regions may be obtained using larger ancestor levels.

The argument \plc{parallel_data} returns the parallel data
if the argument is not \code{NULL}.

The argument \plc{team_size} returns the team size if the argument is
not \code{NULL}.

\effect

If the runtime entry point returns 0 or 1, no argument is modified. Otherwise,
the entry point has the effects described below.

If a non-null value was passed for \plc{parallel_data}, the
value returned in *\plc{parallel_data} is a pointer to a data word
associated with the parallel region at the specified level.

If a non-null value was passed for \plc{team_size}, the value
returned in *\plc{team_size} is the number of threads in the team
associated with the parallel region.

\constraints
While argument \plc{ancestor_level} is passed by
value, all other arguments to the entry point must be pointers
to variables of the specified types or \code{NULL}.


\restrictions
Between a \emph{parallel-begin} event and an \emph{implicit-task-begin}
event, a call to \code{ompt_get_parallel_info(0,...)} may return
information about the outer parallel team, the new parallel team or an
inconsistent state.

If a thread is in the state \code{omp_state_wait_barrier_implicit_parallel},
a call to \code{ompt_get_parallel_info}
may return a pointer to a copy of the specified parallel region's \plc{parallel_data}
rather than a pointer to the data word for the region itself. This convention enables the master thread
for a parallel region to free storage for the region immediately after the region ends, yet
avoid having some other thread in the region's team
potentially reference the region's \plc{parallel_data} object after it has been freed.

\crossreferences
\begin{itemize}
\item \code{ompt_data_t} type, see \specref{sec:ompt_data_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_get_task_info_t}}
\label{sec:ompt_get_task_info_t}
\label{sec:ompt_get_task_info}

\summary
A runtime entry point known as \code{ompt_get_task_info}
with type signature \code{ompt_get_task_info_t} provides information about the
task, if any, at the specified ancestor level in the current execution
context.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_get_task_info_t) (
  int \plc{ancestor_level},
  int *\plc{flag},
  ompt_data_t **\plc{task_data},
  omp_frame_t **\plc{task_frame},
  ompt_data_t **\plc{parallel_data},
  int *\plc{thread_num}
);
\end{omptInquiry}
\end{ccppspecific}

\descr
During execution, an OpenMP thread may be executing an OpenMP task.
Additionally, the thread's stack may contain
procedure frames associated with suspended OpenMP tasks or
OpenMP runtime system routines.
To obtain information about any task on the current thread's stack,
a tool uses the runtime entry point known as
\code{ompt_get_task_info}
with type signature \code{ompt_get_task_info_t}.

Ancestor level 0 refers to the active task; information about
other tasks with associated frames present on the stack in the current execution context may be queried at
higher ancestor levels.

The \code{ompt_get_task_info} runtime entry point
returns 2 if there is a task region at the
specified ancestor level
and the information is available, 1 if there is a task region at the
specified ancestor level but the information is currently unavailable,
and 0 otherwise.

If a task exists at the specified ancestor level and the information is available,
information will be returned in the variables passed by reference to the entry
point.  If no task region exists at the specified ancestor level
or the information is unavailable,
the values of variables passed by reference to the entry point will be
undefined when the entry point returns.

A tool may use a pointer to a data object for a task or parallel
region that it obtains from this runtime entry point to inspect or modify the
value of the data object.  When either a parallel region or a task
region is created, its data object will be initialized with the value
\code{ompt_data_none}.

This runtime entry point is \emph{async signal safe}.

\argdesc

The argument \plc{ancestor_level} specifies the task region
of interest to a tool by its ancestor level.  Ancestor level 0 refers
to the active task; information about
ancestor tasks found in the current execution context may be queried at
higher ancestor levels.

The argument \plc{flag} returns the task type
if the argument is not \code{NULL}.

The argument \plc{task_data} returns the task data
if the argument is not \code{NULL}.

The argument \plc{task_frame} returns the task frame
pointer
if the argument is not \code{NULL}.

The argument \plc{parallel_data} returns the parallel data
if the argument is not \code{NULL}.

The argument \plc{thread_num} returns the thread number
if the argument is not \code{NULL}.

\effect


If the runtime entry point returns 0 or 1, no argument is modified.
Otherwise, the entry point has the effects described below.

If a non-null value was passed for \plc{flag},
the value returned in *\plc{flag} represents the type of the task
at the specified level.
Task types that a tool may observe on a thread's stack include
initial, implicit, explicit, and target tasks.

If a non-null value was passed for \plc{task_data},
the value returned in *\plc{task_data} is a pointer to a data word
associated with the task at the specified level.

If a non-null value was passed for \plc{task_frame},
the value returned in *\plc{task_frame} is a pointer to the
\code{omp_frame_t} structure associated with the task at the specified level.
Appendix~\ref{chap:frames} discusses an example that
illustrates the use of \code{omp_frame_t} structures with multiple
threads and nested parallelism.

If a non-null value was passed for \plc{parallel_data},
the value returned in *\plc{parallel_data} is a pointer to a data word
associated with the parallel region containing the task at the specified level.
If the task at the specified level is an initial task,
the value of *\plc{parallel_data} will be \code{NULL}.

If a non-null value was passed for \plc{thread_num},
the value returned in *\plc{thread_num}
indicates the number of the thread in the parallel region executing the task.

\constraints
While argument \plc{ancestor_level} is passed by
value, all other arguments to the entry point must be pointers
to variables of the specified types or \code{NULL}.

\crossreferences
\begin{itemize}
\item \code{ompt_data_t} type, see \specref{sec:ompt_data_t}.
\item \code{ompt_task_flag_t} type, see
  \specref{sec:ompt_task_flag_t}.
\item \code{omp_frame_t} type, see \specref{sec:omp_frame_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_get_task_memory_t}}
\label{sec:ompt_get_task_memory_t}
\label{sec:ompt_get_task_memory}

\summary
A runtime entry point known as \code{ompt_get_task_memory} 
with type signature \code{ompt_get_task_memory_t} provides information 
about memory ranges that are associated with the task at task creation
to store the data environment of the task for the execution.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_get_task_memory_t)(
  void **\plc{addr},
  size_t *\plc{size},
  int \plc{block}
);
\end{omptInquiry}
\end{ccppspecific}

\descr

During execution, an OpenMP thread may be executing an OpenMP task.
The OpenMP implementation needs to preserve the data environment
from the creation of the task to the execution of the task.
To obtain information about the memory ranges used to store the 
data environment for the current task, 
a tool uses the runtime entry point known as
\code{ompt_get_task_memory} 
with type signature \code{ompt_get_task_memory_t}. 

There might be multiple memory ranges used to store these data. The
\plc{block} argument allows the tool to iterate over these memory ranges.

The \code{ompt_get_task_memory} runtime entry point
returns 1 if there are more memory ranges available, and 0 otherwise. 

If there is no memory used for a task, \plc{size} is set to 0. 
In this case, addr is unspecified.

This runtime entry point is \emph{async signal safe}.

\argdesc

The argument \plc{addr} is a pointer to a void pointer return value
to provide the start address of a memory block.  

The argument \plc{size} is a pointer to a size type return
value to provide the size of the memory block.

The argument \plc{block} is an integer value to specify the
memory block of interest.

%\effect
%
%If the runtime has 
%a non-null value was passed for \plc{thread_num},
%the value returned in *\plc{thread_num}
%indicates the number of the thread in the parallel region executing the task.

\subsubsubsection{\hcode{ompt_get_target_info_t}}
\label{sec:ompt_get_target_info_t}
\label{sec:ompt_get_target_info}

\summary
A runtime entry point known as \code{ompt_get_target_info}
with type signature \code{ompt_get_target_info_t} returns identifiers that specify a
thread's current target region and target operation id, if any.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_get_target_info_t) (
  uint64_t *\plc{device_num},
  ompt_id_t *\plc{target_id},
  ompt_id_t *\plc{host_op_id}
);
\end{omptInquiry}
\end{ccppspecific}

\descr
A tool can query whether an OpenMP thread is in a target region by
invoking the entry point known as \code{ompt_get_target_info}
with type signature \code{ompt_get_target_info_t}.
This runtime entry point returns 1 if the current thread is
in a target region and 0 otherwise. If the entry point returns 0,
the values of the variables passed by reference as its arguments
are undefined.

If the current thread is in a target region, the entry point will
return information about the current device, active target region, and
active host operation, if any.

This runtime entry point is \emph{async signal safe}.

\argdesc

If the host is in a \code{target} region,
\plc{device_num} returns the target device.

If the host is in a \code{target} region,
\plc{target_id} returns the \code{target} region identifier.

If the current thread is in the process of initiating an
operation on a target device (for example, copying data to or from an
accelerator or launching a kernel) \plc{host_op_id} returns
the identifier for the operation; otherwise,
\plc{host_op_id} returns \code{ompt_id_none}.

\constraints

Arguments passed to the entry point must be valid
references to variables of the specified types.

\crossreferences
\begin{itemize}
\item \code{ompt_id_t} type, see \specref{sec:ompt_id_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_get_num_devices_t}}
\label{sec:ompt_get_num_devices_t}
\label{sec:ompt_get_num_devices}

\summary
A runtime entry point known as \code{ompt_get_num_devices}
with type signature \code{ompt_get_num_devices_t}
returns the number of available devices.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_get_num_devices_t) (void);
\end{omptInquiry}
\end{ccppspecific}

\descr

An OpenMP program may execute on one or more devices.
A tool may determine the number of devices available to an OpenMP
program by invoking a runtime entry point
known as \code{ompt_get_num_devices}
with type signature \code{ompt_get_num_devices_t}.

This runtime entry point is \emph{async signal safe}.



\subsubsubsection{\hcode{ompt_get_unique_id_t}}
\label{sec:ompt_get_unique_id_t}
\label{sec:ompt_get_unique_id}

\summary
A runtime entry point known as \code{ompt_get_unique_id}
with type signature \code{ompt_get_unique_id_t}
returns a unique number.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef uint64_t (*ompt_get_unique_id_t) (void);
\end{omptInquiry}
\end{ccppspecific}

\descr

A tool may obtain a number that is unique for the duration of an
OpenMP program by invoking a runtime entry point
known as \code{ompt_get_unique_id}
with type signature \code{ompt_get_unique_id_t}.
Successive invocations may not result in
consecutive or even increasing numbers.

This runtime entry point is \emph{async signal safe}.


\subsubsubsection{\hcode{ompt_finalize_tool_t}}
\label{sec:ompt_finalize_tool_t}
\label{sec:ompt_finalize_tool}

\summary
A runtime entry point known as \code{ompt_finalize_tool}
with type signature \code{ompt_finalize_tool_t}
enables the tool to finalize itself.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef void (*ompt_finalize_tool_t) (void);
\end{omptInquiry}
\end{ccppspecific}

\descr

A tool may detect that the execution of an OpenMP program is ending 
before the OpenMP implementation does.
To facilitate clean termination of the tool, the tool may
invoke a runtime entry point known as \code{ompt_finalize_tool}
with type signature \code{ompt_finalize_tool_t}. 
Upon completion of the \code{ompt_finalize_tool} routine, no OMPT callbacks are 
dispatched.

\effect

The \code{ompt_finalize_tool} routine detaches the tool from the runtime, unregisters 
all callbacks and invalidates all OMPT entry points passed to the tool in the 
lookup-function. 
Upon completion of the \code{ompt_finalize_tool} routine, no further callbacks on any 
thread will be issued.

Before the callbacks get unregistered, the OpenMP runtime should make all efforts to 
dispatch all outstanding registered callbacks as well as the callbacks that would be 
encountered during shutdown of the runtime, if possible in the current execution context.

\subsubsection{Entry Points in the OMPT Device Tracing Interface}
\label{sec:ompt-tracing-entry-points}


\subsubsubsection{\hcode{ompt_get_device_num_procs_t}}
\label{sec:ompt_get_device_num_procs_t}

\summary

A runtime entry point for a device known as
\code{ompt_get_device_num_procs} with type signature
\code{ompt_get_device_num_procs_t} returns
the number of processors currently available to the execution
environment on the specified device.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_get_device_num_procs_t) (
  ompt_device_t *\plc{device}
);
\end{omptInquiry}
\end{ccppspecific}

\descr
A runtime entry point for a device known
as \code{ompt_get_device_num_procs} with type signature
\code{ompt_get_device_num_procs_t} returns the
number of processors that are available on the device at the time
the routine is called. This value may change between the time that
it is determined and the time that it is read in the calling context due to
system actions outside the control of the OpenMP implementation.

\argdesc

The argument \plc{device} is a pointer to an opaque object that
represents the target device instance. The pointer to the device
instance object is used by functions in the device tracing interface
to identify the device being addressed.

\crossreferences
\begin{itemize}
\item \code{ompt_device_t},
see \specref{sec:ompt_device_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_get_device_time_t}}
\label{sec:ompt_get_device_time_t}

\summary
A runtime entry point for a device known
as \code{ompt_get_device_time}
with type signature \code{ompt_get_device_time_t}
returns the current time on the specified device.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef ompt_device_time_t (*ompt_get_device_time_t) (
  ompt_device_t *\plc{device}
);
\end{omptInquiry}
\end{ccppspecific}

\descr
Host and target devices are typically distinct and run independently.
If host and target devices are different hardware components, they
may use different clock generators. For this reason,  there may be
no common time base for ordering host-side and device-side events.

A runtime entry point for a device known
as \code{ompt_get_device_time} with type signature
\code{ompt_get_device_time_t}
returns the current time on the specified device.
A tool can use this information
to align time stamps from different devices.

\argdesc

The argument \plc{device} is a pointer to an opaque object that
represents the target device instance. The pointer to the device
instance object is used by functions in the device tracing interface
to identify the device being addressed.

\crossreferences
\begin{itemize}
\item \code{ompt_device_t},
see \specref{sec:ompt_device_t}.
\item \code{ompt_device_time_t},
see \specref{sec:ompt_device_time_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_translate_time_t}}
\label{sec:ompt_translate_time_t}

\summary
A runtime entry point for a device known
as \code{ompt_translate_time}
with type signature \code{ompt_translate_time_t} translates
a time value obtained from the specified device to a corresponding time
value on the host device.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef double (*ompt_translate_time_t) (
  ompt_device_t *\plc{device},
  ompt_device_time_t \plc{time}
);
\end{omptInquiry}
\end{ccppspecific}

\descr
A runtime entry point for a device known as \code{ompt_translate_time}
with type signature \code{ompt_translate_time_t} translates
a time value obtained from the specified device to a corresponding time
value on the host device. The returned value for the host time has
the same meaning as the value returned from \code{omp_get_wtime}.

\needspace{6\baselineskip}\begin{note}
The accuracy of time translations may degrade if they are not
performed promptly after a device time value is received and if either
the host or device vary their clock speeds. Prompt translation of
device times to host times is recommended.
\end{note}

\argdesc

The argument \plc{device} is a pointer to an opaque object that
represents the target device instance. The pointer to the device
instance object is used by functions in the device tracing interface
to identify the device being addressed.

The argument \plc{time} is a time from the specified device.

\crossreferences
\begin{itemize}
\item \code{ompt_device_t},
see \specref{sec:ompt_device_t}.
\item \code{ompt_device_time_t},
see \specref{sec:ompt_device_time_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_set_trace_ompt_t}}
\label{sec:ompt_set_trace_ompt_t}

\summary
A runtime entry point for a device known as \code{ompt_set_trace_ompt}
with type signature \code{ompt_set_trace_ompt_t}
enables or disables the recording of trace records for one or more
types of OMPT events.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_set_trace_ompt_t) (
  ompt_device_t *\plc{device},
  unsigned int \plc{enable},
  unsigned int \plc{etype}
);
\end{omptInquiry}
\end{ccppspecific}

\argdesc

The \plc{device} argument points to an opaque object that represents
the target device instance. Functions in the device tracing interface
use this pointer to identify the device that is being addressed.

The argument \plc{enable} indicates whether tracing should be
enabled or disabled for the event or events specified by
argument \plc{etype}. A positive value for \plc{enable}
indicates that recording of one or more events specified by
\plc{etype} should be enabled; a value of 0 for \plc{enable} indicates
that recording of events should be disabled by this invocation.

An argument \plc{etype} value 0 indicates that traces for all
event types will be enabled or disabled.  Passing a positive value for
\plc{etype} inidicates that recording should be enabled or disabled
for the event in \code{ompt_callbacks_t} that matches \plc{etype}.


\effect

Table~\ref{table:record_set} shows the possible return
codes for \code{ompt_set_trace_ompt}.  If a single invocation
of \code{ompt_set_trace_ompt} is used to enable or disable
more than one event, the return code will
be 3 if tracing is possible for one or more events but not for
others.

\nolinenumbers
\renewcommand{\arraystretch}{1.5}
\tablefirsthead{%
\hline
\textsf{\textbf{Return Code}} & \textsf{\textbf{Meaning}}\\
\hline\\[-3ex]
}
\tablehead{%
\multicolumn{2}{l}{\small\slshape table continued from previous page}\\
\hline
\textsf{\textbf{Return Code}} & \textsf{\textbf{Meaning}}\\
\hline\\[-3ex]
}
\tabletail{%
\hline\\[-4ex]
\multicolumn{2}{l}{\small\slshape table continued on next page}\\
}
\tablelasttail{\hline}
\tablecaption{Return Codes for \code{ompt_set_trace_ompt} and
    \code{ompt_set_trace_native}\label{table:record_set}}
\begin{supertabular}{p{2.0in} p{3.0in}}
0 & error\\
1 & event will never occur\\
2 & event may occur but no tracing is possible\\
3 & event may occur and will be traced when convenient\\
4 & event may occur and will always be traced if event occurs\\
\end{supertabular}

\linenumbers

\crossreferences
\begin{itemize}
\item \code{ompt_callbacks_t},
see \specref{sec:ompt_callbacks_t}.
\item \code{ompt_device_t},
see \specref{sec:ompt_device_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_set_trace_native_t}}
\label{sec:ompt_set_trace_native_t}

\summary
A runtime entry point for a device known as \code{ompt_set_trace_native}
with type signature \code{ompt_set_trace_native_t}
enables or disables the recording of native trace records for a device.


\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_set_trace_native_t) (
  ompt_device_t *\plc{device},
  int \plc{enable},
  int \plc{flags}
);
\end{omptInquiry}
\end{ccppspecific}

\descr
This interface is designed for use by a tool with no knowledge about
an attached device. If a tool knows how to program a particular
attached device, it may opt to invoke native control functions
directly using pointers obtained through the \plc{lookup} function
associated with the device and described in the \plc{documentation}
string that is provided to the device initializer callback.

\argdesc
The \plc{device} argument points to an opaque object that represents
the target device instance. Functions in the device tracing interface
use this pointer to identify the device that is being addressed.

The argument \plc{enable} indicates whether recording of events
should be enabled or disabled by this invocation.

The argument \plc{flags} specifies the kinds of native device
monitoring to enable or disable.
Each kind of monitoring is specified by a flag bit.
Flags can be composed by using logical {\ttfamily or}  to combine enumeration
values from type \code{ompt_native_mon_flag_t}.
Table~\ref{table:record_set} shows the possible return codes for
\code{ompt_set_trace_native}.  If a single invocation of
\code{ompt_set_trace_native} is used to enable/disable more
than one kind of monitoring, the return code will be 3 if tracing
is possible for one or more kinds of monitoring but not for others.

To start, pause, flush, or stop tracing for a specific target device
associated with the handle \plc{device}, a tool invokes the 
\code{ompt_start_trace}, \code{ompt_pause_trace}, \code{ompt_flush_trace}, or
\code{ompt_stop_trace} runtime entry point for the device.


\crossreferences
\begin{itemize}
\item \code{ompt_device_t},
see \specref{sec:ompt_device_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_start_trace_t}}
\label{sec:ompt_start_trace_t}

\summary
A runtime entry point for a device known as \code{ompt_start_trace}
with type signature \code{ompt_start_trace_t}
starts tracing of activity on a specific device.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_start_trace_t) (
  ompt_device_t *\plc{device},
  ompt_callback_buffer_request_t \plc{request},
  ompt_callback_buffer_complete_t \plc{complete}
);
\end{omptInquiry}
\end{ccppspecific}

\descr
A tool may initiate tracing on a device by invoking the device's \code{ompt_start_trace}
runtime entry point.

Under normal operating conditions, every event buffer provided to
a device by a tool callback will be returned to the tool
before the OpenMP runtime shuts down.
If an exceptional condition terminates  execution of an OpenMP
program, the OpenMP runtime may not return buffers provided to the
device.

An invocation of \code{ompt_start_trace} returns 1 if the command
succeeds and 0 otherwise.

\argdesc
The \plc{device} argument points to an opaque object that represents
the target device instance. Functions in the device tracing interface
use this pointer to identify the device that is being addressed.

The argument \emph{buffer request} specifies a tool callback
that will supply a device with a buffer to deposit events.

The argument \emph{buffer complete} specifies a tool callback
that will be invoked by the OpenMP implementation to empty a buffer
containing event records.

\crossreferences
\begin{itemize}
\item \code{ompt_device_t},
see \specref{sec:ompt_device_t}.
\item \code{ompt_callback_buffer_request_t},
see \specref{sec:ompt_callback_buffer_request_t}.
\item \code{ompt_callback_buffer_complete_t},
see \specref{sec:ompt_callback_buffer_complete_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_pause_trace_t}}
\label{sec:ompt_pause_trace_t}

\summary
A runtime entry point for a device known as \code{ompt_pause_trace}
with type signature \code{ompt_pause_trace_t}
pauses or restarts activity tracing on a specific device.

\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_pause_trace_t) (
  ompt_device_t *\plc{device},
  int \plc{begin_pause}
);
\end{omptInquiry}
\end{ccppspecific}

\descr

A tool may pause or resume tracing on a device by invoking the device's
\code{ompt_pause_trace} runtime entry point.
An invocation of \code{ompt_pause_trace} returns 1 if the command
succeeds and 0 otherwise.

Redundant pause or resume commands are idempotent and will
return 1 indicating success.

\argdesc
The \plc{device} argument points to an opaque object that represents
the target device instance. Functions in the device tracing interface
use this pointer to identify the device that is being addressed.

The argument \plc{begin_pause} indicates whether to pause or
resume tracing.
To resume tracing, zero should be supplied for \plc{begin_pause}.

\crossreferences
\begin{itemize}
\item \code{ompt_device_t},
see \specref{sec:ompt_device_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_flush_trace_t}}
\label{sec:ompt_flush_trace_t}

\summary
A runtime entry point for a device known as \code{ompt_flush_trace}
with type signature \code{ompt_flush_trace_t} causes all pending trace 
records for the specified device to be delivered to the tool.

\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_flush_trace_t) (
  ompt_device_t *\plc{device}
);
\end{omptInquiry}
\end{ccppspecific}

\descr

A tool may request that a device flush any pending trace records
by invoking the \code{ompt_flush_trace} runtime entry point for the device.
Invoking \code{ompt_flush_trace} causes the OpenMP implementation to issue a sequence 
of zero or more buffer completion callbacks to deliver to the tool all trace records 
that have been collected prior to the flush.
An invocation of \code{ompt_flush_trace} returns 1 if the command
succeeds and 0 otherwise.

\argdesc
The \plc{device} argument points to an opaque object that represents
the target device instance. Functions in the device tracing interface
use this pointer to identify the device that is being addressed.

\crossreferences
\begin{itemize}
\item \code{ompt_device_t},
see \specref{sec:ompt_device_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_stop_trace_t}}
\label{sec:ompt_stop_trace_t}

\summary
A runtime entry point for a device known as \code{ompt_stop_trace}
with type signature \code{ompt_stop_trace_t}
stops tracing for a device.

\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_stop_trace_t) (
  ompt_device_t *\plc{device}
);
\end{omptInquiry}
\end{ccppspecific}

\descr

A tool may halt tracing on a device and request that the device flush any pending trace records
by invoking the \code{ompt_stop_trace} runtime entry point for the device.
An invocation of \code{ompt_stop_trace} returns 1 if the command
succeeds and 0 otherwise.

\argdesc
The \plc{device} argument points to an opaque object that represents
the target device instance. Functions in the device tracing interface
use this pointer to identify the device that is being addressed.


%%? johnmc says: we should export one more function from a target device: ompt_target_scope(begin/end, host_id)
%% this function will be used by the OpenMP runtime when a target device is being monitored to signal the target device when
%% (1) entering and leaving a target region
%% (2) before and after launching a kernel
%% (3) before and after performing a data operation: copy, allocation, release, ...
%% this function will enable the target device to associate device_activity_ids with some host_id that either represents a
%% target region, target data operation, or target kernel submission

\crossreferences
\begin{itemize}
\item \code{ompt_device_t},
see \specref{sec:ompt_device_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_advance_buffer_cursor_t}}
\label{sec:ompt_advance_buffer_cursor_t}

%There are several routines that need to be used together to process %target event records deposited in a buffer by a device.

\summary
A runtime entry point for a device known as \code{ompt_advance_buffer_cursor}
with type signature \code{ompt_advance_buffer_cursor_t}
advances a trace buffer cursor to the next record.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef int (*ompt_advance_buffer_cursor_t) (
  ompt_buffer_t *\plc{buffer},
  size_t \plc{size},
  ompt_buffer_cursor_t \plc{current},
  ompt_buffer_cursor_t *\plc{next}
);
\end{omptInquiry}
\end{ccppspecific}

\descr
It returns \plc{true} if the advance is successful and the next
position in the buffer is valid.

\argdesc
The \plc{device} argument points to an opaque object that represents
the target device instance. Functions in the device tracing interface
use this pointer to identify the device that is being addressed.

The argument \plc{buffer} indicates a trace buffer associated
with the cursors.

The argument \plc{size} indicates the size of \plc{buffer} in
bytes.

The argument \plc{current} is an opaque buffer cursor.

The argument \plc{next} returns the next value of a opaque buffer cursor.


\crossreferences
\begin{itemize}
\item \code{ompt_device_t},
see \specref{sec:ompt_device_t}.
\item \code{ompt_buffer_cursor_t},
see \specref{sec:ompt_buffer_cursor_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_get_record_type_t}}
\label{sec:ompt_get_record_type_t}

\summary
A runtime entry point for a device known as
\code{ompt_get_record_type} with type signature
\code{ompt_get_record_type_t} inspects the type
of a trace record for a device.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef ompt_record_t (*ompt_get_record_type_t) (
  ompt_buffer_t *\plc{buffer},
  ompt_buffer_cursor_t \plc{current}
);
\end{omptInquiry}
\end{ccppspecific}

\descr

Trace records for a device may be in one of two forms: a
\emph{native} record format, which may be device-specific,
or an \emph{OMPT} record format, where each trace record
corresponds to an OpenMP \emph{event} and fields in the record
structure are mostly the arguments that would be passed to the
OMPT callback for the event.

A runtime entry point for a device known as
\code{ompt_get_record_type} with type signature
\code{ompt_get_record_type_t} inspects the type
of a trace record and indicates whether the record at the current
position in the provided trace buffer is an OMPT record,
a native record, or an invalid record. An invalid record type
is returned if the cursor is out of bounds.

\argdesc
The argument \plc{buffer} indicates a trace buffer.

The argument \plc{current} is an opaque buffer cursor.




\crossreferences
\begin{itemize}
\item \code{ompt_record_t},
see \specref{sec:ompt_record_t}.
\item \code{ompt_buffer_t},
see \specref{sec:ompt_buffer_t}.
\item \code{ompt_buffer_cursor_t},
see \specref{sec:ompt_buffer_cursor_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_get_record_ompt_t}}
\label{sec:ompt_get_record_ompt_t}

\summary
A runtime entry point for a device known as \code{ompt_get_record_ompt}
with type signature \code{ompt_get_record_ompt_t}
obtains a pointer to an OMPT trace record from a trace buffer associated with a device.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef ompt_record_ompt_t *(*ompt_get_record_ompt_t) (
  ompt_buffer_t *\plc{buffer},
  ompt_buffer_cursor_t \plc{current}
);
\end{omptInquiry}
\end{ccppspecific}

\descr

This function returns a pointer that may point to a record in the
trace buffer, or it may point to a record in thread local storage
where the information extracted from a record was assembled. The
information available for an event depends upon its type.

The return value of type \code{ompt_record_ompt_t}
includes a field of a union type that can represent
information for any OMPT event record type.
Another call to the runtime entry point may overwrite the
contents of the fields in a record returned by a prior invocation.

\argdesc
The argument \plc{buffer} indicates a trace buffer.

The argument \plc{current} is an opaque buffer cursor.

\crossreferences
\begin{itemize}
\item \code{ompt_record_ompt_t},
see \specref{sec:ompt_record_ompt_t}.
\item \code{ompt_device_t},
see \specref{sec:ompt_device_t}.
\item \code{ompt_buffer_cursor_t},
see \specref{sec:ompt_buffer_cursor_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_get_record_native_t}}
\label{sec:ompt_get_record_native_t}

\summary

A runtime entry point for a device known as
\code{ompt_get_record_native} with type signature
\code{ompt_get_record_native_t}
obtains a pointer to a native trace record from a trace buffer associated with a device.

\format
\begin{ccppspecific}
\begin{omptInquiry}
typedef void *(*ompt_get_record_native_t) (
  ompt_buffer_t *\plc{buffer},
  ompt_buffer_cursor_t \plc{current},
  ompt_id_t *\plc{host_op_id}
);
\end{omptInquiry}
\end{ccppspecific}

\descr

The pointer returned  may point into the specified trace buffer, or into
thread local storage where the information extracted from a trace
record was assembled. The information available for a native event
depends upon its type. If the function returns a non-null result,
it will also set \code{*host_op_id} to identify host-side identifier
for the operation associated with the record.  A subsequent call
to \code{ompt_get_record_native} may overwrite the
contents of the fields in a record returned by a prior invocation.

\argdesc
The argument \plc{buffer} indicates a trace buffer.

The argument \plc{current} is an opaque buffer cursor.

The argument \plc{host_op_id} is a pointer to an identifier
that will be returned by the function. The entry point will set
*\plc{host_op_id} to the value of a host-side identifier for an operation on
a target device that was created when the operation was initiated by
the host.


\crossreferences
\begin{itemize}
\item \code{ompt_id_t},
see \specref{sec:ompt_id_t}.
\item \code{ompt_buffer_t},
see \specref{sec:ompt_buffer_t}.
\item \code{ompt_buffer_cursor_t},
see \specref{sec:ompt_buffer_cursor_t}.
\end{itemize}

\subsubsubsection{\hcode{ompt_get_record_abstract_t}}
\label{sec:ompt_get_record_abstract_t}

\summary
A runtime entry point for a device known as
\code{ompt_get_record_abstract}
with type signature
\code{ompt_get_record_abstract_t}
summarizes the context of a native (device-specific) trace record.

\format
\begin{ccppspecific}
\begin{omptOther}
typedef ompt_record_abstract_t *
(*ompt_get_record_abstract_t) (
  void *\plc{native_record}
);
\end{omptOther}
\end{ccppspecific}

\descr
An OpenMP implementation may execute on a device that logs
trace records in a native (device-specific) format unknown to a tool.
A tool can use the \code{ompt_get_record_abstract}
runtime entry point for the device with type signature
\code{ompt_get_record_abstract_t}
to decode a native trace record that it
does not understand into a standard form that it can interpret.

\argdesc

The argument \plc{native_record} is a pointer to a native trace
record.

\crossreferences
\begin{itemize}
\item \code{ompt_record_abstract_t},
see \specref{sec:ompt_record_abstract_t}.
\end{itemize}

\subsubsection{Lookup Entry Point}

\subsubsubsection{\hcode{ompt_function_lookup_t}}
\label{sec:ompt_function_lookup_t}
\label{sec:ompt_function_lookup}

\summary
A tool uses a lookup routine with type signature
\code{ompt_function_lookup_t}
to obtain pointers to runtime entry points that are
part of the OMPT interface.

\format

\begin{ccppspecific}
\begin{omptInquiry}
typedef void (*ompt_interface_fn_t) (void);

typedef ompt_interface_fn_t (*ompt_function_lookup_t) (
  const char *\plc{interface_function_name}
);
\end{omptInquiry}
\end{ccppspecific}


\descr

An OpenMP implementation provides a pointer to a lookup routine as an
argument to tool callbacks used to initialize tool support for
monitoring an OpenMP device using either tracing or callbacks.



When an OpenMP implementation invokes a tool initializer to configure
the OMPT callback interface, the OpenMP implementation will pass the
initializer a lookup function that the tool can use to obtain
pointers to runtime entry points that implement routines that are part of
the OMPT callback interface.

When an OpenMP implementation invokes a tool initializer to configure
the OMPT tracing interface for a device, the Open implementation will
pass the device tracing initializer a lookup function that the tool
can use to obtain pointers to runtime entry points that implement
tracing control routines appropriate for that device.

A tool can call the lookup function to obtain a pointer to a runtime
entry point.

\argdesc
The argument \plc{interface_function_name} is a C string
that represents the name of a runtime entry point.

\crossreferences
\begin{itemize}
\item Tool initializer for a device's OMPT tracing interface, 
\specref{sec:tracing-device-activity}.
\item Tool initializer for the OMPT callback interface, \specref{sec:ompt_initialize_t}
\item Entry points in the OMPT callback interface, see
  \tabref{table:ompt-callback-interface-functions} for a list and
  \specref{sec:ompt-callback-entry-points} for detailed definitions.
\item Entry points in the OMPT tracing interface, see
  \tabref{table:ompt-tracing-interface-functions} for a list and
  \specref{sec:ompt-tracing-entry-points} for detailed definitions.
\end{itemize}
% This is the end of ch4-toolsSupport.tex
